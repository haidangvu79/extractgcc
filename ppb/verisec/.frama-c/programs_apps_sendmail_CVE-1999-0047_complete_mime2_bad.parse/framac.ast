/* Generated by Frama-C */
#include "assert.h"
#include "ctype.h"
#include "errno.h"
#include "stdarg.h"
#include "stddef.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "strings.h"
#include "sys/types.h"
#include "unistd.h"
struct header {
   char *h_field ;
   char *h_value ;
   struct header *h_link ;
   u_short h_flags ;
};
typedef struct header HDR;
struct address {
   char *q_paddr ;
   char *q_user ;
   char *q_ruser ;
   char *q_host ;
   u_long q_flags ;
   uid_t q_uid ;
   gid_t q_gid ;
   char *q_home ;
   char *q_fullname ;
   struct address *q_next ;
   struct address *q_alias ;
   char *q_owner ;
   struct address *q_tchain ;
   char *q_orcpt ;
   char *q_status ;
   char *q_rstatus ;
   char *q_statmta ;
   short q_specificity ;
};
typedef struct address ADDRESS;
struct envelope {
   HDR *e_header ;
   long e_msgpriority ;
   time_t e_ctime ;
   char *e_to ;
   ADDRESS e_from ;
   char *e_sender ;
   char **e_fromdomain ;
   ADDRESS *e_sendqueue ;
   ADDRESS *e_errorqueue ;
   long e_msgsize ;
   long e_flags ;
   int e_nrcpts ;
   short e_class ;
   short e_hopcount ;
   short e_nsent ;
   short e_sendmode ;
   short e_errormode ;
   short e_timeoutclass ;
   struct envelope *e_parent ;
   struct envelope *e_sibling ;
   char *e_bodytype ;
   FILE *e_dfp ;
   char *e_id ;
   FILE *e_xfp ;
   FILE *e_lockfp ;
   char *e_message ;
   char *e_statmsg ;
   char *e_msgboundary ;
   char *e_origrcpt ;
   char *e_envid ;
   char *e_status ;
   time_t e_dtime ;
   int e_ntries ;
   dev_t e_dfdev ;
   ino_t e_dfino ;
   char *e_macro[256] ;
};
typedef struct envelope ENVELOPE;
void mime7to8(HDR *header, ENVELOPE *e) __attribute__((__FC_OLDSTYLEPROTO__));

char *hvalue(char *field, HDR *header) __attribute__((__FC_OLDSTYLEPROTO__));

int main(int argc, char **argv)
{
  int __retres;
  HDR *header;
  register ENVELOPE *e;
  FILE *temp;
  __FC_assert((argc == 2) != 0,
              "programs/apps/sendmail/CVE-1999-0047/complete/mime2_bad.c",78,
              "argc==2");
  header = (HDR *)malloc(sizeof(struct header));
  header->h_field = (char *)"Content-Transfer-Encoding";
  header->h_value = (char *)"base64";
  e = (ENVELOPE *)malloc(sizeof(struct envelope));
  e->e_id = (char *)"First Entry";
  temp = fopen((char const *)*(argv + 1),"r");
  e->e_dfp = temp;
  mime7to8(header,e);
  fclose(temp);
  __retres = 0;
  goto return_label;
  __retres = 0;
  return_label: return __retres;
}

static char index_64[128] =
  {(char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)62,
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)63,
   (char)52,
   (char)53,
   (char)54,
   (char)55,
   (char)56,
   (char)57,
   (char)58,
   (char)59,
   (char)60,
   (char)61,
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)0,
   (char)1,
   (char)2,
   (char)3,
   (char)4,
   (char)5,
   (char)6,
   (char)7,
   (char)8,
   (char)9,
   (char)10,
   (char)11,
   (char)12,
   (char)13,
   (char)14,
   (char)15,
   (char)16,
   (char)17,
   (char)18,
   (char)19,
   (char)20,
   (char)21,
   (char)22,
   (char)23,
   (char)24,
   (char)25,
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)26,
   (char)27,
   (char)28,
   (char)29,
   (char)30,
   (char)31,
   (char)32,
   (char)33,
   (char)34,
   (char)35,
   (char)36,
   (char)37,
   (char)38,
   (char)39,
   (char)40,
   (char)41,
   (char)42,
   (char)43,
   (char)44,
   (char)45,
   (char)46,
   (char)47,
   (char)48,
   (char)49,
   (char)50,
   (char)51,
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1),
   (char)(-1)};
/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_1(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_2(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_3(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_4(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_5(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_6(char const * restrict format);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_7(char const * restrict format, char *param0);

void mime7to8(HDR *header, ENVELOPE *e) __attribute__((__FC_OLDSTYLEPROTO__));
void mime7to8(HDR *header, ENVELOPE *e)
{
  register char *p;
  u_char *fbufp;
  char canary[10];
  u_char fbuf[50 + 1];
  int tmp_10;
  strcpy(canary,"GOOD");
  p = hvalue((char *)"Content-Transfer-Encoding",header);
  if (p == (char *)0) {
    printf("Content-Transfer-Encoding not found in header\n"); /* printf_va_1 */
    goto return_label;
  }
  tmp_10 = strcasecmp((char const *)p,"base64");
  if (tmp_10 == 0) {
    int c1;
    int c2;
    int c3;
    int c4;
    fbufp = fbuf;
    while (1) {
      c1 = fgetc(e->e_dfp);
      if (! (c1 != -1)) break;
      {
        int tmp;
        u_char *tmp_7;
        u_char *tmp_8;
        u_char *tmp_9;
        tmp = isascii(c1);
        if (tmp) {
          int tmp_0;
          tmp_0 = isspace(c1);
          if (tmp_0) continue;
        }
        while (1) {
          int tmp_1;
          c2 = fgetc(e->e_dfp);
          tmp_1 = isascii(c2);
          if (tmp_1) {
            int tmp_2;
            tmp_2 = isspace(c2);
            if (! tmp_2) break;
          }
          else break;
        }
        if (c2 == -1) break;
        while (1) {
          int tmp_3;
          c3 = fgetc(e->e_dfp);
          tmp_3 = isascii(c3);
          if (tmp_3) {
            int tmp_4;
            tmp_4 = isspace(c3);
            if (! tmp_4) break;
          }
          else break;
        }
        if (c3 == -1) break;
        while (1) {
          int tmp_5;
          c4 = fgetc(e->e_dfp);
          tmp_5 = isascii(c4);
          if (tmp_5) {
            int tmp_6;
            tmp_6 = isspace(c4);
            if (! tmp_6) break;
          }
          else break;
        }
        if (c4 == -1) break;
        if (c1 == '=') continue;
        else 
          if (c2 == '=') continue;
        if (c1 < 0) c1 = -1;
        else 
          if (c1 > 127) c1 = -1; else c1 = (int)index_64[c1];
        if (c2 < 0) c2 = -1;
        else 
          if (c2 > 127) c2 = -1; else c2 = (int)index_64[c2];
        *fbufp = (u_char)((c1 << 2) | ((c2 & 0x30) >> 4));
        tmp_7 = fbufp;
        fbufp ++;
        ;
        if ((int)*tmp_7 == '\n') goto _LOR;
        else 
          if (fbuf >= & fbuf[50]) {
            _LOR:
            {
              fbufp --;
              ;
              if ((int)*fbufp != '\n') fbufp ++;
              else {
                fbufp --;
                ;
                if ((int)*fbufp != '\r') fbufp ++;
              }
              *fbufp = (u_char)'\000';
              printf("resetting fbufp\n"); /* printf_va_2 */
              fbufp = fbuf;
            }
          }
        if (c3 == '=') continue;
        if (c3 < 0) c3 = -1;
        else 
          if (c3 > 127) c3 = -1; else c3 = (int)index_64[c3];
        *fbufp = (u_char)(((c2 & 0x0f) << 4) | ((c3 & 0x3c) >> 2));
        tmp_8 = fbufp;
        fbufp ++;
        ;
        if ((int)*tmp_8 == '\n') goto _LOR_0;
        else 
          if (fbuf >= & fbuf[50]) {
            _LOR_0:
            {
              fbufp --;
              ;
              if ((int)*fbufp != '\n') fbufp ++;
              else {
                fbufp --;
                ;
                if ((int)*fbufp != '\r') fbufp ++;
              }
              *fbufp = (u_char)'\000';
              printf("resetting fbufp\n"); /* printf_va_3 */
              fbufp = fbuf;
            }
          }
        if (c4 == '=') continue;
        if (c4 < 0) c4 = -1;
        else 
          if (c4 > 127) c4 = -1; else c4 = (int)index_64[c4];
        *fbufp = (u_char)(((c3 & 0x03) << 6) | c4);
        tmp_9 = fbufp;
        fbufp ++;
        ;
        if ((int)*tmp_9 == '\n') goto _LOR_1;
        else 
          if (fbuf >= & fbuf[50]) {
            _LOR_1:
            {
              fbufp --;
              ;
              if ((int)*fbufp != '\n') fbufp ++;
              else {
                fbufp --;
                ;
                if ((int)*fbufp != '\r') fbufp ++;
              }
              *fbufp = (u_char)'\000';
              printf("resetting fbufp\n"); /* printf_va_4 */
              fbufp = fbuf;
            }
          }
      }
    }
    if (fbufp > fbuf) *fbufp = (u_char)'\000';
  }
  else printf("We only support base64 encoding...\n"); /* printf_va_5 */
  printf("canary should be GOOD\n"); /* printf_va_6 */
  printf("canary = %s\n",canary); /* printf_va_7 */
  return_label: return;
}

char *hvalue(char *field, HDR *header) __attribute__((__FC_OLDSTYLEPROTO__));
char *hvalue(char *field, HDR *header)
{
  char *__retres;
  register HDR *h;
  h = header;
  while (h != (HDR *)0) {
    if (! (((int)h->h_flags & 0x0004) != 0)) {
      int tmp;
      tmp = strcasecmp((char const *)h->h_field,(char const *)field);
      if (tmp == 0) {
        __retres = h->h_value;
        goto return_label;
      }
    }
    h = h->h_link;
  }
  __retres = (char *)0;
  return_label: return __retres;
}


