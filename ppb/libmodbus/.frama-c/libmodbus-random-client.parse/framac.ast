/* Generated by Frama-C */
#include "__fc_builtin.h"
#include "arpa/inet.h"
#include "assert.h"
#include "errno.h"
#include "fcntl.h"
#include "inttypes.h"
#include "netdb.h"
#include "netinet/in.h"
#include "signal.h"
#include "stdarg.h"
#include "stddef.h"
#include "stdint.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.c"
#include "string.h"
#include "strings.h"
#include "stropts.h"
#include "sys/select.h"
#include "sys/socket.h"
#include "sys/time.h"
#include "sys/uio.h"
#include "termios.h"
#include "time.h"
#include "unistd.h"
enum __anonenum_1 {
    MODBUS_EXCEPTION_ILLEGAL_FUNCTION = 0x01,
    MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS = 2,
    MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE = 3,
    MODBUS_EXCEPTION_SLAVE_OR_SERVER_FAILURE = 4,
    MODBUS_EXCEPTION_ACKNOWLEDGE = 5,
    MODBUS_EXCEPTION_SLAVE_OR_SERVER_BUSY = 6,
    MODBUS_EXCEPTION_NEGATIVE_ACKNOWLEDGE = 7,
    MODBUS_EXCEPTION_MEMORY_PARITY = 8,
    MODBUS_EXCEPTION_NOT_DEFINED = 9,
    MODBUS_EXCEPTION_GATEWAY_PATH = 10,
    MODBUS_EXCEPTION_GATEWAY_TARGET = 11,
    MODBUS_EXCEPTION_MAX = 12
};
typedef struct _modbus modbus_t;
struct __anonstruct_modbus_mapping_t_2 {
   int nb_bits ;
   int start_bits ;
   int nb_input_bits ;
   int start_input_bits ;
   int nb_input_registers ;
   int start_input_registers ;
   int nb_registers ;
   int start_registers ;
   uint8_t *tab_bits ;
   uint8_t *tab_input_bits ;
   uint16_t *tab_input_registers ;
   uint16_t *tab_registers ;
};
typedef struct __anonstruct_modbus_mapping_t_2 modbus_mapping_t;
enum __anonenum_modbus_error_recovery_mode_3 {
    MODBUS_ERROR_RECOVERY_NONE = 0,
    MODBUS_ERROR_RECOVERY_LINK = 1 << 1,
    MODBUS_ERROR_RECOVERY_PROTOCOL = 1 << 2
};
typedef enum __anonenum_modbus_error_recovery_mode_3 modbus_error_recovery_mode;
enum __anonenum_modbus_backend_type_t_4 {
    _MODBUS_BACKEND_TYPE_RTU = 0,
    _MODBUS_BACKEND_TYPE_TCP = 1
};
enum __anonenum_msg_type_t_5 {
    MSG_INDICATION = 0,
    MSG_CONFIRMATION = 1
};
typedef enum __anonenum_msg_type_t_5 msg_type_t;
struct _sft {
   int slave ;
   int function ;
   int t_id ;
};
typedef struct _sft sft_t;
struct _modbus_backend {
   unsigned int backend_type ;
   unsigned int header_length ;
   unsigned int checksum_length ;
   unsigned int max_adu_length ;
   int (*set_slave)(modbus_t *ctx, int slave) ;
   int (*build_request_basis)(modbus_t *ctx, int function, int addr, int nb,
                              uint8_t *req) ;
   int (*build_response_basis)(sft_t *sft, uint8_t *rsp) ;
   int (*prepare_response_tid)(uint8_t const *req, int *req_length) ;
   int (*send_msg_pre)(uint8_t *req, int req_length) ;
   ssize_t (*send)(modbus_t *ctx, uint8_t const *req, int req_length) ;
   int (*receive)(modbus_t *ctx, uint8_t *req) ;
   ssize_t (*recv)(modbus_t *ctx, uint8_t *rsp, int rsp_length) ;
   int (*check_integrity)(modbus_t *ctx, uint8_t *msg, int const msg_length) ;
   int (*pre_check_confirmation)(modbus_t *ctx, uint8_t const *req,
                                 uint8_t const *rsp, int rsp_length) ;
   int (*connect)(modbus_t *ctx) ;
   void (*close)(modbus_t *ctx) ;
   int (*flush)(modbus_t *ctx) ;
   int (*select)(modbus_t *ctx, fd_set *rset, struct timeval *tv,
                 int msg_length) ;
   void (*free)(modbus_t *ctx) ;
};
typedef struct _modbus_backend modbus_backend_t;
struct _modbus {
   int slave ;
   int s ;
   int debug ;
   int error_recovery ;
   struct timeval response_timeout ;
   struct timeval byte_timeout ;
   modbus_backend_t const *backend ;
   void *backend_data ;
};
struct _modbus_rtu {
   char *device ;
   int baud ;
   uint8_t data_bit ;
   uint8_t stop_bit ;
   char parity ;
   struct termios old_tios ;
   int rts ;
   int rts_delay ;
   int onebyte_time ;
   void (*set_rts)(modbus_t *ctx, int on) ;
   int confirmation_to_ignore ;
};
typedef struct _modbus_rtu modbus_rtu_t;
struct _modbus_tcp {
   uint16_t t_id ;
   int port ;
   char ip[16] ;
};
typedef struct _modbus_tcp modbus_tcp_t;
struct _modbus_tcp_pi {
   uint16_t t_id ;
   int port ;
   char node[1025] ;
   char service[32] ;
};
typedef struct _modbus_tcp_pi modbus_tcp_pi_t;
enum __anonenum__step_t_6 {
    _STEP_FUNCTION = 0,
    _STEP_META = 1,
    _STEP_DATA = 2
};
typedef enum __anonenum__step_t_6 _step_t;
/* compiler builtin: 
   unsigned int __builtin_bswap32(unsigned int);   */
unsigned int const libmodbus_version_major;

unsigned int const libmodbus_version_minor;

unsigned int const libmodbus_version_micro;

int modbus_set_slave(modbus_t *ctx, int slave);

int modbus_get_slave(modbus_t *ctx);

int modbus_set_error_recovery(modbus_t *ctx,
                              modbus_error_recovery_mode error_recovery);

int modbus_set_socket(modbus_t *ctx, int s);

int modbus_get_socket(modbus_t *ctx);

int modbus_get_response_timeout(modbus_t *ctx, uint32_t *to_sec,
                                uint32_t *to_usec);

int modbus_set_response_timeout(modbus_t *ctx, uint32_t to_sec,
                                uint32_t to_usec);

int modbus_get_byte_timeout(modbus_t *ctx, uint32_t *to_sec,
                            uint32_t *to_usec);

int modbus_set_byte_timeout(modbus_t *ctx, uint32_t to_sec, uint32_t to_usec);

int modbus_get_header_length(modbus_t *ctx);

int modbus_connect(modbus_t *ctx);

void modbus_close(modbus_t *ctx);

void modbus_free(modbus_t *ctx);

int modbus_flush(modbus_t *ctx);

int modbus_set_debug(modbus_t *ctx, int flag);

char const *modbus_strerror(int errnum);

int modbus_read_bits(modbus_t *ctx, int addr, int nb, uint8_t *dest);

int modbus_read_input_bits(modbus_t *ctx, int addr, int nb, uint8_t *dest);

int modbus_read_registers(modbus_t *ctx, int addr, int nb, uint16_t *dest);

int modbus_read_input_registers(modbus_t *ctx, int addr, int nb,
                                uint16_t *dest);

int modbus_write_bit(modbus_t *ctx, int addr, int status);

int modbus_write_register(modbus_t *ctx, int addr, int value);

int modbus_write_bits(modbus_t *ctx, int addr, int nb, uint8_t const *src);

int modbus_write_registers(modbus_t *ctx, int addr, int nb,
                           uint16_t const *src);

int modbus_mask_write_register(modbus_t *ctx, int addr, uint16_t and_mask,
                               uint16_t or_mask);

int modbus_write_and_read_registers(modbus_t *ctx, int write_addr,
                                    int write_nb, uint16_t const *src,
                                    int read_addr, int read_nb,
                                    uint16_t *dest);

int modbus_report_slave_id(modbus_t *ctx, int max_dest, uint8_t *dest);

modbus_mapping_t *modbus_mapping_new_start_address(unsigned int start_bits,
                                                   unsigned int nb_bits,
                                                   unsigned int start_input_bits,
                                                   unsigned int nb_input_bits,
                                                   unsigned int start_registers,
                                                   unsigned int nb_registers,
                                                   unsigned int start_input_registers,
                                                   unsigned int nb_input_registers);

modbus_mapping_t *modbus_mapping_new(int nb_bits, int nb_input_bits,
                                     int nb_registers, int nb_input_registers);

void modbus_mapping_free(modbus_mapping_t *mb_mapping);

int modbus_send_raw_request(modbus_t *ctx, uint8_t *raw_req,
                            int raw_req_length);

int modbus_receive(modbus_t *ctx, uint8_t *req);

int modbus_receive_confirmation(modbus_t *ctx, uint8_t *rsp);

int modbus_reply(modbus_t *ctx, uint8_t const *req, int req_length,
                 modbus_mapping_t *mb_mapping);

int modbus_reply_exception(modbus_t *ctx, uint8_t const *req,
                           unsigned int exception_code);

void modbus_set_bits_from_byte(uint8_t *dest, int idx, uint8_t const value);

void modbus_set_bits_from_bytes(uint8_t *dest, int idx, unsigned int nb_bits,
                                uint8_t const *tab_byte);

uint8_t modbus_get_byte_from_bits(uint8_t const *src, int idx,
                                  unsigned int nb_bits);

float modbus_get_float(uint16_t const *src);

float modbus_get_float_abcd(uint16_t const *src);

float modbus_get_float_dcba(uint16_t const *src);

float modbus_get_float_badc(uint16_t const *src);

float modbus_get_float_cdab(uint16_t const *src);

void modbus_set_float(float f, uint16_t *dest);

void modbus_set_float_abcd(float f, uint16_t *dest);

void modbus_set_float_dcba(float f, uint16_t *dest);

void modbus_set_float_badc(float f, uint16_t *dest);

void modbus_set_float_cdab(float f, uint16_t *dest);

modbus_t *modbus_new_tcp(char const *ip, int port);

int modbus_tcp_listen(modbus_t *ctx, int nb_connection);

int modbus_tcp_accept(modbus_t *ctx, int *s);

modbus_t *modbus_new_tcp_pi(char const *node, char const *service);

int modbus_tcp_pi_listen(modbus_t *ctx, int nb_connection);

int modbus_tcp_pi_accept(modbus_t *ctx, int *s);

modbus_t *modbus_new_rtu(char const *device, int baud, char parity,
                         int data_bit, int stop_bit);

int modbus_rtu_set_serial_mode(modbus_t *ctx, int mode);

int modbus_rtu_get_serial_mode(modbus_t *ctx);

int modbus_rtu_set_rts(modbus_t *ctx, int mode);

int modbus_rtu_get_rts(modbus_t *ctx);

int modbus_rtu_set_custom_rts(modbus_t *ctx,
                              void (*set_rts)(modbus_t *ctx, int on));

int modbus_rtu_set_rts_delay(modbus_t *ctx, int us);

int modbus_rtu_get_rts_delay(modbus_t *ctx);

void modbus_set_bits_from_byte(uint8_t *dest, int idx, uint8_t const value)
{
  int i;
  i = 0;
  while (i < 8) {
    if ((int)value & (1 << i)) *(dest + (idx + i)) = (uint8_t)1;
    else *(dest + (idx + i)) = (uint8_t)0;
    i ++;
  }
  return;
}

void modbus_set_bits_from_bytes(uint8_t *dest, int idx, unsigned int nb_bits,
                                uint8_t const *tab_byte)
{
  unsigned int i;
  int shift = 0;
  i = (unsigned int)idx;
  while (i < (unsigned int)idx + nb_bits) {
    if ((int)*(tab_byte + (i - (unsigned int)idx) / (unsigned int)8) & (
        1 << shift)) *(dest + i) = (uint8_t)1;
    else *(dest + i) = (uint8_t)0;
    shift ++;
    shift %= 8;
    i ++;
  }
  return;
}

uint8_t modbus_get_byte_from_bits(uint8_t const *src, int idx,
                                  unsigned int nb_bits)
{
  unsigned int i;
  uint8_t value = (uint8_t)0;
  if (nb_bits > (unsigned int)8) {
    __FC_assert((nb_bits < (unsigned int)8) != 0,"src/modbus-data.c",106,
                "nb_bits < 8");
    nb_bits = (unsigned int)8;
  }
  i = (unsigned int)0;
  while (i < nb_bits) {
    value = (uint8_t)((int)value | ((int)*(src + ((unsigned int)idx + i)) << i));
    i ++;
  }
  return value;
}

float modbus_get_float_abcd(uint16_t const *src)
{
  float f;
  uint32_t i;
  i = ntohl(((uint32_t)*(src + 0) << 16) + (uint32_t)*(src + 1));
  memcpy((void *)(& f),(void const *)(& i),sizeof(float));
  return f;
}

float modbus_get_float_dcba(uint16_t const *src)
{
  float f;
  uint32_t i;
  unsigned int tmp;
  tmp = __builtin_bswap32(((uint32_t)*(src + 0) << 16) + (uint32_t)*(src + 1));
  i = ntohl(tmp);
  memcpy((void *)(& f),(void const *)(& i),sizeof(float));
  return f;
}

float modbus_get_float_badc(uint16_t const *src)
{
  float f;
  uint32_t i;
  int tmp;
  int tmp_0;
  {
    register unsigned short __x = *(src + 0);
    tmp = (((int)__x >> 8) & 0xff) | (((int)__x & 0xff) << 8);
  }
  {
    register unsigned short __x_0 = *(src + 1);
    tmp_0 = (((int)__x_0 >> 8) & 0xff) | (((int)__x_0 & 0xff) << 8);
  }
  i = ntohl((uint32_t)(tmp << 16) + (uint32_t)tmp_0);
  memcpy((void *)(& f),(void const *)(& i),sizeof(float));
  return f;
}

float modbus_get_float_cdab(uint16_t const *src)
{
  float f;
  uint32_t i;
  i = ntohl(((uint32_t)*(src + 1) << 16) + (uint32_t)*(src + 0));
  memcpy((void *)(& f),(void const *)(& i),sizeof(float));
  return f;
}

float modbus_get_float(uint16_t const *src)
{
  float f;
  uint32_t i;
  i = ((uint32_t)*(src + 1) << 16) + (uint32_t)*(src + 0);
  memcpy((void *)(& f),(void const *)(& i),sizeof(float));
  return f;
}

void modbus_set_float_abcd(float f, uint16_t *dest)
{
  uint32_t i;
  memcpy((void *)(& i),(void const *)(& f),sizeof(uint32_t));
  i = htonl(i);
  *(dest + 0) = (uint16_t)(i >> 16);
  *(dest + 1) = (uint16_t)i;
  return;
}

void modbus_set_float_dcba(float f, uint16_t *dest)
{
  uint32_t i;
  uint32_t tmp;
  memcpy((void *)(& i),(void const *)(& f),sizeof(uint32_t));
  tmp = htonl(i);
  i = __builtin_bswap32(tmp);
  *(dest + 0) = (uint16_t)(i >> 16);
  *(dest + 1) = (uint16_t)i;
  return;
}

void modbus_set_float_badc(float f, uint16_t *dest)
{
  uint32_t i;
  int tmp;
  int tmp_0;
  memcpy((void *)(& i),(void const *)(& f),sizeof(uint32_t));
  i = htonl(i);
  {
    register unsigned short __x = (unsigned short)(i >> 16);
    tmp = (((int)__x >> 8) & 0xff) | (((int)__x & 0xff) << 8);
  }
  *(dest + 0) = (uint16_t)tmp;
  {
    register unsigned short __x_0 =
      (unsigned short)(i & (unsigned int)0xFFFF);
    tmp_0 = (((int)__x_0 >> 8) & 0xff) | (((int)__x_0 & 0xff) << 8);
  }
  *(dest + 1) = (uint16_t)tmp_0;
  return;
}

void modbus_set_float_cdab(float f, uint16_t *dest)
{
  uint32_t i;
  memcpy((void *)(& i),(void const *)(& f),sizeof(uint32_t));
  i = htonl(i);
  *(dest + 0) = (uint16_t)i;
  *(dest + 1) = (uint16_t)(i >> 16);
  return;
}

void modbus_set_float(float f, uint16_t *dest)
{
  uint32_t i;
  memcpy((void *)(& i),(void const *)(& f),sizeof(uint32_t));
  *(dest + 0) = (uint16_t)i;
  *(dest + 1) = (uint16_t)(i >> 16);
  return;
}

void _modbus_init_common(modbus_t *ctx);

void _error_print(modbus_t *ctx, char const *context);

int _modbus_receive_msg(modbus_t *ctx, uint8_t *msg, msg_type_t msg_type);

static uint8_t const table_crc_hi[256] =
  {(uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x01,
   (uint8_t)0xC0,
   (uint8_t)0x80,
   (uint8_t)0x41,
   (uint8_t)0x00,
   (uint8_t)0xC1,
   (uint8_t)0x81,
   (uint8_t)0x40};
static uint8_t const table_crc_lo[256] =
  {(uint8_t)0x00,
   (uint8_t)0xC0,
   (uint8_t)0xC1,
   (uint8_t)0x01,
   (uint8_t)0xC3,
   (uint8_t)0x03,
   (uint8_t)0x02,
   (uint8_t)0xC2,
   (uint8_t)0xC6,
   (uint8_t)0x06,
   (uint8_t)0x07,
   (uint8_t)0xC7,
   (uint8_t)0x05,
   (uint8_t)0xC5,
   (uint8_t)0xC4,
   (uint8_t)0x04,
   (uint8_t)0xCC,
   (uint8_t)0x0C,
   (uint8_t)0x0D,
   (uint8_t)0xCD,
   (uint8_t)0x0F,
   (uint8_t)0xCF,
   (uint8_t)0xCE,
   (uint8_t)0x0E,
   (uint8_t)0x0A,
   (uint8_t)0xCA,
   (uint8_t)0xCB,
   (uint8_t)0x0B,
   (uint8_t)0xC9,
   (uint8_t)0x09,
   (uint8_t)0x08,
   (uint8_t)0xC8,
   (uint8_t)0xD8,
   (uint8_t)0x18,
   (uint8_t)0x19,
   (uint8_t)0xD9,
   (uint8_t)0x1B,
   (uint8_t)0xDB,
   (uint8_t)0xDA,
   (uint8_t)0x1A,
   (uint8_t)0x1E,
   (uint8_t)0xDE,
   (uint8_t)0xDF,
   (uint8_t)0x1F,
   (uint8_t)0xDD,
   (uint8_t)0x1D,
   (uint8_t)0x1C,
   (uint8_t)0xDC,
   (uint8_t)0x14,
   (uint8_t)0xD4,
   (uint8_t)0xD5,
   (uint8_t)0x15,
   (uint8_t)0xD7,
   (uint8_t)0x17,
   (uint8_t)0x16,
   (uint8_t)0xD6,
   (uint8_t)0xD2,
   (uint8_t)0x12,
   (uint8_t)0x13,
   (uint8_t)0xD3,
   (uint8_t)0x11,
   (uint8_t)0xD1,
   (uint8_t)0xD0,
   (uint8_t)0x10,
   (uint8_t)0xF0,
   (uint8_t)0x30,
   (uint8_t)0x31,
   (uint8_t)0xF1,
   (uint8_t)0x33,
   (uint8_t)0xF3,
   (uint8_t)0xF2,
   (uint8_t)0x32,
   (uint8_t)0x36,
   (uint8_t)0xF6,
   (uint8_t)0xF7,
   (uint8_t)0x37,
   (uint8_t)0xF5,
   (uint8_t)0x35,
   (uint8_t)0x34,
   (uint8_t)0xF4,
   (uint8_t)0x3C,
   (uint8_t)0xFC,
   (uint8_t)0xFD,
   (uint8_t)0x3D,
   (uint8_t)0xFF,
   (uint8_t)0x3F,
   (uint8_t)0x3E,
   (uint8_t)0xFE,
   (uint8_t)0xFA,
   (uint8_t)0x3A,
   (uint8_t)0x3B,
   (uint8_t)0xFB,
   (uint8_t)0x39,
   (uint8_t)0xF9,
   (uint8_t)0xF8,
   (uint8_t)0x38,
   (uint8_t)0x28,
   (uint8_t)0xE8,
   (uint8_t)0xE9,
   (uint8_t)0x29,
   (uint8_t)0xEB,
   (uint8_t)0x2B,
   (uint8_t)0x2A,
   (uint8_t)0xEA,
   (uint8_t)0xEE,
   (uint8_t)0x2E,
   (uint8_t)0x2F,
   (uint8_t)0xEF,
   (uint8_t)0x2D,
   (uint8_t)0xED,
   (uint8_t)0xEC,
   (uint8_t)0x2C,
   (uint8_t)0xE4,
   (uint8_t)0x24,
   (uint8_t)0x25,
   (uint8_t)0xE5,
   (uint8_t)0x27,
   (uint8_t)0xE7,
   (uint8_t)0xE6,
   (uint8_t)0x26,
   (uint8_t)0x22,
   (uint8_t)0xE2,
   (uint8_t)0xE3,
   (uint8_t)0x23,
   (uint8_t)0xE1,
   (uint8_t)0x21,
   (uint8_t)0x20,
   (uint8_t)0xE0,
   (uint8_t)0xA0,
   (uint8_t)0x60,
   (uint8_t)0x61,
   (uint8_t)0xA1,
   (uint8_t)0x63,
   (uint8_t)0xA3,
   (uint8_t)0xA2,
   (uint8_t)0x62,
   (uint8_t)0x66,
   (uint8_t)0xA6,
   (uint8_t)0xA7,
   (uint8_t)0x67,
   (uint8_t)0xA5,
   (uint8_t)0x65,
   (uint8_t)0x64,
   (uint8_t)0xA4,
   (uint8_t)0x6C,
   (uint8_t)0xAC,
   (uint8_t)0xAD,
   (uint8_t)0x6D,
   (uint8_t)0xAF,
   (uint8_t)0x6F,
   (uint8_t)0x6E,
   (uint8_t)0xAE,
   (uint8_t)0xAA,
   (uint8_t)0x6A,
   (uint8_t)0x6B,
   (uint8_t)0xAB,
   (uint8_t)0x69,
   (uint8_t)0xA9,
   (uint8_t)0xA8,
   (uint8_t)0x68,
   (uint8_t)0x78,
   (uint8_t)0xB8,
   (uint8_t)0xB9,
   (uint8_t)0x79,
   (uint8_t)0xBB,
   (uint8_t)0x7B,
   (uint8_t)0x7A,
   (uint8_t)0xBA,
   (uint8_t)0xBE,
   (uint8_t)0x7E,
   (uint8_t)0x7F,
   (uint8_t)0xBF,
   (uint8_t)0x7D,
   (uint8_t)0xBD,
   (uint8_t)0xBC,
   (uint8_t)0x7C,
   (uint8_t)0xB4,
   (uint8_t)0x74,
   (uint8_t)0x75,
   (uint8_t)0xB5,
   (uint8_t)0x77,
   (uint8_t)0xB7,
   (uint8_t)0xB6,
   (uint8_t)0x76,
   (uint8_t)0x72,
   (uint8_t)0xB2,
   (uint8_t)0xB3,
   (uint8_t)0x73,
   (uint8_t)0xB1,
   (uint8_t)0x71,
   (uint8_t)0x70,
   (uint8_t)0xB0,
   (uint8_t)0x50,
   (uint8_t)0x90,
   (uint8_t)0x91,
   (uint8_t)0x51,
   (uint8_t)0x93,
   (uint8_t)0x53,
   (uint8_t)0x52,
   (uint8_t)0x92,
   (uint8_t)0x96,
   (uint8_t)0x56,
   (uint8_t)0x57,
   (uint8_t)0x97,
   (uint8_t)0x55,
   (uint8_t)0x95,
   (uint8_t)0x94,
   (uint8_t)0x54,
   (uint8_t)0x9C,
   (uint8_t)0x5C,
   (uint8_t)0x5D,
   (uint8_t)0x9D,
   (uint8_t)0x5F,
   (uint8_t)0x9F,
   (uint8_t)0x9E,
   (uint8_t)0x5E,
   (uint8_t)0x5A,
   (uint8_t)0x9A,
   (uint8_t)0x9B,
   (uint8_t)0x5B,
   (uint8_t)0x99,
   (uint8_t)0x59,
   (uint8_t)0x58,
   (uint8_t)0x98,
   (uint8_t)0x88,
   (uint8_t)0x48,
   (uint8_t)0x49,
   (uint8_t)0x89,
   (uint8_t)0x4B,
   (uint8_t)0x8B,
   (uint8_t)0x8A,
   (uint8_t)0x4A,
   (uint8_t)0x4E,
   (uint8_t)0x8E,
   (uint8_t)0x8F,
   (uint8_t)0x4F,
   (uint8_t)0x8D,
   (uint8_t)0x4D,
   (uint8_t)0x4C,
   (uint8_t)0x8C,
   (uint8_t)0x44,
   (uint8_t)0x84,
   (uint8_t)0x85,
   (uint8_t)0x45,
   (uint8_t)0x87,
   (uint8_t)0x47,
   (uint8_t)0x46,
   (uint8_t)0x86,
   (uint8_t)0x82,
   (uint8_t)0x42,
   (uint8_t)0x43,
   (uint8_t)0x83,
   (uint8_t)0x41,
   (uint8_t)0x81,
   (uint8_t)0x80,
   (uint8_t)0x40};
static int _modbus_set_slave(modbus_t *ctx, int slave)
{
  int __retres;
  if (slave >= 0) {
    if (slave <= 247) ctx->slave = slave; else goto _LAND;
  }
  else {
    _LAND: {
             __fc_errno = 22;
             __retres = -1;
             goto return_label;
           }
  }
  __retres = 0;
  return_label: return __retres;
}

static int _modbus_rtu_build_request_basis(modbus_t *ctx, int function,
                                           int addr, int nb, uint8_t *req)
{
  int __retres;
  __FC_assert((ctx->slave != -1) != 0,"src/modbus-rtu.c",110,
              "ctx->slave != -1");
  *(req + 0) = (uint8_t)ctx->slave;
  *(req + 1) = (uint8_t)function;
  *(req + 2) = (uint8_t)(addr >> 8);
  *(req + 3) = (uint8_t)(addr & 0x00ff);
  *(req + 4) = (uint8_t)(nb >> 8);
  *(req + 5) = (uint8_t)(nb & 0x00ff);
  __retres = 6;
  return __retres;
}

static int _modbus_rtu_build_response_basis(sft_t *sft, uint8_t *rsp)
{
  int __retres;
  *(rsp + 0) = (uint8_t)sft->slave;
  *(rsp + 1) = (uint8_t)sft->function;
  __retres = 2;
  return __retres;
}

static uint16_t crc16(uint8_t *buffer, uint16_t buffer_length)
{
  uint16_t __retres;
  unsigned int i;
  uint8_t crc_hi = (uint8_t)0xFF;
  uint8_t crc_lo = (uint8_t)0xFF;
  while (1) {
    uint16_t tmp_0;
    tmp_0 = buffer_length;
    buffer_length = (uint16_t)((int)buffer_length - 1);
    ;
    if (! tmp_0) break;
    {
      uint8_t *tmp;
      tmp = buffer;
      buffer ++;
      i = (unsigned int)((int)crc_hi ^ (int)*tmp);
      crc_hi = (uint8_t)((int)crc_lo ^ (int)table_crc_hi[i]);
      crc_lo = table_crc_lo[i];
    }
  }
  __retres = (uint16_t)(((int)crc_hi << 8) | (int)crc_lo);
  return __retres;
}

static int _modbus_rtu_prepare_response_tid(uint8_t const *req,
                                            int *req_length)
{
  int __retres;
  *req_length -= 2;
  __retres = 0;
  return __retres;
}

static int _modbus_rtu_send_msg_pre(uint8_t *req, int req_length)
{
  int tmp_0;
  int tmp_1;
  uint16_t crc = crc16(req,(uint16_t)req_length);
  tmp_0 = req_length;
  req_length ++;
  *(req + tmp_0) = (uint8_t)((int)crc >> 8);
  tmp_1 = req_length;
  req_length ++;
  *(req + tmp_1) = (uint8_t)((int)crc & 0x00FF);
  return req_length;
}

static void _modbus_rtu_ioctl_rts(modbus_t *ctx, int on)
{
  int flags;
  int fd = ctx->s;
  ioctl(fd,0x5415,(void *)(& flags)); /* __va_ioctl_ptr */
  if (on) flags |= 0x004; else flags &= ~ 0x004;
  ioctl(fd,0x5418,(void *)(& flags)); /* __va_ioctl_ptr */
  return;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_1(FILE * restrict stream, char const * restrict format);

static ssize_t _modbus_rtu_send(modbus_t *ctx, uint8_t const *req,
                                int req_length)
{
  ssize_t __retres;
  modbus_rtu_t *ctx_rtu = (modbus_rtu_t *)ctx->backend_data;
  if (ctx_rtu->rts != 0) {
    ssize_t size;
    if (ctx->debug) fprintf(__fc_stderr,"Sending request using RTS signal\n"); /* fprintf_va_1 */
    (*(ctx_rtu->set_rts))(ctx,ctx_rtu->rts == 1);
    usleep((useconds_t)ctx_rtu->rts_delay);
    size = write(ctx->s,(void const *)req,(size_t)req_length);
    usleep((useconds_t)(ctx_rtu->onebyte_time * req_length + ctx_rtu->rts_delay));
    (*(ctx_rtu->set_rts))(ctx,ctx_rtu->rts != 1);
    __retres = size;
    goto return_label;
  }
  else {
    ssize_t tmp;
    tmp = write(ctx->s,(void const *)req,(size_t)req_length);
    __retres = tmp;
    goto return_label;
  }
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_1(char const * restrict format);

static int _modbus_rtu_receive(modbus_t *ctx, uint8_t *req)
{
  int rc;
  modbus_rtu_t *ctx_rtu = (modbus_rtu_t *)ctx->backend_data;
  if (ctx_rtu->confirmation_to_ignore) {
    _modbus_receive_msg(ctx,req,MSG_CONFIRMATION);
    ctx_rtu->confirmation_to_ignore = 0;
    rc = 0;
    if (ctx->debug) printf("Confirmation to ignore\n"); /* printf_va_1 */
  }
  else {
    rc = _modbus_receive_msg(ctx,req,MSG_INDICATION);
    if (rc == 0) ctx_rtu->confirmation_to_ignore = 1;
  }
  return rc;
}

static ssize_t _modbus_rtu_recv(modbus_t *ctx, uint8_t *rsp, int rsp_length)
{
  ssize_t tmp;
  tmp = read(ctx->s,(void *)rsp,(size_t)rsp_length);
  return tmp;
}

static int _modbus_rtu_flush(modbus_t *ctx);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param1, param0;
 */
int fprintf_va_2(FILE * restrict stream, char const * restrict format,
                 int param0, int param1);

static int _modbus_rtu_pre_check_confirmation(modbus_t *ctx,
                                              uint8_t const *req,
                                              uint8_t const *rsp,
                                              int rsp_length)
{
  int __retres;
  if ((int)*(req + 0) != (int)*(rsp + 0)) {
    if ((int)*(req + 0) != 0) {
      if (ctx->debug) fprintf(__fc_stderr,
                              "The responding slave %d isn\'t the requested slave %d\n",
                              (int)*(rsp + 0),(int)*(req + 0)); /* fprintf_va_2 */
      __fc_errno = (112345678 + MODBUS_EXCEPTION_GATEWAY_TARGET) + 6;
      __retres = -1;
      goto return_label;
    }
    else goto _LAND;
  }
  else {
    _LAND: {
             __retres = 0;
             goto return_label;
           }
  }
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_2(char const * restrict format, int param0, int param1);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param1, param0;
 */
int fprintf_va_3(FILE * restrict stream, char const * restrict format,
                 unsigned int param0, unsigned int param1);

static int _modbus_rtu_check_integrity(modbus_t *ctx, uint8_t *msg,
                                       int const msg_length)
{
  int __retres;
  uint16_t crc_calculated;
  uint16_t crc_received;
  int slave = (int)*(msg + 0);
  if (slave != ctx->slave) 
    if (slave != 0) {
      if (ctx->debug) printf("Request for slave %d ignored (not %d)\n",slave,
                             ctx->slave); /* printf_va_2 */
      __retres = 0;
      goto return_label;
    }
  crc_calculated = crc16(msg,(uint16_t)(msg_length - 2));
  crc_received = (uint16_t)(((int)*(msg + (msg_length - 2)) << 8) | (int)*(
                            msg + (msg_length - 1)));
  if ((int)crc_calculated == (int)crc_received) {
    __retres = msg_length;
    goto return_label;
  }
  else {
    if (ctx->debug) fprintf(__fc_stderr,
                            "ERROR CRC received 0x%0X != CRC calculated 0x%0X\n",
                            (unsigned int)((int)crc_received),
                            (unsigned int)((int)crc_calculated)); /* fprintf_va_3 */
    if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) _modbus_rtu_flush
                                                              (ctx);
    __fc_errno = (112345678 + MODBUS_EXCEPTION_GATEWAY_TARGET) + 1;
    __retres = -1;
    goto return_label;
  }
  return_label: return __retres;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param4),
            (indirect: param3), (indirect: param2), (indirect: param1),
            (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param4, param3, param2, param1, *(param0 + (0 ..));
 */
int printf_va_3(char const * restrict format, char *param0, int param1,
                int param2, int param3, int param4);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param1 + (0 ..)),
            *(param0 + (0 ..));
 */
int fprintf_va_4(FILE * restrict stream, char const * restrict format,
                 char *param0, char *param1);

/*@ requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param1 + (0 ..)), param0;
 */
int fprintf_va_5(FILE * restrict stream, char const * restrict format,
                 int param0, char *param1);

static int _modbus_rtu_connect(modbus_t *ctx)
{
  int __retres;
  struct termios tios;
  speed_t speed;
  int flags;
  int tmp_0;
  int tmp_2;
  modbus_rtu_t *ctx_rtu = (modbus_rtu_t *)ctx->backend_data;
  if (ctx->debug) printf("Opening %s at %d bauds (%c, %d, %d)\n",
                         ctx_rtu->device,ctx_rtu->baud,(int)ctx_rtu->parity,
                         (int)ctx_rtu->data_bit,(int)ctx_rtu->stop_bit); /* printf_va_3 */
  flags = ((2 | 0x100) | 0x800) | 0x80;
  flags |= 0x80000;
  ctx->s = open((char const *)ctx_rtu->device,flags); /* __va_open_void */
  if (ctx->s == -1) {
    if (ctx->debug) {
      char *tmp;
      tmp = strerror(__fc_errno);
      ;
      ;
      fprintf(__fc_stderr,"ERROR Can\'t open the device %s (%s)\n",
              ctx_rtu->device,tmp); /* fprintf_va_4 */
    }
    __retres = -1;
    goto return_label;
  }
  tcgetattr(ctx->s,& ctx_rtu->old_tios);
  memset((void *)(& tios),0,sizeof(struct termios));
  switch (ctx_rtu->baud) {
    case 110: speed = (speed_t)0000003;
    break;
    case 300: speed = (speed_t)0000007;
    break;
    case 600: speed = (speed_t)0000010;
    break;
    case 1200: speed = (speed_t)0000011;
    break;
    case 2400: speed = (speed_t)0000013;
    break;
    case 4800: speed = (speed_t)0000014;
    break;
    case 9600: speed = (speed_t)0000015;
    break;
    case 19200: speed = (speed_t)0000016;
    break;
    case 38400: speed = (speed_t)0000017;
    break;
    case 57600: speed = (speed_t)0010001;
    break;
    case 115200: speed = (speed_t)0010002;
    break;
    case 230400: speed = (speed_t)0010003;
    break;
    case 460800: speed = (speed_t)0010004;
    break;
    case 500000: speed = (speed_t)0010005;
    break;
    case 576000: speed = (speed_t)0010006;
    break;
    case 921600: speed = (speed_t)0010007;
    break;
    case 1000000: speed = (speed_t)0010010;
    break;
    case 1152000: speed = (speed_t)0010011;
    break;
    case 1500000: speed = (speed_t)0010012;
    break;
    case 2500000: speed = (speed_t)0010014;
    break;
    case 3000000: speed = (speed_t)0010015;
    break;
    case 3500000: speed = (speed_t)0010016;
    break;
    case 4000000: speed = (speed_t)0010017;
    break;
    default: speed = (speed_t)0000015;
    if (ctx->debug) fprintf(__fc_stderr,
                            "WARNING Unknown baud rate %d for %s (B9600 used)\n",
                            ctx_rtu->baud,ctx_rtu->device); /* fprintf_va_5 */
  }
  tmp_0 = cfsetispeed(& tios,speed);
  if (tmp_0 < 0) goto _LOR;
  else {
    int tmp_1;
    tmp_1 = cfsetospeed(& tios,speed);
    if (tmp_1 < 0) {
      _LOR: {
              close(ctx->s);
              ctx->s = -1;
              __retres = -1;
              goto return_label;
            }
    }
  }
  tios.c_cflag |= (unsigned int)(0000200 | 0004000);
  tios.c_cflag &= (unsigned int)(~ 0000060);
  switch ((int)ctx_rtu->data_bit) {
    case 5: tios.c_cflag |= (unsigned int)0000000;
    break;
    case 6: tios.c_cflag |= (unsigned int)0000020;
    break;
    case 7: tios.c_cflag |= (unsigned int)0000040;
    break;
    case 8: default: tios.c_cflag |= (unsigned int)0000060;
    break;
  }
  if ((int)ctx_rtu->stop_bit == 1) tios.c_cflag &= (unsigned int)(~ 0000100);
  else tios.c_cflag |= (unsigned int)0000100;
  if ((int)ctx_rtu->parity == 'N') tios.c_cflag &= (unsigned int)(~ 0000400);
  else 
    if ((int)ctx_rtu->parity == 'E') {
      tios.c_cflag |= (unsigned int)0000400;
      tios.c_cflag &= (unsigned int)(~ 0001000);
    }
    else {
      tios.c_cflag |= (unsigned int)0000400;
      tios.c_cflag |= (unsigned int)0001000;
    }
  tios.c_lflag &= (unsigned int)(~ (((0000002 | 0000010) | 0000020) | 0000001));
  if ((int)ctx_rtu->parity == 'N') tios.c_iflag &= (unsigned int)(~ 0000020);
  else tios.c_iflag |= (unsigned int)0000020;
  tios.c_iflag &= (unsigned int)(~ ((0002000 | 0010000) | 0004000));
  tios.c_oflag &= (unsigned int)(~ 0000001);
  tios.c_cc[6] = (cc_t)0;
  tios.c_cc[5] = (cc_t)0;
  tmp_2 = tcsetattr(ctx->s,0,& tios);
  if (tmp_2 < 0) {
    close(ctx->s);
    ctx->s = -1;
    __retres = -1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_6(FILE * restrict stream, char const * restrict format);

int modbus_rtu_set_serial_mode(modbus_t *ctx, int mode)
{
  int __retres;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  if ((ctx->backend)->backend_type == (unsigned int)_MODBUS_BACKEND_TYPE_RTU) {
    if (ctx->debug) fprintf(__fc_stderr,
                            "This function isn\'t supported on your platform\n"); /* fprintf_va_6 */
    __fc_errno = 95;
    __retres = -1;
    goto return_label;
  }
  __fc_errno = 22;
  __retres = -1;
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_7(FILE * restrict stream, char const * restrict format);

int modbus_rtu_get_serial_mode(modbus_t *ctx)
{
  int __retres;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  if ((ctx->backend)->backend_type == (unsigned int)_MODBUS_BACKEND_TYPE_RTU) {
    if (ctx->debug) fprintf(__fc_stderr,
                            "This function isn\'t supported on your platform\n"); /* fprintf_va_7 */
    __fc_errno = 95;
    __retres = -1;
    goto return_label;
  }
  else {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  return_label: return __retres;
}

int modbus_rtu_get_rts(modbus_t *ctx)
{
  int __retres;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  if ((ctx->backend)->backend_type == (unsigned int)_MODBUS_BACKEND_TYPE_RTU) {
    modbus_rtu_t *ctx_rtu = (modbus_rtu_t *)ctx->backend_data;
    __retres = ctx_rtu->rts;
    goto return_label;
  }
  else {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  return_label: return __retres;
}

int modbus_rtu_set_rts(modbus_t *ctx, int mode)
{
  int __retres;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  if ((ctx->backend)->backend_type == (unsigned int)_MODBUS_BACKEND_TYPE_RTU) {
    modbus_rtu_t *ctx_rtu = (modbus_rtu_t *)ctx->backend_data;
    if (mode == 0) goto _LOR;
    else 
      if (mode == 1) goto _LOR;
      else 
        if (mode == 2) {
          _LOR:
          {
            ctx_rtu->rts = mode;
            (*(ctx_rtu->set_rts))(ctx,ctx_rtu->rts != 1);
            __retres = 0;
            goto return_label;
          }
        }
        else {
          __fc_errno = 22;
          __retres = -1;
          goto return_label;
        }
  }
  __fc_errno = 22;
  __retres = -1;
  return_label: return __retres;
}

int modbus_rtu_set_custom_rts(modbus_t *ctx,
                              void (*set_rts)(modbus_t *ctx, int on))
{
  int __retres;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  if ((ctx->backend)->backend_type == (unsigned int)_MODBUS_BACKEND_TYPE_RTU) {
    modbus_rtu_t *ctx_rtu = (modbus_rtu_t *)ctx->backend_data;
    ctx_rtu->set_rts = set_rts;
    __retres = 0;
    goto return_label;
  }
  else {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  return_label: return __retres;
}

int modbus_rtu_get_rts_delay(modbus_t *ctx)
{
  int __retres;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  if ((ctx->backend)->backend_type == (unsigned int)_MODBUS_BACKEND_TYPE_RTU) {
    modbus_rtu_t *ctx_rtu;
    ctx_rtu = (modbus_rtu_t *)ctx->backend_data;
    __retres = ctx_rtu->rts_delay;
    goto return_label;
  }
  else {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  return_label: return __retres;
}

int modbus_rtu_set_rts_delay(modbus_t *ctx, int us)
{
  int __retres;
  if (ctx == (modbus_t *)0) goto _LOR;
  else 
    if (us < 0) {
      _LOR: {
              __fc_errno = 22;
              __retres = -1;
              goto return_label;
            }
    }
  if ((ctx->backend)->backend_type == (unsigned int)_MODBUS_BACKEND_TYPE_RTU) {
    modbus_rtu_t *ctx_rtu;
    ctx_rtu = (modbus_rtu_t *)ctx->backend_data;
    ctx_rtu->rts_delay = us;
    __retres = 0;
    goto return_label;
  }
  else {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  return_label: return __retres;
}

static void _modbus_rtu_close(modbus_t *ctx)
{
  modbus_rtu_t *ctx_rtu = (modbus_rtu_t *)ctx->backend_data;
  if (ctx->s != -1) {
    tcsetattr(ctx->s,0,& ctx_rtu->old_tios);
    close(ctx->s);
    ctx->s = -1;
  }
  return;
}

static int _modbus_rtu_flush(modbus_t *ctx)
{
  int tmp;
  tmp = tcflush(ctx->s,2);
  return tmp;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_8(FILE * restrict stream, char const * restrict format);

static int _modbus_rtu_select(modbus_t *ctx, fd_set *rset,
                              struct timeval *tv, int length_to_read)
{
  int __retres;
  int s_rc;
  while (1) {
    s_rc = select(ctx->s + 1,rset,(fd_set *)0,(fd_set *)0,tv);
    if (! (s_rc == -1)) break;
    if (__fc_errno == 4) {
      if (ctx->debug) fprintf(__fc_stderr,
                              "A non blocked signal was caught\n"); /* fprintf_va_8 */
      FD_ZERO(rset);
      FD_SET(ctx->s,rset);
    }
    else {
      __retres = -1;
      goto return_label;
    }
  }
  if (s_rc == 0) {
    __fc_errno = 110;
    __retres = -1;
    goto return_label;
  }
  __retres = s_rc;
  return_label: return __retres;
}

static void _modbus_rtu_free(modbus_t *ctx)
{
  free((void *)((modbus_rtu_t *)ctx->backend_data)->device);
  free(ctx->backend_data);
  free((void *)ctx);
  return;
}

modbus_backend_t const _modbus_rtu_backend =
  {.backend_type = (unsigned int)_MODBUS_BACKEND_TYPE_RTU,
   .header_length = (unsigned int)1,
   .checksum_length = (unsigned int)2,
   .max_adu_length = (unsigned int)256,
   .set_slave = & _modbus_set_slave,
   .build_request_basis = & _modbus_rtu_build_request_basis,
   .build_response_basis = & _modbus_rtu_build_response_basis,
   .prepare_response_tid = & _modbus_rtu_prepare_response_tid,
   .send_msg_pre = & _modbus_rtu_send_msg_pre,
   .send = & _modbus_rtu_send,
   .receive = & _modbus_rtu_receive,
   .recv = & _modbus_rtu_recv,
   .check_integrity = & _modbus_rtu_check_integrity,
   .pre_check_confirmation = & _modbus_rtu_pre_check_confirmation,
   .connect = & _modbus_rtu_connect,
   .close = & _modbus_rtu_close,
   .flush = & _modbus_rtu_flush,
   .select = & _modbus_rtu_select,
   .free = & _modbus_rtu_free};
/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_9(FILE * restrict stream, char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_10(FILE * restrict stream, char const * restrict format);

modbus_t *modbus_new_rtu(char const *device, int baud, char parity,
                         int data_bit, int stop_bit)
{
  modbus_t *__retres;
  modbus_t *ctx;
  modbus_rtu_t *ctx_rtu;
  void *tmp_2;
  size_t tmp_1;
  int tmp_3;
  if (device == (char const *)0) goto _LOR;
  else 
    if ((int)*device == 0) {
      _LOR:
      {
        fprintf(__fc_stderr,"The device string is empty\n"); /* fprintf_va_9 */
        __fc_errno = 22;
        __retres = (modbus_t *)0;
        goto return_label;
      }
    }
  if (baud == 0) {
    fprintf(__fc_stderr,"The baud rate value must not be zero\n"); /* fprintf_va_10 */
    __fc_errno = 22;
    __retres = (modbus_t *)0;
    goto return_label;
  }
  ctx = (modbus_t *)malloc(sizeof(modbus_t));
  _modbus_init_common(ctx);
  ctx->backend = & _modbus_rtu_backend;
  ctx->backend_data = malloc(sizeof(modbus_rtu_t));
  ctx_rtu = (modbus_rtu_t *)ctx->backend_data;
  ctx_rtu->device = (char *)0;
  tmp_1 = strlen(device);
  tmp_2 = malloc((tmp_1 + (size_t)1) * sizeof(char));
  ctx_rtu->device = (char *)tmp_2;
  strcpy(ctx_rtu->device,device);
  ctx_rtu->baud = baud;
  if ((int)parity == 'N') goto _LOR_0;
  else 
    if ((int)parity == 'E') goto _LOR_0;
    else 
      if ((int)parity == 'O') _LOR_0: ctx_rtu->parity = parity;
      else {
        modbus_free(ctx);
        __fc_errno = 22;
        __retres = (modbus_t *)0;
        goto return_label;
      }
  ctx_rtu->data_bit = (uint8_t)data_bit;
  ctx_rtu->stop_bit = (uint8_t)stop_bit;
  ctx_rtu->rts = 0;
  if ((int)parity == 'N') tmp_3 = 0; else tmp_3 = 1;
  ctx_rtu->onebyte_time = (1000000 * (((1 + data_bit) + tmp_3) + stop_bit)) / baud;
  ctx_rtu->set_rts = & _modbus_rtu_ioctl_rts;
  ctx_rtu->rts_delay = ctx_rtu->onebyte_time;
  ctx_rtu->confirmation_to_ignore = 0;
  __retres = ctx;
  return_label: return __retres;
}

static int _modbus_set_slave_0(modbus_t *ctx, int slave)
{
  int __retres;
  if (slave >= 0) {
    if (slave <= 247) ctx->slave = slave; else goto _LAND;
  }
  else {
    _LAND: ;
    if (slave == 0xFF) ctx->slave = slave;
    else {
      __fc_errno = 22;
      __retres = -1;
      goto return_label;
    }
  }
  __retres = 0;
  return_label: return __retres;
}

static int _modbus_tcp_build_request_basis(modbus_t *ctx, int function,
                                           int addr, int nb, uint8_t *req)
{
  int __retres;
  modbus_tcp_t *ctx_tcp = (modbus_tcp_t *)ctx->backend_data;
  if ((int)ctx_tcp->t_id < 65535) ctx_tcp->t_id = (uint16_t)((int)ctx_tcp->t_id + 1);
  else ctx_tcp->t_id = (uint16_t)0;
  *(req + 0) = (uint8_t)((int)ctx_tcp->t_id >> 8);
  *(req + 1) = (uint8_t)((int)ctx_tcp->t_id & 0x00ff);
  *(req + 2) = (uint8_t)0;
  *(req + 3) = (uint8_t)0;
  *(req + 6) = (uint8_t)ctx->slave;
  *(req + 7) = (uint8_t)function;
  *(req + 8) = (uint8_t)(addr >> 8);
  *(req + 9) = (uint8_t)(addr & 0x00ff);
  *(req + 10) = (uint8_t)(nb >> 8);
  *(req + 11) = (uint8_t)(nb & 0x00ff);
  __retres = 12;
  return __retres;
}

static int _modbus_tcp_build_response_basis(sft_t *sft, uint8_t *rsp)
{
  int __retres;
  *(rsp + 0) = (uint8_t)(sft->t_id >> 8);
  *(rsp + 1) = (uint8_t)(sft->t_id & 0x00ff);
  *(rsp + 2) = (uint8_t)0;
  *(rsp + 3) = (uint8_t)0;
  *(rsp + 6) = (uint8_t)sft->slave;
  *(rsp + 7) = (uint8_t)sft->function;
  __retres = 8;
  return __retres;
}

static int _modbus_tcp_prepare_response_tid(uint8_t const *req,
                                            int *req_length)
{
  int __retres;
  __retres = ((int)*(req + 0) << 8) + (int)*(req + 1);
  return __retres;
}

static int _modbus_tcp_send_msg_pre(uint8_t *req, int req_length)
{
  int mbap_length = req_length - 6;
  *(req + 4) = (uint8_t)(mbap_length >> 8);
  *(req + 5) = (uint8_t)(mbap_length & 0x00FF);
  return req_length;
}

static ssize_t _modbus_tcp_send(modbus_t *ctx, uint8_t const *req,
                                int req_length)
{
  ssize_t tmp;
  tmp = send(ctx->s,(void const *)req,(size_t)req_length,0x4000);
  return tmp;
}

static int _modbus_tcp_receive(modbus_t *ctx, uint8_t *req)
{
  int tmp;
  tmp = _modbus_receive_msg(ctx,req,MSG_INDICATION);
  return tmp;
}

static ssize_t _modbus_tcp_recv(modbus_t *ctx, uint8_t *rsp, int rsp_length)
{
  ssize_t tmp;
  tmp = recv(ctx->s,(void *)rsp,(size_t)rsp_length,0);
  return tmp;
}

static int _modbus_tcp_check_integrity(modbus_t *ctx, uint8_t *msg,
                                       int const msg_length)
{
  return msg_length;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param1, param0;
 */
int fprintf_va_11(FILE * restrict stream, char const * restrict format,
                  unsigned int param0, unsigned int param1);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param0;
 */
int fprintf_va_12(FILE * restrict stream, char const * restrict format,
                  unsigned int param0);

static int _modbus_tcp_pre_check_confirmation(modbus_t *ctx,
                                              uint8_t const *req,
                                              uint8_t const *rsp,
                                              int rsp_length)
{
  int __retres;
  if ((int)*(req + 0) != (int)*(rsp + 0)) goto _LOR;
  else 
    if ((int)*(req + 1) != (int)*(rsp + 1)) {
      _LOR:
      {
        if (ctx->debug) fprintf(__fc_stderr,
                                "Invalid transaction ID received 0x%X (not 0x%X)\n",
                                (unsigned int)(((int)*(rsp + 0) << 8) + (int)*(
                                               rsp + 1)),
                                (unsigned int)(((int)*(req + 0) << 8) + (int)*(
                                               req + 1))); /* fprintf_va_11 */
        __fc_errno = (112345678 + MODBUS_EXCEPTION_GATEWAY_TARGET) + 2;
        __retres = -1;
        goto return_label;
      }
    }
  if ((int)*(rsp + 2) != 0x0) 
    if ((int)*(rsp + 3) != 0x0) {
      if (ctx->debug) fprintf(__fc_stderr,
                              "Invalid protocol ID received 0x%X (not 0x0)\n",
                              (unsigned int)(((int)*(rsp + 2) << 8) + (int)*(
                                             rsp + 3))); /* fprintf_va_12 */
      __fc_errno = (112345678 + MODBUS_EXCEPTION_GATEWAY_TARGET) + 2;
      __retres = -1;
      goto return_label;
    }
  __retres = 0;
  return_label: return __retres;
}

static int _modbus_tcp_set_ipv4_options(int s)
{
  int __retres;
  int rc;
  int option;
  option = 1;
  rc = setsockopt(s,IPPROTO_TCP,1,(void const *)(& option),
                  (socklen_t)sizeof(int));
  if (rc == -1) {
    __retres = -1;
    goto return_label;
  }
  option = 1;
  ioctl(s,0x5421,(void *)(& option)); /* __va_ioctl_ptr */
  option = 0x10;
  rc = setsockopt(s,IPPROTO_IP,1,(void const *)(& option),
                  (socklen_t)sizeof(int));
  if (rc == -1) {
    __retres = -1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static int _connect(int sockfd, struct sockaddr const *addr,
                    socklen_t addrlen, struct timeval const *ro_tv)
{
  int __retres;
  int rc = connect(sockfd,addr,addrlen);
  if (rc == -1) 
    if (__fc_errno == 115) {
      fd_set wset;
      int optval;
      socklen_t optlen = (socklen_t)sizeof(optval);
      struct timeval tv = *ro_tv;
      FD_ZERO(& wset);
      FD_SET(sockfd,& wset);
      rc = select(sockfd + 1,(fd_set *)0,& wset,(fd_set *)0,& tv);
      if (rc <= 0) {
        __retres = -1;
        goto return_label;
      }
      rc = getsockopt(sockfd,1,4,(void *)(& optval),& optlen);
      if (rc == 0) {
        if (optval == 0) {
          __retres = 0;
          goto return_label;
        }
        else goto _LAND;
      }
      else {
        _LAND: {
                 __fc_errno = 111;
                 __retres = -1;
                 goto return_label;
               }
      }
    }
  __retres = rc;
  return_label: return __retres;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, *(param0 + (0 ..));
 */
int printf_va_4(char const * restrict format, char *param0, int param1);

static int _modbus_tcp_connect(modbus_t *ctx)
{
  int __retres;
  int rc;
  struct sockaddr_in addr;
  modbus_tcp_t *ctx_tcp = (modbus_tcp_t *)ctx->backend_data;
  int flags = 1;
  flags |= 02000000;
  ctx->s = socket(2,flags,0);
  if (ctx->s == -1) {
    __retres = -1;
    goto return_label;
  }
  rc = _modbus_tcp_set_ipv4_options(ctx->s);
  if (rc == -1) {
    close(ctx->s);
    ctx->s = -1;
    __retres = -1;
    goto return_label;
  }
  if (ctx->debug) printf("Connecting to %s:%d\n",ctx_tcp->ip,ctx_tcp->port); /* printf_va_4 */
  addr.sin_family = (sa_family_t)2;
  addr.sin_port = htons((uint16_t)ctx_tcp->port);
  addr.sin_addr.s_addr = inet_addr((char const *)(ctx_tcp->ip));
  rc = _connect(ctx->s,(struct sockaddr const *)(& addr),
                (socklen_t)sizeof(addr),
                (struct timeval const *)(& ctx->response_timeout));
  if (rc == -1) {
    close(ctx->s);
    ctx->s = -1;
    __retres = -1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_13(FILE * restrict stream, char const * restrict format,
                  char *param0);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param1 + (0 ..)), *(param0 + (0 ..));
 */
int printf_va_5(char const * restrict format, char *param0, char *param1);

static int _modbus_tcp_pi_connect(modbus_t *ctx)
{
  int __retres;
  int rc;
  struct addrinfo *ai_list;
  struct addrinfo *ai_ptr;
  struct addrinfo ai_hints;
  modbus_tcp_pi_t *ctx_tcp_pi = (modbus_tcp_pi_t *)ctx->backend_data;
  memset((void *)(& ai_hints),0,sizeof(ai_hints));
  ai_hints.ai_flags |= 0x0020;
  ai_hints.ai_family = 0;
  ai_hints.ai_socktype = 1;
  ai_hints.ai_addr = (struct sockaddr *)0;
  ai_hints.ai_canonname = (char *)0;
  ai_hints.ai_next = (struct addrinfo *)0;
  ai_list = (struct addrinfo *)0;
  rc = getaddrinfo((char const *)(ctx_tcp_pi->node),
                   (char const *)(ctx_tcp_pi->service),
                   (struct addrinfo const *)(& ai_hints),& ai_list);
  if (rc != 0) {
    if (ctx->debug) {
      char const *tmp;
      tmp = gai_strerror(rc);
      ;
      fprintf(__fc_stderr,"Error returned by getaddrinfo: %s\n",(char *)tmp); /* fprintf_va_13 */
    }
    __fc_errno = 111;
    __retres = -1;
    goto return_label;
  }
  ai_ptr = ai_list;
  while (ai_ptr != (struct addrinfo *)0) {
    {
      int s;
      int flags = ai_ptr->ai_socktype;
      flags |= 02000000;
      s = socket(ai_ptr->ai_family,flags,ai_ptr->ai_protocol);
      if (s < 0) goto __Cont;
      if (ai_ptr->ai_family == 2) _modbus_tcp_set_ipv4_options(s);
      if (ctx->debug) printf("Connecting to [%s]:%s\n",ctx_tcp_pi->node,
                             ctx_tcp_pi->service); /* printf_va_5 */
      rc = _connect(s,(struct sockaddr const *)ai_ptr->ai_addr,
                    ai_ptr->ai_addrlen,
                    (struct timeval const *)(& ctx->response_timeout));
      if (rc == -1) {
        close(s);
        goto __Cont;
      }
      ctx->s = s;
      break;
    }
    __Cont: ai_ptr = ai_ptr->ai_next;
  }
  freeaddrinfo(ai_list);
  if (ctx->s < 0) {
    __retres = -1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static void _modbus_tcp_close(modbus_t *ctx)
{
  if (ctx->s != -1) {
    shutdown(ctx->s,SHUT_RDWR);
    close(ctx->s);
    ctx->s = -1;
  }
  return;
}

static int _modbus_tcp_flush(modbus_t *ctx)
{
  int rc;
  int rc_sum = 0;
  while (1) {
    {
      char devnull[260];
      ssize_t tmp;
      tmp = recv(ctx->s,(void *)(devnull),(size_t)260,0x40);
      rc = (int)tmp;
      if (rc > 0) rc_sum += rc;
    }
    if (! (rc == 260)) break;
  }
  return rc_sum;
}

int modbus_tcp_listen(modbus_t *ctx, int nb_connection)
{
  int __retres;
  int new_s;
  int enable;
  struct sockaddr_in addr;
  modbus_tcp_t *ctx_tcp;
  int tmp;
  int tmp_0;
  int tmp_1;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  ctx_tcp = (modbus_tcp_t *)ctx->backend_data;
  new_s = socket(2,1,IPPROTO_TCP);
  if (new_s == -1) {
    __retres = -1;
    goto return_label;
  }
  enable = 1;
  tmp = setsockopt(new_s,1,2,(void const *)(& enable),
                   (socklen_t)sizeof(enable));
  if (tmp == -1) {
    close(new_s);
    __retres = -1;
    goto return_label;
  }
  memset((void *)(& addr),0,sizeof(addr));
  addr.sin_family = (sa_family_t)2;
  addr.sin_port = htons((uint16_t)ctx_tcp->port);
  if ((int)ctx_tcp->ip[0] == '0') addr.sin_addr.s_addr = htonl((uint32_t)0);
  else addr.sin_addr.s_addr = inet_addr((char const *)(ctx_tcp->ip));
  tmp_0 = bind(new_s,(struct sockaddr const *)(& addr),
               (socklen_t)sizeof(addr));
  if (tmp_0 == -1) {
    close(new_s);
    __retres = -1;
    goto return_label;
  }
  tmp_1 = listen(new_s,nb_connection);
  if (tmp_1 == -1) {
    close(new_s);
    __retres = -1;
    goto return_label;
  }
  __retres = new_s;
  return_label: return __retres;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_14(FILE * restrict stream, char const * restrict format,
                  char *param0);

int modbus_tcp_pi_listen(modbus_t *ctx, int nb_connection)
{
  int __retres;
  int rc;
  struct addrinfo *ai_list;
  struct addrinfo *ai_ptr;
  struct addrinfo ai_hints;
  char const *node;
  char const *service;
  int new_s;
  modbus_tcp_pi_t *ctx_tcp_pi;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  ctx_tcp_pi = (modbus_tcp_pi_t *)ctx->backend_data;
  if ((int)ctx_tcp_pi->node[0] == 0) node = (char const *)0;
  else node = (char const *)(ctx_tcp_pi->node);
  if ((int)ctx_tcp_pi->service[0] == 0) service = "502";
  else service = (char const *)(ctx_tcp_pi->service);
  memset((void *)(& ai_hints),0,sizeof(ai_hints));
  ai_hints.ai_flags |= 0x0001;
  ai_hints.ai_flags |= 0x0020;
  ai_hints.ai_family = 0;
  ai_hints.ai_socktype = 1;
  ai_hints.ai_addr = (struct sockaddr *)0;
  ai_hints.ai_canonname = (char *)0;
  ai_hints.ai_next = (struct addrinfo *)0;
  ai_list = (struct addrinfo *)0;
  rc = getaddrinfo(node,service,(struct addrinfo const *)(& ai_hints),
                   & ai_list);
  if (rc != 0) {
    if (ctx->debug) {
      char const *tmp;
      tmp = gai_strerror(rc);
      ;
      fprintf(__fc_stderr,"Error returned by getaddrinfo: %s\n",(char *)tmp); /* fprintf_va_14 */
    }
    __fc_errno = 111;
    __retres = -1;
    goto return_label;
  }
  new_s = -1;
  ai_ptr = ai_list;
  while (ai_ptr != (struct addrinfo *)0) {
    {
      int s;
      s = socket(ai_ptr->ai_family,ai_ptr->ai_socktype,ai_ptr->ai_protocol);
      if (s < 0) {
        if (ctx->debug) perror("socket");
        goto __Cont;
      }
      else {
        int enable = 1;
        rc = setsockopt(s,1,2,(void const *)(& enable),
                        (socklen_t)sizeof(enable));
        if (rc != 0) {
          close(s);
          if (ctx->debug) perror("setsockopt");
          goto __Cont;
        }
      }
      rc = bind(s,(struct sockaddr const *)ai_ptr->ai_addr,
                ai_ptr->ai_addrlen);
      if (rc != 0) {
        close(s);
        if (ctx->debug) perror("bind");
        goto __Cont;
      }
      rc = listen(s,nb_connection);
      if (rc != 0) {
        close(s);
        if (ctx->debug) perror("listen");
        goto __Cont;
      }
      new_s = s;
      break;
    }
    __Cont: ai_ptr = ai_ptr->ai_next;
  }
  freeaddrinfo(ai_list);
  if (new_s < 0) {
    __retres = -1;
    goto return_label;
  }
  __retres = new_s;
  return_label: return __retres;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_6(char const * restrict format, char *param0);

int modbus_tcp_accept(modbus_t *ctx, int *s)
{
  int __retres;
  struct sockaddr_in addr;
  socklen_t addrlen;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  addrlen = (socklen_t)sizeof(addr);
  ctx->s = accept(*s,(struct sockaddr *)(& addr),& addrlen);
  if (ctx->s == -1) {
    __retres = -1;
    goto return_label;
  }
  if (ctx->debug) {
    char *tmp;
    tmp = inet_ntoa(addr.sin_addr);
    printf("The client connection from %s is accepted\n",tmp); /* printf_va_6 */
  }
  __retres = ctx->s;
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_7(char const * restrict format);

int modbus_tcp_pi_accept(modbus_t *ctx, int *s)
{
  int __retres;
  struct sockaddr_storage addr;
  socklen_t addrlen;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  addrlen = (socklen_t)sizeof(addr);
  ctx->s = accept(*s,(struct sockaddr *)(& addr),& addrlen);
  if (ctx->s == -1) {
    __retres = -1;
    goto return_label;
  }
  if (ctx->debug) printf("The client connection is accepted.\n"); /* printf_va_7 */
  __retres = ctx->s;
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_15(FILE * restrict stream, char const * restrict format);

static int _modbus_tcp_select(modbus_t *ctx, fd_set *rset,
                              struct timeval *tv, int length_to_read)
{
  int __retres;
  int s_rc;
  while (1) {
    s_rc = select(ctx->s + 1,rset,(fd_set *)0,(fd_set *)0,tv);
    if (! (s_rc == -1)) break;
    if (__fc_errno == 4) {
      if (ctx->debug) fprintf(__fc_stderr,
                              "A non blocked signal was caught\n"); /* fprintf_va_15 */
      FD_ZERO(rset);
      FD_SET(ctx->s,rset);
    }
    else {
      __retres = -1;
      goto return_label;
    }
  }
  if (s_rc == 0) {
    __fc_errno = 110;
    __retres = -1;
    goto return_label;
  }
  __retres = s_rc;
  return_label: return __retres;
}

static void _modbus_tcp_free(modbus_t *ctx)
{
  free(ctx->backend_data);
  free((void *)ctx);
  return;
}

modbus_backend_t const _modbus_tcp_backend =
  {.backend_type = (unsigned int)_MODBUS_BACKEND_TYPE_TCP,
   .header_length = (unsigned int)7,
   .checksum_length = (unsigned int)0,
   .max_adu_length = (unsigned int)260,
   .set_slave = & _modbus_set_slave_0,
   .build_request_basis = & _modbus_tcp_build_request_basis,
   .build_response_basis = & _modbus_tcp_build_response_basis,
   .prepare_response_tid = & _modbus_tcp_prepare_response_tid,
   .send_msg_pre = & _modbus_tcp_send_msg_pre,
   .send = & _modbus_tcp_send,
   .receive = & _modbus_tcp_receive,
   .recv = & _modbus_tcp_recv,
   .check_integrity = & _modbus_tcp_check_integrity,
   .pre_check_confirmation = & _modbus_tcp_pre_check_confirmation,
   .connect = & _modbus_tcp_connect,
   .close = & _modbus_tcp_close,
   .flush = & _modbus_tcp_flush,
   .select = & _modbus_tcp_select,
   .free = & _modbus_tcp_free};
modbus_backend_t const _modbus_tcp_pi_backend =
  {.backend_type = (unsigned int)_MODBUS_BACKEND_TYPE_TCP,
   .header_length = (unsigned int)7,
   .checksum_length = (unsigned int)0,
   .max_adu_length = (unsigned int)260,
   .set_slave = & _modbus_set_slave_0,
   .build_request_basis = & _modbus_tcp_build_request_basis,
   .build_response_basis = & _modbus_tcp_build_response_basis,
   .prepare_response_tid = & _modbus_tcp_prepare_response_tid,
   .send_msg_pre = & _modbus_tcp_send_msg_pre,
   .send = & _modbus_tcp_send,
   .receive = & _modbus_tcp_receive,
   .recv = & _modbus_tcp_recv,
   .check_integrity = & _modbus_tcp_check_integrity,
   .pre_check_confirmation = & _modbus_tcp_pre_check_confirmation,
   .connect = & _modbus_tcp_pi_connect,
   .close = & _modbus_tcp_close,
   .flush = & _modbus_tcp_flush,
   .select = & _modbus_tcp_select,
   .free = & _modbus_tcp_free};
/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_16(FILE * restrict stream, char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_17(FILE * restrict stream, char const * restrict format);

modbus_t *modbus_new_tcp(char const *ip, int port)
{
  modbus_t *__retres;
  modbus_t *ctx;
  modbus_tcp_t *ctx_tcp;
  size_t dest_size;
  size_t ret_size;
  ctx = (modbus_t *)malloc(sizeof(modbus_t));
  if (! ctx) {
    __fc_errno = 12;
    __retres = (modbus_t *)0;
    goto return_label;
  }
  _modbus_init_common(ctx);
  ctx->slave = 0xFF;
  ctx->backend = & _modbus_tcp_backend;
  ctx->backend_data = malloc(sizeof(modbus_tcp_t));
  ctx_tcp = (modbus_tcp_t *)ctx->backend_data;
  if (ip != (char const *)0) {
    dest_size = sizeof(char) * (unsigned long)16;
    ret_size = strlcpy(ctx_tcp->ip,ip,dest_size);
    if (ret_size == (size_t)0) {
      fprintf(__fc_stderr,"The IP string is empty\n"); /* fprintf_va_16 */
      modbus_free(ctx);
      __fc_errno = 22;
      __retres = (modbus_t *)0;
      goto return_label;
    }
    if (ret_size >= dest_size) {
      fprintf(__fc_stderr,"The IP string has been truncated\n"); /* fprintf_va_17 */
      modbus_free(ctx);
      __fc_errno = 22;
      __retres = (modbus_t *)0;
      goto return_label;
    }
  }
  else ctx_tcp->ip[0] = (char)'0';
  ctx_tcp->port = port;
  ctx_tcp->t_id = (uint16_t)0;
  __retres = ctx;
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_18(FILE * restrict stream, char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_19(FILE * restrict stream, char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_20(FILE * restrict stream, char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_21(FILE * restrict stream, char const * restrict format);

modbus_t *modbus_new_tcp_pi(char const *node, char const *service)
{
  modbus_t *__retres;
  modbus_t *ctx;
  modbus_tcp_pi_t *ctx_tcp_pi;
  size_t dest_size;
  size_t ret_size;
  ctx = (modbus_t *)malloc(sizeof(modbus_t));
  _modbus_init_common(ctx);
  ctx->slave = 0xFF;
  ctx->backend = & _modbus_tcp_pi_backend;
  ctx->backend_data = malloc(sizeof(modbus_tcp_pi_t));
  ctx_tcp_pi = (modbus_tcp_pi_t *)ctx->backend_data;
  if (node == (char const *)0) ctx_tcp_pi->node[0] = (char)0;
  else {
    dest_size = sizeof(char) * (unsigned long)1025;
    ret_size = strlcpy(ctx_tcp_pi->node,node,dest_size);
    if (ret_size == (size_t)0) {
      fprintf(__fc_stderr,"The node string is empty\n"); /* fprintf_va_18 */
      modbus_free(ctx);
      __fc_errno = 22;
      __retres = (modbus_t *)0;
      goto return_label;
    }
    if (ret_size >= dest_size) {
      fprintf(__fc_stderr,"The node string has been truncated\n"); /* fprintf_va_19 */
      modbus_free(ctx);
      __fc_errno = 22;
      __retres = (modbus_t *)0;
      goto return_label;
    }
  }
  if (service != (char const *)0) {
    dest_size = sizeof(char) * (unsigned long)32;
    ret_size = strlcpy(ctx_tcp_pi->service,service,dest_size);
  }
  else ret_size = (size_t)0;
  if (ret_size == (size_t)0) {
    fprintf(__fc_stderr,"The service string is empty\n"); /* fprintf_va_20 */
    modbus_free(ctx);
    __fc_errno = 22;
    __retres = (modbus_t *)0;
    goto return_label;
  }
  if (ret_size >= dest_size) {
    fprintf(__fc_stderr,"The service string has been truncated\n"); /* fprintf_va_21 */
    modbus_free(ctx);
    __fc_errno = 22;
    __retres = (modbus_t *)0;
    goto return_label;
  }
  ctx_tcp_pi->t_id = (uint16_t)0;
  __retres = ctx;
  return_label: return __retres;
}

unsigned int const libmodbus_version_major = (unsigned int)3;
unsigned int const libmodbus_version_minor = (unsigned int)1;
unsigned int const libmodbus_version_micro = (unsigned int)4;
char const *modbus_strerror(int errnum)
{
  char const *__retres;
  switch (errnum) {
    char const *tmp;
    case 112345678 + MODBUS_EXCEPTION_ILLEGAL_FUNCTION:
    __retres = "Illegal function";
    goto return_label;
    case 112345678 + MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS:
    __retres = "Illegal data address";
    goto return_label;
    case 112345678 + MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE:
    __retres = "Illegal data value";
    goto return_label;
    case 112345678 + MODBUS_EXCEPTION_SLAVE_OR_SERVER_FAILURE:
    __retres = "Slave device or server failure";
    goto return_label;
    case 112345678 + MODBUS_EXCEPTION_ACKNOWLEDGE: __retres = "Acknowledge";
    goto return_label;
    case 112345678 + MODBUS_EXCEPTION_SLAVE_OR_SERVER_BUSY:
    __retres = "Slave device or server is busy";
    goto return_label;
    case 112345678 + MODBUS_EXCEPTION_NEGATIVE_ACKNOWLEDGE:
    __retres = "Negative acknowledge";
    goto return_label;
    case 112345678 + MODBUS_EXCEPTION_MEMORY_PARITY:
    __retres = "Memory parity error";
    goto return_label;
    case 112345678 + MODBUS_EXCEPTION_GATEWAY_PATH:
    __retres = "Gateway path unavailable";
    goto return_label;
    case 112345678 + MODBUS_EXCEPTION_GATEWAY_TARGET:
    __retres = "Target device failed to respond";
    goto return_label;
    case (112345678 + MODBUS_EXCEPTION_GATEWAY_TARGET) + 1:
    __retres = "Invalid CRC";
    goto return_label;
    case (112345678 + MODBUS_EXCEPTION_GATEWAY_TARGET) + 2:
    __retres = "Invalid data";
    goto return_label;
    case (112345678 + MODBUS_EXCEPTION_GATEWAY_TARGET) + 3:
    __retres = "Invalid exception code";
    goto return_label;
    case (112345678 + MODBUS_EXCEPTION_GATEWAY_TARGET) + 5:
    __retres = "Too many data";
    goto return_label;
    case (112345678 + MODBUS_EXCEPTION_GATEWAY_TARGET) + 6:
    __retres = "Response not from requested slave";
    goto return_label;
    default: tmp = (char const *)strerror(errnum);
    __retres = tmp;
    goto return_label;
  }
  return_label: return __retres;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_22(FILE * restrict stream, char const * restrict format,
                  char *param0);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_23(FILE * restrict stream, char const * restrict format,
                  char *param0);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_24(FILE * restrict stream, char const * restrict format);

void _error_print(modbus_t *ctx, char const *context)
{
  if (ctx->debug) {
    char const *tmp;
    tmp = modbus_strerror(__fc_errno);
    ;
    fprintf(__fc_stderr,"ERROR %s",(char *)tmp); /* fprintf_va_22 */
    if (context != (char const *)0) fprintf(__fc_stderr,": %s\n",
                                            (char *)context); /* fprintf_va_23 */
    else fprintf(__fc_stderr,"\n"); /* fprintf_va_24 */
  }
  return;
}

static void _sleep_response_timeout(modbus_t *ctx)
{
  struct timespec request;
  struct timespec remaining;
  request.tv_sec = ctx->response_timeout.tv_sec;
  request.tv_nsec = (long)ctx->response_timeout.tv_usec * (long)1000;
  while (1) {
    int tmp;
    tmp = nanosleep((struct timespec const *)(& request),& remaining);
    if (tmp == -1) {
      if (! (__fc_errno == 4)) break;
    }
    else break;
    request = remaining;
  }
  return;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_8(char const * restrict format, int param0);

int modbus_flush(modbus_t *ctx)
{
  int __retres;
  int rc;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  rc = (*((ctx->backend)->flush))(ctx);
  if (rc != -1) 
    if (ctx->debug) printf("Bytes flushed (%d)\n",rc); /* printf_va_8 */
  __retres = rc;
  return_label: return __retres;
}

static unsigned int compute_response_length_from_request(modbus_t *ctx,
                                                         uint8_t *req)
{
  unsigned int __retres;
  int length;
  int const offset = (int)(ctx->backend)->header_length;
  switch ((int)*(req + offset)) {
    case 0x01: case 0x02:
    {
      int tmp;
      int nb =
        ((int)*(req + (offset + 3)) << 8) | (int)*(req + (offset + 4));
      if (nb % 8) tmp = 1; else tmp = 0;
      length = (2 + nb / 8) + tmp;
    }
    break;
    case 0x17: case 0x03: case 0x04:
    length = 2 + 2 * (((int)*(req + (offset + 3)) << 8) | (int)*(req + (
                                                                 offset + 4)));
    break;
    case 0x07: length = 3;
    break;
    case 0x11: __retres = (unsigned int)(-1);
    goto return_label;
    case 0x16: length = 7;
    break;
    default: length = 5;
  }
  __retres = (unsigned int)(offset + length) + (ctx->backend)->checksum_length;
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_9(char const * restrict format, unsigned int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_10(char const * restrict format);

static int send_msg(modbus_t *ctx, uint8_t *msg, int msg_length)
{
  int __retres;
  int rc;
  int i;
  msg_length = (*((ctx->backend)->send_msg_pre))(msg,msg_length);
  if (ctx->debug) {
    i = 0;
    /*@ loop unroll 260; */
    while (i < msg_length) {
      printf("[%.2X]",(unsigned int)((int)*(msg + i))); /* printf_va_9 */
      i ++;
    }
    printf("\n"); /* printf_va_10 */
  }
  while (1) {
    {
      ssize_t tmp;
      tmp = (*((ctx->backend)->send))(ctx,(uint8_t const *)msg,msg_length);
      rc = (int)tmp;
      if (rc == -1) {
        _error_print(ctx,(char const *)0);
        if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_LINK) {
          int saved_errno = __fc_errno;
          if (__fc_errno == 9) goto _LOR;
          else 
            if (__fc_errno == 104) goto _LOR;
            else 
              if (__fc_errno == 32) {
                _LOR:
                {
                  modbus_close(ctx);
                  _sleep_response_timeout(ctx);
                  modbus_connect(ctx);
                }
              }
              else {
                _sleep_response_timeout(ctx);
                modbus_flush(ctx);
              }
          __fc_errno = saved_errno;
        }
      }
    }
    if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_LINK) {
      if (! (rc == -1)) break;
    }
    else break;
  }
  if (rc > 0) 
    if (rc != msg_length) {
      __fc_errno = (112345678 + MODBUS_EXCEPTION_GATEWAY_TARGET) + 2;
      __retres = -1;
      goto return_label;
    }
  __retres = rc;
  return_label: return __retres;
}

int modbus_send_raw_request(modbus_t *ctx, uint8_t *raw_req,
                            int raw_req_length)
{
  int __retres;
  sft_t sft;
  uint8_t req[260];
  int req_length;
  int tmp;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  if (raw_req_length < 2) goto _LOR;
  else 
    if (raw_req_length > 253 + 1) {
      _LOR: {
              __fc_errno = 22;
              __retres = -1;
              goto return_label;
            }
    }
  sft.slave = (int)*(raw_req + 0);
  sft.function = (int)*(raw_req + 1);
  sft.t_id = 0;
  req_length = (*((ctx->backend)->build_response_basis))(& sft,req);
  if (raw_req_length > 2) {
    memcpy((void *)(& req[req_length]),(void const *)(raw_req + 2),
           (size_t)(raw_req_length - 2));
    req_length += raw_req_length - 2;
  }
  tmp = send_msg(ctx,req,req_length);
  __retres = tmp;
  return_label: return __retres;
}

static uint8_t compute_meta_length_after_function(int function,
                                                  msg_type_t msg_type)
{
  uint8_t __retres;
  int length;
  if (msg_type == (unsigned int)MSG_INDICATION) {
    if (function <= 0x06) length = 4;
    else 
      if (function == 0x0F) goto _LOR;
      else 
        if (function == 0x10) _LOR: length = 5;
        else 
          if (function == 0x16) length = 6;
          else 
            if (function == 0x17) length = 9; else length = 0;
  }
  else 
    switch (function) {
      case 0x05: case 0x06: case 0x0F: case 0x10: length = 4;
      break;
      case 0x16: length = 6;
      break;
      default: length = 1;
    }
  __retres = (uint8_t)length;
  return __retres;
}

static int compute_data_length_after_meta(modbus_t *ctx, uint8_t *msg,
                                          msg_type_t msg_type)
{
  int length;
  int function = (int)*(msg + (ctx->backend)->header_length);
  if (msg_type == (unsigned int)MSG_INDICATION) 
    switch (function) {
      case 0x0F: case 0x10:
      length = (int)*(msg + ((ctx->backend)->header_length + (unsigned int)5));
      break;
      case 0x17:
      length = (int)*(msg + ((ctx->backend)->header_length + (unsigned int)9));
      break;
      default: length = 0;
    }
  else 
    if (function <= 0x04) goto _LOR;
    else 
      if (function == 0x11) goto _LOR;
      else 
        if (function == 0x17) _LOR:
                              length = (int)*(msg + ((ctx->backend)->header_length + (unsigned int)1));
        else length = 0;
  length = (int)((unsigned int)length + (ctx->backend)->checksum_length);
  return length;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_11(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_12(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_13(char const * restrict format, unsigned int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_14(char const * restrict format);

int _modbus_receive_msg(modbus_t *ctx, uint8_t *msg, msg_type_t msg_type)
{
  int __retres;
  int rc;
  fd_set rset;
  struct timeval tv;
  struct timeval *p_tv;
  int length_to_read;
  _step_t step;
  int tmp_1;
  int msg_length = 0;
  if (ctx->debug) 
    if (msg_type == (unsigned int)MSG_INDICATION) printf("Waiting for a indication...\n"); /* printf_va_11 */
    else printf("Waiting for a confirmation...\n"); /* printf_va_12 */
  FD_ZERO(& rset);
  FD_SET(ctx->s,& rset);
  step = _STEP_FUNCTION;
  length_to_read = (int)((ctx->backend)->header_length + (unsigned int)1);
  if (msg_type == (unsigned int)MSG_INDICATION) p_tv = (struct timeval *)0;
  else {
    tv.tv_sec = ctx->response_timeout.tv_sec;
    tv.tv_usec = ctx->response_timeout.tv_usec;
    p_tv = & tv;
  }
  while (length_to_read != 0) {
    ssize_t tmp;
    rc = (*((ctx->backend)->select))(ctx,& rset,p_tv,length_to_read);
    if (rc == -1) {
      _error_print(ctx,"select");
      if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_LINK) {
        int saved_errno = __fc_errno;
        if (__fc_errno == 110) {
          _sleep_response_timeout(ctx);
          modbus_flush(ctx);
        }
        else 
          if (__fc_errno == 9) {
            modbus_close(ctx);
            modbus_connect(ctx);
          }
        __fc_errno = saved_errno;
      }
      __retres = -1;
      goto return_label;
    }
    tmp = (*((ctx->backend)->recv))(ctx,msg + msg_length,length_to_read);
    rc = (int)tmp;
    if (rc == 0) {
      __fc_errno = 104;
      rc = -1;
    }
    if (rc == -1) {
      _error_print(ctx,"read");
      if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_LINK) 
        if (__fc_errno == 104) goto _LOR;
        else 
          if (__fc_errno == 111) goto _LOR;
          else 
            if (__fc_errno == 9) {
              _LOR:
              {
                int saved_errno_0 = __fc_errno;
                modbus_close(ctx);
                modbus_connect(ctx);
                __fc_errno = saved_errno_0;
              }
            }
      __retres = -1;
      goto return_label;
    }
    if (ctx->debug) {
      int i;
      i = 0;
      while (i < rc) {
        printf("<%.2X>",(unsigned int)((int)*(msg + (msg_length + i)))); /* printf_va_13 */
        i ++;
      }
    }
    msg_length += rc;
    length_to_read -= rc;
    if (length_to_read == 0) 
      switch (step) {
        uint8_t tmp_0;
        case _STEP_FUNCTION:
        { /* sequence */
          tmp_0 = compute_meta_length_after_function((int)*(msg + (ctx->backend)->header_length),
                                                     msg_type);
          length_to_read = (int)tmp_0;
        }
        if (length_to_read != 0) {
          step = _STEP_META;
          break;
        }
        case _STEP_META:
        length_to_read = compute_data_length_after_meta(ctx,msg,msg_type);
        if (msg_length + length_to_read > (int)(ctx->backend)->max_adu_length) {
          __fc_errno = (112345678 + MODBUS_EXCEPTION_GATEWAY_TARGET) + 2;
          _error_print(ctx,"too many data");
          __retres = -1;
          goto return_label;
        }
        step = _STEP_DATA;
        break;
        default: break;
      }
    if (length_to_read > 0) 
      if (ctx->byte_timeout.tv_sec > (time_t)0) goto _LOR_0;
      else 
        if (ctx->byte_timeout.tv_usec > 0) {
          _LOR_0:
          {
            tv.tv_sec = ctx->byte_timeout.tv_sec;
            tv.tv_usec = ctx->byte_timeout.tv_usec;
            p_tv = & tv;
          }
        }
  }
  if (ctx->debug) printf("\n"); /* printf_va_14 */
  tmp_1 = (*((ctx->backend)->check_integrity))(ctx,msg,msg_length);
  __retres = tmp_1;
  return_label: return __retres;
}

int modbus_receive(modbus_t *ctx, uint8_t *req)
{
  int __retres;
  int tmp;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  tmp = (*((ctx->backend)->receive))(ctx,req);
  __retres = tmp;
  return_label: return __retres;
}

int modbus_receive_confirmation(modbus_t *ctx, uint8_t *rsp)
{
  int __retres;
  int tmp;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  tmp = _modbus_receive_msg(ctx,rsp,MSG_CONFIRMATION);
  __retres = tmp;
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param1, param0;
 */
int fprintf_va_25(FILE * restrict stream, char const * restrict format,
                  unsigned int param0, unsigned int param1);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param1, param0;
 */
int fprintf_va_26(FILE * restrict stream, char const * restrict format,
                  int param0, int param1);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param1, param0;
 */
int fprintf_va_27(FILE * restrict stream, char const * restrict format,
                  int param0, int param1);

static int check_confirmation(modbus_t *ctx, uint8_t *req, uint8_t *rsp,
                              int rsp_length)
{
  int __retres;
  int rc;
  int rsp_length_computed;
  unsigned int tmp;
  int const offset = (int)(ctx->backend)->header_length;
  int const function = (int)*(rsp + offset);
  if ((ctx->backend)->pre_check_confirmation) {
    rc = (*((ctx->backend)->pre_check_confirmation))(ctx,
                                                     (uint8_t const *)req,
                                                     (uint8_t const *)rsp,
                                                     rsp_length);
    if (rc == -1) {
      if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {
        _sleep_response_timeout(ctx);
        modbus_flush(ctx);
      }
      __retres = -1;
      goto return_label;
    }
  }
  tmp = compute_response_length_from_request(ctx,req);
  rsp_length_computed = (int)tmp;
  if (function >= 0x80) 
    if (rsp_length == (offset + 2) + (int)(ctx->backend)->checksum_length) {
      if ((int)*(req + offset) == (int)*(rsp + offset) - 0x80) {
        int exception_code = (int)*(rsp + (offset + 1));
        if (exception_code < MODBUS_EXCEPTION_MAX) __fc_errno = 112345678 + exception_code;
        else __fc_errno = (112345678 + MODBUS_EXCEPTION_GATEWAY_TARGET) + 3;
        _error_print(ctx,(char const *)0);
        __retres = -1;
        goto return_label;
      }
      else goto _LAND;
    }
    else {
      _LAND:
      {
        __fc_errno = (112345678 + MODBUS_EXCEPTION_GATEWAY_TARGET) + 3;
        _error_print(ctx,(char const *)0);
        __retres = -1;
        goto return_label;
      }
    }
  if (rsp_length == rsp_length_computed) goto _LOR;
  else 
    if (rsp_length_computed == -1) {
      _LOR: ;
      if (function < 0x80) {
        int req_nb_value;
        int rsp_nb_value;
        if (function != (int)*(req + offset)) {
          if (ctx->debug) fprintf(__fc_stderr,
                                  "Received function not corresponding to the request (0x%X != 0x%X)\n",
                                  (unsigned int)function,
                                  (unsigned int)((int)*(req + offset))); /* fprintf_va_25 */
          if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {
            _sleep_response_timeout(ctx);
            modbus_flush(ctx);
          }
          __fc_errno = (112345678 + MODBUS_EXCEPTION_GATEWAY_TARGET) + 2;
          __retres = -1;
          goto return_label;
        }
        switch (function) {
          int tmp_0;
          case 0x01: case 0x02:
          req_nb_value = ((int)*(req + (offset + 3)) << 8) + (int)*(req + (
                                                                    offset + 4));
          if (req_nb_value % 8) tmp_0 = 1; else tmp_0 = 0;
          req_nb_value = req_nb_value / 8 + tmp_0;
          rsp_nb_value = (int)*(rsp + (offset + 1));
          break;
          case 0x17: case 0x03: case 0x04:
          req_nb_value = ((int)*(req + (offset + 3)) << 8) + (int)*(req + (
                                                                    offset + 4));
          rsp_nb_value = (int)*(rsp + (offset + 1)) / 2;
          break;
          case 0x0F: case 0x10:
          req_nb_value = ((int)*(req + (offset + 3)) << 8) + (int)*(req + (
                                                                    offset + 4));
          rsp_nb_value = ((int)*(rsp + (offset + 3)) << 8) | (int)*(rsp + (
                                                                    offset + 4));
          break;
          case 0x11:
          { /* sequence */
            rsp_nb_value = (int)*(rsp + (offset + 1));
            req_nb_value = rsp_nb_value;
          }
          break;
          default:
          { /* sequence */
            rsp_nb_value = 1;
            req_nb_value = rsp_nb_value;
          }
        }
        if (req_nb_value == rsp_nb_value) rc = rsp_nb_value;
        else {
          if (ctx->debug) fprintf(__fc_stderr,
                                  "Quantity not corresponding to the request (%d != %d)\n",
                                  rsp_nb_value,req_nb_value); /* fprintf_va_26 */
          if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {
            _sleep_response_timeout(ctx);
            modbus_flush(ctx);
          }
          __fc_errno = (112345678 + MODBUS_EXCEPTION_GATEWAY_TARGET) + 2;
          rc = -1;
        }
      }
      else goto _LAND_0;
    }
    else {
      _LAND_0:
      {
        if (ctx->debug) fprintf(__fc_stderr,
                                "Message length not corresponding to the computed length (%d != %d)\n",
                                rsp_length,rsp_length_computed); /* fprintf_va_27 */
        if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {
          _sleep_response_timeout(ctx);
          modbus_flush(ctx);
        }
        __fc_errno = (112345678 + MODBUS_EXCEPTION_GATEWAY_TARGET) + 2;
        rc = -1;
      }
    }
  __retres = rc;
  return_label: return __retres;
}

static int response_io_status(uint8_t *tab_io_status, int address, int nb,
                              uint8_t *rsp, int offset)
{
  int i;
  int shift = 0;
  int one_byte = 0;
  i = address;
  while (i < address + nb) {
    one_byte |= (int)*(tab_io_status + i) << shift;
    if (shift == 7) {
      int tmp;
      tmp = offset;
      offset ++;
      *(rsp + tmp) = (uint8_t)one_byte;
      shift = 0;
      one_byte = shift;
    }
    else shift ++;
    i ++;
  }
  if (shift != 0) {
    int tmp_0;
    tmp_0 = offset;
    offset ++;
    *(rsp + tmp_0) = (uint8_t)one_byte;
  }
  return offset;
}

static int response_exception(modbus_t *ctx, sft_t *sft, int exception_code,
                              uint8_t *rsp, unsigned int to_flush,
                              char const *template, void * const *__va_params)
{
  int rsp_length;
  int tmp;
  if (ctx->debug) {
    va_list ap;
    ap = __va_params;
    vfprintf(__fc_stderr,template,ap);
  }
  if (to_flush) {
    _sleep_response_timeout(ctx);
    modbus_flush(ctx);
  }
  sft->function += 0x80;
  rsp_length = (*((ctx->backend)->build_response_basis))(sft,rsp);
  tmp = rsp_length;
  rsp_length ++;
  *(rsp + tmp) = (uint8_t)exception_code;
  return rsp_length;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_28(FILE * restrict stream, char const * restrict format);

int modbus_reply(modbus_t *ctx, uint8_t const *req, int req_length,
                 modbus_mapping_t *mb_mapping)
{
  int __retres;
  int offset;
  int slave;
  int function;
  uint16_t address;
  uint8_t rsp[260];
  sft_t sft;
  int tmp_26;
  int rsp_length = 0;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  offset = (int)(ctx->backend)->header_length;
  slave = (int)*(req + (offset - 1));
  function = (int)*(req + offset);
  address = (uint16_t)(((int)*(req + (offset + 1)) << 8) + (int)*(req + (
                                                                  offset + 2)));
  sft.slave = slave;
  sft.function = function;
  sft.t_id = (*((ctx->backend)->prepare_response_tid))(req,& req_length);
  switch (function) {
    case 0x01: case 0x02:
    {
      int tmp;
      int tmp_0;
      uint8_t *tmp_1;
      char const *tmp_2;
      unsigned int is_input = (unsigned int)(function == 0x02);
      if (is_input) tmp = mb_mapping->start_input_bits;
      else tmp = mb_mapping->start_bits;
      int start_bits = tmp;
      if (is_input) tmp_0 = mb_mapping->nb_input_bits;
      else tmp_0 = mb_mapping->nb_bits;
      int nb_bits = tmp_0;
      if (is_input) tmp_1 = mb_mapping->tab_input_bits;
      else tmp_1 = mb_mapping->tab_bits;
      uint8_t *tab_bits = tmp_1;
      if (is_input) tmp_2 = "read_input_bits"; else tmp_2 = "read_bits";
      char const * const name = tmp_2;
      int nb =
        ((int)*(req + (offset + 3)) << 8) + (int)*(req + (offset + 4));
      int mapping_address = (int)address - start_bits;
      if (nb < 1) goto _LOR_0;
      else 
        if (2000 < nb) {
          _LOR_0:
          {
            int __va_arg0 = nb;
            char const *__va_arg1 = name;
            int __va_arg2 = 2000;
            void *__va_args[3] = {& __va_arg0, & __va_arg1, & __va_arg2};
            rsp_length = response_exception(ctx,& sft,
                                            MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE,
                                            rsp,(unsigned int)1,
                                            "Illegal nb of values %d in %s (max %d)\n",
                                            (void * const *)(__va_args));
          }
        }
        else 
          if (mapping_address < 0) goto _LOR;
          else 
            if (mapping_address + nb > nb_bits) {
              _LOR:
              {
                int tmp_3;
                ;
                if (mapping_address < 0) tmp_3 = (int)address;
                else tmp_3 = (int)address + nb;
                ;
                {
                  int __va_arg0_84 = tmp_3;
                  char const *__va_arg1_86 = name;
                  void *__va_args_88[2] = {& __va_arg0_84, & __va_arg1_86};
                  rsp_length = response_exception(ctx,& sft,
                                                  MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
                                                  rsp,(unsigned int)0,
                                                  "Illegal data address 0x%0X in %s\n",
                                                  (void * const *)(__va_args_88));
                }
              }
            }
            else {
              int tmp_4;
              int tmp_5;
              rsp_length = (*((ctx->backend)->build_response_basis))(& sft,
                                                                    rsp);
              tmp_4 = rsp_length;
              rsp_length ++;
              if (nb % 8) tmp_5 = 1; else tmp_5 = 0;
              rsp[tmp_4] = (uint8_t)(nb / 8 + tmp_5);
              rsp_length = response_io_status(tab_bits,mapping_address,nb,
                                              rsp,rsp_length);
            }
    }
    break;
    case 0x03: case 0x04:
    {
      int tmp_6;
      int tmp_7;
      uint16_t *tmp_8;
      char const *tmp_9;
      unsigned int is_input_0 = (unsigned int)(function == 0x04);
      if (is_input_0) tmp_6 = mb_mapping->start_input_registers;
      else tmp_6 = mb_mapping->start_registers;
      int start_registers = tmp_6;
      if (is_input_0) tmp_7 = mb_mapping->nb_input_registers;
      else tmp_7 = mb_mapping->nb_registers;
      int nb_registers = tmp_7;
      if (is_input_0) tmp_8 = mb_mapping->tab_input_registers;
      else tmp_8 = mb_mapping->tab_registers;
      uint16_t *tab_registers = tmp_8;
      if (is_input_0) tmp_9 = "read_input_registers";
      else tmp_9 = "read_registers";
      char const * const name_0 = tmp_9;
      int nb_0 =
        ((int)*(req + (offset + 3)) << 8) + (int)*(req + (offset + 4));
      int mapping_address_0 = (int)address - start_registers;
      if (nb_0 < 1) goto _LOR_2;
      else 
        if (125 < nb_0) {
          _LOR_2:
          {
            int __va_arg0_90 = nb_0;
            char const *__va_arg1_92 = name_0;
            int __va_arg2_94 = 125;
            void *__va_args_96[3] =
              {& __va_arg0_90, & __va_arg1_92, & __va_arg2_94};
            rsp_length = response_exception(ctx,& sft,
                                            MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE,
                                            rsp,(unsigned int)1,
                                            "Illegal nb of values %d in %s (max %d)\n",
                                            (void * const *)(__va_args_96));
          }
        }
        else 
          if (mapping_address_0 < 0) goto _LOR_1;
          else 
            if (mapping_address_0 + nb_0 > nb_registers) {
              _LOR_1:
              {
                int tmp_10;
                ;
                if (mapping_address_0 < 0) tmp_10 = (int)address;
                else tmp_10 = (int)address + nb_0;
                ;
                {
                  int __va_arg0_98 = tmp_10;
                  char const *__va_arg1_100 = name_0;
                  void *__va_args_102[2] = {& __va_arg0_98, & __va_arg1_100};
                  rsp_length = response_exception(ctx,& sft,
                                                  MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
                                                  rsp,(unsigned int)0,
                                                  "Illegal data address 0x%0X in %s\n",
                                                  (void * const *)(__va_args_102));
                }
              }
            }
            else {
              int i;
              int tmp_11;
              rsp_length = (*((ctx->backend)->build_response_basis))(& sft,
                                                                    rsp);
              tmp_11 = rsp_length;
              rsp_length ++;
              rsp[tmp_11] = (uint8_t)(nb_0 << 1);
              i = mapping_address_0;
              while (i < mapping_address_0 + nb_0) {
                {
                  int tmp_12;
                  int tmp_13;
                  tmp_12 = rsp_length;
                  rsp_length ++;
                  rsp[tmp_12] = (uint8_t)((int)*(tab_registers + i) >> 8);
                  tmp_13 = rsp_length;
                  rsp_length ++;
                  rsp[tmp_13] = (uint8_t)((int)*(tab_registers + i) & 0xFF);
                }
                i ++;
              }
            }
    }
    break;
    case 0x05:
    {
      int mapping_address_1 = (int)address - mb_mapping->start_bits;
      if (mapping_address_1 < 0) goto _LOR_4;
      else 
        if (mapping_address_1 >= mb_mapping->nb_bits) {
          _LOR_4:
          {
            int __va_arg0_104 = (int)address;
            void *__va_args_106[1] = {& __va_arg0_104};
            rsp_length = response_exception(ctx,& sft,
                                            MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
                                            rsp,(unsigned int)0,
                                            "Illegal data address 0x%0X in write_bit\n",
                                            (void * const *)(__va_args_106));
          }
        }
        else {
          int data =
            ((int)*(req + (offset + 3)) << 8) + (int)*(req + (offset + 4));
          if (data == 0xFF00) goto _LOR_3;
          else 
            if (data == 0x0) {
              _LOR_3:
              {
                if (data) *(mb_mapping->tab_bits + mapping_address_1) = (uint8_t)1;
                else *(mb_mapping->tab_bits + mapping_address_1) = (uint8_t)0;
                memcpy((void *)(rsp),(void const *)req,(size_t)req_length);
                rsp_length = req_length;
              }
            }
            else {
              {
                int __va_arg0_108 = data;
                int __va_arg1_110 = (int)address;
                void *__va_args_112[2] = {& __va_arg0_108, & __va_arg1_110};
                rsp_length = response_exception(ctx,& sft,
                                                MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE,
                                                rsp,(unsigned int)0,
                                                "Illegal data value 0x%0X in write_bit request at address %0X\n",
                                                (void * const *)(__va_args_112));
              }
            }
        }
    }
    break;
    case 0x06:
    {
      int mapping_address_2 = (int)address - mb_mapping->start_registers;
      if (mapping_address_2 < 0) goto _LOR_5;
      else 
        if (mapping_address_2 >= mb_mapping->nb_registers) {
          _LOR_5:
          {
            int __va_arg0_114 = (int)address;
            void *__va_args_116[1] = {& __va_arg0_114};
            rsp_length = response_exception(ctx,& sft,
                                            MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
                                            rsp,(unsigned int)0,
                                            "Illegal data address 0x%0X in write_register\n",
                                            (void * const *)(__va_args_116));
          }
        }
        else {
          int data_0 =
            ((int)*(req + (offset + 3)) << 8) + (int)*(req + (offset + 4));
          *(mb_mapping->tab_registers + mapping_address_2) = (uint16_t)data_0;
          memcpy((void *)(rsp),(void const *)req,(size_t)req_length);
          rsp_length = req_length;
        }
    }
    break;
    case 0x0F:
    {
      int nb_1 =
        ((int)*(req + (offset + 3)) << 8) + (int)*(req + (offset + 4));
      int mapping_address_3 = (int)address - mb_mapping->start_bits;
      if (nb_1 < 1) goto _LOR_7;
      else 
        if (1968 < nb_1) {
          _LOR_7:
          {
            int __va_arg0_118 = nb_1;
            int __va_arg1_120 = 1968;
            void *__va_args_122[2] = {& __va_arg0_118, & __va_arg1_120};
            rsp_length = response_exception(ctx,& sft,
                                            MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE,
                                            rsp,(unsigned int)1,
                                            "Illegal number of values %d in write_bits (max %d)\n",
                                            (void * const *)(__va_args_122));
          }
        }
        else 
          if (mapping_address_3 < 0) goto _LOR_6;
          else 
            if (mapping_address_3 + nb_1 > mb_mapping->nb_bits) {
              _LOR_6:
              {
                int tmp_14;
                if (mapping_address_3 < 0) tmp_14 = (int)address;
                else tmp_14 = (int)address + nb_1;
                ;
                {
                  int __va_arg0_124 = tmp_14;
                  void *__va_args_126[1] = {& __va_arg0_124};
                  rsp_length = response_exception(ctx,& sft,
                                                  MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
                                                  rsp,(unsigned int)0,
                                                  "Illegal data address 0x%0X in write_bits\n",
                                                  (void * const *)(__va_args_126));
                }
              }
            }
            else {
              modbus_set_bits_from_bytes(mb_mapping->tab_bits,
                                         mapping_address_3,
                                         (unsigned int)nb_1,
                                         req + (offset + 6));
              rsp_length = (*((ctx->backend)->build_response_basis))(& sft,
                                                                    rsp);
              memcpy((void *)(& rsp[rsp_length]),
                     (void const *)(req + rsp_length),(size_t)4);
              rsp_length += 4;
            }
    }
    break;
    case 0x10:
    {
      int nb_2 =
        ((int)*(req + (offset + 3)) << 8) + (int)*(req + (offset + 4));
      int mapping_address_4 = (int)address - mb_mapping->start_registers;
      if (nb_2 < 1) goto _LOR_9;
      else 
        if (123 < nb_2) {
          _LOR_9:
          {
            int __va_arg0_128 = nb_2;
            int __va_arg1_130 = 123;
            void *__va_args_132[2] = {& __va_arg0_128, & __va_arg1_130};
            rsp_length = response_exception(ctx,& sft,
                                            MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE,
                                            rsp,(unsigned int)1,
                                            "Illegal number of values %d in write_registers (max %d)\n",
                                            (void * const *)(__va_args_132));
          }
        }
        else 
          if (mapping_address_4 < 0) goto _LOR_8;
          else 
            if (mapping_address_4 + nb_2 > mb_mapping->nb_registers) {
              _LOR_8:
              {
                int tmp_15;
                if (mapping_address_4 < 0) tmp_15 = (int)address;
                else tmp_15 = (int)address + nb_2;
                ;
                {
                  int __va_arg0_134 = tmp_15;
                  void *__va_args_136[1] = {& __va_arg0_134};
                  rsp_length = response_exception(ctx,& sft,
                                                  MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
                                                  rsp,(unsigned int)0,
                                                  "Illegal data address 0x%0X in write_registers\n",
                                                  (void * const *)(__va_args_136));
                }
              }
            }
            else {
              int i_0;
              int j;
              i_0 = mapping_address_4;
              j = 6;
              while (i_0 < mapping_address_4 + nb_2) {
                *(mb_mapping->tab_registers + i_0) = (uint16_t)(((int)*(
                                                                 req + (
                                                                 offset + j)) << 8) + (int)*(
                                                                req + (
                                                                (offset + j) + 1)));
                i_0 ++;
                j += 2;
              }
              rsp_length = (*((ctx->backend)->build_response_basis))(& sft,
                                                                    rsp);
              memcpy((void *)(& rsp[rsp_length]),
                     (void const *)(req + rsp_length),(size_t)4);
              rsp_length += 4;
            }
    }
    break;
    case 0x11:
    {
      int str_len;
      int byte_count_pos;
      int tmp_16;
      int tmp_17;
      int tmp_18;
      size_t tmp_19;
      rsp_length = (*((ctx->backend)->build_response_basis))(& sft,rsp);
      tmp_16 = rsp_length;
      rsp_length ++;
      byte_count_pos = tmp_16;
      tmp_17 = rsp_length;
      rsp_length ++;
      rsp[tmp_17] = (uint8_t)180;
      tmp_18 = rsp_length;
      rsp_length ++;
      rsp[tmp_18] = (uint8_t)0xFF;
      tmp_19 = strlen("3.1.4");
      str_len = (int)((size_t)3 + tmp_19);
      memcpy((void *)(& rsp[rsp_length]),(void const *)"LMB3.1.4",
             (size_t)str_len);
      rsp_length += str_len;
      rsp[byte_count_pos] = (uint8_t)((rsp_length - byte_count_pos) - 1);
    }
    break;
    case 0x07: ;
    if (ctx->debug) fprintf(__fc_stderr,"FIXME Not implemented\n"); /* fprintf_va_28 */
    __fc_errno = 92;
    __retres = -1;
    goto return_label;
    break;
    case 0x16:
    {
      int mapping_address_5 = (int)address - mb_mapping->start_registers;
      if (mapping_address_5 < 0) goto _LOR_10;
      else 
        if (mapping_address_5 >= mb_mapping->nb_registers) {
          _LOR_10:
          {
            int __va_arg0_138 = (int)address;
            void *__va_args_140[1] = {& __va_arg0_138};
            rsp_length = response_exception(ctx,& sft,
                                            MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
                                            rsp,(unsigned int)0,
                                            "Illegal data address 0x%0X in write_register\n",
                                            (void * const *)(__va_args_140));
          }
        }
        else {
          uint16_t data_1 = *(mb_mapping->tab_registers + mapping_address_5);
          uint16_t and =
            (uint16_t)(((int)*(req + (offset + 3)) << 8) + (int)*(req + (
                                                                  offset + 4)));
          uint16_t or =
            (uint16_t)(((int)*(req + (offset + 5)) << 8) + (int)*(req + (
                                                                  offset + 6)));
          data_1 = (uint16_t)(((int)data_1 & (int)and) | ((int)or & ~ ((int)and)));
          *(mb_mapping->tab_registers + mapping_address_5) = data_1;
          memcpy((void *)(rsp),(void const *)req,(size_t)req_length);
          rsp_length = req_length;
        }
    }
    break;
    case 0x17:
    {
      int nb_3 =
        ((int)*(req + (offset + 3)) << 8) + (int)*(req + (offset + 4));
      uint16_t address_write =
        (uint16_t)(((int)*(req + (offset + 5)) << 8) + (int)*(req + (
                                                              offset + 6)));
      int nb_write =
        ((int)*(req + (offset + 7)) << 8) + (int)*(req + (offset + 8));
      int nb_write_bytes = (int)*(req + (offset + 9));
      int mapping_address_6 = (int)address - mb_mapping->start_registers;
      int mapping_address_write =
        (int)address_write - mb_mapping->start_registers;
      if (nb_write < 1) goto _LOR_12;
      else 
        if (121 < nb_write) goto _LOR_12;
        else 
          if (nb_3 < 1) goto _LOR_12;
          else 
            if (125 < nb_3) goto _LOR_12;
            else 
              if (nb_write_bytes != nb_write * 2) {
                _LOR_12:
                {
                  int __va_arg0_142 = nb_write;
                  int __va_arg1_144 = nb_3;
                  int __va_arg2_146 = 121;
                  int __va_arg3 = 125;
                  void *__va_args_149[4] =
                    {& __va_arg0_142,
                     & __va_arg1_144,
                     & __va_arg2_146,
                     & __va_arg3};
                  rsp_length = response_exception(ctx,& sft,
                                                  MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE,
                                                  rsp,(unsigned int)1,
                                                  "Illegal nb of values (W%d, R%d) in write_and_read_registers (max W%d, R%d)\n",
                                                  (void * const *)(__va_args_149));
                }
              }
              else 
                if (mapping_address_6 < 0) goto _LOR_11;
                else 
                  if (mapping_address_6 + nb_3 > mb_mapping->nb_registers) 
                    goto _LOR_11;
                  else 
                    if (mapping_address_6 < 0) goto _LOR_11;
                    else 
                      if (mapping_address_write + nb_write > mb_mapping->nb_registers) {
                        _LOR_11:
                        {
                          int tmp_20;
                          int tmp_21;
                          if (mapping_address_write < 0) tmp_20 = (int)address_write;
                          else tmp_20 = (int)address_write + nb_write;
                          if (mapping_address_6 < 0) tmp_21 = (int)address;
                          else tmp_21 = (int)address + nb_3;
                          ;
                          {
                            int __va_arg0_151 = tmp_21;
                            int __va_arg1_153 = tmp_20;
                            void *__va_args_155[2] =
                              {& __va_arg0_151, & __va_arg1_153};
                            rsp_length = response_exception(ctx,& sft,
                                                            MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS,
                                                            rsp,
                                                            (unsigned int)0,
                                                            "Illegal data read address 0x%0X or write address 0x%0X write_and_read_registers\n",
                                                            (void * const *)(__va_args_155));
                          }
                        }
                      }
                      else {
                        int i_1;
                        int j_0;
                        int tmp_22;
                        rsp_length = (*((ctx->backend)->build_response_basis))
                        (& sft,rsp);
                        tmp_22 = rsp_length;
                        rsp_length ++;
                        rsp[tmp_22] = (uint8_t)(nb_3 << 1);
                        i_1 = mapping_address_write;
                        j_0 = 10;
                        while (i_1 < mapping_address_write + nb_write) {
                          *(mb_mapping->tab_registers + i_1) = (uint16_t)(
                          ((int)*(req + (offset + j_0)) << 8) + (int)*(
                          req + ((offset + j_0) + 1)));
                          i_1 ++;
                          j_0 += 2;
                        }
                        i_1 = mapping_address_6;
                        while (i_1 < mapping_address_6 + nb_3) {
                          {
                            int tmp_23;
                            int tmp_24;
                            tmp_23 = rsp_length;
                            rsp_length ++;
                            rsp[tmp_23] = (uint8_t)((int)*(mb_mapping->tab_registers + i_1) >> 8);
                            tmp_24 = rsp_length;
                            rsp_length ++;
                            rsp[tmp_24] = (uint8_t)((int)*(mb_mapping->tab_registers + i_1) & 0xFF);
                          }
                          i_1 ++;
                        }
                      }
    }
    break;
    default:
    {
      int __va_arg0_157 = function;
      void *__va_args_159[1] = {& __va_arg0_157};
      rsp_length = response_exception(ctx,& sft,
                                      MODBUS_EXCEPTION_ILLEGAL_FUNCTION,rsp,
                                      (unsigned int)1,
                                      "Unknown Modbus function code: 0x%0X\n",
                                      (void * const *)(__va_args_159));
    }
    break;
  }
  if (slave == 0) tmp_26 = 0; else tmp_26 = send_msg(ctx,rsp,rsp_length);
  __retres = tmp_26;
  return_label: return __retres;
}

int modbus_reply_exception(modbus_t *ctx, uint8_t const *req,
                           unsigned int exception_code)
{
  int __retres;
  int offset;
  int slave;
  int function;
  uint8_t rsp[260];
  int rsp_length;
  sft_t sft;
  int dummy_length = 99;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  offset = (int)(ctx->backend)->header_length;
  slave = (int)*(req + (offset - 1));
  function = (int)*(req + offset);
  sft.slave = slave;
  sft.function = function + 0x80;
  sft.t_id = (*((ctx->backend)->prepare_response_tid))(req,& dummy_length);
  rsp_length = (*((ctx->backend)->build_response_basis))(& sft,rsp);
  if (exception_code < (unsigned int)MODBUS_EXCEPTION_MAX) {
    int tmp;
    int tmp_0;
    tmp = rsp_length;
    rsp_length ++;
    rsp[tmp] = (uint8_t)exception_code;
    tmp_0 = send_msg(ctx,rsp,rsp_length);
    __retres = tmp_0;
    goto return_label;
  }
  else {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  return_label: return __retres;
}

static int read_io_status(modbus_t *ctx, int function, int addr, int nb,
                          uint8_t *dest)
{
  int __retres;
  int rc;
  int req_length;
  uint8_t req[12];
  uint8_t rsp[260];
  req_length = (*((ctx->backend)->build_request_basis))(ctx,function,addr,nb,
                                                        req);
  rc = send_msg(ctx,req,req_length);
  if (rc > 0) {
    int i;
    int temp;
    int bit;
    int offset;
    int offset_end;
    int pos = 0;
    rc = _modbus_receive_msg(ctx,rsp,MSG_CONFIRMATION);
    if (rc == -1) {
      __retres = -1;
      goto return_label;
    }
    rc = check_confirmation(ctx,req,rsp,rc);
    if (rc == -1) {
      __retres = -1;
      goto return_label;
    }
    offset = (int)((ctx->backend)->header_length + (unsigned int)2);
    offset_end = offset + rc;
    i = offset;
    /*@ loop unroll 14; */
    while (i < offset_end) {
      temp = (int)rsp[i];
      bit = 0x01;
      /*@ loop unroll 16; */
      while (1) {
        if (bit & 0xff) {
          if (! (pos < nb)) break;
        }
        else break;
        {
          int tmp;
          tmp = pos;
          pos ++;
          if (temp & bit) *(dest + tmp) = (uint8_t)1;
          else *(dest + tmp) = (uint8_t)0;
          bit <<= 1;
        }
      }
      i ++;
    }
  }
  __retres = rc;
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param1, param0;
 */
int fprintf_va_29(FILE * restrict stream, char const * restrict format,
                  int param0, int param1);

int modbus_read_bits(modbus_t *ctx, int addr, int nb, uint8_t *dest)
{
  int __retres;
  int rc;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  if (nb > 2000) {
    if (ctx->debug) fprintf(__fc_stderr,
                            "ERROR Too many bits requested (%d > %d)\n",nb,
                            2000); /* fprintf_va_29 */
    __fc_errno = (112345678 + MODBUS_EXCEPTION_GATEWAY_TARGET) + 5;
    __retres = -1;
    goto return_label;
  }
  rc = read_io_status(ctx,0x01,addr,nb,dest);
  if (rc == -1) {
    __retres = -1;
    goto return_label;
  }
  else {
    __retres = nb;
    goto return_label;
  }
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param1, param0;
 */
int fprintf_va_30(FILE * restrict stream, char const * restrict format,
                  int param0, int param1);

int modbus_read_input_bits(modbus_t *ctx, int addr, int nb, uint8_t *dest)
{
  int __retres;
  int rc;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  if (nb > 2000) {
    if (ctx->debug) fprintf(__fc_stderr,
                            "ERROR Too many discrete inputs requested (%d > %d)\n",
                            nb,2000); /* fprintf_va_30 */
    __fc_errno = (112345678 + MODBUS_EXCEPTION_GATEWAY_TARGET) + 5;
    __retres = -1;
    goto return_label;
  }
  rc = read_io_status(ctx,0x02,addr,nb,dest);
  if (rc == -1) {
    __retres = -1;
    goto return_label;
  }
  else {
    __retres = nb;
    goto return_label;
  }
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param1, param0;
 */
int fprintf_va_31(FILE * restrict stream, char const * restrict format,
                  int param0, int param1);

static int read_registers(modbus_t *ctx, int function, int addr, int nb,
                          uint16_t *dest)
{
  int __retres;
  int rc;
  int req_length;
  uint8_t req[12];
  uint8_t rsp[260];
  if (nb > 125) {
    if (ctx->debug) fprintf(__fc_stderr,
                            "ERROR Too many registers requested (%d > %d)\n",
                            nb,125); /* fprintf_va_31 */
    __fc_errno = (112345678 + MODBUS_EXCEPTION_GATEWAY_TARGET) + 5;
    __retres = -1;
    goto return_label;
  }
  req_length = (*((ctx->backend)->build_request_basis))(ctx,function,addr,nb,
                                                        req);
  rc = send_msg(ctx,req,req_length);
  if (rc > 0) {
    int offset;
    int i;
    rc = _modbus_receive_msg(ctx,rsp,MSG_CONFIRMATION);
    if (rc == -1) {
      __retres = -1;
      goto return_label;
    }
    rc = check_confirmation(ctx,req,rsp,rc);
    if (rc == -1) {
      __retres = -1;
      goto return_label;
    }
    offset = (int)(ctx->backend)->header_length;
    i = 0;
    /*@ loop unroll 100; */
    while (i < rc) {
      *(dest + i) = (uint16_t)(((int)rsp[(offset + 2) + (i << 1)] << 8) | (int)rsp[
                               (offset + 3) + (i << 1)]);
      i ++;
    }
  }
  __retres = rc;
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param1, param0;
 */
int fprintf_va_32(FILE * restrict stream, char const * restrict format,
                  int param0, int param1);

int modbus_read_registers(modbus_t *ctx, int addr, int nb, uint16_t *dest)
{
  int __retres;
  int status;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  if (nb > 125) {
    if (ctx->debug) fprintf(__fc_stderr,
                            "ERROR Too many registers requested (%d > %d)\n",
                            nb,125); /* fprintf_va_32 */
    __fc_errno = (112345678 + MODBUS_EXCEPTION_GATEWAY_TARGET) + 5;
    __retres = -1;
    goto return_label;
  }
  status = read_registers(ctx,0x03,addr,nb,dest);
  __retres = status;
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param1, param0;
 */
int fprintf_va_33(FILE * restrict stream, char const * restrict format,
                  int param0, int param1);

int modbus_read_input_registers(modbus_t *ctx, int addr, int nb,
                                uint16_t *dest)
{
  int __retres;
  int status;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  if (nb > 125) {
    fprintf(__fc_stderr,
            "ERROR Too many input registers requested (%d > %d)\n",nb,125); /* fprintf_va_33 */
    __fc_errno = (112345678 + MODBUS_EXCEPTION_GATEWAY_TARGET) + 5;
    __retres = -1;
    goto return_label;
  }
  status = read_registers(ctx,0x04,addr,nb,dest);
  __retres = status;
  return_label: return __retres;
}

static int write_single(modbus_t *ctx, int function, int addr, int value)
{
  int __retres;
  int rc;
  int req_length;
  uint8_t req[12];
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  req_length = (*((ctx->backend)->build_request_basis))(ctx,function,addr,
                                                        value,req);
  rc = send_msg(ctx,req,req_length);
  if (rc > 0) {
    uint8_t rsp[260];
    rc = _modbus_receive_msg(ctx,rsp,MSG_CONFIRMATION);
    if (rc == -1) {
      __retres = -1;
      goto return_label;
    }
    rc = check_confirmation(ctx,req,rsp,rc);
  }
  __retres = rc;
  return_label: return __retres;
}

int modbus_write_bit(modbus_t *ctx, int addr, int status)
{
  int __retres;
  int tmp_0;
  int tmp;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  if (status) tmp = 0xFF00; else tmp = 0;
  ;
  ;
  tmp_0 = write_single(ctx,0x05,addr,tmp);
  __retres = tmp_0;
  return_label: return __retres;
}

int modbus_write_register(modbus_t *ctx, int addr, int value)
{
  int __retres;
  int tmp;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  tmp = write_single(ctx,0x06,addr,value);
  __retres = tmp;
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param1, param0;
 */
int fprintf_va_34(FILE * restrict stream, char const * restrict format,
                  int param0, int param1);

int modbus_write_bits(modbus_t *ctx, int addr, int nb, uint8_t const *src)
{
  int __retres;
  int rc;
  int i;
  int byte_count;
  int req_length;
  uint8_t req[260];
  int tmp;
  int tmp_0;
  int bit_check = 0;
  int pos = 0;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  if (nb > 1968) {
    if (ctx->debug) fprintf(__fc_stderr,
                            "ERROR Writing too many bits (%d > %d)\n",nb,
                            1968); /* fprintf_va_34 */
    __fc_errno = (112345678 + MODBUS_EXCEPTION_GATEWAY_TARGET) + 5;
    __retres = -1;
    goto return_label;
  }
  req_length = (*((ctx->backend)->build_request_basis))(ctx,0x0F,addr,nb,req);
  if (nb % 8) tmp = 1; else tmp = 0;
  byte_count = nb / 8 + tmp;
  tmp_0 = req_length;
  req_length ++;
  req[tmp_0] = (uint8_t)byte_count;
  i = 0;
  /*@ loop unroll 13; */
  while (i < byte_count) {
    {
      int bit;
      bit = 0x01;
      req[req_length] = (uint8_t)0;
      while (1) {
        if (bit & 0xFF) {
          int tmp_2;
          tmp_2 = bit_check;
          bit_check ++;
          ;
          if (! (tmp_2 < nb)) break;
        }
        else break;
        {
          int tmp_1;
          tmp_1 = pos;
          pos ++;
          ;
          if (*(src + tmp_1)) req[req_length] = (uint8_t)((int)req[req_length] | bit);
          else req[req_length] = (uint8_t)((int)req[req_length] & ~ bit);
          bit <<= 1;
        }
      }
      req_length ++;
    }
    i ++;
  }
  rc = send_msg(ctx,req,req_length);
  if (rc > 0) {
    uint8_t rsp[260];
    rc = _modbus_receive_msg(ctx,rsp,MSG_CONFIRMATION);
    if (rc == -1) {
      __retres = -1;
      goto return_label;
    }
    rc = check_confirmation(ctx,req,rsp,rc);
  }
  __retres = rc;
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param1, param0;
 */
int fprintf_va_35(FILE * restrict stream, char const * restrict format,
                  int param0, int param1);

int modbus_write_registers(modbus_t *ctx, int addr, int nb,
                           uint16_t const *src)
{
  int __retres;
  int rc;
  int i;
  int req_length;
  int byte_count;
  uint8_t req[260];
  int tmp;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  if (nb > 123) {
    if (ctx->debug) fprintf(__fc_stderr,
                            "ERROR Trying to write to too many registers (%d > %d)\n",
                            nb,123); /* fprintf_va_35 */
    __fc_errno = (112345678 + MODBUS_EXCEPTION_GATEWAY_TARGET) + 5;
    __retres = -1;
    goto return_label;
  }
  req_length = (*((ctx->backend)->build_request_basis))(ctx,0x10,addr,nb,req);
  byte_count = nb * 2;
  tmp = req_length;
  req_length ++;
  req[tmp] = (uint8_t)byte_count;
  i = 0;
  /*@ loop unroll 100; */
  while (i < nb) {
    {
      int tmp_0;
      int tmp_1;
      tmp_0 = req_length;
      req_length ++;
      req[tmp_0] = (uint8_t)((int)*(src + i) >> 8);
      tmp_1 = req_length;
      req_length ++;
      req[tmp_1] = (uint8_t)((int)*(src + i) & 0x00FF);
    }
    i ++;
  }
  rc = send_msg(ctx,req,req_length);
  if (rc > 0) {
    uint8_t rsp[260];
    rc = _modbus_receive_msg(ctx,rsp,MSG_CONFIRMATION);
    if (rc == -1) {
      __retres = -1;
      goto return_label;
    }
    rc = check_confirmation(ctx,req,rsp,rc);
  }
  __retres = rc;
  return_label: return __retres;
}

int modbus_mask_write_register(modbus_t *ctx, int addr, uint16_t and_mask,
                               uint16_t or_mask)
{
  int __retres;
  int rc;
  int req_length;
  uint8_t req[12 + 2];
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  req_length = (*((ctx->backend)->build_request_basis))(ctx,0x16,addr,0,req);
  req_length -= 2;
  tmp = req_length;
  req_length ++;
  req[tmp] = (uint8_t)((int)and_mask >> 8);
  tmp_0 = req_length;
  req_length ++;
  req[tmp_0] = (uint8_t)((int)and_mask & 0x00ff);
  tmp_1 = req_length;
  req_length ++;
  req[tmp_1] = (uint8_t)((int)or_mask >> 8);
  tmp_2 = req_length;
  req_length ++;
  req[tmp_2] = (uint8_t)((int)or_mask & 0x00ff);
  rc = send_msg(ctx,req,req_length);
  if (rc > 0) {
    uint8_t rsp[260];
    rc = _modbus_receive_msg(ctx,rsp,MSG_CONFIRMATION);
    if (rc == -1) {
      __retres = -1;
      goto return_label;
    }
    rc = check_confirmation(ctx,req,rsp,rc);
  }
  __retres = rc;
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param1, param0;
 */
int fprintf_va_36(FILE * restrict stream, char const * restrict format,
                  int param0, int param1);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param1, param0;
 */
int fprintf_va_37(FILE * restrict stream, char const * restrict format,
                  int param0, int param1);

int modbus_write_and_read_registers(modbus_t *ctx, int write_addr,
                                    int write_nb, uint16_t const *src,
                                    int read_addr, int read_nb,
                                    uint16_t *dest)
{
  int __retres;
  int rc;
  int req_length;
  int i;
  int byte_count;
  uint8_t req[260];
  uint8_t rsp[260];
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  if (write_nb > 121) {
    if (ctx->debug) fprintf(__fc_stderr,
                            "ERROR Too many registers to write (%d > %d)\n",
                            write_nb,121); /* fprintf_va_36 */
    __fc_errno = (112345678 + MODBUS_EXCEPTION_GATEWAY_TARGET) + 5;
    __retres = -1;
    goto return_label;
  }
  if (read_nb > 125) {
    if (ctx->debug) fprintf(__fc_stderr,
                            "ERROR Too many registers requested (%d > %d)\n",
                            read_nb,125); /* fprintf_va_37 */
    __fc_errno = (112345678 + MODBUS_EXCEPTION_GATEWAY_TARGET) + 5;
    __retres = -1;
    goto return_label;
  }
  req_length = (*((ctx->backend)->build_request_basis))(ctx,0x17,read_addr,
                                                        read_nb,req);
  tmp = req_length;
  req_length ++;
  req[tmp] = (uint8_t)(write_addr >> 8);
  tmp_0 = req_length;
  req_length ++;
  req[tmp_0] = (uint8_t)(write_addr & 0x00ff);
  tmp_1 = req_length;
  req_length ++;
  req[tmp_1] = (uint8_t)(write_nb >> 8);
  tmp_2 = req_length;
  req_length ++;
  req[tmp_2] = (uint8_t)(write_nb & 0x00ff);
  byte_count = write_nb * 2;
  tmp_3 = req_length;
  req_length ++;
  req[tmp_3] = (uint8_t)byte_count;
  i = 0;
  /*@ loop unroll 100; */
  while (i < write_nb) {
    {
      int tmp_4;
      int tmp_5;
      tmp_4 = req_length;
      req_length ++;
      req[tmp_4] = (uint8_t)((int)*(src + i) >> 8);
      tmp_5 = req_length;
      req_length ++;
      req[tmp_5] = (uint8_t)((int)*(src + i) & 0x00FF);
    }
    i ++;
  }
  rc = send_msg(ctx,req,req_length);
  if (rc > 0) {
    int offset;
    rc = _modbus_receive_msg(ctx,rsp,MSG_CONFIRMATION);
    if (rc == -1) {
      __retres = -1;
      goto return_label;
    }
    rc = check_confirmation(ctx,req,rsp,rc);
    if (rc == -1) {
      __retres = -1;
      goto return_label;
    }
    offset = (int)(ctx->backend)->header_length;
    i = 0;
    /*@ loop unroll 100; */
    while (i < rc) {
      *(dest + i) = (uint16_t)(((int)rsp[(offset + 2) + (i << 1)] << 8) | (int)rsp[
                               (offset + 3) + (i << 1)]);
      i ++;
    }
  }
  __retres = rc;
  return_label: return __retres;
}

int modbus_report_slave_id(modbus_t *ctx, int max_dest, uint8_t *dest)
{
  int __retres;
  int rc;
  int req_length;
  uint8_t req[12];
  if (ctx == (modbus_t *)0) goto _LOR;
  else 
    if (max_dest <= 0) {
      _LOR: {
              __fc_errno = 22;
              __retres = -1;
              goto return_label;
            }
    }
  req_length = (*((ctx->backend)->build_request_basis))(ctx,0x11,0,0,req);
  req_length -= 4;
  rc = send_msg(ctx,req,req_length);
  if (rc > 0) {
    int i;
    int offset;
    uint8_t rsp[260];
    rc = _modbus_receive_msg(ctx,rsp,MSG_CONFIRMATION);
    if (rc == -1) {
      __retres = -1;
      goto return_label;
    }
    rc = check_confirmation(ctx,req,rsp,rc);
    if (rc == -1) {
      __retres = -1;
      goto return_label;
    }
    offset = (int)((ctx->backend)->header_length + (unsigned int)2);
    i = 0;
    while (1) {
      if (i < rc) {
        if (! (i < max_dest)) break;
      }
      else break;
      *(dest + i) = rsp[offset + i];
      i ++;
    }
  }
  __retres = rc;
  return_label: return __retres;
}

void _modbus_init_common(modbus_t *ctx)
{
  ctx->slave = -1;
  ctx->s = -1;
  ctx->debug = 0;
  ctx->error_recovery = MODBUS_ERROR_RECOVERY_NONE;
  ctx->response_timeout.tv_sec = (time_t)0;
  ctx->response_timeout.tv_usec = 500000;
  ctx->byte_timeout.tv_sec = (time_t)0;
  ctx->byte_timeout.tv_usec = 500000;
  return;
}

int modbus_set_slave(modbus_t *ctx, int slave)
{
  int __retres;
  int tmp;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  tmp = (*((ctx->backend)->set_slave))(ctx,slave);
  __retres = tmp;
  return_label: return __retres;
}

int modbus_get_slave(modbus_t *ctx)
{
  int __retres;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  __retres = ctx->slave;
  return_label: return __retres;
}

int modbus_set_error_recovery(modbus_t *ctx,
                              modbus_error_recovery_mode error_recovery)
{
  int __retres;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  ctx->error_recovery = (int)((uint8_t)error_recovery);
  __retres = 0;
  return_label: return __retres;
}

int modbus_set_socket(modbus_t *ctx, int s)
{
  int __retres;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  ctx->s = s;
  __retres = 0;
  return_label: return __retres;
}

int modbus_get_socket(modbus_t *ctx)
{
  int __retres;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  __retres = ctx->s;
  return_label: return __retres;
}

int modbus_get_response_timeout(modbus_t *ctx, uint32_t *to_sec,
                                uint32_t *to_usec)
{
  int __retres;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  *to_sec = (uint32_t)ctx->response_timeout.tv_sec;
  *to_usec = (uint32_t)ctx->response_timeout.tv_usec;
  __retres = 0;
  return_label: return __retres;
}

int modbus_set_response_timeout(modbus_t *ctx, uint32_t to_sec,
                                uint32_t to_usec)
{
  int __retres;
  if (ctx == (modbus_t *)0) goto _LOR;
  else 
    if (to_sec == (uint32_t)0) {
      if (to_usec == (uint32_t)0) goto _LOR; else goto _LAND;
    }
    else {
      _LAND: ;
      if (to_usec > (uint32_t)999999) {
        _LOR: {
                __fc_errno = 22;
                __retres = -1;
                goto return_label;
              }
      }
    }
  ctx->response_timeout.tv_sec = (time_t)to_sec;
  ctx->response_timeout.tv_usec = (suseconds_t)to_usec;
  __retres = 0;
  return_label: return __retres;
}

int modbus_get_byte_timeout(modbus_t *ctx, uint32_t *to_sec,
                            uint32_t *to_usec)
{
  int __retres;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  *to_sec = (uint32_t)ctx->byte_timeout.tv_sec;
  *to_usec = (uint32_t)ctx->byte_timeout.tv_usec;
  __retres = 0;
  return_label: return __retres;
}

int modbus_set_byte_timeout(modbus_t *ctx, uint32_t to_sec, uint32_t to_usec)
{
  int __retres;
  if (ctx == (modbus_t *)0) goto _LOR;
  else 
    if (to_usec > (uint32_t)999999) {
      _LOR: {
              __fc_errno = 22;
              __retres = -1;
              goto return_label;
            }
    }
  ctx->byte_timeout.tv_sec = (time_t)to_sec;
  ctx->byte_timeout.tv_usec = (suseconds_t)to_usec;
  __retres = 0;
  return_label: return __retres;
}

int modbus_get_header_length(modbus_t *ctx)
{
  int __retres;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  __retres = (int)(ctx->backend)->header_length;
  return_label: return __retres;
}

int modbus_connect(modbus_t *ctx)
{
  int __retres;
  int tmp;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  tmp = (*((ctx->backend)->connect))(ctx);
  __retres = tmp;
  return_label: return __retres;
}

void modbus_close(modbus_t *ctx)
{
  if (ctx == (modbus_t *)0) goto return_label;
  (*((ctx->backend)->close))(ctx);
  return_label: return;
}

void modbus_free(modbus_t *ctx)
{
  if (ctx == (modbus_t *)0) goto return_label;
  (*((ctx->backend)->free))(ctx);
  return_label: return;
}

int modbus_set_debug(modbus_t *ctx, int flag)
{
  int __retres;
  if (ctx == (modbus_t *)0) {
    __fc_errno = 22;
    __retres = -1;
    goto return_label;
  }
  ctx->debug = flag;
  __retres = 0;
  return_label: return __retres;
}

modbus_mapping_t *modbus_mapping_new_start_address(unsigned int start_bits,
                                                   unsigned int nb_bits,
                                                   unsigned int start_input_bits,
                                                   unsigned int nb_input_bits,
                                                   unsigned int start_registers,
                                                   unsigned int nb_registers,
                                                   unsigned int start_input_registers,
                                                   unsigned int nb_input_registers)
{
  modbus_mapping_t *__retres;
  modbus_mapping_t *mb_mapping;
  mb_mapping = (modbus_mapping_t *)malloc(sizeof(modbus_mapping_t));
  if (mb_mapping == (modbus_mapping_t *)0) {
    __retres = (modbus_mapping_t *)0;
    goto return_label;
  }
  mb_mapping->nb_bits = (int)nb_bits;
  mb_mapping->start_bits = (int)start_bits;
  if (nb_bits == (unsigned int)0) mb_mapping->tab_bits = (uint8_t *)0;
  else {
    mb_mapping->tab_bits = (uint8_t *)malloc((unsigned long)nb_bits * sizeof(uint8_t));
    if (mb_mapping->tab_bits == (uint8_t *)0) {
      free((void *)mb_mapping);
      __retres = (modbus_mapping_t *)0;
      goto return_label;
    }
    memset((void *)mb_mapping->tab_bits,0,
           (unsigned long)nb_bits * sizeof(uint8_t));
  }
  mb_mapping->nb_input_bits = (int)nb_input_bits;
  mb_mapping->start_input_bits = (int)start_input_bits;
  if (nb_input_bits == (unsigned int)0) mb_mapping->tab_input_bits = (uint8_t *)0;
  else {
    mb_mapping->tab_input_bits = (uint8_t *)malloc((unsigned long)nb_input_bits * sizeof(uint8_t));
    if (mb_mapping->tab_input_bits == (uint8_t *)0) {
      free((void *)mb_mapping->tab_bits);
      free((void *)mb_mapping);
      __retres = (modbus_mapping_t *)0;
      goto return_label;
    }
    memset((void *)mb_mapping->tab_input_bits,0,
           (unsigned long)nb_input_bits * sizeof(uint8_t));
  }
  mb_mapping->nb_registers = (int)nb_registers;
  mb_mapping->start_registers = (int)start_registers;
  if (nb_registers == (unsigned int)0) mb_mapping->tab_registers = (uint16_t *)0;
  else {
    mb_mapping->tab_registers = (uint16_t *)malloc((unsigned long)nb_registers * sizeof(uint16_t));
    if (mb_mapping->tab_registers == (uint16_t *)0) {
      free((void *)mb_mapping->tab_input_bits);
      free((void *)mb_mapping->tab_bits);
      free((void *)mb_mapping);
      __retres = (modbus_mapping_t *)0;
      goto return_label;
    }
    memset((void *)mb_mapping->tab_registers,0,
           (unsigned long)nb_registers * sizeof(uint16_t));
  }
  mb_mapping->nb_input_registers = (int)nb_input_registers;
  mb_mapping->start_input_registers = (int)start_input_registers;
  if (nb_input_registers == (unsigned int)0) mb_mapping->tab_input_registers = (uint16_t *)0;
  else {
    mb_mapping->tab_input_registers = (uint16_t *)malloc((unsigned long)nb_input_registers * sizeof(uint16_t));
    if (mb_mapping->tab_input_registers == (uint16_t *)0) {
      free((void *)mb_mapping->tab_registers);
      free((void *)mb_mapping->tab_input_bits);
      free((void *)mb_mapping->tab_bits);
      free((void *)mb_mapping);
      __retres = (modbus_mapping_t *)0;
      goto return_label;
    }
    memset((void *)mb_mapping->tab_input_registers,0,
           (unsigned long)nb_input_registers * sizeof(uint16_t));
  }
  __retres = mb_mapping;
  return_label: return __retres;
}

modbus_mapping_t *modbus_mapping_new(int nb_bits, int nb_input_bits,
                                     int nb_registers, int nb_input_registers)
{
  modbus_mapping_t *tmp;
  tmp = modbus_mapping_new_start_address((unsigned int)0,
                                         (unsigned int)nb_bits,
                                         (unsigned int)0,
                                         (unsigned int)nb_input_bits,
                                         (unsigned int)0,
                                         (unsigned int)nb_registers,
                                         (unsigned int)0,
                                         (unsigned int)nb_input_registers);
  return tmp;
}

void modbus_mapping_free(modbus_mapping_t *mb_mapping)
{
  if (mb_mapping == (modbus_mapping_t *)0) goto return_label;
  free((void *)mb_mapping->tab_input_registers);
  free((void *)mb_mapping->tab_registers);
  free((void *)mb_mapping->tab_input_bits);
  free((void *)mb_mapping->tab_bits);
  free((void *)mb_mapping);
  return_label: return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_38(FILE * restrict stream, char const * restrict format,
                  char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_15(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_16(char const * restrict format, int param0, int param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_17(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_18(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_19(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_20(char const * restrict format, int param0, int param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_21(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_22(char const * restrict format, int param0, int param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_23(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param4),
            (indirect: param3), (indirect: param2), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param4, param3, param2, param1, param0;
 */
int printf_va_24(char const * restrict format, int param0, int param1,
                 unsigned int param2, int param3, unsigned int param4);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_25(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param2),
            (indirect: param1), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param2, param1, param0;
 */
int printf_va_26(char const * restrict format, int param0, int param1,
                 unsigned int param2);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_27(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_28(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_29(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param4),
            (indirect: param3), (indirect: param2), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param4, param3, param2, param1, param0;
 */
int printf_va_30(char const * restrict format, int param0, int param1,
                 unsigned int param2, int param3, unsigned int param4);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_31(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_32(char const * restrict format, int param0, int param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_33(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_34(char const * restrict format, int param0, int param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_35(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param4),
            (indirect: param3), (indirect: param2), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param4, param3, param2, param1, param0;
 */
int printf_va_36(char const * restrict format, int param0, int param1,
                 unsigned int param2, int param3, unsigned int param4);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_37(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_38(char const * restrict format, int param0, int param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_39(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param4),
            (indirect: param3), (indirect: param2), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param4, param3, param2, param1, param0;
 */
int printf_va_40(char const * restrict format, int param0, int param1,
                 unsigned int param2, int param3, unsigned int param4);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_41(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_42(char const * restrict format, int param0, int param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_43(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param4),
            (indirect: param3), (indirect: param2), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param4, param3, param2, param1, param0;
 */
int printf_va_44(char const * restrict format, int param0, int param1,
                 unsigned int param2, int param3, unsigned int param4);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_45(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_46(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_47(char const * restrict format);

int main(void)
{
  int __retres;
  modbus_t *ctx;
  int rc;
  int nb_fail;
  int nb_loop;
  int addr;
  int nb;
  uint8_t *tab_rq_bits;
  uint8_t *tab_rp_bits;
  uint16_t *tab_rq_registers;
  uint16_t *tab_rw_rq_registers;
  uint16_t *tab_rp_registers;
  int tmp_0;
  ctx = modbus_new_tcp("127.0.0.1",1502);
  modbus_set_debug(ctx,1);
  tmp_0 = modbus_connect(ctx);
  if (tmp_0 == -1) {
    char const *tmp;
    tmp = modbus_strerror(__fc_errno);
    ;
    fprintf(__fc_stderr,"Connection failed: %s\n",(char *)tmp); /* fprintf_va_38 */
    modbus_free(ctx);
    __retres = -1;
    goto return_label;
  }
  nb = 99 - 0;
  tab_rq_bits = (uint8_t *)malloc((unsigned long)nb * sizeof(uint8_t));
  if (! tab_rq_bits) {
    __retres = 1;
    goto return_label;
  }
  memset((void *)tab_rq_bits,0,(unsigned long)nb * sizeof(uint8_t));
  tab_rp_bits = (uint8_t *)malloc((unsigned long)nb * sizeof(uint8_t));
  if (! tab_rp_bits) {
    __retres = 1;
    goto return_label;
  }
  memset((void *)tab_rp_bits,0,(unsigned long)nb * sizeof(uint8_t));
  tab_rq_registers = (uint16_t *)malloc((unsigned long)nb * sizeof(uint16_t));
  if (! tab_rq_registers) {
    __retres = 1;
    goto return_label;
  }
  memset((void *)tab_rq_registers,0,(unsigned long)nb * sizeof(uint16_t));
  tab_rp_registers = (uint16_t *)malloc((unsigned long)nb * sizeof(uint16_t));
  if (! tab_rp_registers) {
    __retres = 1;
    goto return_label;
  }
  memset((void *)tab_rp_registers,0,(unsigned long)nb * sizeof(uint16_t));
  tab_rw_rq_registers = (uint16_t *)malloc((unsigned long)nb * sizeof(uint16_t));
  if (! tab_rw_rq_registers) {
    __retres = 1;
    goto return_label;
  }
  memset((void *)tab_rw_rq_registers,0,(unsigned long)nb * sizeof(uint16_t));
  nb_fail = 0;
  nb_loop = nb_fail;
  while (1) {
    int tmp_7;
    tmp_7 = nb_loop;
    nb_loop ++;
    ;
    if (! (tmp_7 < 1)) break;
    addr = 0;
    while (addr < 99) {
      {
        int i;
        i = 0;
        /*@ loop unroll 100; */
        while (i < nb) {
          {
            int tmp_6;
            tmp_6 = rand();
            *(tab_rq_registers + i) = (uint16_t)((65535.0 * (double)tmp_6) / (
                                                 (double)2147483647 + 1.0));
            *(tab_rw_rq_registers + i) = (uint16_t)(~ ((int)*(tab_rq_registers + i)));
            *(tab_rq_bits + i) = (uint8_t)((int)*(tab_rq_registers + i) % 2);
          }
          i ++;
        }
        nb = 99 - addr;
        rc = modbus_write_bit(ctx,addr,(int)*(tab_rq_bits + 0));
        if (rc != 1) {
          printf("ERROR modbus_write_bit (%d)\n",rc); /* printf_va_15 */
          printf("Address = %d, value = %d\n",addr,(int)*(tab_rq_bits + 0)); /* printf_va_16 */
          nb_fail ++;
        }
        else {
          rc = modbus_read_bits(ctx,addr,1,tab_rp_bits);
          if (rc != 1) goto _LOR;
          else 
            if ((int)*(tab_rq_bits + 0) != (int)*(tab_rp_bits + 0)) {
              _LOR:
              {
                printf("ERROR modbus_read_bits single (%d)\n",rc); /* printf_va_17 */
                printf("address = %d\n",addr); /* printf_va_18 */
                nb_fail ++;
              }
            }
        }
        rc = modbus_write_bits(ctx,addr,nb,(uint8_t const *)tab_rq_bits);
        if (rc != nb) {
          printf("ERROR modbus_write_bits (%d)\n",rc); /* printf_va_19 */
          printf("Address = %d, nb = %d\n",addr,nb); /* printf_va_20 */
          nb_fail ++;
        }
        else {
          rc = modbus_read_bits(ctx,addr,nb,tab_rp_bits);
          if (rc != nb) {
            printf("ERROR modbus_read_bits\n"); /* printf_va_21 */
            printf("Address = %d, nb = %d\n",addr,nb); /* printf_va_22 */
            nb_fail ++;
          }
          else {
            i = 0;
            /*@ loop unroll 100; */
            while (i < nb) {
              if ((int)*(tab_rp_bits + i) != (int)*(tab_rq_bits + i)) {
                printf("ERROR modbus_read_bits\n"); /* printf_va_23 */
                printf("Address = %d, value %d (0x%X) != %d (0x%X)\n",addr,
                       (int)*(tab_rq_bits + i),
                       (unsigned int)((int)*(tab_rq_bits + i)),
                       (int)*(tab_rp_bits + i),
                       (unsigned int)((int)*(tab_rp_bits + i))); /* printf_va_24 */
                nb_fail ++;
              }
              i ++;
            }
          }
        }
        rc = modbus_write_register(ctx,addr,(int)*(tab_rq_registers + 0));
        if (rc != 1) {
          printf("ERROR modbus_write_register (%d)\n",rc); /* printf_va_25 */
          printf("Address = %d, value = %d (0x%X)\n",addr,
                 (int)*(tab_rq_registers + 0),
                 (unsigned int)((int)*(tab_rq_registers + 0))); /* printf_va_26 */
          nb_fail ++;
        }
        else {
          rc = modbus_read_registers(ctx,addr,1,tab_rp_registers);
          if (rc != 1) {
            printf("ERROR modbus_read_registers single (%d)\n",rc); /* printf_va_27 */
            printf("Address = %d\n",addr); /* printf_va_28 */
            nb_fail ++;
          }
          else 
            if ((int)*(tab_rq_registers + 0) != (int)*(tab_rp_registers + 0)) {
              printf("ERROR modbus_read_registers single\n"); /* printf_va_29 */
              printf("Address = %d, value = %d (0x%X) != %d (0x%X)\n",addr,
                     (int)*(tab_rq_registers + 0),
                     (unsigned int)((int)*(tab_rq_registers + 0)),
                     (int)*(tab_rp_registers + 0),
                     (unsigned int)((int)*(tab_rp_registers + 0))); /* printf_va_30 */
              nb_fail ++;
            }
        }
        rc = modbus_write_registers(ctx,addr,nb,
                                    (uint16_t const *)tab_rq_registers);
        if (rc != nb) {
          printf("ERROR modbus_write_registers (%d)\n",rc); /* printf_va_31 */
          printf("Address = %d, nb = %d\n",addr,nb); /* printf_va_32 */
          nb_fail ++;
        }
        else {
          rc = modbus_read_registers(ctx,addr,nb,tab_rp_registers);
          if (rc != nb) {
            printf("ERROR modbus_read_registers (%d)\n",rc); /* printf_va_33 */
            printf("Address = %d, nb = %d\n",addr,nb); /* printf_va_34 */
            nb_fail ++;
          }
          else {
            i = 0;
            /*@ loop unroll 100; */
            while (i < nb) {
              if ((int)*(tab_rq_registers + i) != (int)*(tab_rp_registers + i)) {
                printf("ERROR modbus_read_registers\n"); /* printf_va_35 */
                printf("Address = %d, value %d (0x%X) != %d (0x%X)\n",addr,
                       (int)*(tab_rq_registers + i),
                       (unsigned int)((int)*(tab_rq_registers + i)),
                       (int)*(tab_rp_registers + i),
                       (unsigned int)((int)*(tab_rp_registers + i))); /* printf_va_36 */
                nb_fail ++;
              }
              i ++;
            }
          }
        }
        rc = modbus_write_and_read_registers(ctx,addr,nb,
                                             (uint16_t const *)tab_rw_rq_registers,
                                             addr,nb,tab_rp_registers);
        if (rc != nb) {
          printf("ERROR modbus_read_and_write_registers (%d)\n",rc); /* printf_va_37 */
          printf("Address = %d, nb = %d\n",addr,nb); /* printf_va_38 */
          nb_fail ++;
        }
        else {
          i = 0;
          /*@ loop unroll 100; */
          while (i < nb) {
            if ((int)*(tab_rp_registers + i) != (int)*(tab_rw_rq_registers + i)) {
              printf("ERROR modbus_read_and_write_registers READ\n"); /* printf_va_39 */
              printf("Address = %d, value %d (0x%X) != %d (0x%X)\n",addr,
                     (int)*(tab_rp_registers + i),
                     (unsigned int)((int)*(tab_rw_rq_registers + i)),
                     (int)*(tab_rp_registers + i),
                     (unsigned int)((int)*(tab_rw_rq_registers + i))); /* printf_va_40 */
              nb_fail ++;
            }
            i ++;
          }
          rc = modbus_read_registers(ctx,addr,nb,tab_rp_registers);
          if (rc != nb) {
            printf("ERROR modbus_read_registers (%d)\n",rc); /* printf_va_41 */
            printf("Address = %d, nb = %d\n",addr,nb); /* printf_va_42 */
            nb_fail ++;
          }
          else {
            i = 0;
            /*@ loop unroll 100; */
            while (i < nb) {
              if ((int)*(tab_rw_rq_registers + i) != (int)*(tab_rp_registers + i)) {
                printf("ERROR modbus_read_and_write_registers WRITE\n"); /* printf_va_43 */
                printf("Address = %d, value %d (0x%X) != %d (0x%X)\n",addr,
                       (int)*(tab_rw_rq_registers + i),
                       (unsigned int)((int)*(tab_rw_rq_registers + i)),
                       (int)*(tab_rp_registers + i),
                       (unsigned int)((int)*(tab_rp_registers + i))); /* printf_va_44 */
                nb_fail ++;
              }
              i ++;
            }
          }
        }
      }
      addr ++;
    }
    printf("Test: "); /* printf_va_45 */
    if (nb_fail) printf("%d FAILS\n",nb_fail); /* printf_va_46 */
    else printf("SUCCESS\n"); /* printf_va_47 */
  }
  free((void *)tab_rq_bits);
  free((void *)tab_rp_bits);
  free((void *)tab_rq_registers);
  free((void *)tab_rp_registers);
  free((void *)tab_rw_rq_registers);
  modbus_close(ctx);
  modbus_free(ctx);
  __retres = 0;
  return_label: return __retres;
}


