/* Generated by Frama-C */
#include "assert.h"
#include "errno.h"
#include "stdarg.h"
#include "stddef.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "strings.h"
typedef unsigned char yaml_char_t;
struct yaml_version_directive_s {
   int major ;
   int minor ;
};
typedef struct yaml_version_directive_s yaml_version_directive_t;
struct yaml_tag_directive_s {
   yaml_char_t *handle ;
   yaml_char_t *prefix ;
};
typedef struct yaml_tag_directive_s yaml_tag_directive_t;
enum yaml_encoding_e {
    YAML_ANY_ENCODING = 0,
    YAML_UTF8_ENCODING = 1,
    YAML_UTF16LE_ENCODING = 2,
    YAML_UTF16BE_ENCODING = 3
};
typedef enum yaml_encoding_e yaml_encoding_t;
enum yaml_break_e {
    YAML_ANY_BREAK = 0,
    YAML_CR_BREAK = 1,
    YAML_LN_BREAK = 2,
    YAML_CRLN_BREAK = 3
};
typedef enum yaml_break_e yaml_break_t;
enum yaml_error_type_e {
    YAML_NO_ERROR = 0,
    YAML_MEMORY_ERROR = 1,
    YAML_READER_ERROR = 2,
    YAML_SCANNER_ERROR = 3,
    YAML_PARSER_ERROR = 4,
    YAML_COMPOSER_ERROR = 5,
    YAML_WRITER_ERROR = 6,
    YAML_EMITTER_ERROR = 7
};
typedef enum yaml_error_type_e yaml_error_type_t;
struct yaml_mark_s {
   size_t index ;
   size_t line ;
   size_t column ;
};
typedef struct yaml_mark_s yaml_mark_t;
enum yaml_scalar_style_e {
    YAML_ANY_SCALAR_STYLE = 0,
    YAML_PLAIN_SCALAR_STYLE = 1,
    YAML_SINGLE_QUOTED_SCALAR_STYLE = 2,
    YAML_DOUBLE_QUOTED_SCALAR_STYLE = 3,
    YAML_LITERAL_SCALAR_STYLE = 4,
    YAML_FOLDED_SCALAR_STYLE = 5
};
typedef enum yaml_scalar_style_e yaml_scalar_style_t;
enum yaml_sequence_style_e {
    YAML_ANY_SEQUENCE_STYLE = 0,
    YAML_BLOCK_SEQUENCE_STYLE = 1,
    YAML_FLOW_SEQUENCE_STYLE = 2
};
typedef enum yaml_sequence_style_e yaml_sequence_style_t;
enum yaml_mapping_style_e {
    YAML_ANY_MAPPING_STYLE = 0,
    YAML_BLOCK_MAPPING_STYLE = 1,
    YAML_FLOW_MAPPING_STYLE = 2
};
typedef enum yaml_mapping_style_e yaml_mapping_style_t;
enum yaml_token_type_e {
    YAML_NO_TOKEN = 0,
    YAML_STREAM_START_TOKEN = 1,
    YAML_STREAM_END_TOKEN = 2,
    YAML_VERSION_DIRECTIVE_TOKEN = 3,
    YAML_TAG_DIRECTIVE_TOKEN = 4,
    YAML_DOCUMENT_START_TOKEN = 5,
    YAML_DOCUMENT_END_TOKEN = 6,
    YAML_BLOCK_SEQUENCE_START_TOKEN = 7,
    YAML_BLOCK_MAPPING_START_TOKEN = 8,
    YAML_BLOCK_END_TOKEN = 9,
    YAML_FLOW_SEQUENCE_START_TOKEN = 10,
    YAML_FLOW_SEQUENCE_END_TOKEN = 11,
    YAML_FLOW_MAPPING_START_TOKEN = 12,
    YAML_FLOW_MAPPING_END_TOKEN = 13,
    YAML_BLOCK_ENTRY_TOKEN = 14,
    YAML_FLOW_ENTRY_TOKEN = 15,
    YAML_KEY_TOKEN = 16,
    YAML_VALUE_TOKEN = 17,
    YAML_ALIAS_TOKEN = 18,
    YAML_ANCHOR_TOKEN = 19,
    YAML_TAG_TOKEN = 20,
    YAML_SCALAR_TOKEN = 21
};
typedef enum yaml_token_type_e yaml_token_type_t;
struct __anonstruct_stream_start_2 {
   yaml_encoding_t encoding ;
};
struct __anonstruct_alias_3 {
   yaml_char_t *value ;
};
struct __anonstruct_anchor_4 {
   yaml_char_t *value ;
};
struct __anonstruct_tag_5 {
   yaml_char_t *handle ;
   yaml_char_t *suffix ;
};
struct __anonstruct_scalar_6 {
   yaml_char_t *value ;
   size_t length ;
   yaml_scalar_style_t style ;
};
struct __anonstruct_version_directive_7 {
   int major ;
   int minor ;
};
struct __anonstruct_tag_directive_8 {
   yaml_char_t *handle ;
   yaml_char_t *prefix ;
};
union __anonunion_data_1 {
   struct __anonstruct_stream_start_2 stream_start ;
   struct __anonstruct_alias_3 alias ;
   struct __anonstruct_anchor_4 anchor ;
   struct __anonstruct_tag_5 tag ;
   struct __anonstruct_scalar_6 scalar ;
   struct __anonstruct_version_directive_7 version_directive ;
   struct __anonstruct_tag_directive_8 tag_directive ;
};
struct yaml_token_s {
   yaml_token_type_t type ;
   union __anonunion_data_1 data ;
   yaml_mark_t start_mark ;
   yaml_mark_t end_mark ;
};
typedef struct yaml_token_s yaml_token_t;
enum yaml_event_type_e {
    YAML_NO_EVENT = 0,
    YAML_STREAM_START_EVENT = 1,
    YAML_STREAM_END_EVENT = 2,
    YAML_DOCUMENT_START_EVENT = 3,
    YAML_DOCUMENT_END_EVENT = 4,
    YAML_ALIAS_EVENT = 5,
    YAML_SCALAR_EVENT = 6,
    YAML_SEQUENCE_START_EVENT = 7,
    YAML_SEQUENCE_END_EVENT = 8,
    YAML_MAPPING_START_EVENT = 9,
    YAML_MAPPING_END_EVENT = 10
};
typedef enum yaml_event_type_e yaml_event_type_t;
struct __anonstruct_stream_start_10 {
   yaml_encoding_t encoding ;
};
struct __anonstruct_tag_directives_12 {
   yaml_tag_directive_t *start ;
   yaml_tag_directive_t *end ;
};
struct __anonstruct_document_start_11 {
   yaml_version_directive_t *version_directive ;
   struct __anonstruct_tag_directives_12 tag_directives ;
   int implicit ;
};
struct __anonstruct_document_end_13 {
   int implicit ;
};
struct __anonstruct_alias_14 {
   yaml_char_t *anchor ;
};
struct __anonstruct_scalar_15 {
   yaml_char_t *anchor ;
   yaml_char_t *tag ;
   yaml_char_t *value ;
   size_t length ;
   int plain_implicit ;
   int quoted_implicit ;
   yaml_scalar_style_t style ;
};
struct __anonstruct_sequence_start_16 {
   yaml_char_t *anchor ;
   yaml_char_t *tag ;
   int implicit ;
   yaml_sequence_style_t style ;
};
struct __anonstruct_mapping_start_17 {
   yaml_char_t *anchor ;
   yaml_char_t *tag ;
   int implicit ;
   yaml_mapping_style_t style ;
};
union __anonunion_data_9 {
   struct __anonstruct_stream_start_10 stream_start ;
   struct __anonstruct_document_start_11 document_start ;
   struct __anonstruct_document_end_13 document_end ;
   struct __anonstruct_alias_14 alias ;
   struct __anonstruct_scalar_15 scalar ;
   struct __anonstruct_sequence_start_16 sequence_start ;
   struct __anonstruct_mapping_start_17 mapping_start ;
};
struct yaml_event_s {
   yaml_event_type_t type ;
   union __anonunion_data_9 data ;
   yaml_mark_t start_mark ;
   yaml_mark_t end_mark ;
};
typedef struct yaml_event_s yaml_event_t;
enum yaml_node_type_e {
    YAML_NO_NODE = 0,
    YAML_SCALAR_NODE = 1,
    YAML_SEQUENCE_NODE = 2,
    YAML_MAPPING_NODE = 3
};
typedef enum yaml_node_type_e yaml_node_type_t;
struct yaml_node_s;
typedef struct yaml_node_s yaml_node_t;
typedef int yaml_node_item_t;
struct yaml_node_pair_s {
   int key ;
   int value ;
};
typedef struct yaml_node_pair_s yaml_node_pair_t;
struct __anonstruct_scalar_19 {
   yaml_char_t *value ;
   size_t length ;
   yaml_scalar_style_t style ;
};
struct __anonstruct_items_21 {
   yaml_node_item_t *start ;
   yaml_node_item_t *end ;
   yaml_node_item_t *top ;
};
struct __anonstruct_sequence_20 {
   struct __anonstruct_items_21 items ;
   yaml_sequence_style_t style ;
};
struct __anonstruct_pairs_23 {
   yaml_node_pair_t *start ;
   yaml_node_pair_t *end ;
   yaml_node_pair_t *top ;
};
struct __anonstruct_mapping_22 {
   struct __anonstruct_pairs_23 pairs ;
   yaml_mapping_style_t style ;
};
union __anonunion_data_18 {
   struct __anonstruct_scalar_19 scalar ;
   struct __anonstruct_sequence_20 sequence ;
   struct __anonstruct_mapping_22 mapping ;
};
struct yaml_node_s {
   yaml_node_type_t type ;
   yaml_char_t *tag ;
   union __anonunion_data_18 data ;
   yaml_mark_t start_mark ;
   yaml_mark_t end_mark ;
};
struct __anonstruct_nodes_24 {
   yaml_node_t *start ;
   yaml_node_t *end ;
   yaml_node_t *top ;
};
struct __anonstruct_tag_directives_25 {
   yaml_tag_directive_t *start ;
   yaml_tag_directive_t *end ;
};
struct yaml_document_s {
   struct __anonstruct_nodes_24 nodes ;
   yaml_version_directive_t *version_directive ;
   struct __anonstruct_tag_directives_25 tag_directives ;
   int start_implicit ;
   int end_implicit ;
   yaml_mark_t start_mark ;
   yaml_mark_t end_mark ;
};
typedef struct yaml_document_s yaml_document_t;
typedef int yaml_read_handler_t(void *data, unsigned char *buffer,
                                size_t size, size_t *size_read);
struct yaml_simple_key_s {
   int possible ;
   int required ;
   size_t token_number ;
   yaml_mark_t mark ;
};
typedef struct yaml_simple_key_s yaml_simple_key_t;
enum yaml_parser_state_e {
    YAML_PARSE_STREAM_START_STATE = 0,
    YAML_PARSE_IMPLICIT_DOCUMENT_START_STATE = 1,
    YAML_PARSE_DOCUMENT_START_STATE = 2,
    YAML_PARSE_DOCUMENT_CONTENT_STATE = 3,
    YAML_PARSE_DOCUMENT_END_STATE = 4,
    YAML_PARSE_BLOCK_NODE_STATE = 5,
    YAML_PARSE_BLOCK_NODE_OR_INDENTLESS_SEQUENCE_STATE = 6,
    YAML_PARSE_FLOW_NODE_STATE = 7,
    YAML_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE = 8,
    YAML_PARSE_BLOCK_SEQUENCE_ENTRY_STATE = 9,
    YAML_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE = 10,
    YAML_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE = 11,
    YAML_PARSE_BLOCK_MAPPING_KEY_STATE = 12,
    YAML_PARSE_BLOCK_MAPPING_VALUE_STATE = 13,
    YAML_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE = 14,
    YAML_PARSE_FLOW_SEQUENCE_ENTRY_STATE = 15,
    YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE = 16,
    YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE = 17,
    YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE = 18,
    YAML_PARSE_FLOW_MAPPING_FIRST_KEY_STATE = 19,
    YAML_PARSE_FLOW_MAPPING_KEY_STATE = 20,
    YAML_PARSE_FLOW_MAPPING_VALUE_STATE = 21,
    YAML_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE = 22,
    YAML_PARSE_END_STATE = 23
};
typedef enum yaml_parser_state_e yaml_parser_state_t;
struct yaml_alias_data_s {
   yaml_char_t *anchor ;
   int index ;
   yaml_mark_t mark ;
};
typedef struct yaml_alias_data_s yaml_alias_data_t;
struct __anonstruct_string_27 {
   unsigned char const *start ;
   unsigned char const *end ;
   unsigned char const *current ;
};
union __anonunion_input_26 {
   struct __anonstruct_string_27 string ;
   FILE *file ;
};
struct __anonstruct_buffer_28 {
   yaml_char_t *start ;
   yaml_char_t *end ;
   yaml_char_t *pointer ;
   yaml_char_t *last ;
};
struct __anonstruct_raw_buffer_29 {
   unsigned char *start ;
   unsigned char *end ;
   unsigned char *pointer ;
   unsigned char *last ;
};
struct __anonstruct_tokens_30 {
   yaml_token_t *start ;
   yaml_token_t *end ;
   yaml_token_t *head ;
   yaml_token_t *tail ;
};
struct __anonstruct_indents_31 {
   int *start ;
   int *end ;
   int *top ;
};
struct __anonstruct_simple_keys_32 {
   yaml_simple_key_t *start ;
   yaml_simple_key_t *end ;
   yaml_simple_key_t *top ;
};
struct __anonstruct_states_33 {
   yaml_parser_state_t *start ;
   yaml_parser_state_t *end ;
   yaml_parser_state_t *top ;
};
struct __anonstruct_marks_34 {
   yaml_mark_t *start ;
   yaml_mark_t *end ;
   yaml_mark_t *top ;
};
struct __anonstruct_tag_directives_35 {
   yaml_tag_directive_t *start ;
   yaml_tag_directive_t *end ;
   yaml_tag_directive_t *top ;
};
struct __anonstruct_aliases_36 {
   yaml_alias_data_t *start ;
   yaml_alias_data_t *end ;
   yaml_alias_data_t *top ;
};
struct yaml_parser_s {
   yaml_error_type_t error ;
   char const *problem ;
   size_t problem_offset ;
   int problem_value ;
   yaml_mark_t problem_mark ;
   char const *context ;
   yaml_mark_t context_mark ;
   yaml_read_handler_t *read_handler ;
   void *read_handler_data ;
   union __anonunion_input_26 input ;
   int eof ;
   struct __anonstruct_buffer_28 buffer ;
   size_t unread ;
   struct __anonstruct_raw_buffer_29 raw_buffer ;
   yaml_encoding_t encoding ;
   size_t offset ;
   yaml_mark_t mark ;
   int stream_start_produced ;
   int stream_end_produced ;
   int flow_level ;
   struct __anonstruct_tokens_30 tokens ;
   size_t tokens_parsed ;
   int token_available ;
   struct __anonstruct_indents_31 indents ;
   int indent ;
   int simple_key_allowed ;
   struct __anonstruct_simple_keys_32 simple_keys ;
   struct __anonstruct_states_33 states ;
   yaml_parser_state_t state ;
   struct __anonstruct_marks_34 marks ;
   struct __anonstruct_tag_directives_35 tag_directives ;
   struct __anonstruct_aliases_36 aliases ;
   yaml_document_t *document ;
};
typedef struct yaml_parser_s yaml_parser_t;
typedef int yaml_write_handler_t(void *data, unsigned char *buffer,
                                 size_t size);
enum yaml_emitter_state_e {
    YAML_EMIT_STREAM_START_STATE = 0,
    YAML_EMIT_FIRST_DOCUMENT_START_STATE = 1,
    YAML_EMIT_DOCUMENT_START_STATE = 2,
    YAML_EMIT_DOCUMENT_CONTENT_STATE = 3,
    YAML_EMIT_DOCUMENT_END_STATE = 4,
    YAML_EMIT_FLOW_SEQUENCE_FIRST_ITEM_STATE = 5,
    YAML_EMIT_FLOW_SEQUENCE_ITEM_STATE = 6,
    YAML_EMIT_FLOW_MAPPING_FIRST_KEY_STATE = 7,
    YAML_EMIT_FLOW_MAPPING_KEY_STATE = 8,
    YAML_EMIT_FLOW_MAPPING_SIMPLE_VALUE_STATE = 9,
    YAML_EMIT_FLOW_MAPPING_VALUE_STATE = 10,
    YAML_EMIT_BLOCK_SEQUENCE_FIRST_ITEM_STATE = 11,
    YAML_EMIT_BLOCK_SEQUENCE_ITEM_STATE = 12,
    YAML_EMIT_BLOCK_MAPPING_FIRST_KEY_STATE = 13,
    YAML_EMIT_BLOCK_MAPPING_KEY_STATE = 14,
    YAML_EMIT_BLOCK_MAPPING_SIMPLE_VALUE_STATE = 15,
    YAML_EMIT_BLOCK_MAPPING_VALUE_STATE = 16,
    YAML_EMIT_END_STATE = 17
};
typedef enum yaml_emitter_state_e yaml_emitter_state_t;
struct yaml_anchors_s {
   int references ;
   int anchor ;
   int serialized ;
};
typedef struct yaml_anchors_s yaml_anchors_t;
struct __anonstruct_string_38 {
   unsigned char *buffer ;
   size_t size ;
   size_t *size_written ;
};
union __anonunion_output_37 {
   struct __anonstruct_string_38 string ;
   FILE *file ;
};
struct __anonstruct_buffer_39 {
   yaml_char_t *start ;
   yaml_char_t *end ;
   yaml_char_t *pointer ;
   yaml_char_t *last ;
};
struct __anonstruct_raw_buffer_40 {
   unsigned char *start ;
   unsigned char *end ;
   unsigned char *pointer ;
   unsigned char *last ;
};
struct __anonstruct_states_41 {
   yaml_emitter_state_t *start ;
   yaml_emitter_state_t *end ;
   yaml_emitter_state_t *top ;
};
struct __anonstruct_events_42 {
   yaml_event_t *start ;
   yaml_event_t *end ;
   yaml_event_t *head ;
   yaml_event_t *tail ;
};
struct __anonstruct_indents_43 {
   int *start ;
   int *end ;
   int *top ;
};
struct __anonstruct_tag_directives_44 {
   yaml_tag_directive_t *start ;
   yaml_tag_directive_t *end ;
   yaml_tag_directive_t *top ;
};
struct __anonstruct_anchor_data_45 {
   yaml_char_t *anchor ;
   size_t anchor_length ;
   int alias ;
};
struct __anonstruct_tag_data_46 {
   yaml_char_t *handle ;
   size_t handle_length ;
   yaml_char_t *suffix ;
   size_t suffix_length ;
};
struct __anonstruct_scalar_data_47 {
   yaml_char_t *value ;
   size_t length ;
   int multiline ;
   int flow_plain_allowed ;
   int block_plain_allowed ;
   int single_quoted_allowed ;
   int block_allowed ;
   yaml_scalar_style_t style ;
};
struct yaml_emitter_s {
   yaml_error_type_t error ;
   char const *problem ;
   yaml_write_handler_t *write_handler ;
   void *write_handler_data ;
   union __anonunion_output_37 output ;
   struct __anonstruct_buffer_39 buffer ;
   struct __anonstruct_raw_buffer_40 raw_buffer ;
   yaml_encoding_t encoding ;
   int canonical ;
   int best_indent ;
   int best_width ;
   int unicode ;
   yaml_break_t line_break ;
   struct __anonstruct_states_41 states ;
   yaml_emitter_state_t state ;
   struct __anonstruct_events_42 events ;
   struct __anonstruct_indents_43 indents ;
   struct __anonstruct_tag_directives_44 tag_directives ;
   int indent ;
   int flow_level ;
   int root_context ;
   int sequence_context ;
   int mapping_context ;
   int simple_key_context ;
   int line ;
   int column ;
   int whitespace ;
   int indention ;
   int open_ended ;
   struct __anonstruct_anchor_data_45 anchor_data ;
   struct __anonstruct_tag_data_46 tag_data ;
   struct __anonstruct_scalar_data_47 scalar_data ;
   int opened ;
   int closed ;
   yaml_anchors_t *anchors ;
   int last_anchor_id ;
   yaml_document_t *document ;
};
typedef struct yaml_emitter_s yaml_emitter_t;
struct __anonstruct_yaml_string_t_48 {
   yaml_char_t *start ;
   yaml_char_t *end ;
   yaml_char_t *pointer ;
};
typedef struct __anonstruct_yaml_string_t_48 yaml_string_t;
struct __anonstruct_context_49 {
   yaml_error_type_t error ;
};
struct __anonstruct_tag_directives_copy_50 {
   yaml_tag_directive_t *start ;
   yaml_tag_directive_t *end ;
   yaml_tag_directive_t *top ;
};
struct __anonstruct_context_51 {
   yaml_error_type_t error ;
};
struct __anonstruct_nodes_52 {
   yaml_node_t *start ;
   yaml_node_t *end ;
   yaml_node_t *top ;
};
struct __anonstruct_tag_directives_copy_53 {
   yaml_tag_directive_t *start ;
   yaml_tag_directive_t *end ;
   yaml_tag_directive_t *top ;
};
struct __anonstruct_context_54 {
   yaml_error_type_t error ;
};
struct __anonstruct_context_55 {
   yaml_error_type_t error ;
};
struct __anonstruct_items_56 {
   yaml_node_item_t *start ;
   yaml_node_item_t *end ;
   yaml_node_item_t *top ;
};
struct __anonstruct_context_57 {
   yaml_error_type_t error ;
};
struct __anonstruct_pairs_58 {
   yaml_node_pair_t *start ;
   yaml_node_pair_t *end ;
   yaml_node_pair_t *top ;
};
struct __anonstruct_context_59 {
   yaml_error_type_t error ;
};
struct __anonstruct_context_60 {
   yaml_error_type_t error ;
};
struct loader_ctx {
   int *start ;
   int *end ;
   int *top ;
};
struct __anonstruct_items_49 {
   yaml_node_item_t *start ;
   yaml_node_item_t *end ;
   yaml_node_item_t *top ;
};
struct __anonstruct_pairs_50 {
   yaml_node_pair_t *start ;
   yaml_node_pair_t *end ;
   yaml_node_pair_t *top ;
};
struct __anonstruct_tag_directives_49 {
   yaml_tag_directive_t *start ;
   yaml_tag_directive_t *end ;
};
struct __anonstruct_tag_directives_50 {
   yaml_tag_directive_t *start ;
   yaml_tag_directive_t *end ;
   yaml_tag_directive_t *top ;
};
struct __anonstruct_test_case_48 {
   char *title ;
   char *test ;
   int result ;
};
typedef struct __anonstruct_test_case_48 test_case;
char const *yaml_get_version_string(void);

void yaml_get_version(int *major, int *minor, int *patch);

void yaml_token_delete(yaml_token_t *token);

int yaml_stream_start_event_initialize(yaml_event_t *event,
                                       yaml_encoding_t encoding);

int yaml_stream_end_event_initialize(yaml_event_t *event);

int yaml_document_start_event_initialize(yaml_event_t *event,
                                         yaml_version_directive_t *version_directive,
                                         yaml_tag_directive_t *tag_directives_start,
                                         yaml_tag_directive_t *tag_directives_end,
                                         int implicit);

int yaml_document_end_event_initialize(yaml_event_t *event, int implicit);

int yaml_alias_event_initialize(yaml_event_t *event,
                                yaml_char_t const *anchor);

int yaml_scalar_event_initialize(yaml_event_t *event,
                                 yaml_char_t const *anchor,
                                 yaml_char_t const *tag,
                                 yaml_char_t const *value, int length,
                                 int plain_implicit, int quoted_implicit,
                                 yaml_scalar_style_t style);

int yaml_sequence_start_event_initialize(yaml_event_t *event,
                                         yaml_char_t const *anchor,
                                         yaml_char_t const *tag,
                                         int implicit,
                                         yaml_sequence_style_t style);

int yaml_sequence_end_event_initialize(yaml_event_t *event);

int yaml_mapping_start_event_initialize(yaml_event_t *event,
                                        yaml_char_t const *anchor,
                                        yaml_char_t const *tag, int implicit,
                                        yaml_mapping_style_t style);

int yaml_mapping_end_event_initialize(yaml_event_t *event);

void yaml_event_delete(yaml_event_t *event);

int yaml_document_initialize(yaml_document_t *document,
                             yaml_version_directive_t *version_directive,
                             yaml_tag_directive_t *tag_directives_start,
                             yaml_tag_directive_t *tag_directives_end,
                             int start_implicit, int end_implicit);

void yaml_document_delete(yaml_document_t *document);

yaml_node_t *yaml_document_get_node(yaml_document_t *document, int index_0);

yaml_node_t *yaml_document_get_root_node(yaml_document_t *document);

int yaml_document_add_scalar(yaml_document_t *document,
                             yaml_char_t const *tag,
                             yaml_char_t const *value, int length,
                             yaml_scalar_style_t style);

int yaml_document_add_sequence(yaml_document_t *document,
                               yaml_char_t const *tag,
                               yaml_sequence_style_t style);

int yaml_document_add_mapping(yaml_document_t *document,
                              yaml_char_t const *tag,
                              yaml_mapping_style_t style);

int yaml_document_append_sequence_item(yaml_document_t *document,
                                       int sequence, int item);

int yaml_document_append_mapping_pair(yaml_document_t *document, int mapping,
                                      int key, int value);

int yaml_parser_initialize(yaml_parser_t *parser);

void yaml_parser_delete(yaml_parser_t *parser);

void yaml_parser_set_input_string(yaml_parser_t *parser,
                                  unsigned char const *input, size_t size);

void yaml_parser_set_input_file(yaml_parser_t *parser, FILE *file);

void yaml_parser_set_input(yaml_parser_t *parser,
                           yaml_read_handler_t *handler, void *data);

void yaml_parser_set_encoding(yaml_parser_t *parser, yaml_encoding_t encoding);

int yaml_parser_scan(yaml_parser_t *parser, yaml_token_t *token);

int yaml_parser_parse(yaml_parser_t *parser, yaml_event_t *event);

int yaml_parser_load(yaml_parser_t *parser, yaml_document_t *document);

int yaml_emitter_initialize(yaml_emitter_t *emitter);

void yaml_emitter_delete(yaml_emitter_t *emitter);

void yaml_emitter_set_output_string(yaml_emitter_t *emitter,
                                    unsigned char *output, size_t size,
                                    size_t *size_written);

void yaml_emitter_set_output_file(yaml_emitter_t *emitter, FILE *file);

void yaml_emitter_set_output(yaml_emitter_t *emitter,
                             yaml_write_handler_t *handler, void *data);

void yaml_emitter_set_encoding(yaml_emitter_t *emitter,
                               yaml_encoding_t encoding);

void yaml_emitter_set_canonical(yaml_emitter_t *emitter, int canonical);

void yaml_emitter_set_indent(yaml_emitter_t *emitter, int indent);

void yaml_emitter_set_width(yaml_emitter_t *emitter, int width);

void yaml_emitter_set_unicode(yaml_emitter_t *emitter, int unicode);

void yaml_emitter_set_break(yaml_emitter_t *emitter, yaml_break_t line_break);

int yaml_emitter_emit(yaml_emitter_t *emitter, yaml_event_t *event);

int yaml_emitter_open(yaml_emitter_t *emitter);

int yaml_emitter_close(yaml_emitter_t *emitter);

int yaml_emitter_dump(yaml_emitter_t *emitter, yaml_document_t *document);

int yaml_emitter_flush(yaml_emitter_t *emitter);

void *yaml_malloc(size_t size);

void *yaml_realloc(void *ptr, size_t size);

void yaml_free(void *ptr);

yaml_char_t *yaml_strdup(yaml_char_t const *str);

int yaml_parser_update_buffer(yaml_parser_t *parser, size_t length);

int yaml_parser_fetch_more_tokens(yaml_parser_t *parser);

int yaml_string_extend(yaml_char_t **start, yaml_char_t **pointer,
                       yaml_char_t **end);

int yaml_string_join(yaml_char_t **a_start, yaml_char_t **a_pointer,
                     yaml_char_t **a_end, yaml_char_t **b_start,
                     yaml_char_t **b_pointer,
                     yaml_char_t **b_end __attribute__((__unused__)));

int yaml_stack_extend(void **start, void **top, void **end);

int yaml_queue_extend(void **start, void **head, void **tail, void **end);

char const *yaml_get_version_string(void)
{
  char const *__retres;
  __retres = "0.2.5";
  return __retres;
}

void yaml_get_version(int *major, int *minor, int *patch)
{
  *major = 0;
  *minor = 2;
  *patch = 5;
  return;
}

void *yaml_malloc(size_t size)
{
  void *tmp_0;
  size_t tmp;
  if (size) tmp = size; else tmp = (size_t)1;
  tmp_0 = malloc(tmp);
  return tmp_0;
}

void *yaml_realloc(void *ptr, size_t size)
{
  void *tmp_3;
  if (ptr) {
    void *tmp_0;
    size_t tmp;
    if (size) tmp = size; else tmp = (size_t)1;
    ;
    tmp_0 = realloc(ptr,tmp);
    tmp_3 = tmp_0;
  }
  else {
    void *tmp_2;
    size_t tmp_1;
    if (size) tmp_1 = size; else tmp_1 = (size_t)1;
    tmp_2 = malloc(tmp_1);
    tmp_3 = tmp_2;
  }
  return tmp_3;
}

void yaml_free(void *ptr)
{
  if (ptr) free(ptr);
  return;
}

yaml_char_t *yaml_strdup(yaml_char_t const *str)
{
  yaml_char_t *__retres;
  yaml_char_t *tmp;
  if (! str) {
    __retres = (yaml_char_t *)0;
    goto return_label;
  }
  tmp = (yaml_char_t *)strdup((char const *)str);
  __retres = tmp;
  return_label: return __retres;
}

int yaml_string_extend(yaml_char_t **start, yaml_char_t **pointer,
                       yaml_char_t **end)
{
  int __retres;
  yaml_char_t *new_start =
    yaml_realloc((void *)*start,(size_t)((*end - *start) * (long)2));
  if (! new_start) {
    __retres = 0;
    goto return_label;
  }
  memset((void *)(new_start + (*end - *start)),0,(size_t)(*end - *start));
  *pointer = new_start + (*pointer - *start);
  *end = new_start + (*end - *start) * (long)2;
  *start = new_start;
  __retres = 1;
  return_label: return __retres;
}

int yaml_string_join(yaml_char_t **a_start, yaml_char_t **a_pointer,
                     yaml_char_t **a_end, yaml_char_t **b_start,
                     yaml_char_t **b_pointer,
                     yaml_char_t **b_end __attribute__((__unused__)))
{
  int __retres;
  if (*b_start == *b_pointer) {
    __retres = 1;
    goto return_label;
  }
  while (*a_end - *a_pointer <= *b_pointer - *b_start) {
    int tmp;
    tmp = yaml_string_extend(a_start,a_pointer,a_end);
    if (! tmp) {
      __retres = 0;
      goto return_label;
    }
  }
  memcpy((void *)*a_pointer,(void const *)*b_start,
         (size_t)(*b_pointer - *b_start));
  *a_pointer += *b_pointer - *b_start;
  __retres = 1;
  return_label: return __retres;
}

int yaml_stack_extend(void **start, void **top, void **end)
{
  int __retres;
  void *new_start;
  if ((char *)*end - (char *)*start >= (long)(2147483647 / 2)) {
    __retres = 0;
    goto return_label;
  }
  new_start = yaml_realloc(*start,
                           (size_t)(((char *)*end - (char *)*start) * (long)2));
  if (! new_start) {
    __retres = 0;
    goto return_label;
  }
  *top = (void *)((char *)new_start + ((char *)*top - (char *)*start));
  *end = (void *)((char *)new_start + ((char *)*end - (char *)*start) * (long)2);
  *start = new_start;
  __retres = 1;
  return_label: return __retres;
}

int yaml_queue_extend(void **start, void **head, void **tail, void **end)
{
  int __retres;
  if (*start == *head) 
    if (*tail == *end) {
      void *new_start =
        yaml_realloc(*start,
                     (size_t)(((char *)*end - (char *)*start) * (long)2));
      if (! new_start) {
        __retres = 0;
        goto return_label;
      }
      *head = (void *)((char *)new_start + ((char *)*head - (char *)*start));
      *tail = (void *)((char *)new_start + ((char *)*tail - (char *)*start));
      *end = (void *)((char *)new_start + ((char *)*end - (char *)*start) * (long)2);
      *start = new_start;
    }
  if (*tail == *end) {
    if (*head != *tail) memmove(*start,(void const *)*head,
                                (size_t)((char *)*tail - (char *)*head));
    *tail = (void *)((char *)*start + ((char *)*tail - (char *)*head));
    *head = *start;
  }
  __retres = 1;
  return_label: return __retres;
}

int yaml_parser_initialize(yaml_parser_t *parser)
{
  int __retres;
  int tmp_2;
  unsigned char *tmp;
  int tmp_6;
  yaml_char_t *tmp_3;
  int tmp_10;
  yaml_token_t *tmp_7;
  int tmp_13;
  int *tmp_11;
  int tmp_16;
  yaml_simple_key_t *tmp_14;
  int tmp_19;
  yaml_parser_state_t *tmp_17;
  int tmp_22;
  yaml_mark_t *tmp_20;
  int tmp_25;
  yaml_tag_directive_t *tmp_23;
  unsigned char *tmp_27;
  unsigned char *tmp_26;
  yaml_char_t *tmp_29;
  yaml_char_t *tmp_28;
  yaml_token_t *tmp_32;
  yaml_token_t *tmp_31;
  yaml_token_t *tmp_30;
  int *tmp_34;
  int *tmp_33;
  yaml_simple_key_t *tmp_36;
  yaml_simple_key_t *tmp_35;
  yaml_parser_state_t *tmp_38;
  yaml_parser_state_t *tmp_37;
  yaml_mark_t *tmp_40;
  yaml_mark_t *tmp_39;
  yaml_tag_directive_t *tmp_42;
  yaml_tag_directive_t *tmp_41;
  __FC_assert(parser != (yaml_parser_t *)0,"src/api.c",179,"parser");
  memset((void *)parser,0,sizeof(yaml_parser_t));
  tmp = (unsigned char *)yaml_malloc((size_t)16384);
  parser->raw_buffer.start = tmp;
  if (tmp) {
    unsigned char *tmp_1;
    tmp_1 = parser->raw_buffer.start;
    parser->raw_buffer.pointer = tmp_1;
    parser->raw_buffer.last = tmp_1;
    parser->raw_buffer.end = parser->raw_buffer.start + 16384;
    tmp_2 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_2 = 0;
  }
  if (! tmp_2) goto error;
  tmp_3 = (yaml_char_t *)yaml_malloc((size_t)(16384 * 3));
  parser->buffer.start = tmp_3;
  if (tmp_3) {
    yaml_char_t *tmp_5;
    tmp_5 = parser->buffer.start;
    parser->buffer.pointer = tmp_5;
    parser->buffer.last = tmp_5;
    parser->buffer.end = parser->buffer.start + 16384 * 3;
    tmp_6 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_6 = 0;
  }
  if (! tmp_6) goto error;
  tmp_7 = (yaml_token_t *)yaml_malloc((unsigned long)16 * sizeof(*(parser->tokens.start)));
  parser->tokens.start = tmp_7;
  if (tmp_7) {
    yaml_token_t *tmp_9;
    tmp_9 = parser->tokens.start;
    parser->tokens.tail = tmp_9;
    parser->tokens.head = tmp_9;
    parser->tokens.end = parser->tokens.start + 16;
    tmp_10 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_10 = 0;
  }
  if (! tmp_10) goto error;
  tmp_11 = (int *)yaml_malloc((unsigned long)16 * sizeof(*(parser->indents.start)));
  parser->indents.start = tmp_11;
  if (tmp_11) {
    parser->indents.top = parser->indents.start;
    parser->indents.end = parser->indents.start + 16;
    tmp_13 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_13 = 0;
  }
  if (! tmp_13) goto error;
  tmp_14 = (yaml_simple_key_t *)yaml_malloc((unsigned long)16 * sizeof(*(parser->simple_keys.start)));
  parser->simple_keys.start = tmp_14;
  if (tmp_14) {
    parser->simple_keys.top = parser->simple_keys.start;
    parser->simple_keys.end = parser->simple_keys.start + 16;
    tmp_16 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_16 = 0;
  }
  if (! tmp_16) goto error;
  tmp_17 = (yaml_parser_state_t *)yaml_malloc((unsigned long)16 * sizeof(*(parser->states.start)));
  parser->states.start = tmp_17;
  if (tmp_17) {
    parser->states.top = parser->states.start;
    parser->states.end = parser->states.start + 16;
    tmp_19 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_19 = 0;
  }
  if (! tmp_19) goto error;
  tmp_20 = (yaml_mark_t *)yaml_malloc((unsigned long)16 * sizeof(*(parser->marks.start)));
  parser->marks.start = tmp_20;
  if (tmp_20) {
    parser->marks.top = parser->marks.start;
    parser->marks.end = parser->marks.start + 16;
    tmp_22 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_22 = 0;
  }
  if (! tmp_22) goto error;
  tmp_23 = (yaml_tag_directive_t *)yaml_malloc((unsigned long)16 * sizeof(*(parser->tag_directives.start)));
  parser->tag_directives.start = tmp_23;
  if (tmp_23) {
    parser->tag_directives.top = parser->tag_directives.start;
    parser->tag_directives.end = parser->tag_directives.start + 16;
    tmp_25 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_25 = 0;
  }
  if (! tmp_25) goto error;
  __retres = 1;
  goto return_label;
  error: yaml_free((void *)parser->raw_buffer.start);
  tmp_27 = (unsigned char *)0;
  parser->raw_buffer.end = tmp_27;
  tmp_26 = tmp_27;
  parser->raw_buffer.pointer = tmp_26;
  parser->raw_buffer.start = tmp_26;
  yaml_free((void *)parser->buffer.start);
  tmp_29 = (yaml_char_t *)0;
  parser->buffer.end = tmp_29;
  tmp_28 = tmp_29;
  parser->buffer.pointer = tmp_28;
  parser->buffer.start = tmp_28;
  yaml_free((void *)parser->tokens.start);
  tmp_32 = (yaml_token_t *)0;
  parser->tokens.end = tmp_32;
  tmp_31 = tmp_32;
  parser->tokens.tail = tmp_31;
  tmp_30 = tmp_31;
  parser->tokens.head = tmp_30;
  parser->tokens.start = tmp_30;
  yaml_free((void *)parser->indents.start);
  tmp_34 = (int *)0;
  parser->indents.end = tmp_34;
  tmp_33 = tmp_34;
  parser->indents.top = tmp_33;
  parser->indents.start = tmp_33;
  yaml_free((void *)parser->simple_keys.start);
  tmp_36 = (yaml_simple_key_t *)0;
  parser->simple_keys.end = tmp_36;
  tmp_35 = tmp_36;
  parser->simple_keys.top = tmp_35;
  parser->simple_keys.start = tmp_35;
  yaml_free((void *)parser->states.start);
  tmp_38 = (yaml_parser_state_t *)0;
  parser->states.end = tmp_38;
  tmp_37 = tmp_38;
  parser->states.top = tmp_37;
  parser->states.start = tmp_37;
  yaml_free((void *)parser->marks.start);
  tmp_40 = (yaml_mark_t *)0;
  parser->marks.end = tmp_40;
  tmp_39 = tmp_40;
  parser->marks.top = tmp_39;
  parser->marks.start = tmp_39;
  yaml_free((void *)parser->tag_directives.start);
  tmp_42 = (yaml_tag_directive_t *)0;
  parser->tag_directives.end = tmp_42;
  tmp_41 = tmp_42;
  parser->tag_directives.top = tmp_41;
  parser->tag_directives.start = tmp_41;
  __retres = 0;
  return_label: return __retres;
}

void yaml_parser_delete(yaml_parser_t *parser)
{
  unsigned char *tmp_0;
  unsigned char *tmp;
  yaml_char_t *tmp_2;
  yaml_char_t *tmp_1;
  yaml_token_t *tmp_6;
  yaml_token_t *tmp_5;
  yaml_token_t *tmp_4;
  int *tmp_8;
  int *tmp_7;
  yaml_simple_key_t *tmp_10;
  yaml_simple_key_t *tmp_9;
  yaml_parser_state_t *tmp_12;
  yaml_parser_state_t *tmp_11;
  yaml_mark_t *tmp_14;
  yaml_mark_t *tmp_13;
  yaml_tag_directive_t *tmp_16;
  yaml_tag_directive_t *tmp_15;
  __FC_assert(parser != (yaml_parser_t *)0,"src/api.c",222,"parser");
  yaml_free((void *)parser->raw_buffer.start);
  tmp_0 = (unsigned char *)0;
  parser->raw_buffer.end = tmp_0;
  tmp = tmp_0;
  parser->raw_buffer.pointer = tmp;
  parser->raw_buffer.start = tmp;
  yaml_free((void *)parser->buffer.start);
  tmp_2 = (yaml_char_t *)0;
  parser->buffer.end = tmp_2;
  tmp_1 = tmp_2;
  parser->buffer.pointer = tmp_1;
  parser->buffer.start = tmp_1;
  while (! (parser->tokens.head == parser->tokens.tail)) {
    yaml_token_t *tmp_3;
    tmp_3 = parser->tokens.head;
    (parser->tokens.head) ++;
    ;
    yaml_token_delete(tmp_3);
  }
  yaml_free((void *)parser->tokens.start);
  tmp_6 = (yaml_token_t *)0;
  parser->tokens.end = tmp_6;
  tmp_5 = tmp_6;
  parser->tokens.tail = tmp_5;
  tmp_4 = tmp_5;
  parser->tokens.head = tmp_4;
  parser->tokens.start = tmp_4;
  yaml_free((void *)parser->indents.start);
  tmp_8 = (int *)0;
  parser->indents.end = tmp_8;
  tmp_7 = tmp_8;
  parser->indents.top = tmp_7;
  parser->indents.start = tmp_7;
  yaml_free((void *)parser->simple_keys.start);
  tmp_10 = (yaml_simple_key_t *)0;
  parser->simple_keys.end = tmp_10;
  tmp_9 = tmp_10;
  parser->simple_keys.top = tmp_9;
  parser->simple_keys.start = tmp_9;
  yaml_free((void *)parser->states.start);
  tmp_12 = (yaml_parser_state_t *)0;
  parser->states.end = tmp_12;
  tmp_11 = tmp_12;
  parser->states.top = tmp_11;
  parser->states.start = tmp_11;
  yaml_free((void *)parser->marks.start);
  tmp_14 = (yaml_mark_t *)0;
  parser->marks.end = tmp_14;
  tmp_13 = tmp_14;
  parser->marks.top = tmp_13;
  parser->marks.start = tmp_13;
  while (! (parser->tag_directives.start == parser->tag_directives.top)) {
    (parser->tag_directives.top) --;
    yaml_tag_directive_t tag_directive = *(parser->tag_directives.top);
    yaml_free((void *)tag_directive.handle);
    yaml_free((void *)tag_directive.prefix);
  }
  yaml_free((void *)parser->tag_directives.start);
  tmp_16 = (yaml_tag_directive_t *)0;
  parser->tag_directives.end = tmp_16;
  tmp_15 = tmp_16;
  parser->tag_directives.top = tmp_15;
  parser->tag_directives.start = tmp_15;
  memset((void *)parser,0,sizeof(yaml_parser_t));
  return;
}

static int yaml_string_read_handler(void *data, unsigned char *buffer,
                                    size_t size, size_t *size_read)
{
  int __retres;
  yaml_parser_t *parser = (yaml_parser_t *)data;
  if (parser->input.string.current == parser->input.string.end) {
    *size_read = (size_t)0;
    __retres = 1;
    goto return_label;
  }
  if (size > (size_t)(parser->input.string.end - parser->input.string.current)) 
    size = (size_t)(parser->input.string.end - parser->input.string.current);
  memcpy((void *)buffer,(void const *)parser->input.string.current,size);
  parser->input.string.current += size;
  *size_read = size;
  __retres = 1;
  return_label: return __retres;
}

static int yaml_file_read_handler(void *data, unsigned char *buffer,
                                  size_t size, size_t *size_read)
{
  int tmp_0;
  int tmp;
  yaml_parser_t *parser = (yaml_parser_t *)data;
  *size_read = fread((void *)buffer,(size_t)1,size,parser->input.file);
  tmp = ferror(parser->input.file);
  if (tmp) tmp_0 = 0; else tmp_0 = 1;
  return tmp_0;
}

void yaml_parser_set_input_string(yaml_parser_t *parser,
                                  unsigned char const *input, size_t size)
{
  __FC_assert(parser != (yaml_parser_t *)0,"src/api.c",292,"parser");
  __FC_assert(! parser->read_handler != 0,"src/api.c",293,
              "!parser->read_handler");
  __FC_assert(input != (unsigned char const *)0,"src/api.c",294,"input");
  parser->read_handler = & yaml_string_read_handler;
  parser->read_handler_data = (void *)parser;
  parser->input.string.start = input;
  parser->input.string.current = input;
  parser->input.string.end = input + size;
  return;
}

void yaml_parser_set_input_file(yaml_parser_t *parser, FILE *file)
{
  __FC_assert(parser != (yaml_parser_t *)0,"src/api.c",311,"parser");
  __FC_assert(! parser->read_handler != 0,"src/api.c",312,
              "!parser->read_handler");
  __FC_assert(file != (FILE *)0,"src/api.c",313,"file");
  parser->read_handler = & yaml_file_read_handler;
  parser->read_handler_data = (void *)parser;
  parser->input.file = file;
  return;
}

void yaml_parser_set_input(yaml_parser_t *parser,
                           yaml_read_handler_t *handler, void *data)
{
  __FC_assert(parser != (yaml_parser_t *)0,"src/api.c",329,"parser");
  __FC_assert(! parser->read_handler != 0,"src/api.c",330,
              "!parser->read_handler");
  __FC_assert(handler != (yaml_read_handler_t *)0,"src/api.c",331,"handler");
  parser->read_handler = handler;
  parser->read_handler_data = data;
  return;
}

void yaml_parser_set_encoding(yaml_parser_t *parser, yaml_encoding_t encoding)
{
  __FC_assert(parser != (yaml_parser_t *)0,"src/api.c",344,"parser");
  __FC_assert(! parser->encoding != 0,"src/api.c",345,"!parser->encoding");
  parser->encoding = encoding;
  return;
}

int yaml_emitter_initialize(yaml_emitter_t *emitter)
{
  int __retres;
  int tmp_2;
  yaml_char_t *tmp;
  int tmp_6;
  unsigned char *tmp_3;
  int tmp_9;
  yaml_emitter_state_t *tmp_7;
  int tmp_13;
  yaml_event_t *tmp_10;
  int tmp_16;
  int *tmp_14;
  int tmp_19;
  yaml_tag_directive_t *tmp_17;
  yaml_char_t *tmp_21;
  yaml_char_t *tmp_20;
  unsigned char *tmp_23;
  unsigned char *tmp_22;
  yaml_emitter_state_t *tmp_25;
  yaml_emitter_state_t *tmp_24;
  yaml_event_t *tmp_28;
  yaml_event_t *tmp_27;
  yaml_event_t *tmp_26;
  int *tmp_30;
  int *tmp_29;
  yaml_tag_directive_t *tmp_32;
  yaml_tag_directive_t *tmp_31;
  __FC_assert(emitter != (yaml_emitter_t *)0,"src/api.c",357,"emitter");
  memset((void *)emitter,0,sizeof(yaml_emitter_t));
  tmp = (yaml_char_t *)yaml_malloc((size_t)16384);
  emitter->buffer.start = tmp;
  if (tmp) {
    yaml_char_t *tmp_1;
    tmp_1 = emitter->buffer.start;
    emitter->buffer.pointer = tmp_1;
    emitter->buffer.last = tmp_1;
    emitter->buffer.end = emitter->buffer.start + 16384;
    tmp_2 = 1;
  }
  else {
    emitter->error = YAML_MEMORY_ERROR;
    tmp_2 = 0;
  }
  if (! tmp_2) goto error;
  tmp_3 = (unsigned char *)yaml_malloc((size_t)(16384 * 2 + 2));
  emitter->raw_buffer.start = tmp_3;
  if (tmp_3) {
    unsigned char *tmp_5;
    tmp_5 = emitter->raw_buffer.start;
    emitter->raw_buffer.pointer = tmp_5;
    emitter->raw_buffer.last = tmp_5;
    emitter->raw_buffer.end = emitter->raw_buffer.start + (16384 * 2 + 2);
    tmp_6 = 1;
  }
  else {
    emitter->error = YAML_MEMORY_ERROR;
    tmp_6 = 0;
  }
  if (! tmp_6) goto error;
  tmp_7 = (yaml_emitter_state_t *)yaml_malloc((unsigned long)16 * sizeof(*(emitter->states.start)));
  emitter->states.start = tmp_7;
  if (tmp_7) {
    emitter->states.top = emitter->states.start;
    emitter->states.end = emitter->states.start + 16;
    tmp_9 = 1;
  }
  else {
    emitter->error = YAML_MEMORY_ERROR;
    tmp_9 = 0;
  }
  if (! tmp_9) goto error;
  tmp_10 = (yaml_event_t *)yaml_malloc((unsigned long)16 * sizeof(*(emitter->events.start)));
  emitter->events.start = tmp_10;
  if (tmp_10) {
    yaml_event_t *tmp_12;
    tmp_12 = emitter->events.start;
    emitter->events.tail = tmp_12;
    emitter->events.head = tmp_12;
    emitter->events.end = emitter->events.start + 16;
    tmp_13 = 1;
  }
  else {
    emitter->error = YAML_MEMORY_ERROR;
    tmp_13 = 0;
  }
  if (! tmp_13) goto error;
  tmp_14 = (int *)yaml_malloc((unsigned long)16 * sizeof(*(emitter->indents.start)));
  emitter->indents.start = tmp_14;
  if (tmp_14) {
    emitter->indents.top = emitter->indents.start;
    emitter->indents.end = emitter->indents.start + 16;
    tmp_16 = 1;
  }
  else {
    emitter->error = YAML_MEMORY_ERROR;
    tmp_16 = 0;
  }
  if (! tmp_16) goto error;
  tmp_17 = (yaml_tag_directive_t *)yaml_malloc((unsigned long)16 * sizeof(*(emitter->tag_directives.start)));
  emitter->tag_directives.start = tmp_17;
  if (tmp_17) {
    emitter->tag_directives.top = emitter->tag_directives.start;
    emitter->tag_directives.end = emitter->tag_directives.start + 16;
    tmp_19 = 1;
  }
  else {
    emitter->error = YAML_MEMORY_ERROR;
    tmp_19 = 0;
  }
  if (! tmp_19) goto error;
  __retres = 1;
  goto return_label;
  error: yaml_free((void *)emitter->buffer.start);
  tmp_21 = (yaml_char_t *)0;
  emitter->buffer.end = tmp_21;
  tmp_20 = tmp_21;
  emitter->buffer.pointer = tmp_20;
  emitter->buffer.start = tmp_20;
  yaml_free((void *)emitter->raw_buffer.start);
  tmp_23 = (unsigned char *)0;
  emitter->raw_buffer.end = tmp_23;
  tmp_22 = tmp_23;
  emitter->raw_buffer.pointer = tmp_22;
  emitter->raw_buffer.start = tmp_22;
  yaml_free((void *)emitter->states.start);
  tmp_25 = (yaml_emitter_state_t *)0;
  emitter->states.end = tmp_25;
  tmp_24 = tmp_25;
  emitter->states.top = tmp_24;
  emitter->states.start = tmp_24;
  yaml_free((void *)emitter->events.start);
  tmp_28 = (yaml_event_t *)0;
  emitter->events.end = tmp_28;
  tmp_27 = tmp_28;
  emitter->events.tail = tmp_27;
  tmp_26 = tmp_27;
  emitter->events.head = tmp_26;
  emitter->events.start = tmp_26;
  yaml_free((void *)emitter->indents.start);
  tmp_30 = (int *)0;
  emitter->indents.end = tmp_30;
  tmp_29 = tmp_30;
  emitter->indents.top = tmp_29;
  emitter->indents.start = tmp_29;
  yaml_free((void *)emitter->tag_directives.start);
  tmp_32 = (yaml_tag_directive_t *)0;
  emitter->tag_directives.end = tmp_32;
  tmp_31 = tmp_32;
  emitter->tag_directives.top = tmp_31;
  emitter->tag_directives.start = tmp_31;
  __retres = 0;
  return_label: return __retres;
}

void yaml_emitter_delete(yaml_emitter_t *emitter)
{
  yaml_char_t *tmp_0;
  yaml_char_t *tmp;
  unsigned char *tmp_2;
  unsigned char *tmp_1;
  yaml_emitter_state_t *tmp_4;
  yaml_emitter_state_t *tmp_3;
  yaml_event_t *tmp_8;
  yaml_event_t *tmp_7;
  yaml_event_t *tmp_6;
  int *tmp_10;
  int *tmp_9;
  yaml_tag_directive_t *tmp_12;
  yaml_tag_directive_t *tmp_11;
  __FC_assert(emitter != (yaml_emitter_t *)0,"src/api.c",394,"emitter");
  yaml_free((void *)emitter->buffer.start);
  tmp_0 = (yaml_char_t *)0;
  emitter->buffer.end = tmp_0;
  tmp = tmp_0;
  emitter->buffer.pointer = tmp;
  emitter->buffer.start = tmp;
  yaml_free((void *)emitter->raw_buffer.start);
  tmp_2 = (unsigned char *)0;
  emitter->raw_buffer.end = tmp_2;
  tmp_1 = tmp_2;
  emitter->raw_buffer.pointer = tmp_1;
  emitter->raw_buffer.start = tmp_1;
  yaml_free((void *)emitter->states.start);
  tmp_4 = (yaml_emitter_state_t *)0;
  emitter->states.end = tmp_4;
  tmp_3 = tmp_4;
  emitter->states.top = tmp_3;
  emitter->states.start = tmp_3;
  while (! (emitter->events.head == emitter->events.tail)) {
    yaml_event_t *tmp_5;
    tmp_5 = emitter->events.head;
    (emitter->events.head) ++;
    ;
    yaml_event_delete(tmp_5);
  }
  yaml_free((void *)emitter->events.start);
  tmp_8 = (yaml_event_t *)0;
  emitter->events.end = tmp_8;
  tmp_7 = tmp_8;
  emitter->events.tail = tmp_7;
  tmp_6 = tmp_7;
  emitter->events.head = tmp_6;
  emitter->events.start = tmp_6;
  yaml_free((void *)emitter->indents.start);
  tmp_10 = (int *)0;
  emitter->indents.end = tmp_10;
  tmp_9 = tmp_10;
  emitter->indents.top = tmp_9;
  emitter->indents.start = tmp_9;
  while (! (emitter->tag_directives.start == emitter->tag_directives.top)) {
    (emitter->tag_directives.top) --;
    yaml_tag_directive_t tag_directive = *(emitter->tag_directives.top);
    yaml_free((void *)tag_directive.handle);
    yaml_free((void *)tag_directive.prefix);
  }
  yaml_free((void *)emitter->tag_directives.start);
  tmp_12 = (yaml_tag_directive_t *)0;
  emitter->tag_directives.end = tmp_12;
  tmp_11 = tmp_12;
  emitter->tag_directives.top = tmp_11;
  emitter->tag_directives.start = tmp_11;
  yaml_free((void *)emitter->anchors);
  memset((void *)emitter,0,sizeof(yaml_emitter_t));
  return;
}

static int yaml_string_write_handler(void *data, unsigned char *buffer,
                                     size_t size)
{
  int __retres;
  yaml_emitter_t *emitter = (yaml_emitter_t *)data;
  if (emitter->output.string.size - *(emitter->output.string.size_written) < size) {
    memcpy((void *)(emitter->output.string.buffer + *(emitter->output.string.size_written)),
           (void const *)buffer,
           emitter->output.string.size - *(emitter->output.string.size_written));
    *(emitter->output.string.size_written) = emitter->output.string.size;
    __retres = 0;
    goto return_label;
  }
  memcpy((void *)(emitter->output.string.buffer + *(emitter->output.string.size_written)),
         (void const *)buffer,size);
  *(emitter->output.string.size_written) += size;
  __retres = 1;
  return_label: return __retres;
}

static int yaml_file_write_handler(void *data, unsigned char *buffer,
                                   size_t size)
{
  int __retres;
  size_t tmp;
  yaml_emitter_t *emitter = (yaml_emitter_t *)data;
  tmp = fwrite((void const *)buffer,(size_t)1,size,emitter->output.file);
  ;
  __retres = tmp == size;
  return __retres;
}

void yaml_emitter_set_output_string(yaml_emitter_t *emitter,
                                    unsigned char *output, size_t size,
                                    size_t *size_written)
{
  __FC_assert(emitter != (yaml_emitter_t *)0,"src/api.c",460,"emitter");
  __FC_assert(! emitter->write_handler != 0,"src/api.c",461,
              "!emitter->write_handler");
  __FC_assert(output != (unsigned char *)0,"src/api.c",462,"output");
  emitter->write_handler = & yaml_string_write_handler;
  emitter->write_handler_data = (void *)emitter;
  emitter->output.string.buffer = output;
  emitter->output.string.size = size;
  emitter->output.string.size_written = size_written;
  *size_written = (size_t)0;
  return;
}

void yaml_emitter_set_output_file(yaml_emitter_t *emitter, FILE *file)
{
  __FC_assert(emitter != (yaml_emitter_t *)0,"src/api.c",480,"emitter");
  __FC_assert(! emitter->write_handler != 0,"src/api.c",481,
              "!emitter->write_handler");
  __FC_assert(file != (FILE *)0,"src/api.c",482,"file");
  emitter->write_handler = & yaml_file_write_handler;
  emitter->write_handler_data = (void *)emitter;
  emitter->output.file = file;
  return;
}

void yaml_emitter_set_output(yaml_emitter_t *emitter,
                             yaml_write_handler_t *handler, void *data)
{
  __FC_assert(emitter != (yaml_emitter_t *)0,"src/api.c",498,"emitter");
  __FC_assert(! emitter->write_handler != 0,"src/api.c",499,
              "!emitter->write_handler");
  __FC_assert(handler != (yaml_write_handler_t *)0,"src/api.c",500,"handler");
  emitter->write_handler = handler;
  emitter->write_handler_data = data;
  return;
}

void yaml_emitter_set_encoding(yaml_emitter_t *emitter,
                               yaml_encoding_t encoding)
{
  __FC_assert(emitter != (yaml_emitter_t *)0,"src/api.c",513,"emitter");
  __FC_assert(! emitter->encoding != 0,"src/api.c",514,"!emitter->encoding");
  emitter->encoding = encoding;
  return;
}

void yaml_emitter_set_canonical(yaml_emitter_t *emitter, int canonical)
{
  __FC_assert(emitter != (yaml_emitter_t *)0,"src/api.c",526,"emitter");
  emitter->canonical = canonical != 0;
  return;
}

void yaml_emitter_set_indent(yaml_emitter_t *emitter, int indent)
{
  __FC_assert(emitter != (yaml_emitter_t *)0,"src/api.c",538,"emitter");
  if (1 < indent) 
    if (indent < 10) emitter->best_indent = indent;
    else emitter->best_indent = 2;
  else emitter->best_indent = 2;
  return;
}

void yaml_emitter_set_width(yaml_emitter_t *emitter, int width)
{
  __FC_assert(emitter != (yaml_emitter_t *)0,"src/api.c",550,"emitter");
  if (width >= 0) emitter->best_width = width; else emitter->best_width = -1;
  return;
}

void yaml_emitter_set_unicode(yaml_emitter_t *emitter, int unicode)
{
  __FC_assert(emitter != (yaml_emitter_t *)0,"src/api.c",562,"emitter");
  emitter->unicode = unicode != 0;
  return;
}

void yaml_emitter_set_break(yaml_emitter_t *emitter, yaml_break_t line_break)
{
  __FC_assert(emitter != (yaml_emitter_t *)0,"src/api.c",574,"emitter");
  emitter->line_break = line_break;
  return;
}

void yaml_token_delete(yaml_token_t *token)
{
  __FC_assert(token != (yaml_token_t *)0,"src/api.c",586,"token");
  switch (token->type) {
    case YAML_TAG_DIRECTIVE_TOKEN:
    yaml_free((void *)token->data.tag_directive.handle);
    yaml_free((void *)token->data.tag_directive.prefix);
    break;
    case YAML_ALIAS_TOKEN: yaml_free((void *)token->data.alias.value);
    break;
    case YAML_ANCHOR_TOKEN: yaml_free((void *)token->data.anchor.value);
    break;
    case YAML_TAG_TOKEN: yaml_free((void *)token->data.tag.handle);
    yaml_free((void *)token->data.tag.suffix);
    break;
    case YAML_SCALAR_TOKEN: yaml_free((void *)token->data.scalar.value);
    break;
    default: break;
  }
  memset((void *)token,0,sizeof(yaml_token_t));
  return;
}

static int yaml_check_utf8(yaml_char_t const *start, size_t length)
{
  int __retres;
  yaml_char_t const *end = start + length;
  yaml_char_t const *pointer = start;
  while (pointer < end) {
    unsigned char octet;
    unsigned int width;
    unsigned int value;
    size_t k;
    octet = *(pointer + 0);
    if (((int)octet & 0x80) == 0x00) width = (unsigned int)1;
    else {
      int tmp_1;
      if (((int)octet & 0xE0) == 0xC0) tmp_1 = 2;
      else {
        int tmp_0;
        if (((int)octet & 0xF0) == 0xE0) tmp_0 = 3;
        else {
          int tmp;
          if (((int)octet & 0xF8) == 0xF0) tmp = 4; else tmp = 0;
          tmp_0 = tmp;
        }
        tmp_1 = tmp_0;
      }
      width = (unsigned int)tmp_1;
    }
    if (((int)octet & 0x80) == 0x00) value = (unsigned int)((int)octet & 0x7F);
    else {
      int tmp_4;
      if (((int)octet & 0xE0) == 0xC0) tmp_4 = (int)octet & 0x1F;
      else {
        int tmp_3;
        if (((int)octet & 0xF0) == 0xE0) tmp_3 = (int)octet & 0x0F;
        else {
          int tmp_2;
          if (((int)octet & 0xF8) == 0xF0) tmp_2 = (int)octet & 0x07;
          else tmp_2 = 0;
          tmp_3 = tmp_2;
        }
        tmp_4 = tmp_3;
      }
      value = (unsigned int)tmp_4;
    }
    if (! width) {
      __retres = 0;
      goto return_label;
    }
    if (pointer + width > end) {
      __retres = 0;
      goto return_label;
    }
    k = (size_t)1;
    while (k < (size_t)width) {
      octet = *(pointer + k);
      if (((int)octet & 0xC0) != 0x80) {
        __retres = 0;
        goto return_label;
      }
      value = (value << 6) + (unsigned int)((int)octet & 0x3F);
      k ++;
    }
    if (! (width == (unsigned int)1)) 
      if (width == (unsigned int)2) {
        if (! (value >= (unsigned int)0x80)) goto _LAND_0;
      }
      else {
        _LAND_0: ;
        if (width == (unsigned int)3) {
          if (! (value >= (unsigned int)0x800)) goto _LAND;
        }
        else {
          _LAND: ;
          if (width == (unsigned int)4) {
            if (! (value >= (unsigned int)0x10000)) {
              __retres = 0;
              goto return_label;
            }
          }
          else {
            __retres = 0;
            goto return_label;
          }
        }
      }
    pointer += width;
  }
  __retres = 1;
  return_label: return __retres;
}

int yaml_stream_start_event_initialize(yaml_event_t *event,
                                       yaml_encoding_t encoding)
{
  int __retres;
  yaml_mark_t mark =
    {.index = (size_t)0, .line = (size_t)0, .column = (size_t)0};
  __FC_assert(event != (yaml_event_t *)0,"src/api.c",674,"event");
  memset((void *)event,0,sizeof(yaml_event_t));
  event->type = YAML_STREAM_START_EVENT;
  event->start_mark = mark;
  event->end_mark = mark;
  event->data.stream_start.encoding = encoding;
  __retres = 1;
  return __retres;
}

int yaml_stream_end_event_initialize(yaml_event_t *event)
{
  int __retres;
  yaml_mark_t mark =
    {.index = (size_t)0, .line = (size_t)0, .column = (size_t)0};
  __FC_assert(event != (yaml_event_t *)0,"src/api.c",690,"event");
  memset((void *)event,0,sizeof(yaml_event_t));
  event->type = YAML_STREAM_END_EVENT;
  event->start_mark = mark;
  event->end_mark = mark;
  __retres = 1;
  return __retres;
}

int yaml_document_start_event_initialize(yaml_event_t *event,
                                         yaml_version_directive_t *version_directive,
                                         yaml_tag_directive_t *tag_directives_start,
                                         yaml_tag_directive_t *tag_directives_end,
                                         int implicit)
{
  int __retres;
  struct __anonstruct_context_49 context;
  int tmp;
  yaml_mark_t mark =
    {.index = (size_t)0, .line = (size_t)0, .column = (size_t)0};
  yaml_version_directive_t *version_directive_copy =
    (yaml_version_directive_t *)0;
  struct __anonstruct_tag_directives_copy_50 tag_directives_copy =
    {.start = (yaml_tag_directive_t *)0,
     .end = (yaml_tag_directive_t *)0,
     .top = (yaml_tag_directive_t *)0};
  yaml_tag_directive_t value =
    {.handle = (yaml_char_t *)0, .prefix = (yaml_char_t *)0};
  __FC_assert(event != (yaml_event_t *)0,"src/api.c",720,"event");
  if (tag_directives_start) {
    if (tag_directives_end) tmp = 1; else goto _LAND;
  }
  else {
    _LAND: ;
    if (tag_directives_start == tag_directives_end) tmp = 1; else tmp = 0;
  }
  __FC_assert(tmp != 0,"src/api.c",721,
              "(tag_directives_start && tag_directives_end) || (tag_directives_start == tag_directives_end)");
  if (version_directive) {
    version_directive_copy = (yaml_version_directive_t *)yaml_malloc(sizeof(yaml_version_directive_t));
    if (! version_directive_copy) goto error;
    version_directive_copy->major = version_directive->major;
    version_directive_copy->minor = version_directive->minor;
  }
  if (tag_directives_start != tag_directives_end) {
    yaml_tag_directive_t *tag_directive;
    int tmp_2;
    tag_directives_copy.start = (yaml_tag_directive_t *)yaml_malloc((unsigned long)16 * sizeof(*(tag_directives_copy.start)));
    if (tag_directives_copy.start) {
      tag_directives_copy.top = tag_directives_copy.start;
      tag_directives_copy.end = tag_directives_copy.start + 16;
      tmp_2 = 1;
    }
    else {
      context.error = YAML_MEMORY_ERROR;
      tmp_2 = 0;
    }
    if (! tmp_2) goto error;
    tag_directive = tag_directives_start;
    while (tag_directive != tag_directives_end) {
      {
        int tmp_4;
        size_t tmp_3;
        int tmp_6;
        size_t tmp_5;
        int tmp_9;
        __FC_assert(tag_directive->handle != (yaml_char_t *)0,"src/api.c",
                    738,"tag_directive->handle");
        __FC_assert(tag_directive->prefix != (yaml_char_t *)0,"src/api.c",
                    739,"tag_directive->prefix");
        tmp_3 = strlen((char const *)tag_directive->handle);
        ;
        tmp_4 = yaml_check_utf8((yaml_char_t const *)tag_directive->handle,
                                tmp_3);
        if (! tmp_4) goto error;
        tmp_5 = strlen((char const *)tag_directive->prefix);
        ;
        tmp_6 = yaml_check_utf8((yaml_char_t const *)tag_directive->prefix,
                                tmp_5);
        if (! tmp_6) goto error;
        value.handle = yaml_strdup((yaml_char_t const *)tag_directive->handle);
        value.prefix = yaml_strdup((yaml_char_t const *)tag_directive->prefix);
        if (! value.handle) goto error;
        else 
          if (! value.prefix) goto error;
        if (tag_directives_copy.top != tag_directives_copy.end) goto _LOR;
        else {
          int tmp_7;
          tmp_7 = yaml_stack_extend((void **)(& tag_directives_copy.start),
                                    (void **)(& tag_directives_copy.top),
                                    (void **)(& tag_directives_copy.end));
          if (tmp_7) {
            yaml_tag_directive_t *tmp_8;
            _LOR: tmp_8 = tag_directives_copy.top;
            (tag_directives_copy.top) ++;
            *tmp_8 = value;
            tmp_9 = 1;
          }
          else {
            context.error = YAML_MEMORY_ERROR;
            tmp_9 = 0;
          }
        }
        if (! tmp_9) goto error;
        value.handle = (yaml_char_t *)0;
        value.prefix = (yaml_char_t *)0;
      }
      tag_directive ++;
    }
  }
  memset((void *)event,0,sizeof(yaml_event_t));
  event->type = YAML_DOCUMENT_START_EVENT;
  event->start_mark = mark;
  event->end_mark = mark;
  event->data.document_start.version_directive = version_directive_copy;
  event->data.document_start.tag_directives.start = tag_directives_copy.start;
  event->data.document_start.tag_directives.end = tag_directives_copy.top;
  event->data.document_start.implicit = implicit;
  __retres = 1;
  goto return_label;
  error: yaml_free((void *)version_directive_copy);
  while (! (tag_directives_copy.start == tag_directives_copy.top)) {
    (tag_directives_copy.top) --;
    yaml_tag_directive_t value_0 = *(tag_directives_copy.top);
    yaml_free((void *)value_0.handle);
    yaml_free((void *)value_0.prefix);
  }
  yaml_free((void *)tag_directives_copy.start);
  tag_directives_copy.end = (yaml_tag_directive_t *)0;
  tag_directives_copy.top = tag_directives_copy.end;
  tag_directives_copy.start = tag_directives_copy.top;
  yaml_free((void *)value.handle);
  yaml_free((void *)value.prefix);
  __retres = 0;
  return_label: return __retres;
}

int yaml_document_end_event_initialize(yaml_event_t *event, int implicit)
{
  int __retres;
  yaml_mark_t mark =
    {.index = (size_t)0, .line = (size_t)0, .column = (size_t)0};
  __FC_assert(event != (yaml_event_t *)0,"src/api.c",785,"event");
  memset((void *)event,0,sizeof(yaml_event_t));
  event->type = YAML_DOCUMENT_END_EVENT;
  event->start_mark = mark;
  event->end_mark = mark;
  event->data.document_end.implicit = implicit;
  __retres = 1;
  return __retres;
}

int yaml_alias_event_initialize(yaml_event_t *event,
                                yaml_char_t const *anchor)
{
  int __retres;
  int tmp_0;
  size_t tmp;
  yaml_mark_t mark =
    {.index = (size_t)0, .line = (size_t)0, .column = (size_t)0};
  yaml_char_t *anchor_copy = (yaml_char_t *)0;
  __FC_assert(event != (yaml_event_t *)0,"src/api.c",802,"event");
  __FC_assert(anchor != (yaml_char_t const *)0,"src/api.c",803,"anchor");
  tmp = strlen((char const *)anchor);
  ;
  tmp_0 = yaml_check_utf8(anchor,tmp);
  if (! tmp_0) {
    __retres = 0;
    goto return_label;
  }
  anchor_copy = yaml_strdup(anchor);
  if (! anchor_copy) {
    __retres = 0;
    goto return_label;
  }
  memset((void *)event,0,sizeof(yaml_event_t));
  event->type = YAML_ALIAS_EVENT;
  event->start_mark = mark;
  event->end_mark = mark;
  event->data.alias.anchor = anchor_copy;
  __retres = 1;
  return_label: return __retres;
}

int yaml_scalar_event_initialize(yaml_event_t *event,
                                 yaml_char_t const *anchor,
                                 yaml_char_t const *tag,
                                 yaml_char_t const *value, int length,
                                 int plain_implicit, int quoted_implicit,
                                 yaml_scalar_style_t style)
{
  int __retres;
  int tmp_4;
  yaml_mark_t mark =
    {.index = (size_t)0, .line = (size_t)0, .column = (size_t)0};
  yaml_char_t *anchor_copy = (yaml_char_t *)0;
  yaml_char_t *tag_copy = (yaml_char_t *)0;
  yaml_char_t *value_copy = (yaml_char_t *)0;
  __FC_assert(event != (yaml_event_t *)0,"src/api.c",832,"event");
  __FC_assert(value != (yaml_char_t const *)0,"src/api.c",833,"value");
  if (anchor) {
    int tmp_0;
    size_t tmp;
    tmp = strlen((char const *)anchor);
    ;
    tmp_0 = yaml_check_utf8(anchor,tmp);
    if (! tmp_0) goto error;
    anchor_copy = yaml_strdup(anchor);
    if (! anchor_copy) goto error;
  }
  if (tag) {
    int tmp_2;
    size_t tmp_1;
    tmp_1 = strlen((char const *)tag);
    ;
    tmp_2 = yaml_check_utf8(tag,tmp_1);
    if (! tmp_2) goto error;
    tag_copy = yaml_strdup(tag);
    if (! tag_copy) goto error;
  }
  if (length < 0) {
    size_t tmp_3;
    tmp_3 = strlen((char const *)value);
    length = (int)tmp_3;
  }
  tmp_4 = yaml_check_utf8(value,(size_t)length);
  if (! tmp_4) goto error;
  value_copy = (yaml_char_t *)yaml_malloc((size_t)(length + 1));
  if (! value_copy) goto error;
  memcpy((void *)value_copy,(void const *)value,(size_t)length);
  *(value_copy + length) = (yaml_char_t)'\000';
  memset((void *)event,0,sizeof(yaml_event_t));
  event->type = YAML_SCALAR_EVENT;
  event->start_mark = mark;
  event->end_mark = mark;
  event->data.scalar.anchor = anchor_copy;
  event->data.scalar.tag = tag_copy;
  event->data.scalar.value = value_copy;
  event->data.scalar.length = (size_t)length;
  event->data.scalar.plain_implicit = plain_implicit;
  event->data.scalar.quoted_implicit = quoted_implicit;
  event->data.scalar.style = style;
  __retres = 1;
  goto return_label;
  error: yaml_free((void *)anchor_copy);
  yaml_free((void *)tag_copy);
  yaml_free((void *)value_copy);
  __retres = 0;
  return_label: return __retres;
}

int yaml_sequence_start_event_initialize(yaml_event_t *event,
                                         yaml_char_t const *anchor,
                                         yaml_char_t const *tag,
                                         int implicit,
                                         yaml_sequence_style_t style)
{
  int __retres;
  yaml_mark_t mark =
    {.index = (size_t)0, .line = (size_t)0, .column = (size_t)0};
  yaml_char_t *anchor_copy = (yaml_char_t *)0;
  yaml_char_t *tag_copy = (yaml_char_t *)0;
  __FC_assert(event != (yaml_event_t *)0,"src/api.c",883,"event");
  if (anchor) {
    int tmp_0;
    size_t tmp;
    tmp = strlen((char const *)anchor);
    ;
    tmp_0 = yaml_check_utf8(anchor,tmp);
    if (! tmp_0) goto error;
    anchor_copy = yaml_strdup(anchor);
    if (! anchor_copy) goto error;
  }
  if (tag) {
    int tmp_2;
    size_t tmp_1;
    tmp_1 = strlen((char const *)tag);
    ;
    tmp_2 = yaml_check_utf8(tag,tmp_1);
    if (! tmp_2) goto error;
    tag_copy = yaml_strdup(tag);
    if (! tag_copy) goto error;
  }
  memset((void *)event,0,sizeof(yaml_event_t));
  event->type = YAML_SEQUENCE_START_EVENT;
  event->start_mark = mark;
  event->end_mark = mark;
  event->data.sequence_start.anchor = anchor_copy;
  event->data.sequence_start.tag = tag_copy;
  event->data.sequence_start.implicit = implicit;
  event->data.sequence_start.style = style;
  __retres = 1;
  goto return_label;
  error: yaml_free((void *)anchor_copy);
  yaml_free((void *)tag_copy);
  __retres = 0;
  return_label: return __retres;
}

int yaml_sequence_end_event_initialize(yaml_event_t *event)
{
  int __retres;
  yaml_mark_t mark =
    {.index = (size_t)0, .line = (size_t)0, .column = (size_t)0};
  __FC_assert(event != (yaml_event_t *)0,"src/api.c",918,"event");
  memset((void *)event,0,sizeof(yaml_event_t));
  event->type = YAML_SEQUENCE_END_EVENT;
  event->start_mark = mark;
  event->end_mark = mark;
  __retres = 1;
  return __retres;
}

int yaml_mapping_start_event_initialize(yaml_event_t *event,
                                        yaml_char_t const *anchor,
                                        yaml_char_t const *tag, int implicit,
                                        yaml_mapping_style_t style)
{
  int __retres;
  yaml_mark_t mark =
    {.index = (size_t)0, .line = (size_t)0, .column = (size_t)0};
  yaml_char_t *anchor_copy = (yaml_char_t *)0;
  yaml_char_t *tag_copy = (yaml_char_t *)0;
  __FC_assert(event != (yaml_event_t *)0,"src/api.c",938,"event");
  if (anchor) {
    int tmp_0;
    size_t tmp;
    tmp = strlen((char const *)anchor);
    ;
    tmp_0 = yaml_check_utf8(anchor,tmp);
    if (! tmp_0) goto error;
    anchor_copy = yaml_strdup(anchor);
    if (! anchor_copy) goto error;
  }
  if (tag) {
    int tmp_2;
    size_t tmp_1;
    tmp_1 = strlen((char const *)tag);
    ;
    tmp_2 = yaml_check_utf8(tag,tmp_1);
    if (! tmp_2) goto error;
    tag_copy = yaml_strdup(tag);
    if (! tag_copy) goto error;
  }
  memset((void *)event,0,sizeof(yaml_event_t));
  event->type = YAML_MAPPING_START_EVENT;
  event->start_mark = mark;
  event->end_mark = mark;
  event->data.mapping_start.anchor = anchor_copy;
  event->data.mapping_start.tag = tag_copy;
  event->data.mapping_start.implicit = implicit;
  event->data.mapping_start.style = style;
  __retres = 1;
  goto return_label;
  error: yaml_free((void *)anchor_copy);
  yaml_free((void *)tag_copy);
  __retres = 0;
  return_label: return __retres;
}

int yaml_mapping_end_event_initialize(yaml_event_t *event)
{
  int __retres;
  yaml_mark_t mark =
    {.index = (size_t)0, .line = (size_t)0, .column = (size_t)0};
  __FC_assert(event != (yaml_event_t *)0,"src/api.c",973,"event");
  memset((void *)event,0,sizeof(yaml_event_t));
  event->type = YAML_MAPPING_END_EVENT;
  event->start_mark = mark;
  event->end_mark = mark;
  __retres = 1;
  return __retres;
}

void yaml_event_delete(yaml_event_t *event)
{
  yaml_tag_directive_t *tag_directive;
  __FC_assert(event != (yaml_event_t *)0,"src/api.c",989,"event");
  switch (event->type) {
    case YAML_DOCUMENT_START_EVENT:
    yaml_free((void *)event->data.document_start.version_directive);
    tag_directive = event->data.document_start.tag_directives.start;
    while (tag_directive != event->data.document_start.tag_directives.end) {
      yaml_free((void *)tag_directive->handle);
      yaml_free((void *)tag_directive->prefix);
      tag_directive ++;
    }
    yaml_free((void *)event->data.document_start.tag_directives.start);
    break;
    case YAML_ALIAS_EVENT: yaml_free((void *)event->data.alias.anchor);
    break;
    case YAML_SCALAR_EVENT: yaml_free((void *)event->data.scalar.anchor);
    yaml_free((void *)event->data.scalar.tag);
    yaml_free((void *)event->data.scalar.value);
    break;
    case YAML_SEQUENCE_START_EVENT:
    yaml_free((void *)event->data.sequence_start.anchor);
    yaml_free((void *)event->data.sequence_start.tag);
    break;
    case YAML_MAPPING_START_EVENT:
    yaml_free((void *)event->data.mapping_start.anchor);
    yaml_free((void *)event->data.mapping_start.tag);
    break;
    default: break;
  }
  memset((void *)event,0,sizeof(yaml_event_t));
  return;
}

int yaml_document_initialize(yaml_document_t *document,
                             yaml_version_directive_t *version_directive,
                             yaml_tag_directive_t *tag_directives_start,
                             yaml_tag_directive_t *tag_directives_end,
                             int start_implicit, int end_implicit)
{
  int __retres;
  struct __anonstruct_context_51 context;
  int tmp;
  int tmp_1;
  struct __anonstruct_nodes_52 nodes =
    {.start = (yaml_node_t *)0,
     .end = (yaml_node_t *)0,
     .top = (yaml_node_t *)0};
  yaml_version_directive_t *version_directive_copy =
    (yaml_version_directive_t *)0;
  struct __anonstruct_tag_directives_copy_53 tag_directives_copy =
    {.start = (yaml_tag_directive_t *)0,
     .end = (yaml_tag_directive_t *)0,
     .top = (yaml_tag_directive_t *)0};
  yaml_tag_directive_t value =
    {.handle = (yaml_char_t *)0, .prefix = (yaml_char_t *)0};
  yaml_mark_t mark =
    {.index = (size_t)0, .line = (size_t)0, .column = (size_t)0};
  __FC_assert(document != (yaml_document_t *)0,"src/api.c",1059,"document");
  if (tag_directives_start) {
    if (tag_directives_end) tmp = 1; else goto _LAND;
  }
  else {
    _LAND: ;
    if (tag_directives_start == tag_directives_end) tmp = 1; else tmp = 0;
  }
  __FC_assert(tmp != 0,"src/api.c",1060,
              "(tag_directives_start && tag_directives_end) || (tag_directives_start == tag_directives_end)");
  nodes.start = (yaml_node_t *)yaml_malloc((unsigned long)16 * sizeof(*(nodes.start)));
  if (nodes.start) {
    nodes.top = nodes.start;
    nodes.end = nodes.start + 16;
    tmp_1 = 1;
  }
  else {
    context.error = YAML_MEMORY_ERROR;
    tmp_1 = 0;
  }
  if (! tmp_1) goto error;
  if (version_directive) {
    version_directive_copy = (yaml_version_directive_t *)yaml_malloc(sizeof(yaml_version_directive_t));
    if (! version_directive_copy) goto error;
    version_directive_copy->major = version_directive->major;
    version_directive_copy->minor = version_directive->minor;
  }
  if (tag_directives_start != tag_directives_end) {
    yaml_tag_directive_t *tag_directive;
    int tmp_4;
    tag_directives_copy.start = (yaml_tag_directive_t *)yaml_malloc((unsigned long)16 * sizeof(*(tag_directives_copy.start)));
    if (tag_directives_copy.start) {
      tag_directives_copy.top = tag_directives_copy.start;
      tag_directives_copy.end = tag_directives_copy.start + 16;
      tmp_4 = 1;
    }
    else {
      context.error = YAML_MEMORY_ERROR;
      tmp_4 = 0;
    }
    if (! tmp_4) goto error;
    tag_directive = tag_directives_start;
    while (tag_directive != tag_directives_end) {
      {
        int tmp_6;
        size_t tmp_5;
        int tmp_8;
        size_t tmp_7;
        int tmp_11;
        __FC_assert(tag_directive->handle != (yaml_char_t *)0,"src/api.c",
                    1079,"tag_directive->handle");
        __FC_assert(tag_directive->prefix != (yaml_char_t *)0,"src/api.c",
                    1080,"tag_directive->prefix");
        tmp_5 = strlen((char const *)tag_directive->handle);
        ;
        tmp_6 = yaml_check_utf8((yaml_char_t const *)tag_directive->handle,
                                tmp_5);
        if (! tmp_6) goto error;
        tmp_7 = strlen((char const *)tag_directive->prefix);
        ;
        tmp_8 = yaml_check_utf8((yaml_char_t const *)tag_directive->prefix,
                                tmp_7);
        if (! tmp_8) goto error;
        value.handle = yaml_strdup((yaml_char_t const *)tag_directive->handle);
        value.prefix = yaml_strdup((yaml_char_t const *)tag_directive->prefix);
        if (! value.handle) goto error;
        else 
          if (! value.prefix) goto error;
        if (tag_directives_copy.top != tag_directives_copy.end) goto _LOR;
        else {
          int tmp_9;
          tmp_9 = yaml_stack_extend((void **)(& tag_directives_copy.start),
                                    (void **)(& tag_directives_copy.top),
                                    (void **)(& tag_directives_copy.end));
          if (tmp_9) {
            yaml_tag_directive_t *tmp_10;
            _LOR: tmp_10 = tag_directives_copy.top;
            (tag_directives_copy.top) ++;
            *tmp_10 = value;
            tmp_11 = 1;
          }
          else {
            context.error = YAML_MEMORY_ERROR;
            tmp_11 = 0;
          }
        }
        if (! tmp_11) goto error;
        value.handle = (yaml_char_t *)0;
        value.prefix = (yaml_char_t *)0;
      }
      tag_directive ++;
    }
  }
  memset((void *)document,0,sizeof(yaml_document_t));
  document->nodes.start = nodes.start;
  document->nodes.end = nodes.end;
  document->nodes.top = nodes.start;
  document->version_directive = version_directive_copy;
  document->tag_directives.start = tag_directives_copy.start;
  document->tag_directives.end = tag_directives_copy.top;
  document->start_implicit = start_implicit;
  document->end_implicit = end_implicit;
  document->start_mark = mark;
  document->end_mark = mark;
  __retres = 1;
  goto return_label;
  error: yaml_free((void *)nodes.start);
  nodes.end = (yaml_node_t *)0;
  nodes.top = nodes.end;
  nodes.start = nodes.top;
  yaml_free((void *)version_directive_copy);
  while (! (tag_directives_copy.start == tag_directives_copy.top)) {
    (tag_directives_copy.top) --;
    yaml_tag_directive_t value_0 = *(tag_directives_copy.top);
    yaml_free((void *)value_0.handle);
    yaml_free((void *)value_0.prefix);
  }
  yaml_free((void *)tag_directives_copy.start);
  tag_directives_copy.end = (yaml_tag_directive_t *)0;
  tag_directives_copy.top = tag_directives_copy.end;
  tag_directives_copy.start = tag_directives_copy.top;
  yaml_free((void *)value.handle);
  yaml_free((void *)value.prefix);
  __retres = 0;
  return_label: return __retres;
}

void yaml_document_delete(yaml_document_t *document)
{
  yaml_tag_directive_t *tag_directive;
  yaml_node_t *tmp_0;
  yaml_node_t *tmp;
  __FC_assert(document != (yaml_document_t *)0,"src/api.c",1127,"document");
  while (! (document->nodes.start == document->nodes.top)) {
    (document->nodes.top) --;
    yaml_node_t node = *(document->nodes.top);
    yaml_free((void *)node.tag);
    switch (node.type) {
      case YAML_SCALAR_NODE: yaml_free((void *)node.data.scalar.value);
      break;
      case YAML_SEQUENCE_NODE:
      yaml_free((void *)node.data.sequence.items.start);
      node.data.sequence.items.end = (yaml_node_item_t *)0;
      node.data.sequence.items.top = node.data.sequence.items.end;
      node.data.sequence.items.start = node.data.sequence.items.top;
      break;
      case YAML_MAPPING_NODE:
      yaml_free((void *)node.data.mapping.pairs.start);
      node.data.mapping.pairs.end = (yaml_node_pair_t *)0;
      node.data.mapping.pairs.top = node.data.mapping.pairs.end;
      node.data.mapping.pairs.start = node.data.mapping.pairs.top;
      break;
      default: __FC_assert(0 != 0,"src/api.c",1143,"0");
    }
  }
  yaml_free((void *)document->nodes.start);
  tmp_0 = (yaml_node_t *)0;
  document->nodes.end = tmp_0;
  tmp = tmp_0;
  document->nodes.top = tmp;
  document->nodes.start = tmp;
  yaml_free((void *)document->version_directive);
  tag_directive = document->tag_directives.start;
  while (tag_directive != document->tag_directives.end) {
    yaml_free((void *)tag_directive->handle);
    yaml_free((void *)tag_directive->prefix);
    tag_directive ++;
  }
  yaml_free((void *)document->tag_directives.start);
  memset((void *)document,0,sizeof(yaml_document_t));
  return;
}

yaml_node_t *yaml_document_get_node(yaml_document_t *document, int index_0)
{
  yaml_node_t *__retres;
  __FC_assert(document != (yaml_document_t *)0,"src/api.c",1167,"document");
  if (index_0 > 0) 
    if (document->nodes.start + index_0 <= document->nodes.top) {
      __retres = (document->nodes.start + index_0) - 1;
      goto return_label;
    }
  __retres = (yaml_node_t *)0;
  return_label: return __retres;
}

yaml_node_t *yaml_document_get_root_node(yaml_document_t *document)
{
  yaml_node_t *__retres;
  __FC_assert(document != (yaml_document_t *)0,"src/api.c",1182,"document");
  if (document->nodes.top != document->nodes.start) {
    __retres = document->nodes.start;
    goto return_label;
  }
  __retres = (yaml_node_t *)0;
  return_label: return __retres;
}

int yaml_document_add_scalar(yaml_document_t *document,
                             yaml_char_t const *tag,
                             yaml_char_t const *value, int length,
                             yaml_scalar_style_t style)
{
  int __retres;
  struct __anonstruct_context_54 context;
  yaml_node_t node;
  int tmp_0;
  size_t tmp;
  int tmp_2;
  int tmp_6;
  yaml_mark_t mark =
    {.index = (size_t)0, .line = (size_t)0, .column = (size_t)0};
  yaml_char_t *tag_copy = (yaml_char_t *)0;
  yaml_char_t *value_copy = (yaml_char_t *)0;
  __FC_assert(document != (yaml_document_t *)0,"src/api.c",1207,"document");
  __FC_assert(value != (yaml_char_t const *)0,"src/api.c",1208,"value");
  if (! tag) tag = (yaml_char_t const *)"tag:yaml.org,2002:str";
  tmp = strlen((char const *)tag);
  ;
  tmp_0 = yaml_check_utf8(tag,tmp);
  if (! tmp_0) goto error;
  tag_copy = yaml_strdup(tag);
  if (! tag_copy) goto error;
  if (length < 0) {
    size_t tmp_1;
    tmp_1 = strlen((char const *)value);
    length = (int)tmp_1;
  }
  tmp_2 = yaml_check_utf8(value,(size_t)length);
  if (! tmp_2) goto error;
  value_copy = (yaml_char_t *)yaml_malloc((size_t)(length + 1));
  if (! value_copy) goto error;
  memcpy((void *)value_copy,(void const *)value,(size_t)length);
  *(value_copy + length) = (yaml_char_t)'\000';
  memset((void *)(& node),0,sizeof(yaml_node_t));
  node.type = YAML_SCALAR_NODE;
  node.tag = tag_copy;
  node.start_mark = mark;
  node.end_mark = mark;
  node.data.scalar.value = value_copy;
  node.data.scalar.length = (size_t)length;
  node.data.scalar.style = style;
  if (document->nodes.top != document->nodes.end) goto _LOR;
  else {
    int tmp_4;
    tmp_4 = yaml_stack_extend((void **)(& document->nodes.start),
                              (void **)(& document->nodes.top),
                              (void **)(& document->nodes.end));
    if (tmp_4) {
      yaml_node_t *tmp_5;
      _LOR: tmp_5 = document->nodes.top;
      (document->nodes.top) ++;
      *tmp_5 = node;
      tmp_6 = 1;
    }
    else {
      context.error = YAML_MEMORY_ERROR;
      tmp_6 = 0;
    }
  }
  if (! tmp_6) goto error;
  __retres = (int)(document->nodes.top - document->nodes.start);
  goto return_label;
  error: yaml_free((void *)tag_copy);
  yaml_free((void *)value_copy);
  __retres = 0;
  return_label: return __retres;
}

int yaml_document_add_sequence(yaml_document_t *document,
                               yaml_char_t const *tag,
                               yaml_sequence_style_t style)
{
  int __retres;
  struct __anonstruct_context_55 context;
  yaml_node_t node;
  int tmp_0;
  size_t tmp;
  int tmp_2;
  int tmp_5;
  yaml_mark_t mark =
    {.index = (size_t)0, .line = (size_t)0, .column = (size_t)0};
  yaml_char_t *tag_copy = (yaml_char_t *)0;
  struct __anonstruct_items_56 items =
    {.start = (yaml_node_item_t *)0,
     .end = (yaml_node_item_t *)0,
     .top = (yaml_node_item_t *)0};
  __FC_assert(document != (yaml_document_t *)0,"src/api.c",1260,"document");
  if (! tag) tag = (yaml_char_t const *)"tag:yaml.org,2002:seq";
  tmp = strlen((char const *)tag);
  ;
  tmp_0 = yaml_check_utf8(tag,tmp);
  if (! tmp_0) goto error;
  tag_copy = yaml_strdup(tag);
  if (! tag_copy) goto error;
  items.start = (yaml_node_item_t *)yaml_malloc((unsigned long)16 * sizeof(*(items.start)));
  if (items.start) {
    items.top = items.start;
    items.end = items.start + 16;
    tmp_2 = 1;
  }
  else {
    context.error = YAML_MEMORY_ERROR;
    tmp_2 = 0;
  }
  if (! tmp_2) goto error;
  memset((void *)(& node),0,sizeof(yaml_node_t));
  node.type = YAML_SEQUENCE_NODE;
  node.tag = tag_copy;
  node.start_mark = mark;
  node.end_mark = mark;
  node.data.sequence.items.start = items.start;
  node.data.sequence.items.end = items.end;
  node.data.sequence.items.top = items.start;
  node.data.sequence.style = style;
  if (document->nodes.top != document->nodes.end) goto _LOR;
  else {
    int tmp_3;
    tmp_3 = yaml_stack_extend((void **)(& document->nodes.start),
                              (void **)(& document->nodes.top),
                              (void **)(& document->nodes.end));
    if (tmp_3) {
      yaml_node_t *tmp_4;
      _LOR: tmp_4 = document->nodes.top;
      (document->nodes.top) ++;
      *tmp_4 = node;
      tmp_5 = 1;
    }
    else {
      context.error = YAML_MEMORY_ERROR;
      tmp_5 = 0;
    }
  }
  if (! tmp_5) goto error;
  __retres = (int)(document->nodes.top - document->nodes.start);
  goto return_label;
  error: yaml_free((void *)items.start);
  items.end = (yaml_node_item_t *)0;
  items.top = items.end;
  items.start = items.top;
  yaml_free((void *)tag_copy);
  __retres = 0;
  return_label: return __retres;
}

int yaml_document_add_mapping(yaml_document_t *document,
                              yaml_char_t const *tag,
                              yaml_mapping_style_t style)
{
  int __retres;
  struct __anonstruct_context_57 context;
  yaml_node_t node;
  int tmp_0;
  size_t tmp;
  int tmp_2;
  int tmp_5;
  yaml_mark_t mark =
    {.index = (size_t)0, .line = (size_t)0, .column = (size_t)0};
  yaml_char_t *tag_copy = (yaml_char_t *)0;
  struct __anonstruct_pairs_58 pairs =
    {.start = (yaml_node_pair_t *)0,
     .end = (yaml_node_pair_t *)0,
     .top = (yaml_node_pair_t *)0};
  __FC_assert(document != (yaml_document_t *)0,"src/api.c",1305,"document");
  if (! tag) tag = (yaml_char_t const *)"tag:yaml.org,2002:map";
  tmp = strlen((char const *)tag);
  ;
  tmp_0 = yaml_check_utf8(tag,tmp);
  if (! tmp_0) goto error;
  tag_copy = yaml_strdup(tag);
  if (! tag_copy) goto error;
  pairs.start = (yaml_node_pair_t *)yaml_malloc((unsigned long)16 * sizeof(*(pairs.start)));
  if (pairs.start) {
    pairs.top = pairs.start;
    pairs.end = pairs.start + 16;
    tmp_2 = 1;
  }
  else {
    context.error = YAML_MEMORY_ERROR;
    tmp_2 = 0;
  }
  if (! tmp_2) goto error;
  memset((void *)(& node),0,sizeof(yaml_node_t));
  node.type = YAML_MAPPING_NODE;
  node.tag = tag_copy;
  node.start_mark = mark;
  node.end_mark = mark;
  node.data.mapping.pairs.start = pairs.start;
  node.data.mapping.pairs.end = pairs.end;
  node.data.mapping.pairs.top = pairs.start;
  node.data.mapping.style = style;
  if (document->nodes.top != document->nodes.end) goto _LOR;
  else {
    int tmp_3;
    tmp_3 = yaml_stack_extend((void **)(& document->nodes.start),
                              (void **)(& document->nodes.top),
                              (void **)(& document->nodes.end));
    if (tmp_3) {
      yaml_node_t *tmp_4;
      _LOR: tmp_4 = document->nodes.top;
      (document->nodes.top) ++;
      *tmp_4 = node;
      tmp_5 = 1;
    }
    else {
      context.error = YAML_MEMORY_ERROR;
      tmp_5 = 0;
    }
  }
  if (! tmp_5) goto error;
  __retres = (int)(document->nodes.top - document->nodes.start);
  goto return_label;
  error: yaml_free((void *)pairs.start);
  pairs.end = (yaml_node_pair_t *)0;
  pairs.top = pairs.end;
  pairs.start = pairs.top;
  yaml_free((void *)tag_copy);
  __retres = 0;
  return_label: return __retres;
}

int yaml_document_append_sequence_item(yaml_document_t *document,
                                       int sequence, int item)
{
  int __retres;
  struct __anonstruct_context_59 context;
  int tmp;
  int tmp_0;
  int tmp_3;
  __FC_assert(document != (yaml_document_t *)0,"src/api.c",1342,"document");
  if (sequence > 0) 
    if (document->nodes.start + sequence <= document->nodes.top) tmp = 1;
    else tmp = 0;
  else tmp = 0;
  __FC_assert(tmp != 0,"src/api.c",1343,
              "sequence > 0 && document->nodes.start + sequence <= document->nodes.top");
  __FC_assert(((document->nodes.start + (sequence - 1))->type == (unsigned int)YAML_SEQUENCE_NODE) != 0,
              "src/api.c",1346,
              "document->nodes.start[sequence-1].type == YAML_SEQUENCE_NODE");
  if (item > 0) 
    if (document->nodes.start + item <= document->nodes.top) tmp_0 = 1;
    else tmp_0 = 0;
  else tmp_0 = 0;
  __FC_assert(tmp_0 != 0,"src/api.c",1348,
              "item > 0 && document->nodes.start + item <= document->nodes.top");
  if ((document->nodes.start + (sequence - 1))->data.sequence.items.top != (
      document->nodes.start + (sequence - 1))->data.sequence.items.end) 
    goto _LOR;
  else {
    int tmp_1;
    tmp_1 = yaml_stack_extend((void **)(& (document->nodes.start + (sequence - 1))->data.sequence.items.start),
                              (void **)(& (document->nodes.start + (sequence - 1))->data.sequence.items.top),
                              (void **)(& (document->nodes.start + (sequence - 1))->data.sequence.items.end));
    if (tmp_1) {
      yaml_node_item_t *tmp_2;
      _LOR:
      tmp_2 = (document->nodes.start + (sequence - 1))->data.sequence.items.top;
      ((document->nodes.start + (sequence - 1))->data.sequence.items.top) ++;
      *tmp_2 = item;
      tmp_3 = 1;
    }
    else {
      context.error = YAML_MEMORY_ERROR;
      tmp_3 = 0;
    }
  }
  if (! tmp_3) {
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

int yaml_document_append_mapping_pair(yaml_document_t *document, int mapping,
                                      int key, int value)
{
  int __retres;
  struct __anonstruct_context_60 context;
  yaml_node_pair_t pair;
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_4;
  __FC_assert(document != (yaml_document_t *)0,"src/api.c",1372,"document");
  if (mapping > 0) 
    if (document->nodes.start + mapping <= document->nodes.top) tmp = 1;
    else tmp = 0;
  else tmp = 0;
  __FC_assert(tmp != 0,"src/api.c",1373,
              "mapping > 0 && document->nodes.start + mapping <= document->nodes.top");
  __FC_assert(((document->nodes.start + (mapping - 1))->type == (unsigned int)YAML_MAPPING_NODE) != 0,
              "src/api.c",1376,
              "document->nodes.start[mapping-1].type == YAML_MAPPING_NODE");
  if (key > 0) 
    if (document->nodes.start + key <= document->nodes.top) tmp_0 = 1;
    else tmp_0 = 0;
  else tmp_0 = 0;
  __FC_assert(tmp_0 != 0,"src/api.c",1378,
              "key > 0 && document->nodes.start + key <= document->nodes.top");
  if (value > 0) 
    if (document->nodes.start + value <= document->nodes.top) tmp_1 = 1;
    else tmp_1 = 0;
  else tmp_1 = 0;
  __FC_assert(tmp_1 != 0,"src/api.c",1380,
              "value > 0 && document->nodes.start + value <= document->nodes.top");
  pair.key = key;
  pair.value = value;
  if ((document->nodes.start + (mapping - 1))->data.mapping.pairs.top != (
      document->nodes.start + (mapping - 1))->data.mapping.pairs.end) 
    goto _LOR;
  else {
    int tmp_2;
    tmp_2 = yaml_stack_extend((void **)(& (document->nodes.start + (mapping - 1))->data.mapping.pairs.start),
                              (void **)(& (document->nodes.start + (mapping - 1))->data.mapping.pairs.top),
                              (void **)(& (document->nodes.start + (mapping - 1))->data.mapping.pairs.end));
    if (tmp_2) {
      yaml_node_pair_t *tmp_3;
      _LOR:
      tmp_3 = (document->nodes.start + (mapping - 1))->data.mapping.pairs.top;
      ((document->nodes.start + (mapping - 1))->data.mapping.pairs.top) ++;
      *tmp_3 = pair;
      tmp_4 = 1;
    }
    else {
      context.error = YAML_MEMORY_ERROR;
      tmp_4 = 0;
    }
  }
  if (! tmp_4) {
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static void yaml_emitter_delete_document_and_anchors(yaml_emitter_t *emitter);

static void yaml_emitter_anchor_node(yaml_emitter_t *emitter, int index_0);

static yaml_char_t *yaml_emitter_generate_anchor(yaml_emitter_t *emitter __attribute__((
                                                 __unused__)), int anchor_id);

static int yaml_emitter_dump_node(yaml_emitter_t *emitter, int index_0);

static int yaml_emitter_dump_alias(yaml_emitter_t *emitter,
                                   yaml_char_t *anchor);

static int yaml_emitter_dump_scalar(yaml_emitter_t *emitter,
                                    yaml_node_t *node, yaml_char_t *anchor);

static int yaml_emitter_dump_sequence(yaml_emitter_t *emitter,
                                      yaml_node_t *node, yaml_char_t *anchor);

static int yaml_emitter_dump_mapping(yaml_emitter_t *emitter,
                                     yaml_node_t *node, yaml_char_t *anchor);

int yaml_emitter_open(yaml_emitter_t *emitter)
{
  int __retres;
  yaml_event_t event;
  int tmp;
  yaml_mark_t mark =
    {.index = (size_t)0, .line = (size_t)0, .column = (size_t)0};
  __FC_assert(emitter != (yaml_emitter_t *)0,"src/dumper.c",67,"emitter");
  __FC_assert(! emitter->opened != 0,"src/dumper.c",68,"!emitter->opened");
  memset((void *)(& event),0,sizeof(yaml_event_t));
  event.type = YAML_STREAM_START_EVENT;
  event.start_mark = mark;
  event.end_mark = mark;
  event.data.stream_start.encoding = YAML_ANY_ENCODING;
  tmp = yaml_emitter_emit(emitter,& event);
  if (! tmp) {
    __retres = 0;
    goto return_label;
  }
  emitter->opened = 1;
  __retres = 1;
  return_label: return __retres;
}

int yaml_emitter_close(yaml_emitter_t *emitter)
{
  int __retres;
  yaml_event_t event;
  int tmp;
  yaml_mark_t mark =
    {.index = (size_t)0, .line = (size_t)0, .column = (size_t)0};
  __FC_assert(emitter != (yaml_emitter_t *)0,"src/dumper.c",91,"emitter");
  __FC_assert(emitter->opened != 0,"src/dumper.c",92,"emitter->opened");
  if (emitter->closed) {
    __retres = 1;
    goto return_label;
  }
  memset((void *)(& event),0,sizeof(yaml_event_t));
  event.type = YAML_STREAM_END_EVENT;
  event.start_mark = mark;
  event.end_mark = mark;
  tmp = yaml_emitter_emit(emitter,& event);
  if (! tmp) {
    __retres = 0;
    goto return_label;
  }
  emitter->closed = 1;
  __retres = 1;
  return_label: return __retres;
}

int yaml_emitter_dump(yaml_emitter_t *emitter, yaml_document_t *document)
{
  int __retres;
  yaml_event_t event;
  int tmp_2;
  int tmp_3;
  int tmp_4;
  yaml_mark_t mark =
    {.index = (size_t)0, .line = (size_t)0, .column = (size_t)0};
  __FC_assert(emitter != (yaml_emitter_t *)0,"src/dumper.c",117,"emitter");
  __FC_assert(document != (yaml_document_t *)0,"src/dumper.c",118,"document");
  emitter->document = document;
  if (! emitter->opened) {
    int tmp;
    tmp = yaml_emitter_open(emitter);
    if (! tmp) goto error;
  }
  if (document->nodes.start == document->nodes.top) {
    int tmp_0;
    tmp_0 = yaml_emitter_close(emitter);
    if (! tmp_0) goto error;
    yaml_emitter_delete_document_and_anchors(emitter);
    __retres = 1;
    goto return_label;
  }
  __FC_assert(emitter->opened != 0,"src/dumper.c",132,"emitter->opened");
  emitter->anchors = (yaml_anchors_t *)yaml_malloc(sizeof(*(emitter->anchors)) * (unsigned long)(
                                                   document->nodes.top - document->nodes.start));
  if (! emitter->anchors) goto error;
  memset((void *)emitter->anchors,0,
         sizeof(*(emitter->anchors)) * (unsigned long)(document->nodes.top - document->nodes.start));
  memset((void *)(& event),0,sizeof(yaml_event_t));
  event.type = YAML_DOCUMENT_START_EVENT;
  event.start_mark = mark;
  event.end_mark = mark;
  event.data.document_start.version_directive = document->version_directive;
  event.data.document_start.tag_directives.start = document->tag_directives.start;
  event.data.document_start.tag_directives.end = document->tag_directives.end;
  event.data.document_start.implicit = document->start_implicit;
  tmp_2 = yaml_emitter_emit(emitter,& event);
  if (! tmp_2) goto error;
  yaml_emitter_anchor_node(emitter,1);
  tmp_3 = yaml_emitter_dump_node(emitter,1);
  if (! tmp_3) goto error;
  memset((void *)(& event),0,sizeof(yaml_event_t));
  event.type = YAML_DOCUMENT_END_EVENT;
  event.start_mark = mark;
  event.end_mark = mark;
  event.data.document_end.implicit = document->end_implicit;
  tmp_4 = yaml_emitter_emit(emitter,& event);
  if (! tmp_4) goto error;
  yaml_emitter_delete_document_and_anchors(emitter);
  __retres = 1;
  goto return_label;
  error: yaml_emitter_delete_document_and_anchors(emitter);
  __retres = 0;
  return_label: return __retres;
}

static void yaml_emitter_delete_document_and_anchors(yaml_emitter_t *emitter)
{
  int index_0;
  yaml_node_t *tmp_0;
  yaml_node_t *tmp;
  if (! emitter->anchors) {
    yaml_document_delete(emitter->document);
    emitter->document = (yaml_document_t *)0;
    goto return_label;
  }
  index_0 = 0;
  while ((emitter->document)->nodes.start + index_0 < (emitter->document)->nodes.top) {
    {
      yaml_node_t node = *((emitter->document)->nodes.start + index_0);
      if (! (emitter->anchors + index_0)->serialized) {
        yaml_free((void *)node.tag);
        if (node.type == (unsigned int)YAML_SCALAR_NODE) yaml_free((void *)node.data.scalar.value);
      }
      if (node.type == (unsigned int)YAML_SEQUENCE_NODE) {
        yaml_free((void *)node.data.sequence.items.start);
        node.data.sequence.items.end = (yaml_node_item_t *)0;
        node.data.sequence.items.top = node.data.sequence.items.end;
        node.data.sequence.items.start = node.data.sequence.items.top;
      }
      if (node.type == (unsigned int)YAML_MAPPING_NODE) {
        yaml_free((void *)node.data.mapping.pairs.start);
        node.data.mapping.pairs.end = (yaml_node_pair_t *)0;
        node.data.mapping.pairs.top = node.data.mapping.pairs.end;
        node.data.mapping.pairs.start = node.data.mapping.pairs.top;
      }
    }
    index_0 ++;
  }
  yaml_free((void *)(emitter->document)->nodes.start);
  tmp_0 = (yaml_node_t *)0;
  (emitter->document)->nodes.end = tmp_0;
  tmp = tmp_0;
  (emitter->document)->nodes.top = tmp;
  (emitter->document)->nodes.start = tmp;
  yaml_free((void *)emitter->anchors);
  emitter->anchors = (yaml_anchors_t *)0;
  emitter->last_anchor_id = 0;
  emitter->document = (yaml_document_t *)0;
  return_label: return;
}

static void yaml_emitter_anchor_node(yaml_emitter_t *emitter, int index_0)
{
  yaml_node_item_t *item;
  yaml_node_pair_t *pair;
  yaml_node_t *node = ((emitter->document)->nodes.start + index_0) - 1;
  ((emitter->anchors + (index_0 - 1))->references) ++;
  if ((emitter->anchors + (index_0 - 1))->references == 1) 
    switch (node->type) {
      case YAML_SEQUENCE_NODE: item = node->data.sequence.items.start;
      while (item < node->data.sequence.items.top) {
        yaml_emitter_anchor_node(emitter,*item);
        item ++;
      }
      break;
      case YAML_MAPPING_NODE: pair = node->data.mapping.pairs.start;
      while (pair < node->data.mapping.pairs.top) {
        yaml_emitter_anchor_node(emitter,pair->key);
        yaml_emitter_anchor_node(emitter,pair->value);
        pair ++;
      }
      break;
      default: break;
    }
  else 
    if ((emitter->anchors + (index_0 - 1))->references == 2) {
      (emitter->last_anchor_id) ++;
      (emitter->anchors + (index_0 - 1))->anchor = emitter->last_anchor_id;
    }
  return;
}

/*@ requires valid_read_string(format);
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: *(format + (0 ..))), (indirect: param0);
    assigns *(s + (0 ..)) \from (indirect: *(format + (0 ..))), param0;
 */
int sprintf_va_1(char * restrict s, char const * restrict format, int param0);

static yaml_char_t *yaml_emitter_generate_anchor(yaml_emitter_t *emitter __attribute__((
                                                 __unused__)), int anchor_id)
{
  yaml_char_t *__retres;
  yaml_char_t *anchor = yaml_malloc((size_t)16);
  if (! anchor) {
    __retres = (yaml_char_t *)0;
    goto return_label;
  }
  sprintf((char *)anchor,"id%03d",anchor_id); /* sprintf_va_1 */
  __retres = anchor;
  return_label: return __retres;
}

static int yaml_emitter_dump_node(yaml_emitter_t *emitter, int index_0)
{
  int __retres;
  yaml_node_t *node = ((emitter->document)->nodes.start + index_0) - 1;
  int anchor_id = (emitter->anchors + (index_0 - 1))->anchor;
  yaml_char_t *anchor = (yaml_char_t *)0;
  if (anchor_id) {
    anchor = yaml_emitter_generate_anchor(emitter,anchor_id);
    if (! anchor) {
      __retres = 0;
      goto return_label;
    }
  }
  if ((emitter->anchors + (index_0 - 1))->serialized) {
    int tmp;
    tmp = yaml_emitter_dump_alias(emitter,anchor);
    __retres = tmp;
    goto return_label;
  }
  (emitter->anchors + (index_0 - 1))->serialized = 1;
  switch (node->type) {
    int tmp_0;
    int tmp_1;
    int tmp_2;
    case YAML_SCALAR_NODE:
    tmp_0 = yaml_emitter_dump_scalar(emitter,node,anchor);
    __retres = tmp_0;
    goto return_label;
    case YAML_SEQUENCE_NODE:
    tmp_1 = yaml_emitter_dump_sequence(emitter,node,anchor);
    __retres = tmp_1;
    goto return_label;
    case YAML_MAPPING_NODE:
    tmp_2 = yaml_emitter_dump_mapping(emitter,node,anchor);
    __retres = tmp_2;
    goto return_label;
    default: __FC_assert(0 != 0,"src/dumper.c",289,"0");
    break;
  }
  __retres = 0;
  return_label: return __retres;
}

static int yaml_emitter_dump_alias(yaml_emitter_t *emitter,
                                   yaml_char_t *anchor)
{
  yaml_event_t event;
  int tmp;
  yaml_mark_t mark =
    {.index = (size_t)0, .line = (size_t)0, .column = (size_t)0};
  memset((void *)(& event),0,sizeof(yaml_event_t));
  event.type = YAML_ALIAS_EVENT;
  event.start_mark = mark;
  event.end_mark = mark;
  event.data.alias.anchor = anchor;
  tmp = yaml_emitter_emit(emitter,& event);
  return tmp;
}

static int yaml_emitter_dump_scalar(yaml_emitter_t *emitter,
                                    yaml_node_t *node, yaml_char_t *anchor)
{
  yaml_event_t event;
  int tmp;
  int tmp_0;
  int tmp_1;
  yaml_mark_t mark =
    {.index = (size_t)0, .line = (size_t)0, .column = (size_t)0};
  tmp = strcmp((char const *)node->tag,"tag:yaml.org,2002:str");
  int plain_implicit = tmp == 0;
  tmp_0 = strcmp((char const *)node->tag,"tag:yaml.org,2002:str");
  int quoted_implicit = tmp_0 == 0;
  memset((void *)(& event),0,sizeof(yaml_event_t));
  event.type = YAML_SCALAR_EVENT;
  event.start_mark = mark;
  event.end_mark = mark;
  event.data.scalar.anchor = anchor;
  event.data.scalar.tag = node->tag;
  event.data.scalar.value = node->data.scalar.value;
  event.data.scalar.length = node->data.scalar.length;
  event.data.scalar.plain_implicit = plain_implicit;
  event.data.scalar.quoted_implicit = quoted_implicit;
  event.data.scalar.style = node->data.scalar.style;
  tmp_1 = yaml_emitter_emit(emitter,& event);
  return tmp_1;
}

static int yaml_emitter_dump_sequence(yaml_emitter_t *emitter,
                                      yaml_node_t *node, yaml_char_t *anchor)
{
  int __retres;
  yaml_event_t event;
  int tmp;
  yaml_node_item_t *item;
  int tmp_0;
  int tmp_2;
  yaml_mark_t mark =
    {.index = (size_t)0, .line = (size_t)0, .column = (size_t)0};
  tmp = strcmp((char const *)node->tag,"tag:yaml.org,2002:seq");
  int implicit = tmp == 0;
  memset((void *)(& event),0,sizeof(yaml_event_t));
  event.type = YAML_SEQUENCE_START_EVENT;
  event.start_mark = mark;
  event.end_mark = mark;
  event.data.sequence_start.anchor = anchor;
  event.data.sequence_start.tag = node->tag;
  event.data.sequence_start.implicit = implicit;
  event.data.sequence_start.style = node->data.sequence.style;
  tmp_0 = yaml_emitter_emit(emitter,& event);
  if (! tmp_0) {
    __retres = 0;
    goto return_label;
  }
  item = node->data.sequence.items.start;
  while (item < node->data.sequence.items.top) {
    {
      int tmp_1;
      tmp_1 = yaml_emitter_dump_node(emitter,*item);
      if (! tmp_1) {
        __retres = 0;
        goto return_label;
      }
    }
    item ++;
  }
  memset((void *)(& event),0,sizeof(yaml_event_t));
  event.type = YAML_SEQUENCE_END_EVENT;
  event.start_mark = mark;
  event.end_mark = mark;
  tmp_2 = yaml_emitter_emit(emitter,& event);
  if (! tmp_2) {
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_dump_mapping(yaml_emitter_t *emitter,
                                     yaml_node_t *node, yaml_char_t *anchor)
{
  int __retres;
  yaml_event_t event;
  int tmp;
  yaml_node_pair_t *pair;
  int tmp_0;
  int tmp_3;
  yaml_mark_t mark =
    {.index = (size_t)0, .line = (size_t)0, .column = (size_t)0};
  tmp = strcmp((char const *)node->tag,"tag:yaml.org,2002:map");
  int implicit = tmp == 0;
  memset((void *)(& event),0,sizeof(yaml_event_t));
  event.type = YAML_MAPPING_START_EVENT;
  event.start_mark = mark;
  event.end_mark = mark;
  event.data.mapping_start.anchor = anchor;
  event.data.mapping_start.tag = node->tag;
  event.data.mapping_start.implicit = implicit;
  event.data.mapping_start.style = node->data.mapping.style;
  tmp_0 = yaml_emitter_emit(emitter,& event);
  if (! tmp_0) {
    __retres = 0;
    goto return_label;
  }
  pair = node->data.mapping.pairs.start;
  while (pair < node->data.mapping.pairs.top) {
    {
      int tmp_1;
      int tmp_2;
      tmp_1 = yaml_emitter_dump_node(emitter,pair->key);
      if (! tmp_1) {
        __retres = 0;
        goto return_label;
      }
      tmp_2 = yaml_emitter_dump_node(emitter,pair->value);
      if (! tmp_2) {
        __retres = 0;
        goto return_label;
      }
    }
    pair ++;
  }
  memset((void *)(& event),0,sizeof(yaml_event_t));
  event.type = YAML_MAPPING_END_EVENT;
  event.start_mark = mark;
  event.end_mark = mark;
  tmp_3 = yaml_emitter_emit(emitter,& event);
  if (! tmp_3) {
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_set_emitter_error(yaml_emitter_t *emitter,
                                          char const *problem);

static int yaml_emitter_need_more_events(yaml_emitter_t *emitter);

static int yaml_emitter_append_tag_directive(yaml_emitter_t *emitter,
                                             yaml_tag_directive_t value,
                                             int allow_duplicates);

static int yaml_emitter_increase_indent(yaml_emitter_t *emitter, int flow,
                                        int indentless);

static int yaml_emitter_state_machine(yaml_emitter_t *emitter,
                                      yaml_event_t *event);

static int yaml_emitter_emit_stream_start(yaml_emitter_t *emitter,
                                          yaml_event_t *event);

static int yaml_emitter_emit_document_start(yaml_emitter_t *emitter,
                                            yaml_event_t *event, int first);

static int yaml_emitter_emit_document_content(yaml_emitter_t *emitter,
                                              yaml_event_t *event);

static int yaml_emitter_emit_document_end(yaml_emitter_t *emitter,
                                          yaml_event_t *event);

static int yaml_emitter_emit_flow_sequence_item(yaml_emitter_t *emitter,
                                                yaml_event_t *event,
                                                int first);

static int yaml_emitter_emit_flow_mapping_key(yaml_emitter_t *emitter,
                                              yaml_event_t *event, int first);

static int yaml_emitter_emit_flow_mapping_value(yaml_emitter_t *emitter,
                                                yaml_event_t *event,
                                                int simple);

static int yaml_emitter_emit_block_sequence_item(yaml_emitter_t *emitter,
                                                 yaml_event_t *event,
                                                 int first);

static int yaml_emitter_emit_block_mapping_key(yaml_emitter_t *emitter,
                                               yaml_event_t *event, int first);

static int yaml_emitter_emit_block_mapping_value(yaml_emitter_t *emitter,
                                                 yaml_event_t *event,
                                                 int simple);

static int yaml_emitter_emit_node(yaml_emitter_t *emitter,
                                  yaml_event_t *event, int root,
                                  int sequence, int mapping, int simple_key);

static int yaml_emitter_emit_alias(yaml_emitter_t *emitter,
                                   yaml_event_t *event __attribute__((
                                   __unused__)));

static int yaml_emitter_emit_scalar(yaml_emitter_t *emitter,
                                    yaml_event_t *event);

static int yaml_emitter_emit_sequence_start(yaml_emitter_t *emitter,
                                            yaml_event_t *event);

static int yaml_emitter_emit_mapping_start(yaml_emitter_t *emitter,
                                           yaml_event_t *event);

static int yaml_emitter_check_empty_document(yaml_emitter_t *emitter __attribute__((
                                             __unused__)));

static int yaml_emitter_check_empty_sequence(yaml_emitter_t *emitter);

static int yaml_emitter_check_empty_mapping(yaml_emitter_t *emitter);

static int yaml_emitter_check_simple_key(yaml_emitter_t *emitter);

static int yaml_emitter_select_scalar_style(yaml_emitter_t *emitter,
                                            yaml_event_t *event);

static int yaml_emitter_process_anchor(yaml_emitter_t *emitter);

static int yaml_emitter_process_tag(yaml_emitter_t *emitter);

static int yaml_emitter_process_scalar(yaml_emitter_t *emitter);

static int yaml_emitter_analyze_version_directive(yaml_emitter_t *emitter,
                                                  yaml_version_directive_t version_directive);

static int yaml_emitter_analyze_tag_directive(yaml_emitter_t *emitter,
                                              yaml_tag_directive_t tag_directive);

static int yaml_emitter_analyze_anchor(yaml_emitter_t *emitter,
                                       yaml_char_t *anchor, int alias);

static int yaml_emitter_analyze_tag(yaml_emitter_t *emitter, yaml_char_t *tag);

static int yaml_emitter_analyze_scalar(yaml_emitter_t *emitter,
                                       yaml_char_t *value, size_t length);

static int yaml_emitter_analyze_event(yaml_emitter_t *emitter,
                                      yaml_event_t *event);

static int yaml_emitter_write_bom(yaml_emitter_t *emitter);

static int yaml_emitter_write_indent(yaml_emitter_t *emitter);

static int yaml_emitter_write_indicator(yaml_emitter_t *emitter,
                                        char const *indicator,
                                        int need_whitespace,
                                        int is_whitespace, int is_indention);

static int yaml_emitter_write_anchor(yaml_emitter_t *emitter,
                                     yaml_char_t *value, size_t length);

static int yaml_emitter_write_tag_handle(yaml_emitter_t *emitter,
                                         yaml_char_t *value, size_t length);

static int yaml_emitter_write_tag_content(yaml_emitter_t *emitter,
                                          yaml_char_t *value, size_t length,
                                          int need_whitespace);

static int yaml_emitter_write_plain_scalar(yaml_emitter_t *emitter,
                                           yaml_char_t *value, size_t length,
                                           int allow_breaks);

static int yaml_emitter_write_single_quoted_scalar(yaml_emitter_t *emitter,
                                                   yaml_char_t *value,
                                                   size_t length,
                                                   int allow_breaks);

static int yaml_emitter_write_double_quoted_scalar(yaml_emitter_t *emitter,
                                                   yaml_char_t *value,
                                                   size_t length,
                                                   int allow_breaks);

static int yaml_emitter_write_block_scalar_hints(yaml_emitter_t *emitter,
                                                 yaml_string_t string);

static int yaml_emitter_write_literal_scalar(yaml_emitter_t *emitter,
                                             yaml_char_t *value,
                                             size_t length);

static int yaml_emitter_write_folded_scalar(yaml_emitter_t *emitter,
                                            yaml_char_t *value, size_t length);

static int yaml_emitter_set_emitter_error(yaml_emitter_t *emitter,
                                          char const *problem)
{
  int __retres;
  emitter->error = YAML_EMITTER_ERROR;
  emitter->problem = problem;
  __retres = 0;
  return __retres;
}

int yaml_emitter_emit(yaml_emitter_t *emitter, yaml_event_t *event)
{
  int __retres;
  int tmp_1;
  if (emitter->events.tail != emitter->events.end) goto _LOR;
  else {
    int tmp;
    tmp = yaml_queue_extend((void **)(& emitter->events.start),
                            (void **)(& emitter->events.head),
                            (void **)(& emitter->events.tail),
                            (void **)(& emitter->events.end));
    if (tmp) {
      yaml_event_t *tmp_0;
      _LOR: tmp_0 = emitter->events.tail;
      (emitter->events.tail) ++;
      *tmp_0 = *event;
      tmp_1 = 1;
    }
    else {
      emitter->error = YAML_MEMORY_ERROR;
      tmp_1 = 0;
    }
  }
  if (! tmp_1) {
    yaml_event_delete(event);
    __retres = 0;
    goto return_label;
  }
  while (1) {
    int tmp_5;
    tmp_5 = yaml_emitter_need_more_events(emitter);
    if (tmp_5) break;
    {
      int tmp_2;
      int tmp_3;
      yaml_event_t *tmp_4;
      tmp_2 = yaml_emitter_analyze_event(emitter,emitter->events.head);
      if (! tmp_2) {
        __retres = 0;
        goto return_label;
      }
      tmp_3 = yaml_emitter_state_machine(emitter,emitter->events.head);
      if (! tmp_3) {
        __retres = 0;
        goto return_label;
      }
      tmp_4 = emitter->events.head;
      (emitter->events.head) ++;
      ;
      yaml_event_delete(tmp_4);
    }
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_need_more_events(yaml_emitter_t *emitter)
{
  int __retres;
  yaml_event_t *event;
  int level = 0;
  int accumulate = 0;
  if (emitter->events.head == emitter->events.tail) {
    __retres = 1;
    goto return_label;
  }
  switch ((emitter->events.head)->type) {
    case YAML_DOCUMENT_START_EVENT: accumulate = 1;
    break;
    case YAML_SEQUENCE_START_EVENT: accumulate = 2;
    break;
    case YAML_MAPPING_START_EVENT: accumulate = 3;
    break;
    default: __retres = 0;
    goto return_label;
  }
  if (emitter->events.tail - emitter->events.head > (long)accumulate) {
    __retres = 0;
    goto return_label;
  }
  event = emitter->events.head;
  while (event != emitter->events.tail) {
    switch (event->type) {
      case YAML_STREAM_START_EVENT: case YAML_DOCUMENT_START_EVENT:
      case YAML_SEQUENCE_START_EVENT: case YAML_MAPPING_START_EVENT:
      level ++;
      break;
      case YAML_STREAM_END_EVENT: case YAML_DOCUMENT_END_EVENT:
      case YAML_SEQUENCE_END_EVENT: case YAML_MAPPING_END_EVENT:
      level --;
      break;
      default: break;
    }
    if (! level) {
      __retres = 0;
      goto return_label;
    }
    event ++;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_append_tag_directive(yaml_emitter_t *emitter,
                                             yaml_tag_directive_t value,
                                             int allow_duplicates)
{
  int __retres;
  yaml_tag_directive_t *tag_directive;
  int tmp_3;
  yaml_tag_directive_t copy =
    {.handle = (yaml_char_t *)0, .prefix = (yaml_char_t *)0};
  tag_directive = emitter->tag_directives.start;
  while (tag_directive != emitter->tag_directives.top) {
    {
      int tmp_0;
      tmp_0 = strcmp((char const *)value.handle,
                     (char const *)tag_directive->handle);
      if (tmp_0 == 0) {
        int tmp;
        if (allow_duplicates) {
          __retres = 1;
          goto return_label;
        }
        tmp = yaml_emitter_set_emitter_error(emitter,
                                             "duplicate %TAG directive");
        __retres = tmp;
        goto return_label;
      }
    }
    tag_directive ++;
  }
  copy.handle = yaml_strdup((yaml_char_t const *)value.handle);
  copy.prefix = yaml_strdup((yaml_char_t const *)value.prefix);
  if (! copy.handle) goto _LOR;
  else 
    if (! copy.prefix) {
      _LOR: {
              emitter->error = YAML_MEMORY_ERROR;
              goto error;
            }
    }
  if (emitter->tag_directives.top != emitter->tag_directives.end) goto _LOR_0;
  else {
    int tmp_1;
    tmp_1 = yaml_stack_extend((void **)(& emitter->tag_directives.start),
                              (void **)(& emitter->tag_directives.top),
                              (void **)(& emitter->tag_directives.end));
    if (tmp_1) {
      yaml_tag_directive_t *tmp_2;
      _LOR_0: tmp_2 = emitter->tag_directives.top;
      (emitter->tag_directives.top) ++;
      *tmp_2 = copy;
      tmp_3 = 1;
    }
    else {
      emitter->error = YAML_MEMORY_ERROR;
      tmp_3 = 0;
    }
  }
  if (! tmp_3) goto error;
  __retres = 1;
  goto return_label;
  error: yaml_free((void *)copy.handle);
  yaml_free((void *)copy.prefix);
  __retres = 0;
  return_label: return __retres;
}

static int yaml_emitter_increase_indent(yaml_emitter_t *emitter, int flow,
                                        int indentless)
{
  int __retres;
  int tmp_1;
  if (emitter->indents.top != emitter->indents.end) goto _LOR;
  else {
    int tmp;
    tmp = yaml_stack_extend((void **)(& emitter->indents.start),
                            (void **)(& emitter->indents.top),
                            (void **)(& emitter->indents.end));
    if (tmp) {
      int *tmp_0;
      _LOR: tmp_0 = emitter->indents.top;
      (emitter->indents.top) ++;
      *tmp_0 = emitter->indent;
      tmp_1 = 1;
    }
    else {
      emitter->error = YAML_MEMORY_ERROR;
      tmp_1 = 0;
    }
  }
  if (! tmp_1) {
    __retres = 0;
    goto return_label;
  }
  if (emitter->indent < 0) 
    if (flow) emitter->indent = emitter->best_indent;
    else emitter->indent = 0;
  else 
    if (! indentless) emitter->indent += emitter->best_indent;
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_state_machine(yaml_emitter_t *emitter,
                                      yaml_event_t *event)
{
  int __retres;
  switch (emitter->state) {
    int tmp;
    int tmp_0;
    int tmp_1;
    int tmp_2;
    int tmp_3;
    int tmp_4;
    int tmp_5;
    int tmp_6;
    int tmp_7;
    int tmp_8;
    int tmp_9;
    int tmp_10;
    int tmp_11;
    int tmp_12;
    int tmp_13;
    int tmp_14;
    int tmp_15;
    int tmp_16;
    case YAML_EMIT_STREAM_START_STATE:
    tmp = yaml_emitter_emit_stream_start(emitter,event);
    __retres = tmp;
    goto return_label;
    case YAML_EMIT_FIRST_DOCUMENT_START_STATE:
    tmp_0 = yaml_emitter_emit_document_start(emitter,event,1);
    __retres = tmp_0;
    goto return_label;
    case YAML_EMIT_DOCUMENT_START_STATE:
    tmp_1 = yaml_emitter_emit_document_start(emitter,event,0);
    __retres = tmp_1;
    goto return_label;
    case YAML_EMIT_DOCUMENT_CONTENT_STATE:
    tmp_2 = yaml_emitter_emit_document_content(emitter,event);
    __retres = tmp_2;
    goto return_label;
    case YAML_EMIT_DOCUMENT_END_STATE:
    tmp_3 = yaml_emitter_emit_document_end(emitter,event);
    __retres = tmp_3;
    goto return_label;
    case YAML_EMIT_FLOW_SEQUENCE_FIRST_ITEM_STATE:
    tmp_4 = yaml_emitter_emit_flow_sequence_item(emitter,event,1);
    __retres = tmp_4;
    goto return_label;
    case YAML_EMIT_FLOW_SEQUENCE_ITEM_STATE:
    tmp_5 = yaml_emitter_emit_flow_sequence_item(emitter,event,0);
    __retres = tmp_5;
    goto return_label;
    case YAML_EMIT_FLOW_MAPPING_FIRST_KEY_STATE:
    tmp_6 = yaml_emitter_emit_flow_mapping_key(emitter,event,1);
    __retres = tmp_6;
    goto return_label;
    case YAML_EMIT_FLOW_MAPPING_KEY_STATE:
    tmp_7 = yaml_emitter_emit_flow_mapping_key(emitter,event,0);
    __retres = tmp_7;
    goto return_label;
    case YAML_EMIT_FLOW_MAPPING_SIMPLE_VALUE_STATE:
    tmp_8 = yaml_emitter_emit_flow_mapping_value(emitter,event,1);
    __retres = tmp_8;
    goto return_label;
    case YAML_EMIT_FLOW_MAPPING_VALUE_STATE:
    tmp_9 = yaml_emitter_emit_flow_mapping_value(emitter,event,0);
    __retres = tmp_9;
    goto return_label;
    case YAML_EMIT_BLOCK_SEQUENCE_FIRST_ITEM_STATE:
    tmp_10 = yaml_emitter_emit_block_sequence_item(emitter,event,1);
    __retres = tmp_10;
    goto return_label;
    case YAML_EMIT_BLOCK_SEQUENCE_ITEM_STATE:
    tmp_11 = yaml_emitter_emit_block_sequence_item(emitter,event,0);
    __retres = tmp_11;
    goto return_label;
    case YAML_EMIT_BLOCK_MAPPING_FIRST_KEY_STATE:
    tmp_12 = yaml_emitter_emit_block_mapping_key(emitter,event,1);
    __retres = tmp_12;
    goto return_label;
    case YAML_EMIT_BLOCK_MAPPING_KEY_STATE:
    tmp_13 = yaml_emitter_emit_block_mapping_key(emitter,event,0);
    __retres = tmp_13;
    goto return_label;
    case YAML_EMIT_BLOCK_MAPPING_SIMPLE_VALUE_STATE:
    tmp_14 = yaml_emitter_emit_block_mapping_value(emitter,event,1);
    __retres = tmp_14;
    goto return_label;
    case YAML_EMIT_BLOCK_MAPPING_VALUE_STATE:
    tmp_15 = yaml_emitter_emit_block_mapping_value(emitter,event,0);
    __retres = tmp_15;
    goto return_label;
    case YAML_EMIT_END_STATE:
    tmp_16 = yaml_emitter_set_emitter_error(emitter,
                                            "expected nothing after STREAM-END");
    __retres = tmp_16;
    goto return_label;
    default: __FC_assert(1 != 0,"src/emitter.c",484,"1");
  }
  __retres = 0;
  return_label: return __retres;
}

static int yaml_emitter_emit_stream_start(yaml_emitter_t *emitter,
                                          yaml_event_t *event)
{
  int __retres;
  int tmp_0;
  emitter->open_ended = 0;
  if (event->type == (unsigned int)YAML_STREAM_START_EVENT) {
    if (! emitter->encoding) emitter->encoding = event->data.stream_start.encoding;
    if (! emitter->encoding) emitter->encoding = YAML_UTF8_ENCODING;
    if (emitter->best_indent < 2) goto _LOR;
    else 
      if (emitter->best_indent > 9) _LOR: emitter->best_indent = 2;
    if (emitter->best_width >= 0) 
      if (emitter->best_width <= emitter->best_indent * 2) emitter->best_width = 80;
    if (emitter->best_width < 0) emitter->best_width = 2147483647;
    if (! emitter->line_break) emitter->line_break = YAML_LN_BREAK;
    emitter->indent = -1;
    emitter->line = 0;
    emitter->column = 0;
    emitter->whitespace = 1;
    emitter->indention = 1;
    if (emitter->encoding != (unsigned int)YAML_UTF8_ENCODING) {
      int tmp;
      tmp = yaml_emitter_write_bom(emitter);
      if (! tmp) {
        __retres = 0;
        goto return_label;
      }
    }
    emitter->state = YAML_EMIT_FIRST_DOCUMENT_START_STATE;
    __retres = 1;
    goto return_label;
  }
  tmp_0 = yaml_emitter_set_emitter_error(emitter,"expected STREAM-START");
  __retres = tmp_0;
  return_label: return __retres;
}

static int yaml_emitter_emit_document_start(yaml_emitter_t *emitter,
                                            yaml_event_t *event, int first)
{
  int __retres;
  int tmp_22;
  if (event->type == (unsigned int)YAML_DOCUMENT_START_EVENT) {
    yaml_tag_directive_t *tag_directive;
    int implicit;
    int tmp_15;
    yaml_tag_directive_t default_tag_directives[3] =
      {{.handle = (yaml_char_t *)"!", .prefix = (yaml_char_t *)"!"},
       {.handle = (yaml_char_t *)"!!",
        .prefix = (yaml_char_t *)"tag:yaml.org,2002:"},
       {.handle = (yaml_char_t *)0, .prefix = (yaml_char_t *)0}};
    if (event->data.document_start.version_directive) {
      int tmp;
      tmp = yaml_emitter_analyze_version_directive(emitter,
                                                   *(event->data.document_start.version_directive));
      if (! tmp) {
        __retres = 0;
        goto return_label;
      }
    }
    tag_directive = event->data.document_start.tag_directives.start;
    while (tag_directive != event->data.document_start.tag_directives.end) {
      {
        int tmp_0;
        int tmp_1;
        tmp_0 = yaml_emitter_analyze_tag_directive(emitter,*tag_directive);
        if (! tmp_0) {
          __retres = 0;
          goto return_label;
        }
        tmp_1 = yaml_emitter_append_tag_directive(emitter,*tag_directive,0);
        if (! tmp_1) {
          __retres = 0;
          goto return_label;
        }
      }
      tag_directive ++;
    }
    tag_directive = default_tag_directives;
    while (tag_directive->handle) {
      {
        int tmp_2;
        tmp_2 = yaml_emitter_append_tag_directive(emitter,*tag_directive,1);
        if (! tmp_2) {
          __retres = 0;
          goto return_label;
        }
      }
      tag_directive ++;
    }
    implicit = event->data.document_start.implicit;
    if (! first) goto _LOR;
    else 
      if (emitter->canonical) _LOR: implicit = 0;
    if (event->data.document_start.version_directive) goto _LOR_0;
    else 
      if (event->data.document_start.tag_directives.start != event->data.document_start.tag_directives.end) {
        _LOR_0: ;
        if (emitter->open_ended) {
          int tmp_3;
          int tmp_4;
          tmp_3 = yaml_emitter_write_indicator(emitter,"...",1,0,0);
          if (! tmp_3) {
            __retres = 0;
            goto return_label;
          }
          tmp_4 = yaml_emitter_write_indent(emitter);
          if (! tmp_4) {
            __retres = 0;
            goto return_label;
          }
        }
      }
    emitter->open_ended = 0;
    if (event->data.document_start.version_directive) {
      int tmp_5;
      int tmp_8;
      implicit = 0;
      tmp_5 = yaml_emitter_write_indicator(emitter,"%YAML",1,0,0);
      if (! tmp_5) {
        __retres = 0;
        goto return_label;
      }
      if ((event->data.document_start.version_directive)->minor == 1) {
        int tmp_6;
        tmp_6 = yaml_emitter_write_indicator(emitter,"1.1",1,0,0);
        if (! tmp_6) {
          __retres = 0;
          goto return_label;
        }
      }
      else {
        int tmp_7;
        tmp_7 = yaml_emitter_write_indicator(emitter,"1.2",1,0,0);
        if (! tmp_7) {
          __retres = 0;
          goto return_label;
        }
      }
      tmp_8 = yaml_emitter_write_indent(emitter);
      if (! tmp_8) {
        __retres = 0;
        goto return_label;
      }
    }
    if (event->data.document_start.tag_directives.start != event->data.document_start.tag_directives.end) {
      implicit = 0;
      tag_directive = event->data.document_start.tag_directives.start;
      while (tag_directive != event->data.document_start.tag_directives.end) {
        {
          int tmp_9;
          int tmp_11;
          size_t tmp_10;
          int tmp_13;
          size_t tmp_12;
          int tmp_14;
          tmp_9 = yaml_emitter_write_indicator(emitter,"%TAG",1,0,0);
          if (! tmp_9) {
            __retres = 0;
            goto return_label;
          }
          tmp_10 = strlen((char const *)tag_directive->handle);
          ;
          ;
          tmp_11 = yaml_emitter_write_tag_handle(emitter,
                                                 tag_directive->handle,
                                                 tmp_10);
          if (! tmp_11) {
            __retres = 0;
            goto return_label;
          }
          tmp_12 = strlen((char const *)tag_directive->prefix);
          ;
          ;
          tmp_13 = yaml_emitter_write_tag_content(emitter,
                                                  tag_directive->prefix,
                                                  tmp_12,1);
          if (! tmp_13) {
            __retres = 0;
            goto return_label;
          }
          tmp_14 = yaml_emitter_write_indent(emitter);
          if (! tmp_14) {
            __retres = 0;
            goto return_label;
          }
        }
        tag_directive ++;
      }
    }
    tmp_15 = yaml_emitter_check_empty_document(emitter);
    if (tmp_15) implicit = 0;
    if (! implicit) {
      int tmp_16;
      int tmp_17;
      tmp_16 = yaml_emitter_write_indent(emitter);
      if (! tmp_16) {
        __retres = 0;
        goto return_label;
      }
      tmp_17 = yaml_emitter_write_indicator(emitter,"---",1,0,0);
      if (! tmp_17) {
        __retres = 0;
        goto return_label;
      }
      if (emitter->canonical) {
        int tmp_18;
        tmp_18 = yaml_emitter_write_indent(emitter);
        if (! tmp_18) {
          __retres = 0;
          goto return_label;
        }
      }
    }
    emitter->state = YAML_EMIT_DOCUMENT_CONTENT_STATE;
    emitter->open_ended = 0;
    __retres = 1;
    goto return_label;
  }
  else 
    if (event->type == (unsigned int)YAML_STREAM_END_EVENT) {
      int tmp_21;
      if (emitter->open_ended == 2) {
        int tmp_19;
        int tmp_20;
        tmp_19 = yaml_emitter_write_indicator(emitter,"...",1,0,0);
        if (! tmp_19) {
          __retres = 0;
          goto return_label;
        }
        emitter->open_ended = 0;
        tmp_20 = yaml_emitter_write_indent(emitter);
        if (! tmp_20) {
          __retres = 0;
          goto return_label;
        }
      }
      tmp_21 = yaml_emitter_flush(emitter);
      if (! tmp_21) {
        __retres = 0;
        goto return_label;
      }
      emitter->state = YAML_EMIT_END_STATE;
      __retres = 1;
      goto return_label;
    }
  tmp_22 = yaml_emitter_set_emitter_error(emitter,
                                          "expected DOCUMENT-START or STREAM-END");
  __retres = tmp_22;
  return_label: return __retres;
}

static int yaml_emitter_emit_document_content(yaml_emitter_t *emitter,
                                              yaml_event_t *event)
{
  int __retres;
  int tmp_1;
  int tmp_2;
  if (emitter->states.top != emitter->states.end) goto _LOR;
  else {
    int tmp;
    tmp = yaml_stack_extend((void **)(& emitter->states.start),
                            (void **)(& emitter->states.top),
                            (void **)(& emitter->states.end));
    if (tmp) {
      yaml_emitter_state_t *tmp_0;
      _LOR: tmp_0 = emitter->states.top;
      (emitter->states.top) ++;
      *tmp_0 = YAML_EMIT_DOCUMENT_END_STATE;
      tmp_1 = 1;
    }
    else {
      emitter->error = YAML_MEMORY_ERROR;
      tmp_1 = 0;
    }
  }
  if (! tmp_1) {
    __retres = 0;
    goto return_label;
  }
  tmp_2 = yaml_emitter_emit_node(emitter,event,1,0,0,0);
  __retres = tmp_2;
  return_label: return __retres;
}

static int yaml_emitter_emit_document_end(yaml_emitter_t *emitter,
                                          yaml_event_t *event)
{
  int __retres;
  int tmp_3;
  if (event->type == (unsigned int)YAML_DOCUMENT_END_EVENT) {
    int tmp;
    int tmp_2;
    tmp = yaml_emitter_write_indent(emitter);
    if (! tmp) {
      __retres = 0;
      goto return_label;
    }
    if (! event->data.document_end.implicit) {
      int tmp_0;
      int tmp_1;
      tmp_0 = yaml_emitter_write_indicator(emitter,"...",1,0,0);
      if (! tmp_0) {
        __retres = 0;
        goto return_label;
      }
      emitter->open_ended = 0;
      tmp_1 = yaml_emitter_write_indent(emitter);
      if (! tmp_1) {
        __retres = 0;
        goto return_label;
      }
    }
    else 
      if (! emitter->open_ended) emitter->open_ended = 1;
    tmp_2 = yaml_emitter_flush(emitter);
    if (! tmp_2) {
      __retres = 0;
      goto return_label;
    }
    emitter->state = YAML_EMIT_DOCUMENT_START_STATE;
    while (! (emitter->tag_directives.start == emitter->tag_directives.top)) {
      (emitter->tag_directives.top) --;
      yaml_tag_directive_t tag_directive = *(emitter->tag_directives.top);
      yaml_free((void *)tag_directive.handle);
      yaml_free((void *)tag_directive.prefix);
    }
    __retres = 1;
    goto return_label;
  }
  tmp_3 = yaml_emitter_set_emitter_error(emitter,"expected DOCUMENT-END");
  __retres = tmp_3;
  return_label: return __retres;
}

static int yaml_emitter_emit_flow_sequence_item(yaml_emitter_t *emitter,
                                                yaml_event_t *event,
                                                int first)
{
  int __retres;
  int tmp_8;
  int tmp_9;
  if (first) {
    int tmp;
    int tmp_0;
    tmp = yaml_emitter_write_indicator(emitter,"[",1,1,0);
    if (! tmp) {
      __retres = 0;
      goto return_label;
    }
    tmp_0 = yaml_emitter_increase_indent(emitter,1,0);
    if (! tmp_0) {
      __retres = 0;
      goto return_label;
    }
    (emitter->flow_level) ++;
  }
  if (event->type == (unsigned int)YAML_SEQUENCE_END_EVENT) {
    int tmp_3;
    (emitter->flow_level) --;
    (emitter->indents.top) --;
    emitter->indent = *(emitter->indents.top);
    if (emitter->canonical) 
      if (! first) {
        int tmp_1;
        int tmp_2;
        tmp_1 = yaml_emitter_write_indicator(emitter,",",0,0,0);
        if (! tmp_1) {
          __retres = 0;
          goto return_label;
        }
        tmp_2 = yaml_emitter_write_indent(emitter);
        if (! tmp_2) {
          __retres = 0;
          goto return_label;
        }
      }
    tmp_3 = yaml_emitter_write_indicator(emitter,"]",0,0,0);
    if (! tmp_3) {
      __retres = 0;
      goto return_label;
    }
    (emitter->states.top) --;
    emitter->state = *(emitter->states.top);
    __retres = 1;
    goto return_label;
  }
  if (! first) {
    int tmp_4;
    tmp_4 = yaml_emitter_write_indicator(emitter,",",0,0,0);
    if (! tmp_4) {
      __retres = 0;
      goto return_label;
    }
  }
  if (emitter->canonical) goto _LOR;
  else 
    if (emitter->column > emitter->best_width) {
      _LOR:
      {
        int tmp_5;
        tmp_5 = yaml_emitter_write_indent(emitter);
        if (! tmp_5) {
          __retres = 0;
          goto return_label;
        }
      }
    }
  if (emitter->states.top != emitter->states.end) goto _LOR_0;
  else {
    int tmp_6;
    tmp_6 = yaml_stack_extend((void **)(& emitter->states.start),
                              (void **)(& emitter->states.top),
                              (void **)(& emitter->states.end));
    if (tmp_6) {
      yaml_emitter_state_t *tmp_7;
      _LOR_0: tmp_7 = emitter->states.top;
      (emitter->states.top) ++;
      *tmp_7 = YAML_EMIT_FLOW_SEQUENCE_ITEM_STATE;
      tmp_8 = 1;
    }
    else {
      emitter->error = YAML_MEMORY_ERROR;
      tmp_8 = 0;
    }
  }
  if (! tmp_8) {
    __retres = 0;
    goto return_label;
  }
  tmp_9 = yaml_emitter_emit_node(emitter,event,0,1,0,0);
  __retres = tmp_9;
  return_label: return __retres;
}

static int yaml_emitter_emit_flow_mapping_key(yaml_emitter_t *emitter,
                                              yaml_event_t *event, int first)
{
  int __retres;
  if (first) {
    int tmp;
    int tmp_0;
    tmp = yaml_emitter_write_indicator(emitter,"{",1,1,0);
    if (! tmp) {
      __retres = 0;
      goto return_label;
    }
    tmp_0 = yaml_emitter_increase_indent(emitter,1,0);
    if (! tmp_0) {
      __retres = 0;
      goto return_label;
    }
    (emitter->flow_level) ++;
  }
  if (event->type == (unsigned int)YAML_MAPPING_END_EVENT) {
    int tmp_3;
    (emitter->flow_level) --;
    (emitter->indents.top) --;
    emitter->indent = *(emitter->indents.top);
    if (emitter->canonical) 
      if (! first) {
        int tmp_1;
        int tmp_2;
        tmp_1 = yaml_emitter_write_indicator(emitter,",",0,0,0);
        if (! tmp_1) {
          __retres = 0;
          goto return_label;
        }
        tmp_2 = yaml_emitter_write_indent(emitter);
        if (! tmp_2) {
          __retres = 0;
          goto return_label;
        }
      }
    tmp_3 = yaml_emitter_write_indicator(emitter,"}",0,0,0);
    if (! tmp_3) {
      __retres = 0;
      goto return_label;
    }
    (emitter->states.top) --;
    emitter->state = *(emitter->states.top);
    __retres = 1;
    goto return_label;
  }
  if (! first) {
    int tmp_4;
    tmp_4 = yaml_emitter_write_indicator(emitter,",",0,0,0);
    if (! tmp_4) {
      __retres = 0;
      goto return_label;
    }
  }
  if (emitter->canonical) goto _LOR;
  else 
    if (emitter->column > emitter->best_width) {
      _LOR:
      {
        int tmp_5;
        tmp_5 = yaml_emitter_write_indent(emitter);
        if (! tmp_5) {
          __retres = 0;
          goto return_label;
        }
      }
    }
  if (! emitter->canonical) {
    int tmp_15;
    tmp_15 = yaml_emitter_check_simple_key(emitter);
    if (tmp_15) {
      int tmp_8;
      int tmp_9;
      if (emitter->states.top != emitter->states.end) goto _LOR_0;
      else {
        int tmp_6;
        tmp_6 = yaml_stack_extend((void **)(& emitter->states.start),
                                  (void **)(& emitter->states.top),
                                  (void **)(& emitter->states.end));
        if (tmp_6) {
          yaml_emitter_state_t *tmp_7;
          _LOR_0: tmp_7 = emitter->states.top;
          (emitter->states.top) ++;
          *tmp_7 = YAML_EMIT_FLOW_MAPPING_SIMPLE_VALUE_STATE;
          tmp_8 = 1;
        }
        else {
          emitter->error = YAML_MEMORY_ERROR;
          tmp_8 = 0;
        }
      }
      if (! tmp_8) {
        __retres = 0;
        goto return_label;
      }
      tmp_9 = yaml_emitter_emit_node(emitter,event,0,0,1,1);
      __retres = tmp_9;
      goto return_label;
    }
    else goto _LAND;
  }
  else {
    _LAND:
    {
      int tmp_10;
      int tmp_13;
      int tmp_14;
      tmp_10 = yaml_emitter_write_indicator(emitter,"?",1,0,0);
      if (! tmp_10) {
        __retres = 0;
        goto return_label;
      }
      if (emitter->states.top != emitter->states.end) goto _LOR_1;
      else {
        int tmp_11;
        tmp_11 = yaml_stack_extend((void **)(& emitter->states.start),
                                   (void **)(& emitter->states.top),
                                   (void **)(& emitter->states.end));
        if (tmp_11) {
          yaml_emitter_state_t *tmp_12;
          _LOR_1: tmp_12 = emitter->states.top;
          (emitter->states.top) ++;
          *tmp_12 = YAML_EMIT_FLOW_MAPPING_VALUE_STATE;
          tmp_13 = 1;
        }
        else {
          emitter->error = YAML_MEMORY_ERROR;
          tmp_13 = 0;
        }
      }
      if (! tmp_13) {
        __retres = 0;
        goto return_label;
      }
      tmp_14 = yaml_emitter_emit_node(emitter,event,0,0,1,0);
      __retres = tmp_14;
      goto return_label;
    }
  }
  return_label: return __retres;
}

static int yaml_emitter_emit_flow_mapping_value(yaml_emitter_t *emitter,
                                                yaml_event_t *event,
                                                int simple)
{
  int __retres;
  int tmp_4;
  int tmp_5;
  if (simple) {
    int tmp;
    tmp = yaml_emitter_write_indicator(emitter,":",0,0,0);
    if (! tmp) {
      __retres = 0;
      goto return_label;
    }
  }
  else {
    int tmp_1;
    if (emitter->canonical) goto _LOR;
    else 
      if (emitter->column > emitter->best_width) {
        _LOR:
        {
          int tmp_0;
          tmp_0 = yaml_emitter_write_indent(emitter);
          if (! tmp_0) {
            __retres = 0;
            goto return_label;
          }
        }
      }
    tmp_1 = yaml_emitter_write_indicator(emitter,":",1,0,0);
    if (! tmp_1) {
      __retres = 0;
      goto return_label;
    }
  }
  if (emitter->states.top != emitter->states.end) goto _LOR_0;
  else {
    int tmp_2;
    tmp_2 = yaml_stack_extend((void **)(& emitter->states.start),
                              (void **)(& emitter->states.top),
                              (void **)(& emitter->states.end));
    if (tmp_2) {
      yaml_emitter_state_t *tmp_3;
      _LOR_0: tmp_3 = emitter->states.top;
      (emitter->states.top) ++;
      *tmp_3 = YAML_EMIT_FLOW_MAPPING_KEY_STATE;
      tmp_4 = 1;
    }
    else {
      emitter->error = YAML_MEMORY_ERROR;
      tmp_4 = 0;
    }
  }
  if (! tmp_4) {
    __retres = 0;
    goto return_label;
  }
  tmp_5 = yaml_emitter_emit_node(emitter,event,0,0,1,0);
  __retres = tmp_5;
  return_label: return __retres;
}

static int yaml_emitter_emit_block_sequence_item(yaml_emitter_t *emitter,
                                                 yaml_event_t *event,
                                                 int first)
{
  int __retres;
  int tmp_1;
  int tmp_2;
  int tmp_5;
  int tmp_6;
  if (first) {
    int tmp_0;
    int tmp;
    if (emitter->mapping_context) 
      if (! emitter->indention) tmp = 1; else tmp = 0;
    else tmp = 0;
    ;
    tmp_0 = yaml_emitter_increase_indent(emitter,0,tmp);
    if (! tmp_0) {
      __retres = 0;
      goto return_label;
    }
  }
  if (event->type == (unsigned int)YAML_SEQUENCE_END_EVENT) {
    (emitter->indents.top) --;
    emitter->indent = *(emitter->indents.top);
    (emitter->states.top) --;
    emitter->state = *(emitter->states.top);
    __retres = 1;
    goto return_label;
  }
  tmp_1 = yaml_emitter_write_indent(emitter);
  if (! tmp_1) {
    __retres = 0;
    goto return_label;
  }
  tmp_2 = yaml_emitter_write_indicator(emitter,"-",1,0,1);
  if (! tmp_2) {
    __retres = 0;
    goto return_label;
  }
  if (emitter->states.top != emitter->states.end) goto _LOR;
  else {
    int tmp_3;
    tmp_3 = yaml_stack_extend((void **)(& emitter->states.start),
                              (void **)(& emitter->states.top),
                              (void **)(& emitter->states.end));
    if (tmp_3) {
      yaml_emitter_state_t *tmp_4;
      _LOR: tmp_4 = emitter->states.top;
      (emitter->states.top) ++;
      *tmp_4 = YAML_EMIT_BLOCK_SEQUENCE_ITEM_STATE;
      tmp_5 = 1;
    }
    else {
      emitter->error = YAML_MEMORY_ERROR;
      tmp_5 = 0;
    }
  }
  if (! tmp_5) {
    __retres = 0;
    goto return_label;
  }
  tmp_6 = yaml_emitter_emit_node(emitter,event,0,1,0,0);
  __retres = tmp_6;
  return_label: return __retres;
}

static int yaml_emitter_emit_block_mapping_key(yaml_emitter_t *emitter,
                                               yaml_event_t *event, int first)
{
  int __retres;
  int tmp_0;
  int tmp_10;
  if (first) {
    int tmp;
    tmp = yaml_emitter_increase_indent(emitter,0,0);
    if (! tmp) {
      __retres = 0;
      goto return_label;
    }
  }
  if (event->type == (unsigned int)YAML_MAPPING_END_EVENT) {
    (emitter->indents.top) --;
    emitter->indent = *(emitter->indents.top);
    (emitter->states.top) --;
    emitter->state = *(emitter->states.top);
    __retres = 1;
    goto return_label;
  }
  tmp_0 = yaml_emitter_write_indent(emitter);
  if (! tmp_0) {
    __retres = 0;
    goto return_label;
  }
  tmp_10 = yaml_emitter_check_simple_key(emitter);
  if (tmp_10) {
    int tmp_3;
    int tmp_4;
    if (emitter->states.top != emitter->states.end) goto _LOR;
    else {
      int tmp_1;
      tmp_1 = yaml_stack_extend((void **)(& emitter->states.start),
                                (void **)(& emitter->states.top),
                                (void **)(& emitter->states.end));
      if (tmp_1) {
        yaml_emitter_state_t *tmp_2;
        _LOR: tmp_2 = emitter->states.top;
        (emitter->states.top) ++;
        *tmp_2 = YAML_EMIT_BLOCK_MAPPING_SIMPLE_VALUE_STATE;
        tmp_3 = 1;
      }
      else {
        emitter->error = YAML_MEMORY_ERROR;
        tmp_3 = 0;
      }
    }
    if (! tmp_3) {
      __retres = 0;
      goto return_label;
    }
    tmp_4 = yaml_emitter_emit_node(emitter,event,0,0,1,1);
    __retres = tmp_4;
    goto return_label;
  }
  else {
    int tmp_5;
    int tmp_8;
    int tmp_9;
    tmp_5 = yaml_emitter_write_indicator(emitter,"?",1,0,1);
    if (! tmp_5) {
      __retres = 0;
      goto return_label;
    }
    if (emitter->states.top != emitter->states.end) goto _LOR_0;
    else {
      int tmp_6;
      tmp_6 = yaml_stack_extend((void **)(& emitter->states.start),
                                (void **)(& emitter->states.top),
                                (void **)(& emitter->states.end));
      if (tmp_6) {
        yaml_emitter_state_t *tmp_7;
        _LOR_0: tmp_7 = emitter->states.top;
        (emitter->states.top) ++;
        *tmp_7 = YAML_EMIT_BLOCK_MAPPING_VALUE_STATE;
        tmp_8 = 1;
      }
      else {
        emitter->error = YAML_MEMORY_ERROR;
        tmp_8 = 0;
      }
    }
    if (! tmp_8) {
      __retres = 0;
      goto return_label;
    }
    tmp_9 = yaml_emitter_emit_node(emitter,event,0,0,1,0);
    __retres = tmp_9;
    goto return_label;
  }
  return_label: return __retres;
}

static int yaml_emitter_emit_block_mapping_value(yaml_emitter_t *emitter,
                                                 yaml_event_t *event,
                                                 int simple)
{
  int __retres;
  int tmp_4;
  int tmp_5;
  if (simple) {
    int tmp;
    tmp = yaml_emitter_write_indicator(emitter,":",0,0,0);
    if (! tmp) {
      __retres = 0;
      goto return_label;
    }
  }
  else {
    int tmp_0;
    int tmp_1;
    tmp_0 = yaml_emitter_write_indent(emitter);
    if (! tmp_0) {
      __retres = 0;
      goto return_label;
    }
    tmp_1 = yaml_emitter_write_indicator(emitter,":",1,0,1);
    if (! tmp_1) {
      __retres = 0;
      goto return_label;
    }
  }
  if (emitter->states.top != emitter->states.end) goto _LOR;
  else {
    int tmp_2;
    tmp_2 = yaml_stack_extend((void **)(& emitter->states.start),
                              (void **)(& emitter->states.top),
                              (void **)(& emitter->states.end));
    if (tmp_2) {
      yaml_emitter_state_t *tmp_3;
      _LOR: tmp_3 = emitter->states.top;
      (emitter->states.top) ++;
      *tmp_3 = YAML_EMIT_BLOCK_MAPPING_KEY_STATE;
      tmp_4 = 1;
    }
    else {
      emitter->error = YAML_MEMORY_ERROR;
      tmp_4 = 0;
    }
  }
  if (! tmp_4) {
    __retres = 0;
    goto return_label;
  }
  tmp_5 = yaml_emitter_emit_node(emitter,event,0,0,1,0);
  __retres = tmp_5;
  return_label: return __retres;
}

static int yaml_emitter_emit_node(yaml_emitter_t *emitter,
                                  yaml_event_t *event, int root,
                                  int sequence, int mapping, int simple_key)
{
  int __retres;
  emitter->root_context = root;
  emitter->sequence_context = sequence;
  emitter->mapping_context = mapping;
  emitter->simple_key_context = simple_key;
  switch (event->type) {
    int tmp;
    int tmp_0;
    int tmp_1;
    int tmp_2;
    int tmp_3;
    case YAML_ALIAS_EVENT: tmp = yaml_emitter_emit_alias(emitter,event);
    __retres = tmp;
    goto return_label;
    case YAML_SCALAR_EVENT: tmp_0 = yaml_emitter_emit_scalar(emitter,event);
    __retres = tmp_0;
    goto return_label;
    case YAML_SEQUENCE_START_EVENT:
    tmp_1 = yaml_emitter_emit_sequence_start(emitter,event);
    __retres = tmp_1;
    goto return_label;
    case YAML_MAPPING_START_EVENT:
    tmp_2 = yaml_emitter_emit_mapping_start(emitter,event);
    __retres = tmp_2;
    goto return_label;
    default:
    tmp_3 = yaml_emitter_set_emitter_error(emitter,
                                           "expected SCALAR, SEQUENCE-START, MAPPING-START, or ALIAS");
    __retres = tmp_3;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static int yaml_emitter_emit_alias(yaml_emitter_t *emitter,
                                   yaml_event_t *event __attribute__((
                                   __unused__)))
{
  int __retres;
  int tmp;
  tmp = yaml_emitter_process_anchor(emitter);
  if (! tmp) {
    __retres = 0;
    goto return_label;
  }
  if (emitter->simple_key_context) 
    if (emitter->buffer.pointer + 5 < emitter->buffer.end) goto _LOR;
    else {
      int tmp_0;
      tmp_0 = yaml_emitter_flush(emitter);
      if (tmp_0) {
        yaml_char_t *tmp_1;
        _LOR:
        { /* sequence */
          tmp_1 = emitter->buffer.pointer;
          (emitter->buffer.pointer) ++;
          *tmp_1 = (yaml_char_t)' ';
        }
        (emitter->column) ++;
      }
      else {
        __retres = 0;
        goto return_label;
      }
    }
  (emitter->states.top) --;
  emitter->state = *(emitter->states.top);
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_emit_scalar(yaml_emitter_t *emitter,
                                    yaml_event_t *event)
{
  int __retres;
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  tmp = yaml_emitter_select_scalar_style(emitter,event);
  if (! tmp) {
    __retres = 0;
    goto return_label;
  }
  tmp_0 = yaml_emitter_process_anchor(emitter);
  if (! tmp_0) {
    __retres = 0;
    goto return_label;
  }
  tmp_1 = yaml_emitter_process_tag(emitter);
  if (! tmp_1) {
    __retres = 0;
    goto return_label;
  }
  tmp_2 = yaml_emitter_increase_indent(emitter,1,0);
  if (! tmp_2) {
    __retres = 0;
    goto return_label;
  }
  tmp_3 = yaml_emitter_process_scalar(emitter);
  if (! tmp_3) {
    __retres = 0;
    goto return_label;
  }
  (emitter->indents.top) --;
  emitter->indent = *(emitter->indents.top);
  (emitter->states.top) --;
  emitter->state = *(emitter->states.top);
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_emit_sequence_start(yaml_emitter_t *emitter,
                                            yaml_event_t *event)
{
  int __retres;
  int tmp;
  int tmp_0;
  tmp = yaml_emitter_process_anchor(emitter);
  if (! tmp) {
    __retres = 0;
    goto return_label;
  }
  tmp_0 = yaml_emitter_process_tag(emitter);
  if (! tmp_0) {
    __retres = 0;
    goto return_label;
  }
  if (emitter->flow_level) goto _LOR;
  else 
    if (emitter->canonical) goto _LOR;
    else 
      if (event->data.sequence_start.style == (unsigned int)YAML_FLOW_SEQUENCE_STYLE) 
        goto _LOR;
      else {
        int tmp_1;
        tmp_1 = yaml_emitter_check_empty_sequence(emitter);
        if (tmp_1) _LOR:
                   emitter->state = YAML_EMIT_FLOW_SEQUENCE_FIRST_ITEM_STATE;
        else emitter->state = YAML_EMIT_BLOCK_SEQUENCE_FIRST_ITEM_STATE;
      }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_emit_mapping_start(yaml_emitter_t *emitter,
                                           yaml_event_t *event)
{
  int __retres;
  int tmp;
  int tmp_0;
  tmp = yaml_emitter_process_anchor(emitter);
  if (! tmp) {
    __retres = 0;
    goto return_label;
  }
  tmp_0 = yaml_emitter_process_tag(emitter);
  if (! tmp_0) {
    __retres = 0;
    goto return_label;
  }
  if (emitter->flow_level) goto _LOR;
  else 
    if (emitter->canonical) goto _LOR;
    else 
      if (event->data.mapping_start.style == (unsigned int)YAML_FLOW_MAPPING_STYLE) 
        goto _LOR;
      else {
        int tmp_1;
        tmp_1 = yaml_emitter_check_empty_mapping(emitter);
        if (tmp_1) _LOR:
                   emitter->state = YAML_EMIT_FLOW_MAPPING_FIRST_KEY_STATE;
        else emitter->state = YAML_EMIT_BLOCK_MAPPING_FIRST_KEY_STATE;
      }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_check_empty_document(yaml_emitter_t *emitter __attribute__((
                                             __unused__)))
{
  int __retres;
  __retres = 0;
  return __retres;
}

static int yaml_emitter_check_empty_sequence(yaml_emitter_t *emitter)
{
  int __retres;
  int tmp;
  if (emitter->events.tail - emitter->events.head < (long)2) {
    __retres = 0;
    goto return_label;
  }
  if ((emitter->events.head + 0)->type == (unsigned int)YAML_SEQUENCE_START_EVENT) 
    if ((emitter->events.head + 1)->type == (unsigned int)YAML_SEQUENCE_END_EVENT) 
      tmp = 1;
    else tmp = 0;
  else tmp = 0;
  __retres = tmp;
  return_label: return __retres;
}

static int yaml_emitter_check_empty_mapping(yaml_emitter_t *emitter)
{
  int __retres;
  int tmp;
  if (emitter->events.tail - emitter->events.head < (long)2) {
    __retres = 0;
    goto return_label;
  }
  if ((emitter->events.head + 0)->type == (unsigned int)YAML_MAPPING_START_EVENT) 
    if ((emitter->events.head + 1)->type == (unsigned int)YAML_MAPPING_END_EVENT) 
      tmp = 1;
    else tmp = 0;
  else tmp = 0;
  __retres = tmp;
  return_label: return __retres;
}

static int yaml_emitter_check_simple_key(yaml_emitter_t *emitter)
{
  int __retres;
  yaml_event_t *event = emitter->events.head;
  size_t length = (size_t)0;
  switch (event->type) {
    int tmp;
    int tmp_0;
    case YAML_ALIAS_EVENT: length += emitter->anchor_data.anchor_length;
    break;
    case YAML_SCALAR_EVENT: ;
    if (emitter->scalar_data.multiline) {
      __retres = 0;
      goto return_label;
    }
    length += ((emitter->anchor_data.anchor_length + emitter->tag_data.handle_length) + emitter->tag_data.suffix_length) + emitter->scalar_data.length;
    break;
    case YAML_SEQUENCE_START_EVENT:
    tmp = yaml_emitter_check_empty_sequence(emitter);
    if (! tmp) {
      __retres = 0;
      goto return_label;
    }
    length += (emitter->anchor_data.anchor_length + emitter->tag_data.handle_length) + emitter->tag_data.suffix_length;
    break;
    case YAML_MAPPING_START_EVENT:
    tmp_0 = yaml_emitter_check_empty_mapping(emitter);
    if (! tmp_0) {
      __retres = 0;
      goto return_label;
    }
    length += (emitter->anchor_data.anchor_length + emitter->tag_data.handle_length) + emitter->tag_data.suffix_length;
    break;
    default: __retres = 0;
    goto return_label;
  }
  if (length > (size_t)128) {
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_select_scalar_style(yaml_emitter_t *emitter,
                                            yaml_event_t *event)
{
  int __retres;
  int tmp;
  yaml_scalar_style_t style = event->data.scalar.style;
  if (! emitter->tag_data.handle) 
    if (! emitter->tag_data.suffix) tmp = 1; else tmp = 0;
  else tmp = 0;
  int no_tag = tmp;
  if (no_tag) 
    if (! event->data.scalar.plain_implicit) 
      if (! event->data.scalar.quoted_implicit) {
        int tmp_0;
        tmp_0 = yaml_emitter_set_emitter_error(emitter,
                                               "neither tag nor implicit flags are specified");
        __retres = tmp_0;
        goto return_label;
      }
  if (style == (unsigned int)YAML_ANY_SCALAR_STYLE) style = YAML_PLAIN_SCALAR_STYLE;
  if (emitter->canonical) style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;
  if (emitter->simple_key_context) 
    if (emitter->scalar_data.multiline) style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;
  if (style == (unsigned int)YAML_PLAIN_SCALAR_STYLE) {
    if (emitter->flow_level) {
      if (! emitter->scalar_data.flow_plain_allowed) style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
      else goto _LAND;
    }
    else 
      _LAND:
      if (! emitter->flow_level) 
        if (! emitter->scalar_data.block_plain_allowed) style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
    if (! emitter->scalar_data.length) 
      if (emitter->flow_level) style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
      else 
        if (emitter->simple_key_context) style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
    if (no_tag) 
      if (! event->data.scalar.plain_implicit) style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
  }
  if (style == (unsigned int)YAML_SINGLE_QUOTED_SCALAR_STYLE) 
    if (! emitter->scalar_data.single_quoted_allowed) style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;
  if (style == (unsigned int)YAML_LITERAL_SCALAR_STYLE) goto _LOR;
  else 
    if (style == (unsigned int)YAML_FOLDED_SCALAR_STYLE) 
      _LOR:
      if (! emitter->scalar_data.block_allowed) style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;
      else 
        if (emitter->flow_level) style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;
        else 
          if (emitter->simple_key_context) style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;
  if (no_tag) 
    if (! event->data.scalar.quoted_implicit) 
      if (style != (unsigned int)YAML_PLAIN_SCALAR_STYLE) {
        emitter->tag_data.handle = (yaml_char_t *)"!";
        emitter->tag_data.handle_length = (size_t)1;
      }
  emitter->scalar_data.style = style;
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_process_anchor(yaml_emitter_t *emitter)
{
  int __retres;
  int tmp_0;
  char const *tmp;
  int tmp_1;
  if (! emitter->anchor_data.anchor) {
    __retres = 1;
    goto return_label;
  }
  if (emitter->anchor_data.alias) tmp = "*"; else tmp = "&";
  ;
  tmp_0 = yaml_emitter_write_indicator(emitter,tmp,1,0,0);
  if (! tmp_0) {
    __retres = 0;
    goto return_label;
  }
  tmp_1 = yaml_emitter_write_anchor(emitter,emitter->anchor_data.anchor,
                                    emitter->anchor_data.anchor_length);
  __retres = tmp_1;
  return_label: return __retres;
}

static int yaml_emitter_process_tag(yaml_emitter_t *emitter)
{
  int __retres;
  if (! emitter->tag_data.handle) 
    if (! emitter->tag_data.suffix) {
      __retres = 1;
      goto return_label;
    }
  if (emitter->tag_data.handle) {
    int tmp;
    tmp = yaml_emitter_write_tag_handle(emitter,emitter->tag_data.handle,
                                        emitter->tag_data.handle_length);
    if (! tmp) {
      __retres = 0;
      goto return_label;
    }
    if (emitter->tag_data.suffix) {
      int tmp_0;
      tmp_0 = yaml_emitter_write_tag_content(emitter,
                                             emitter->tag_data.suffix,
                                             emitter->tag_data.suffix_length,
                                             0);
      if (! tmp_0) {
        __retres = 0;
        goto return_label;
      }
    }
  }
  else {
    int tmp_1;
    int tmp_2;
    int tmp_3;
    tmp_1 = yaml_emitter_write_indicator(emitter,"!<",1,0,0);
    if (! tmp_1) {
      __retres = 0;
      goto return_label;
    }
    tmp_2 = yaml_emitter_write_tag_content(emitter,emitter->tag_data.suffix,
                                           emitter->tag_data.suffix_length,0);
    if (! tmp_2) {
      __retres = 0;
      goto return_label;
    }
    tmp_3 = yaml_emitter_write_indicator(emitter,">",0,0,0);
    if (! tmp_3) {
      __retres = 0;
      goto return_label;
    }
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_process_scalar(yaml_emitter_t *emitter)
{
  int __retres;
  switch (emitter->scalar_data.style) {
    int tmp;
    int tmp_0;
    int tmp_1;
    int tmp_2;
    int tmp_3;
    case YAML_PLAIN_SCALAR_STYLE:
    tmp = yaml_emitter_write_plain_scalar(emitter,emitter->scalar_data.value,
                                          emitter->scalar_data.length,
                                          ! emitter->simple_key_context);
    __retres = tmp;
    goto return_label;
    case YAML_SINGLE_QUOTED_SCALAR_STYLE:
    tmp_0 = yaml_emitter_write_single_quoted_scalar(emitter,
                                                    emitter->scalar_data.value,
                                                    emitter->scalar_data.length,
                                                    ! emitter->simple_key_context);
    __retres = tmp_0;
    goto return_label;
    case YAML_DOUBLE_QUOTED_SCALAR_STYLE:
    tmp_1 = yaml_emitter_write_double_quoted_scalar(emitter,
                                                    emitter->scalar_data.value,
                                                    emitter->scalar_data.length,
                                                    ! emitter->simple_key_context);
    __retres = tmp_1;
    goto return_label;
    case YAML_LITERAL_SCALAR_STYLE:
    tmp_2 = yaml_emitter_write_literal_scalar(emitter,
                                              emitter->scalar_data.value,
                                              emitter->scalar_data.length);
    __retres = tmp_2;
    goto return_label;
    case YAML_FOLDED_SCALAR_STYLE:
    tmp_3 = yaml_emitter_write_folded_scalar(emitter,
                                             emitter->scalar_data.value,
                                             emitter->scalar_data.length);
    __retres = tmp_3;
    goto return_label;
    default: __FC_assert(1 != 0,"src/emitter.c",1341,"1");
  }
  __retres = 0;
  return_label: return __retres;
}

static int yaml_emitter_analyze_version_directive(yaml_emitter_t *emitter,
                                                  yaml_version_directive_t version_directive)
{
  int __retres;
  if (version_directive.major != 1) goto _LOR;
  else 
    if (version_directive.minor != 1) 
      if (version_directive.minor != 2) {
        _LOR:
        {
          int tmp;
          tmp = yaml_emitter_set_emitter_error(emitter,
                                               "incompatible %YAML directive");
          __retres = tmp;
          goto return_label;
        }
      }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_analyze_tag_directive(yaml_emitter_t *emitter,
                                              yaml_tag_directive_t tag_directive)
{
  int __retres;
  yaml_string_t handle;
  yaml_string_t prefix;
  size_t handle_length;
  size_t prefix_length;
  handle_length = strlen((char const *)tag_directive.handle);
  prefix_length = strlen((char const *)tag_directive.prefix);
  handle.start = tag_directive.handle;
  handle.end = tag_directive.handle + handle_length;
  handle.pointer = tag_directive.handle;
  prefix.start = tag_directive.prefix;
  prefix.end = tag_directive.prefix + prefix_length;
  prefix.pointer = tag_directive.prefix;
  if (handle.start == handle.end) {
    int tmp;
    tmp = yaml_emitter_set_emitter_error(emitter,
                                         "tag handle must not be empty");
    __retres = tmp;
    goto return_label;
  }
  if ((int)*(handle.start + 0) != '!') {
    int tmp_0;
    tmp_0 = yaml_emitter_set_emitter_error(emitter,
                                           "tag handle must start with \'!\'");
    __retres = tmp_0;
    goto return_label;
  }
  if ((int)*(handle.end + -1) != '!') {
    int tmp_1;
    tmp_1 = yaml_emitter_set_emitter_error(emitter,
                                           "tag handle must end with \'!\'");
    __retres = tmp_1;
    goto return_label;
  }
  (handle.pointer) ++;
  while (handle.pointer < handle.end - 1) {
    int tmp_6;
    if ((int)*(handle.pointer + 0) >= (int)((yaml_char_t)'0')) {
      if (! ((int)*(handle.pointer + 0) <= (int)((yaml_char_t)'9'))) 
        goto _LAND_1;
    }
    else {
      _LAND_1: ;
      if ((int)*(handle.pointer + 0) >= (int)((yaml_char_t)'A')) {
        if (! ((int)*(handle.pointer + 0) <= (int)((yaml_char_t)'Z'))) 
          goto _LAND_0;
      }
      else {
        _LAND_0: ;
        if ((int)*(handle.pointer + 0) >= (int)((yaml_char_t)'a')) {
          if (! ((int)*(handle.pointer + 0) <= (int)((yaml_char_t)'z'))) 
            goto _LAND;
        }
        else {
          _LAND: ;
          if (! ((int)*(handle.pointer + 0) == '_')) 
            if (! ((int)*(handle.pointer + 0) == '-')) {
              int tmp_2;
              tmp_2 = yaml_emitter_set_emitter_error(emitter,
                                                     "tag handle must contain alphanumerical characters only");
              __retres = tmp_2;
              goto return_label;
            }
        }
      }
    }
    if (((int)*(handle.pointer + 0) & 0x80) == 0x00) tmp_6 = 1;
    else {
      int tmp_5;
      if (((int)*(handle.pointer + 0) & 0xE0) == 0xC0) tmp_5 = 2;
      else {
        int tmp_4;
        if (((int)*(handle.pointer + 0) & 0xF0) == 0xE0) tmp_4 = 3;
        else {
          int tmp_3;
          if (((int)*(handle.pointer + 0) & 0xF8) == 0xF0) tmp_3 = 4;
          else tmp_3 = 0;
          tmp_4 = tmp_3;
        }
        tmp_5 = tmp_4;
      }
      tmp_6 = tmp_5;
    }
    handle.pointer += tmp_6;
  }
  if (prefix.start == prefix.end) {
    int tmp_7;
    tmp_7 = yaml_emitter_set_emitter_error(emitter,
                                           "tag prefix must not be empty");
    __retres = tmp_7;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_analyze_anchor(yaml_emitter_t *emitter,
                                       yaml_char_t *anchor, int alias)
{
  int __retres;
  size_t anchor_length;
  yaml_string_t string;
  anchor_length = strlen((char const *)anchor);
  string.start = anchor;
  string.end = anchor + anchor_length;
  string.pointer = anchor;
  if (string.start == string.end) {
    int tmp_0;
    char const *tmp;
    if (alias) tmp = "alias value must not be empty";
    else tmp = "anchor value must not be empty";
    ;
    tmp_0 = yaml_emitter_set_emitter_error(emitter,tmp);
    __retres = tmp_0;
    goto return_label;
  }
  while (string.pointer != string.end) {
    int tmp_6;
    if ((int)*(string.pointer + 0) >= (int)((yaml_char_t)'0')) {
      if (! ((int)*(string.pointer + 0) <= (int)((yaml_char_t)'9'))) 
        goto _LAND_1;
    }
    else {
      _LAND_1: ;
      if ((int)*(string.pointer + 0) >= (int)((yaml_char_t)'A')) {
        if (! ((int)*(string.pointer + 0) <= (int)((yaml_char_t)'Z'))) 
          goto _LAND_0;
      }
      else {
        _LAND_0: ;
        if ((int)*(string.pointer + 0) >= (int)((yaml_char_t)'a')) {
          if (! ((int)*(string.pointer + 0) <= (int)((yaml_char_t)'z'))) 
            goto _LAND;
        }
        else {
          _LAND: ;
          if (! ((int)*(string.pointer + 0) == '_')) 
            if (! ((int)*(string.pointer + 0) == '-')) {
              int tmp_2;
              char const *tmp_1;
              if (alias) tmp_1 = "alias value must contain alphanumerical characters only";
              else tmp_1 = "anchor value must contain alphanumerical characters only";
              ;
              tmp_2 = yaml_emitter_set_emitter_error(emitter,tmp_1);
              __retres = tmp_2;
              goto return_label;
            }
        }
      }
    }
    if (((int)*(string.pointer + 0) & 0x80) == 0x00) tmp_6 = 1;
    else {
      int tmp_5;
      if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) tmp_5 = 2;
      else {
        int tmp_4;
        if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) tmp_4 = 3;
        else {
          int tmp_3;
          if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) tmp_3 = 4;
          else tmp_3 = 0;
          tmp_4 = tmp_3;
        }
        tmp_5 = tmp_4;
      }
      tmp_6 = tmp_5;
    }
    string.pointer += tmp_6;
  }
  emitter->anchor_data.anchor = string.start;
  emitter->anchor_data.anchor_length = (size_t)(string.end - string.start);
  emitter->anchor_data.alias = alias;
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_analyze_tag(yaml_emitter_t *emitter, yaml_char_t *tag)
{
  int __retres;
  size_t tag_length;
  yaml_string_t string;
  yaml_tag_directive_t *tag_directive;
  tag_length = strlen((char const *)tag);
  string.start = tag;
  string.end = tag + tag_length;
  string.pointer = tag;
  if (string.start == string.end) {
    int tmp;
    tmp = yaml_emitter_set_emitter_error(emitter,
                                         "tag value must not be empty");
    __retres = tmp;
    goto return_label;
  }
  tag_directive = emitter->tag_directives.start;
  while (tag_directive != emitter->tag_directives.top) {
    {
      size_t prefix_length = strlen((char const *)tag_directive->prefix);
      if (prefix_length < (size_t)(string.end - string.start)) {
        int tmp_1;
        tmp_1 = strncmp((char const *)tag_directive->prefix,
                        (char const *)string.start,prefix_length);
        if (tmp_1 == 0) {
          emitter->tag_data.handle = tag_directive->handle;
          emitter->tag_data.handle_length = strlen((char const *)tag_directive->handle);
          emitter->tag_data.suffix = string.start + prefix_length;
          emitter->tag_data.suffix_length = (size_t)(string.end - string.start) - prefix_length;
          __retres = 1;
          goto return_label;
        }
      }
    }
    tag_directive ++;
  }
  emitter->tag_data.suffix = string.start;
  emitter->tag_data.suffix_length = (size_t)(string.end - string.start);
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_analyze_scalar(yaml_emitter_t *emitter,
                                       yaml_char_t *value, size_t length)
{
  int __retres;
  yaml_string_t string;
  int tmp_51;
  int tmp_2;
  int block_indicators = 0;
  int flow_indicators = 0;
  int line_breaks = 0;
  int special_characters = 0;
  int leading_space = 0;
  int leading_break = 0;
  int trailing_space = 0;
  int trailing_break = 0;
  int break_space = 0;
  int space_break = 0;
  int preceded_by_whitespace = 0;
  int followed_by_whitespace = 0;
  int previous_space = 0;
  int previous_break = 0;
  string.start = value;
  string.end = value + length;
  string.pointer = value;
  emitter->scalar_data.value = value;
  emitter->scalar_data.length = length;
  if (string.start == string.end) {
    emitter->scalar_data.multiline = 0;
    emitter->scalar_data.flow_plain_allowed = 0;
    emitter->scalar_data.block_plain_allowed = 1;
    emitter->scalar_data.single_quoted_allowed = 1;
    emitter->scalar_data.block_allowed = 0;
    __retres = 1;
    goto return_label;
  }
  if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'-')) {
    if ((int)*(string.pointer + 1) == (int)((yaml_char_t)'-')) {
      if ((int)*(string.pointer + 2) == (int)((yaml_char_t)'-')) goto _LOR;
      else goto _LAND_0;
    }
    else goto _LAND_0;
  }
  else {
    _LAND_0: ;
    if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'.')) 
      if ((int)*(string.pointer + 1) == (int)((yaml_char_t)'.')) 
        if ((int)*(string.pointer + 2) == (int)((yaml_char_t)'.')) {
          _LOR: {
                  block_indicators = 1;
                  flow_indicators = 1;
                }
        }
  }
  preceded_by_whitespace = 1;
  if (((int)*(string.pointer + 0) & 0x80) == 0x00) tmp_2 = 1;
  else {
    int tmp_1;
    if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) tmp_1 = 2;
    else {
      int tmp_0;
      if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) tmp_0 = 3;
      else {
        int tmp;
        if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) tmp = 4;
        else tmp = 0;
        tmp_0 = tmp;
      }
      tmp_1 = tmp_0;
    }
    tmp_2 = tmp_1;
  }
  ;
  if ((int)*(string.pointer + tmp_2) == (int)((yaml_char_t)' ')) tmp_51 = 1;
  else {
    int tmp_6;
    if (((int)*(string.pointer + 0) & 0x80) == 0x00) tmp_6 = 1;
    else {
      int tmp_5;
      if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) tmp_5 = 2;
      else {
        int tmp_4;
        if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) tmp_4 = 3;
        else {
          int tmp_3;
          if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) tmp_3 = 4;
          else tmp_3 = 0;
          tmp_4 = tmp_3;
        }
        tmp_5 = tmp_4;
      }
      tmp_6 = tmp_5;
    }
    ;
    if ((int)*(string.pointer + tmp_6) == (int)((yaml_char_t)'\t')) tmp_51 = 1;
    else {
      int tmp_10;
      if (((int)*(string.pointer + 0) & 0x80) == 0x00) tmp_10 = 1;
      else {
        int tmp_9;
        if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) tmp_9 = 2;
        else {
          int tmp_8;
          if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) tmp_8 = 3;
          else {
            int tmp_7;
            if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) tmp_7 = 4;
            else tmp_7 = 0;
            tmp_8 = tmp_7;
          }
          tmp_9 = tmp_8;
        }
        tmp_10 = tmp_9;
      }
      ;
      if ((int)*(string.pointer + tmp_10) == (int)((yaml_char_t)'\r')) 
        tmp_51 = 1;
      else {
        int tmp_14;
        if (((int)*(string.pointer + 0) & 0x80) == 0x00) tmp_14 = 1;
        else {
          int tmp_13;
          if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) tmp_13 = 2;
          else {
            int tmp_12;
            if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) tmp_12 = 3;
            else {
              int tmp_11;
              if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) tmp_11 = 4;
              else tmp_11 = 0;
              tmp_12 = tmp_11;
            }
            tmp_13 = tmp_12;
          }
          tmp_14 = tmp_13;
        }
        ;
        if ((int)*(string.pointer + tmp_14) == (int)((yaml_char_t)'\n')) 
          tmp_51 = 1;
        else {
          int tmp_18;
          if (((int)*(string.pointer + 0) & 0x80) == 0x00) tmp_18 = 1;
          else {
            int tmp_17;
            if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) tmp_17 = 2;
            else {
              int tmp_16;
              if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) tmp_16 = 3;
              else {
                int tmp_15;
                if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) tmp_15 = 4;
                else tmp_15 = 0;
                tmp_16 = tmp_15;
              }
              tmp_17 = tmp_16;
            }
            tmp_18 = tmp_17;
          }
          ;
          if ((int)*(string.pointer + tmp_18) == (int)((yaml_char_t)'\302')) {
            int tmp_22;
            if (((int)*(string.pointer + 0) & 0x80) == 0x00) tmp_22 = 1;
            else {
              int tmp_21;
              if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) tmp_21 = 2;
              else {
                int tmp_20;
                if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) tmp_20 = 3;
                else {
                  int tmp_19;
                  if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) tmp_19 = 4;
                  else tmp_19 = 0;
                  tmp_20 = tmp_19;
                }
                tmp_21 = tmp_20;
              }
              tmp_22 = tmp_21;
            }
            ;
            if ((int)*(string.pointer + (tmp_22 + 1)) == (int)((yaml_char_t)'\205')) 
              tmp_51 = 1;
            else goto _LAND_5;
          }
          else {
            int tmp_26;
            _LAND_5:
            { /* sequence */
              if (((int)*(string.pointer + 0) & 0x80) == 0x00) tmp_26 = 1;
              else {
                int tmp_25;
                if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) tmp_25 = 2;
                else {
                  int tmp_24;
                  if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) tmp_24 = 3;
                  else {
                    int tmp_23;
                    if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) 
                      tmp_23 = 4;
                    else tmp_23 = 0;
                    tmp_24 = tmp_23;
                  }
                  tmp_25 = tmp_24;
                }
                tmp_26 = tmp_25;
              }
              ;
            }
            if ((int)*(string.pointer + tmp_26) == (int)((yaml_char_t)'\342')) {
              int tmp_30;
              if (((int)*(string.pointer + 0) & 0x80) == 0x00) tmp_30 = 1;
              else {
                int tmp_29;
                if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) tmp_29 = 2;
                else {
                  int tmp_28;
                  if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) tmp_28 = 3;
                  else {
                    int tmp_27;
                    if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) 
                      tmp_27 = 4;
                    else tmp_27 = 0;
                    tmp_28 = tmp_27;
                  }
                  tmp_29 = tmp_28;
                }
                tmp_30 = tmp_29;
              }
              ;
              if ((int)*(string.pointer + (tmp_30 + 1)) == (int)((yaml_char_t)'\200')) {
                int tmp_34;
                if (((int)*(string.pointer + 0) & 0x80) == 0x00) tmp_34 = 1;
                else {
                  int tmp_33;
                  if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) tmp_33 = 2;
                  else {
                    int tmp_32;
                    if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) 
                      tmp_32 = 3;
                    else {
                      int tmp_31;
                      if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) 
                        tmp_31 = 4;
                      else tmp_31 = 0;
                      tmp_32 = tmp_31;
                    }
                    tmp_33 = tmp_32;
                  }
                  tmp_34 = tmp_33;
                }
                ;
                if ((int)*(string.pointer + (tmp_34 + 2)) == (int)((yaml_char_t)'\250')) 
                  tmp_51 = 1;
                else goto _LAND_4;
              }
              else goto _LAND_4;
            }
            else {
              int tmp_38;
              _LAND_4:
              { /* sequence */
                if (((int)*(string.pointer + 0) & 0x80) == 0x00) tmp_38 = 1;
                else {
                  int tmp_37;
                  if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) tmp_37 = 2;
                  else {
                    int tmp_36;
                    if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) 
                      tmp_36 = 3;
                    else {
                      int tmp_35;
                      if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) 
                        tmp_35 = 4;
                      else tmp_35 = 0;
                      tmp_36 = tmp_35;
                    }
                    tmp_37 = tmp_36;
                  }
                  tmp_38 = tmp_37;
                }
                ;
              }
              if ((int)*(string.pointer + tmp_38) == (int)((yaml_char_t)'\342')) {
                int tmp_42;
                if (((int)*(string.pointer + 0) & 0x80) == 0x00) tmp_42 = 1;
                else {
                  int tmp_41;
                  if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) tmp_41 = 2;
                  else {
                    int tmp_40;
                    if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) 
                      tmp_40 = 3;
                    else {
                      int tmp_39;
                      if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) 
                        tmp_39 = 4;
                      else tmp_39 = 0;
                      tmp_40 = tmp_39;
                    }
                    tmp_41 = tmp_40;
                  }
                  tmp_42 = tmp_41;
                }
                ;
                if ((int)*(string.pointer + (tmp_42 + 1)) == (int)((yaml_char_t)'\200')) {
                  int tmp_46;
                  if (((int)*(string.pointer + 0) & 0x80) == 0x00) tmp_46 = 1;
                  else {
                    int tmp_45;
                    if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) 
                      tmp_45 = 2;
                    else {
                      int tmp_44;
                      if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) 
                        tmp_44 = 3;
                      else {
                        int tmp_43;
                        if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) 
                          tmp_43 = 4;
                        else tmp_43 = 0;
                        tmp_44 = tmp_43;
                      }
                      tmp_45 = tmp_44;
                    }
                    tmp_46 = tmp_45;
                  }
                  ;
                  if ((int)*(string.pointer + (tmp_46 + 2)) == (int)((yaml_char_t)'\251')) 
                    tmp_51 = 1;
                  else goto _LAND_2;
                }
                else goto _LAND_2;
              }
              else {
                int tmp_50;
                _LAND_2:
                { /* sequence */
                  if (((int)*(string.pointer + 0) & 0x80) == 0x00) tmp_50 = 1;
                  else {
                    int tmp_49;
                    if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) 
                      tmp_49 = 2;
                    else {
                      int tmp_48;
                      if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) 
                        tmp_48 = 3;
                      else {
                        int tmp_47;
                        if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) 
                          tmp_47 = 4;
                        else tmp_47 = 0;
                        tmp_48 = tmp_47;
                      }
                      tmp_49 = tmp_48;
                    }
                    tmp_50 = tmp_49;
                  }
                  ;
                }
                if ((int)*(string.pointer + tmp_50) == (int)((yaml_char_t)'\000')) 
                  tmp_51 = 1;
                else tmp_51 = 0;
              }
            }
          }
        }
      }
    }
  }
  followed_by_whitespace = tmp_51;
  while (string.pointer != string.end) {
    int tmp_60;
    int tmp_64;
    if (string.start == string.pointer) {
      if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'#')) goto _LOR_0;
      else 
        if ((int)*(string.pointer + 0) == (int)((yaml_char_t)',')) goto _LOR_0;
        else 
          if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'[')) 
            goto _LOR_0;
          else 
            if ((int)*(string.pointer + 0) == (int)((yaml_char_t)']')) 
              goto _LOR_0;
            else 
              if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'{')) 
                goto _LOR_0;
              else 
                if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'}')) 
                  goto _LOR_0;
                else 
                  if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'&')) 
                    goto _LOR_0;
                  else 
                    if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'*')) 
                      goto _LOR_0;
                    else 
                      if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'!')) 
                        goto _LOR_0;
                      else 
                        if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'|')) 
                          goto _LOR_0;
                        else 
                          if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'>')) 
                            goto _LOR_0;
                          else 
                            if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\'')) 
                              goto _LOR_0;
                            else 
                              if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\"')) 
                                goto _LOR_0;
                              else 
                                if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'%')) 
                                  goto _LOR_0;
                                else 
                                  if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'@')) 
                                    goto _LOR_0;
                                  else 
                                    if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'`')) {
                                      _LOR_0:
                                      {
                                        flow_indicators = 1;
                                        block_indicators = 1;
                                      }
                                    }
      if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'?')) goto _LOR_1;
      else 
        if ((int)*(string.pointer + 0) == (int)((yaml_char_t)':')) {
          _LOR_1:
          {
            flow_indicators = 1;
            if (followed_by_whitespace) block_indicators = 1;
          }
        }
      if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'-')) 
        if (followed_by_whitespace) {
          flow_indicators = 1;
          block_indicators = 1;
        }
    }
    else {
      if ((int)*(string.pointer + 0) == (int)((yaml_char_t)',')) goto _LOR_2;
      else 
        if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'?')) goto _LOR_2;
        else 
          if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'[')) 
            goto _LOR_2;
          else 
            if ((int)*(string.pointer + 0) == (int)((yaml_char_t)']')) 
              goto _LOR_2;
            else 
              if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'{')) 
                goto _LOR_2;
              else 
                if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'}')) 
                  _LOR_2:
                  flow_indicators = 1;
      if ((int)*(string.pointer + 0) == (int)((yaml_char_t)':')) {
        flow_indicators = 1;
        if (followed_by_whitespace) block_indicators = 1;
      }
      if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'#')) 
        if (preceded_by_whitespace) {
          flow_indicators = 1;
          block_indicators = 1;
        }
    }
    if ((int)*(string.pointer + 0) == 0x0A) goto _LAND_6;
    else 
      if ((int)*(string.pointer + 0) >= 0x20) {
        if ((int)*(string.pointer + 0) <= 0x7E) goto _LAND_6;
        else goto _LAND_11;
      }
      else {
        _LAND_11: ;
        if ((int)*(string.pointer + 0) == 0xC2) {
          if ((int)*(string.pointer + (0 + 1)) >= 0xA0) goto _LAND_6;
          else goto _LAND_10;
        }
        else {
          _LAND_10: ;
          if ((int)*(string.pointer + 0) > 0xC2) {
            if ((int)*(string.pointer + 0) < 0xED) goto _LAND_6;
            else goto _LAND_9;
          }
          else {
            _LAND_9: ;
            if ((int)*(string.pointer + 0) == 0xED) {
              if ((int)*(string.pointer + (0 + 1)) < 0xA0) goto _LAND_6;
              else goto _LAND_8;
            }
            else {
              _LAND_8: ;
              if ((int)*(string.pointer + 0) == 0xEE) goto _LAND_6;
              else 
                if ((int)*(string.pointer + 0) == 0xEF) 
                  if ((int)*(string.pointer + (0 + 1)) == 0xBB) {
                    if ((int)*(string.pointer + (0 + 2)) == 0xBF) goto _LOR_3;
                    else goto _LAND_7;
                  }
                  else {
                    _LAND_7: ;
                    if ((int)*(string.pointer + (0 + 1)) == 0xBF) {
                      if ((int)*(string.pointer + (0 + 2)) == 0xBE) goto _LOR_3;
                      else 
                        if ((int)*(string.pointer + (0 + 2)) == 0xBF) 
                          goto _LOR_3;
                        else goto _LAND_6;
                    }
                    else 
                      _LAND_6:
                      if (! ((int)*(string.pointer + 0) <= (int)((yaml_char_t)'\177'))) 
                        if (! emitter->unicode) _LOR_3:
                                                special_characters = 1;
                  }
                else goto _LOR_3;
            }
          }
        }
      }
    if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\r')) goto _LOR_5;
    else 
      if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\n')) goto _LOR_5;
      else 
        if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\302')) {
          if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\205')) 
            goto _LOR_5;
          else goto _LAND_14;
        }
        else {
          _LAND_14: ;
          if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\342')) {
            if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
              if ((int)*(string.pointer + (0 + 2)) == (int)((yaml_char_t)'\250')) 
                goto _LOR_5;
              else goto _LAND_13;
            }
            else goto _LAND_13;
          }
          else {
            _LAND_13: ;
            if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\342')) 
              if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) 
                if ((int)*(string.pointer + (0 + 2)) == (int)((yaml_char_t)'\251')) 
                  _LOR_5:
                  line_breaks = 1;
          }
        }
    if ((int)*(string.pointer + 0) == (int)((yaml_char_t)' ')) {
      int tmp_55;
      if (string.start == string.pointer) leading_space = 1;
      if (((int)*(string.pointer + 0) & 0x80) == 0x00) tmp_55 = 1;
      else {
        int tmp_54;
        if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) tmp_54 = 2;
        else {
          int tmp_53;
          if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) tmp_53 = 3;
          else {
            int tmp_52;
            if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) tmp_52 = 4;
            else tmp_52 = 0;
            tmp_53 = tmp_52;
          }
          tmp_54 = tmp_53;
        }
        tmp_55 = tmp_54;
      }
      ;
      if (string.pointer + tmp_55 == string.end) trailing_space = 1;
      if (previous_break) break_space = 1;
      previous_space = 1;
      previous_break = 0;
    }
    else 
      if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\r')) goto _LOR_6;
      else 
        if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\n')) goto _LOR_6;
        else 
          if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\302')) {
            if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\205')) 
              goto _LOR_6;
            else goto _LAND_19;
          }
          else {
            _LAND_19: ;
            if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\342')) {
              if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                if ((int)*(string.pointer + (0 + 2)) == (int)((yaml_char_t)'\250')) 
                  goto _LOR_6;
                else goto _LAND_18;
              }
              else goto _LAND_18;
            }
            else {
              _LAND_18: ;
              if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\342')) {
                if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                  if ((int)*(string.pointer + (0 + 2)) == (int)((yaml_char_t)'\251')) {
                    _LOR_6:
                    {
                      int tmp_59;
                      if (string.start == string.pointer) leading_break = 1;
                      if (((int)*(string.pointer + 0) & 0x80) == 0x00) 
                        tmp_59 = 1;
                      else {
                        int tmp_58;
                        if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) 
                          tmp_58 = 2;
                        else {
                          int tmp_57;
                          if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) 
                            tmp_57 = 3;
                          else {
                            int tmp_56;
                            if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) 
                              tmp_56 = 4;
                            else tmp_56 = 0;
                            tmp_57 = tmp_56;
                          }
                          tmp_58 = tmp_57;
                        }
                        tmp_59 = tmp_58;
                      }
                      ;
                      if (string.pointer + tmp_59 == string.end) trailing_break = 1;
                      if (previous_space) space_break = 1;
                      previous_space = 0;
                      previous_break = 1;
                    }
                  }
                  else goto _LAND_16;
                }
                else goto _LAND_16;
              }
              else {
                _LAND_16: {
                            previous_space = 0;
                            previous_break = 0;
                          }
              }
            }
          }
    if ((int)*(string.pointer + 0) == (int)((yaml_char_t)' ')) tmp_60 = 1;
    else 
      if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\t')) tmp_60 = 1;
      else 
        if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\r')) tmp_60 = 1;
        else 
          if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\n')) 
            tmp_60 = 1;
          else 
            if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\302')) {
              if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\205')) 
                tmp_60 = 1;
              else goto _LAND_24;
            }
            else {
              _LAND_24: ;
              if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\342')) {
                if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                  if ((int)*(string.pointer + (0 + 2)) == (int)((yaml_char_t)'\250')) 
                    tmp_60 = 1;
                  else goto _LAND_23;
                }
                else goto _LAND_23;
              }
              else {
                _LAND_23: ;
                if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\342')) {
                  if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                    if ((int)*(string.pointer + (0 + 2)) == (int)((yaml_char_t)'\251')) 
                      tmp_60 = 1;
                    else goto _LAND_21;
                  }
                  else goto _LAND_21;
                }
                else {
                  _LAND_21: ;
                  if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\000')) 
                    tmp_60 = 1;
                  else tmp_60 = 0;
                }
              }
            }
    preceded_by_whitespace = tmp_60;
    if (((int)*(string.pointer + 0) & 0x80) == 0x00) tmp_64 = 1;
    else {
      int tmp_63;
      if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) tmp_63 = 2;
      else {
        int tmp_62;
        if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) tmp_62 = 3;
        else {
          int tmp_61;
          if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) tmp_61 = 4;
          else tmp_61 = 0;
          tmp_62 = tmp_61;
        }
        tmp_63 = tmp_62;
      }
      tmp_64 = tmp_63;
    }
    string.pointer += tmp_64;
    if (string.pointer != string.end) {
      int tmp_117;
      int tmp_68;
      if (((int)*(string.pointer + 0) & 0x80) == 0x00) tmp_68 = 1;
      else {
        int tmp_67;
        if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) tmp_67 = 2;
        else {
          int tmp_66;
          if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) tmp_66 = 3;
          else {
            int tmp_65;
            if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) tmp_65 = 4;
            else tmp_65 = 0;
            tmp_66 = tmp_65;
          }
          tmp_67 = tmp_66;
        }
        tmp_68 = tmp_67;
      }
      ;
      if ((int)*(string.pointer + tmp_68) == (int)((yaml_char_t)' ')) 
        tmp_117 = 1;
      else {
        int tmp_72;
        if (((int)*(string.pointer + 0) & 0x80) == 0x00) tmp_72 = 1;
        else {
          int tmp_71;
          if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) tmp_71 = 2;
          else {
            int tmp_70;
            if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) tmp_70 = 3;
            else {
              int tmp_69;
              if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) tmp_69 = 4;
              else tmp_69 = 0;
              tmp_70 = tmp_69;
            }
            tmp_71 = tmp_70;
          }
          tmp_72 = tmp_71;
        }
        ;
        if ((int)*(string.pointer + tmp_72) == (int)((yaml_char_t)'\t')) 
          tmp_117 = 1;
        else {
          int tmp_76;
          if (((int)*(string.pointer + 0) & 0x80) == 0x00) tmp_76 = 1;
          else {
            int tmp_75;
            if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) tmp_75 = 2;
            else {
              int tmp_74;
              if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) tmp_74 = 3;
              else {
                int tmp_73;
                if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) tmp_73 = 4;
                else tmp_73 = 0;
                tmp_74 = tmp_73;
              }
              tmp_75 = tmp_74;
            }
            tmp_76 = tmp_75;
          }
          ;
          if ((int)*(string.pointer + tmp_76) == (int)((yaml_char_t)'\r')) 
            tmp_117 = 1;
          else {
            int tmp_80;
            if (((int)*(string.pointer + 0) & 0x80) == 0x00) tmp_80 = 1;
            else {
              int tmp_79;
              if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) tmp_79 = 2;
              else {
                int tmp_78;
                if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) tmp_78 = 3;
                else {
                  int tmp_77;
                  if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) tmp_77 = 4;
                  else tmp_77 = 0;
                  tmp_78 = tmp_77;
                }
                tmp_79 = tmp_78;
              }
              tmp_80 = tmp_79;
            }
            ;
            if ((int)*(string.pointer + tmp_80) == (int)((yaml_char_t)'\n')) 
              tmp_117 = 1;
            else {
              int tmp_84;
              if (((int)*(string.pointer + 0) & 0x80) == 0x00) tmp_84 = 1;
              else {
                int tmp_83;
                if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) tmp_83 = 2;
                else {
                  int tmp_82;
                  if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) tmp_82 = 3;
                  else {
                    int tmp_81;
                    if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) 
                      tmp_81 = 4;
                    else tmp_81 = 0;
                    tmp_82 = tmp_81;
                  }
                  tmp_83 = tmp_82;
                }
                tmp_84 = tmp_83;
              }
              ;
              if ((int)*(string.pointer + tmp_84) == (int)((yaml_char_t)'\302')) {
                int tmp_88;
                if (((int)*(string.pointer + 0) & 0x80) == 0x00) tmp_88 = 1;
                else {
                  int tmp_87;
                  if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) tmp_87 = 2;
                  else {
                    int tmp_86;
                    if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) 
                      tmp_86 = 3;
                    else {
                      int tmp_85;
                      if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) 
                        tmp_85 = 4;
                      else tmp_85 = 0;
                      tmp_86 = tmp_85;
                    }
                    tmp_87 = tmp_86;
                  }
                  tmp_88 = tmp_87;
                }
                ;
                if ((int)*(string.pointer + (tmp_88 + 1)) == (int)((yaml_char_t)'\205')) 
                  tmp_117 = 1;
                else goto _LAND_29;
              }
              else {
                int tmp_92;
                _LAND_29:
                { /* sequence */
                  if (((int)*(string.pointer + 0) & 0x80) == 0x00) tmp_92 = 1;
                  else {
                    int tmp_91;
                    if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) 
                      tmp_91 = 2;
                    else {
                      int tmp_90;
                      if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) 
                        tmp_90 = 3;
                      else {
                        int tmp_89;
                        if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) 
                          tmp_89 = 4;
                        else tmp_89 = 0;
                        tmp_90 = tmp_89;
                      }
                      tmp_91 = tmp_90;
                    }
                    tmp_92 = tmp_91;
                  }
                  ;
                }
                if ((int)*(string.pointer + tmp_92) == (int)((yaml_char_t)'\342')) {
                  int tmp_96;
                  if (((int)*(string.pointer + 0) & 0x80) == 0x00) tmp_96 = 1;
                  else {
                    int tmp_95;
                    if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) 
                      tmp_95 = 2;
                    else {
                      int tmp_94;
                      if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) 
                        tmp_94 = 3;
                      else {
                        int tmp_93;
                        if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) 
                          tmp_93 = 4;
                        else tmp_93 = 0;
                        tmp_94 = tmp_93;
                      }
                      tmp_95 = tmp_94;
                    }
                    tmp_96 = tmp_95;
                  }
                  ;
                  if ((int)*(string.pointer + (tmp_96 + 1)) == (int)((yaml_char_t)'\200')) {
                    int tmp_100;
                    if (((int)*(string.pointer + 0) & 0x80) == 0x00) 
                      tmp_100 = 1;
                    else {
                      int tmp_99;
                      if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) 
                        tmp_99 = 2;
                      else {
                        int tmp_98;
                        if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) 
                          tmp_98 = 3;
                        else {
                          int tmp_97;
                          if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) 
                            tmp_97 = 4;
                          else tmp_97 = 0;
                          tmp_98 = tmp_97;
                        }
                        tmp_99 = tmp_98;
                      }
                      tmp_100 = tmp_99;
                    }
                    ;
                    if ((int)*(string.pointer + (tmp_100 + 2)) == (int)((yaml_char_t)'\250')) 
                      tmp_117 = 1;
                    else goto _LAND_28;
                  }
                  else goto _LAND_28;
                }
                else {
                  int tmp_104;
                  _LAND_28:
                  { /* sequence */
                    if (((int)*(string.pointer + 0) & 0x80) == 0x00) 
                      tmp_104 = 1;
                    else {
                      int tmp_103;
                      if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) 
                        tmp_103 = 2;
                      else {
                        int tmp_102;
                        if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) 
                          tmp_102 = 3;
                        else {
                          int tmp_101;
                          if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) 
                            tmp_101 = 4;
                          else tmp_101 = 0;
                          tmp_102 = tmp_101;
                        }
                        tmp_103 = tmp_102;
                      }
                      tmp_104 = tmp_103;
                    }
                    ;
                  }
                  if ((int)*(string.pointer + tmp_104) == (int)((yaml_char_t)'\342')) {
                    int tmp_108;
                    if (((int)*(string.pointer + 0) & 0x80) == 0x00) 
                      tmp_108 = 1;
                    else {
                      int tmp_107;
                      if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) 
                        tmp_107 = 2;
                      else {
                        int tmp_106;
                        if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) 
                          tmp_106 = 3;
                        else {
                          int tmp_105;
                          if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) 
                            tmp_105 = 4;
                          else tmp_105 = 0;
                          tmp_106 = tmp_105;
                        }
                        tmp_107 = tmp_106;
                      }
                      tmp_108 = tmp_107;
                    }
                    ;
                    if ((int)*(string.pointer + (tmp_108 + 1)) == (int)((yaml_char_t)'\200')) {
                      int tmp_112;
                      if (((int)*(string.pointer + 0) & 0x80) == 0x00) 
                        tmp_112 = 1;
                      else {
                        int tmp_111;
                        if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) 
                          tmp_111 = 2;
                        else {
                          int tmp_110;
                          if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) 
                            tmp_110 = 3;
                          else {
                            int tmp_109;
                            if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) 
                              tmp_109 = 4;
                            else tmp_109 = 0;
                            tmp_110 = tmp_109;
                          }
                          tmp_111 = tmp_110;
                        }
                        tmp_112 = tmp_111;
                      }
                      ;
                      if ((int)*(string.pointer + (tmp_112 + 2)) == (int)((yaml_char_t)'\251')) 
                        tmp_117 = 1;
                      else goto _LAND_26;
                    }
                    else goto _LAND_26;
                  }
                  else {
                    int tmp_116;
                    _LAND_26:
                    { /* sequence */
                      if (((int)*(string.pointer + 0) & 0x80) == 0x00) 
                        tmp_116 = 1;
                      else {
                        int tmp_115;
                        if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) 
                          tmp_115 = 2;
                        else {
                          int tmp_114;
                          if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) 
                            tmp_114 = 3;
                          else {
                            int tmp_113;
                            if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) 
                              tmp_113 = 4;
                            else tmp_113 = 0;
                            tmp_114 = tmp_113;
                          }
                          tmp_115 = tmp_114;
                        }
                        tmp_116 = tmp_115;
                      }
                      ;
                    }
                    if ((int)*(string.pointer + tmp_116) == (int)((yaml_char_t)'\000')) 
                      tmp_117 = 1;
                    else tmp_117 = 0;
                  }
                }
              }
            }
          }
        }
      }
      followed_by_whitespace = tmp_117;
    }
  }
  emitter->scalar_data.multiline = line_breaks;
  emitter->scalar_data.flow_plain_allowed = 1;
  emitter->scalar_data.block_plain_allowed = 1;
  emitter->scalar_data.single_quoted_allowed = 1;
  emitter->scalar_data.block_allowed = 1;
  if (leading_space) goto _LOR_7;
  else 
    if (leading_break) goto _LOR_7;
    else 
      if (trailing_space) goto _LOR_7;
      else 
        if (trailing_break) {
          _LOR_7:
          {
            emitter->scalar_data.flow_plain_allowed = 0;
            emitter->scalar_data.block_plain_allowed = 0;
          }
        }
  if (trailing_space) emitter->scalar_data.block_allowed = 0;
  if (break_space) {
    emitter->scalar_data.flow_plain_allowed = 0;
    emitter->scalar_data.block_plain_allowed = 0;
    emitter->scalar_data.single_quoted_allowed = 0;
  }
  if (space_break) goto _LOR_8;
  else 
    if (special_characters) {
      _LOR_8:
      {
        emitter->scalar_data.flow_plain_allowed = 0;
        emitter->scalar_data.block_plain_allowed = 0;
        emitter->scalar_data.single_quoted_allowed = 0;
        emitter->scalar_data.block_allowed = 0;
      }
    }
  if (line_breaks) {
    emitter->scalar_data.flow_plain_allowed = 0;
    emitter->scalar_data.block_plain_allowed = 0;
  }
  if (flow_indicators) emitter->scalar_data.flow_plain_allowed = 0;
  if (block_indicators) emitter->scalar_data.block_plain_allowed = 0;
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_analyze_event(yaml_emitter_t *emitter,
                                      yaml_event_t *event)
{
  int __retres;
  emitter->anchor_data.anchor = (yaml_char_t *)0;
  emitter->anchor_data.anchor_length = (size_t)0;
  emitter->tag_data.handle = (yaml_char_t *)0;
  emitter->tag_data.handle_length = (size_t)0;
  emitter->tag_data.suffix = (yaml_char_t *)0;
  emitter->tag_data.suffix_length = (size_t)0;
  emitter->scalar_data.value = (yaml_char_t *)0;
  emitter->scalar_data.length = (size_t)0;
  switch (event->type) {
    int tmp;
    int tmp_2;
    case YAML_ALIAS_EVENT:
    tmp = yaml_emitter_analyze_anchor(emitter,event->data.alias.anchor,1);
    if (! tmp) {
      __retres = 0;
      goto return_label;
    }
    __retres = 1;
    goto return_label;
    case YAML_SCALAR_EVENT: ;
    if (event->data.scalar.anchor) {
      int tmp_0;
      tmp_0 = yaml_emitter_analyze_anchor(emitter,event->data.scalar.anchor,
                                          0);
      if (! tmp_0) {
        __retres = 0;
        goto return_label;
      }
    }
    if (event->data.scalar.tag) 
      if (emitter->canonical) goto _LOR;
      else 
        if (! event->data.scalar.plain_implicit) 
          if (! event->data.scalar.quoted_implicit) {
            _LOR:
            {
              int tmp_1;
              tmp_1 = yaml_emitter_analyze_tag(emitter,
                                               event->data.scalar.tag);
              if (! tmp_1) {
                __retres = 0;
                goto return_label;
              }
            }
          }
    tmp_2 = yaml_emitter_analyze_scalar(emitter,event->data.scalar.value,
                                        event->data.scalar.length);
    if (! tmp_2) {
      __retres = 0;
      goto return_label;
    }
    __retres = 1;
    goto return_label;
    case YAML_SEQUENCE_START_EVENT: ;
    if (event->data.sequence_start.anchor) {
      int tmp_3;
      tmp_3 = yaml_emitter_analyze_anchor(emitter,
                                          event->data.sequence_start.anchor,
                                          0);
      if (! tmp_3) {
        __retres = 0;
        goto return_label;
      }
    }
    if (event->data.sequence_start.tag) 
      if (emitter->canonical) goto _LOR_0;
      else 
        if (! event->data.sequence_start.implicit) {
          _LOR_0:
          {
            int tmp_4;
            tmp_4 = yaml_emitter_analyze_tag(emitter,
                                             event->data.sequence_start.tag);
            if (! tmp_4) {
              __retres = 0;
              goto return_label;
            }
          }
        }
    __retres = 1;
    goto return_label;
    case YAML_MAPPING_START_EVENT: ;
    if (event->data.mapping_start.anchor) {
      int tmp_5;
      tmp_5 = yaml_emitter_analyze_anchor(emitter,
                                          event->data.mapping_start.anchor,0);
      if (! tmp_5) {
        __retres = 0;
        goto return_label;
      }
    }
    if (event->data.mapping_start.tag) 
      if (emitter->canonical) goto _LOR_1;
      else 
        if (! event->data.mapping_start.implicit) {
          _LOR_1:
          {
            int tmp_6;
            tmp_6 = yaml_emitter_analyze_tag(emitter,
                                             event->data.mapping_start.tag);
            if (! tmp_6) {
              __retres = 0;
              goto return_label;
            }
          }
        }
    __retres = 1;
    goto return_label;
    default: __retres = 1;
    goto return_label;
  }
  return_label: return __retres;
}

static int yaml_emitter_write_bom(yaml_emitter_t *emitter)
{
  int __retres;
  yaml_char_t *tmp_0;
  yaml_char_t *tmp_1;
  yaml_char_t *tmp_2;
  if (! (emitter->buffer.pointer + 5 < emitter->buffer.end)) {
    int tmp;
    tmp = yaml_emitter_flush(emitter);
    if (! tmp) {
      __retres = 0;
      goto return_label;
    }
  }
  tmp_0 = emitter->buffer.pointer;
  (emitter->buffer.pointer) ++;
  *tmp_0 = (yaml_char_t)'\357';
  tmp_1 = emitter->buffer.pointer;
  (emitter->buffer.pointer) ++;
  *tmp_1 = (yaml_char_t)'\273';
  tmp_2 = emitter->buffer.pointer;
  (emitter->buffer.pointer) ++;
  *tmp_2 = (yaml_char_t)'\277';
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_write_indent(yaml_emitter_t *emitter)
{
  int __retres;
  int tmp;
  if (emitter->indent >= 0) tmp = emitter->indent; else tmp = 0;
  int indent = tmp;
  if (! emitter->indention) goto _LOR_0;
  else 
    if (emitter->column > indent) goto _LOR_0;
    else 
      if (emitter->column == indent) 
        if (! emitter->whitespace) 
          _LOR_0:
          if (emitter->buffer.pointer + 5 < emitter->buffer.end) goto _LOR;
          else {
            int tmp_0;
            tmp_0 = yaml_emitter_flush(emitter);
            if (tmp_0) {
              _LOR: ;
              if (emitter->line_break == (unsigned int)YAML_CR_BREAK) {
                yaml_char_t *tmp_1;
                tmp_1 = emitter->buffer.pointer;
                (emitter->buffer.pointer) ++;
                *tmp_1 = (yaml_char_t)'\r';
                yaml_char_t tmp_9 = *tmp_1;
              }
              else 
                if (emitter->line_break == (unsigned int)YAML_LN_BREAK) {
                  yaml_char_t *tmp_2;
                  tmp_2 = emitter->buffer.pointer;
                  (emitter->buffer.pointer) ++;
                  *tmp_2 = (yaml_char_t)'\n';
                  yaml_char_t tmp_7 = *tmp_2;
                }
                else 
                  if (emitter->line_break == (unsigned int)YAML_CRLN_BREAK) {
                    yaml_char_t *tmp_3;
                    yaml_char_t *tmp_4;
                    tmp_3 = emitter->buffer.pointer;
                    (emitter->buffer.pointer) ++;
                    *tmp_3 = (yaml_char_t)'\r';
                    tmp_4 = emitter->buffer.pointer;
                    (emitter->buffer.pointer) ++;
                    *tmp_4 = (yaml_char_t)'\n';
                    yaml_char_t tmp_5 = *tmp_4;
                  }
              emitter->column = 0;
              (emitter->line) ++;
            }
            else {
              __retres = 0;
              goto return_label;
            }
          }
  while (emitter->column < indent) 
    if (emitter->buffer.pointer + 5 < emitter->buffer.end) goto _LOR_1;
    else {
      int tmp_5_0;
      tmp_5_0 = yaml_emitter_flush(emitter);
      if (tmp_5_0) {
        yaml_char_t *tmp_6;
        _LOR_1:
        { /* sequence */
          tmp_6 = emitter->buffer.pointer;
          (emitter->buffer.pointer) ++;
          *tmp_6 = (yaml_char_t)' ';
        }
        (emitter->column) ++;
      }
      else {
        __retres = 0;
        goto return_label;
      }
    }
  emitter->whitespace = 1;
  emitter->indention = 1;
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_write_indicator(yaml_emitter_t *emitter,
                                        char const *indicator,
                                        int need_whitespace,
                                        int is_whitespace, int is_indention)
{
  int __retres;
  size_t indicator_length;
  yaml_string_t string;
  int tmp_22_0;
  indicator_length = strlen(indicator);
  string.start = (yaml_char_t *)indicator;
  string.end = (yaml_char_t *)indicator + indicator_length;
  string.pointer = (yaml_char_t *)indicator;
  if (need_whitespace) 
    if (! emitter->whitespace) 
      if (emitter->buffer.pointer + 5 < emitter->buffer.end) goto _LOR;
      else {
        int tmp;
        tmp = yaml_emitter_flush(emitter);
        if (tmp) {
          yaml_char_t *tmp_0;
          _LOR:
          { /* sequence */
            tmp_0 = emitter->buffer.pointer;
            (emitter->buffer.pointer) ++;
            *tmp_0 = (yaml_char_t)' ';
          }
          (emitter->column) ++;
        }
        else {
          __retres = 0;
          goto return_label;
        }
      }
  while (string.pointer != string.end) 
    if (emitter->buffer.pointer + 5 < emitter->buffer.end) goto _LOR_0;
    else {
      int tmp_1;
      tmp_1 = yaml_emitter_flush(emitter);
      if (tmp_1) {
        _LOR_0: ;
        if (((int)*(string.pointer) & 0x80) == 0x00) {
          yaml_char_t *tmp_2;
          yaml_char_t *tmp_3;
          tmp_2 = emitter->buffer.pointer;
          (emitter->buffer.pointer) ++;
          tmp_3 = string.pointer;
          (string.pointer) ++;
          *tmp_2 = *tmp_3;
          yaml_char_t tmp_28 = *tmp_2;
        }
        else 
          if (((int)*(string.pointer) & 0xE0) == 0xC0) {
            yaml_char_t *tmp_4;
            yaml_char_t *tmp_5;
            yaml_char_t *tmp_6;
            yaml_char_t *tmp_7;
            tmp_4 = emitter->buffer.pointer;
            (emitter->buffer.pointer) ++;
            tmp_5 = string.pointer;
            (string.pointer) ++;
            *tmp_4 = *tmp_5;
            tmp_6 = emitter->buffer.pointer;
            (emitter->buffer.pointer) ++;
            tmp_7 = string.pointer;
            (string.pointer) ++;
            *tmp_6 = *tmp_7;
            yaml_char_t tmp_26 = *tmp_6;
          }
          else 
            if (((int)*(string.pointer) & 0xF0) == 0xE0) {
              yaml_char_t *tmp_8;
              yaml_char_t *tmp_9;
              yaml_char_t *tmp_10;
              yaml_char_t *tmp_11;
              yaml_char_t *tmp_12;
              yaml_char_t *tmp_13;
              tmp_8 = emitter->buffer.pointer;
              (emitter->buffer.pointer) ++;
              tmp_9 = string.pointer;
              (string.pointer) ++;
              *tmp_8 = *tmp_9;
              tmp_10 = emitter->buffer.pointer;
              (emitter->buffer.pointer) ++;
              tmp_11 = string.pointer;
              (string.pointer) ++;
              *tmp_10 = *tmp_11;
              tmp_12 = emitter->buffer.pointer;
              (emitter->buffer.pointer) ++;
              tmp_13 = string.pointer;
              (string.pointer) ++;
              *tmp_12 = *tmp_13;
              yaml_char_t tmp_24 = *tmp_12;
            }
            else 
              if (((int)*(string.pointer) & 0xF8) == 0xF0) {
                yaml_char_t *tmp_14;
                yaml_char_t *tmp_15;
                yaml_char_t *tmp_16;
                yaml_char_t *tmp_17;
                yaml_char_t *tmp_18;
                yaml_char_t *tmp_19;
                yaml_char_t *tmp_20;
                yaml_char_t *tmp_21;
                tmp_14 = emitter->buffer.pointer;
                (emitter->buffer.pointer) ++;
                tmp_15 = string.pointer;
                (string.pointer) ++;
                *tmp_14 = *tmp_15;
                tmp_16 = emitter->buffer.pointer;
                (emitter->buffer.pointer) ++;
                tmp_17 = string.pointer;
                (string.pointer) ++;
                *tmp_16 = *tmp_17;
                tmp_18 = emitter->buffer.pointer;
                (emitter->buffer.pointer) ++;
                tmp_19 = string.pointer;
                (string.pointer) ++;
                *tmp_18 = *tmp_19;
                tmp_20 = emitter->buffer.pointer;
                (emitter->buffer.pointer) ++;
                tmp_21 = string.pointer;
                (string.pointer) ++;
                *tmp_20 = *tmp_21;
                yaml_char_t tmp_22 = *tmp_20;
              }
        (emitter->column) ++;
      }
      else {
        __retres = 0;
        goto return_label;
      }
    }
  emitter->whitespace = is_whitespace;
  if (emitter->indention) 
    if (is_indention) tmp_22_0 = 1; else tmp_22_0 = 0;
  else tmp_22_0 = 0;
  emitter->indention = tmp_22_0;
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_write_anchor(yaml_emitter_t *emitter,
                                     yaml_char_t *value, size_t length)
{
  int __retres;
  yaml_string_t string;
  string.start = value;
  string.end = value + length;
  string.pointer = value;
  while (string.pointer != string.end) 
    if (emitter->buffer.pointer + 5 < emitter->buffer.end) goto _LOR;
    else {
      int tmp;
      tmp = yaml_emitter_flush(emitter);
      if (tmp) {
        _LOR: ;
        if (((int)*(string.pointer) & 0x80) == 0x00) {
          yaml_char_t *tmp_0;
          yaml_char_t *tmp_1;
          tmp_0 = emitter->buffer.pointer;
          (emitter->buffer.pointer) ++;
          tmp_1 = string.pointer;
          (string.pointer) ++;
          *tmp_0 = *tmp_1;
          yaml_char_t tmp_26 = *tmp_0;
        }
        else 
          if (((int)*(string.pointer) & 0xE0) == 0xC0) {
            yaml_char_t *tmp_2;
            yaml_char_t *tmp_3;
            yaml_char_t *tmp_4;
            yaml_char_t *tmp_5;
            tmp_2 = emitter->buffer.pointer;
            (emitter->buffer.pointer) ++;
            tmp_3 = string.pointer;
            (string.pointer) ++;
            *tmp_2 = *tmp_3;
            tmp_4 = emitter->buffer.pointer;
            (emitter->buffer.pointer) ++;
            tmp_5 = string.pointer;
            (string.pointer) ++;
            *tmp_4 = *tmp_5;
            yaml_char_t tmp_24 = *tmp_4;
          }
          else 
            if (((int)*(string.pointer) & 0xF0) == 0xE0) {
              yaml_char_t *tmp_6;
              yaml_char_t *tmp_7;
              yaml_char_t *tmp_8;
              yaml_char_t *tmp_9;
              yaml_char_t *tmp_10;
              yaml_char_t *tmp_11;
              tmp_6 = emitter->buffer.pointer;
              (emitter->buffer.pointer) ++;
              tmp_7 = string.pointer;
              (string.pointer) ++;
              *tmp_6 = *tmp_7;
              tmp_8 = emitter->buffer.pointer;
              (emitter->buffer.pointer) ++;
              tmp_9 = string.pointer;
              (string.pointer) ++;
              *tmp_8 = *tmp_9;
              tmp_10 = emitter->buffer.pointer;
              (emitter->buffer.pointer) ++;
              tmp_11 = string.pointer;
              (string.pointer) ++;
              *tmp_10 = *tmp_11;
              yaml_char_t tmp_22 = *tmp_10;
            }
            else 
              if (((int)*(string.pointer) & 0xF8) == 0xF0) {
                yaml_char_t *tmp_12;
                yaml_char_t *tmp_13;
                yaml_char_t *tmp_14;
                yaml_char_t *tmp_15;
                yaml_char_t *tmp_16;
                yaml_char_t *tmp_17;
                yaml_char_t *tmp_18;
                yaml_char_t *tmp_19;
                tmp_12 = emitter->buffer.pointer;
                (emitter->buffer.pointer) ++;
                tmp_13 = string.pointer;
                (string.pointer) ++;
                *tmp_12 = *tmp_13;
                tmp_14 = emitter->buffer.pointer;
                (emitter->buffer.pointer) ++;
                tmp_15 = string.pointer;
                (string.pointer) ++;
                *tmp_14 = *tmp_15;
                tmp_16 = emitter->buffer.pointer;
                (emitter->buffer.pointer) ++;
                tmp_17 = string.pointer;
                (string.pointer) ++;
                *tmp_16 = *tmp_17;
                tmp_18 = emitter->buffer.pointer;
                (emitter->buffer.pointer) ++;
                tmp_19 = string.pointer;
                (string.pointer) ++;
                *tmp_18 = *tmp_19;
                yaml_char_t tmp_20 = *tmp_18;
              }
        (emitter->column) ++;
      }
      else {
        __retres = 0;
        goto return_label;
      }
    }
  emitter->whitespace = 0;
  emitter->indention = 0;
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_write_tag_handle(yaml_emitter_t *emitter,
                                         yaml_char_t *value, size_t length)
{
  int __retres;
  yaml_string_t string;
  string.start = value;
  string.end = value + length;
  string.pointer = value;
  if (! emitter->whitespace) 
    if (emitter->buffer.pointer + 5 < emitter->buffer.end) goto _LOR;
    else {
      int tmp;
      tmp = yaml_emitter_flush(emitter);
      if (tmp) {
        yaml_char_t *tmp_0;
        _LOR:
        { /* sequence */
          tmp_0 = emitter->buffer.pointer;
          (emitter->buffer.pointer) ++;
          *tmp_0 = (yaml_char_t)' ';
        }
        (emitter->column) ++;
      }
      else {
        __retres = 0;
        goto return_label;
      }
    }
  while (string.pointer != string.end) 
    if (emitter->buffer.pointer + 5 < emitter->buffer.end) goto _LOR_0;
    else {
      int tmp_1;
      tmp_1 = yaml_emitter_flush(emitter);
      if (tmp_1) {
        _LOR_0: ;
        if (((int)*(string.pointer) & 0x80) == 0x00) {
          yaml_char_t *tmp_2;
          yaml_char_t *tmp_3;
          tmp_2 = emitter->buffer.pointer;
          (emitter->buffer.pointer) ++;
          tmp_3 = string.pointer;
          (string.pointer) ++;
          *tmp_2 = *tmp_3;
          yaml_char_t tmp_28 = *tmp_2;
        }
        else 
          if (((int)*(string.pointer) & 0xE0) == 0xC0) {
            yaml_char_t *tmp_4;
            yaml_char_t *tmp_5;
            yaml_char_t *tmp_6;
            yaml_char_t *tmp_7;
            tmp_4 = emitter->buffer.pointer;
            (emitter->buffer.pointer) ++;
            tmp_5 = string.pointer;
            (string.pointer) ++;
            *tmp_4 = *tmp_5;
            tmp_6 = emitter->buffer.pointer;
            (emitter->buffer.pointer) ++;
            tmp_7 = string.pointer;
            (string.pointer) ++;
            *tmp_6 = *tmp_7;
            yaml_char_t tmp_26 = *tmp_6;
          }
          else 
            if (((int)*(string.pointer) & 0xF0) == 0xE0) {
              yaml_char_t *tmp_8;
              yaml_char_t *tmp_9;
              yaml_char_t *tmp_10;
              yaml_char_t *tmp_11;
              yaml_char_t *tmp_12;
              yaml_char_t *tmp_13;
              tmp_8 = emitter->buffer.pointer;
              (emitter->buffer.pointer) ++;
              tmp_9 = string.pointer;
              (string.pointer) ++;
              *tmp_8 = *tmp_9;
              tmp_10 = emitter->buffer.pointer;
              (emitter->buffer.pointer) ++;
              tmp_11 = string.pointer;
              (string.pointer) ++;
              *tmp_10 = *tmp_11;
              tmp_12 = emitter->buffer.pointer;
              (emitter->buffer.pointer) ++;
              tmp_13 = string.pointer;
              (string.pointer) ++;
              *tmp_12 = *tmp_13;
              yaml_char_t tmp_24 = *tmp_12;
            }
            else 
              if (((int)*(string.pointer) & 0xF8) == 0xF0) {
                yaml_char_t *tmp_14;
                yaml_char_t *tmp_15;
                yaml_char_t *tmp_16;
                yaml_char_t *tmp_17;
                yaml_char_t *tmp_18;
                yaml_char_t *tmp_19;
                yaml_char_t *tmp_20;
                yaml_char_t *tmp_21;
                tmp_14 = emitter->buffer.pointer;
                (emitter->buffer.pointer) ++;
                tmp_15 = string.pointer;
                (string.pointer) ++;
                *tmp_14 = *tmp_15;
                tmp_16 = emitter->buffer.pointer;
                (emitter->buffer.pointer) ++;
                tmp_17 = string.pointer;
                (string.pointer) ++;
                *tmp_16 = *tmp_17;
                tmp_18 = emitter->buffer.pointer;
                (emitter->buffer.pointer) ++;
                tmp_19 = string.pointer;
                (string.pointer) ++;
                *tmp_18 = *tmp_19;
                tmp_20 = emitter->buffer.pointer;
                (emitter->buffer.pointer) ++;
                tmp_21 = string.pointer;
                (string.pointer) ++;
                *tmp_20 = *tmp_21;
                yaml_char_t tmp_22 = *tmp_20;
              }
        (emitter->column) ++;
      }
      else {
        __retres = 0;
        goto return_label;
      }
    }
  emitter->whitespace = 0;
  emitter->indention = 0;
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_write_tag_content(yaml_emitter_t *emitter,
                                          yaml_char_t *value, size_t length,
                                          int need_whitespace)
{
  int __retres;
  yaml_string_t string;
  string.start = value;
  string.end = value + length;
  string.pointer = value;
  if (need_whitespace) 
    if (! emitter->whitespace) 
      if (emitter->buffer.pointer + 5 < emitter->buffer.end) goto _LOR;
      else {
        int tmp;
        tmp = yaml_emitter_flush(emitter);
        if (tmp) {
          yaml_char_t *tmp_0;
          _LOR:
          { /* sequence */
            tmp_0 = emitter->buffer.pointer;
            (emitter->buffer.pointer) ++;
            *tmp_0 = (yaml_char_t)' ';
          }
          (emitter->column) ++;
        }
        else {
          __retres = 0;
          goto return_label;
        }
      }
  while (string.pointer != string.end) 
    if ((int)*(string.pointer + 0) >= (int)((yaml_char_t)'0')) {
      if ((int)*(string.pointer + 0) <= (int)((yaml_char_t)'9')) goto _LOR_4;
      else goto _LAND_1;
    }
    else {
      _LAND_1: ;
      if ((int)*(string.pointer + 0) >= (int)((yaml_char_t)'A')) {
        if ((int)*(string.pointer + 0) <= (int)((yaml_char_t)'Z')) goto _LOR_4;
        else goto _LAND_0;
      }
      else {
        _LAND_0: ;
        if ((int)*(string.pointer + 0) >= (int)((yaml_char_t)'a')) {
          if ((int)*(string.pointer + 0) <= (int)((yaml_char_t)'z')) 
            goto _LOR_4;
          else goto _LAND;
        }
        else {
          _LAND: ;
          if ((int)*(string.pointer + 0) == '_') goto _LOR_4;
          else 
            if ((int)*(string.pointer + 0) == '-') goto _LOR_4;
            else 
              if ((int)*(string.pointer + 0) == (int)((yaml_char_t)';')) 
                goto _LOR_4;
              else 
                if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'/')) 
                  goto _LOR_4;
                else 
                  if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'?')) 
                    goto _LOR_4;
                  else 
                    if ((int)*(string.pointer + 0) == (int)((yaml_char_t)':')) 
                      goto _LOR_4;
                    else 
                      if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'@')) 
                        goto _LOR_4;
                      else 
                        if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'&')) 
                          goto _LOR_4;
                        else 
                          if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'=')) 
                            goto _LOR_4;
                          else 
                            if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'+')) 
                              goto _LOR_4;
                            else 
                              if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'$')) 
                                goto _LOR_4;
                              else 
                                if ((int)*(string.pointer + 0) == (int)((yaml_char_t)',')) 
                                  goto _LOR_4;
                                else 
                                  if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'_')) 
                                    goto _LOR_4;
                                  else 
                                    if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'.')) 
                                      goto _LOR_4;
                                    else 
                                      if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'~')) 
                                        goto _LOR_4;
                                      else 
                                        if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'*')) 
                                          goto _LOR_4;
                                        else 
                                          if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\'')) 
                                            goto _LOR_4;
                                          else 
                                            if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'(')) 
                                              goto _LOR_4;
                                            else 
                                              if ((int)*(string.pointer + 0) == (int)((yaml_char_t)')')) 
                                                goto _LOR_4;
                                              else 
                                                if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'[')) 
                                                  goto _LOR_4;
                                                else 
                                                  if ((int)*(string.pointer + 0) == (int)((yaml_char_t)']')) {
                                                    _LOR_4:
                                                    if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                                      goto _LOR_0;
                                                    else {
                                                      int tmp_1;
                                                      tmp_1 = yaml_emitter_flush
                                                      (emitter);
                                                      if (tmp_1) {
                                                        _LOR_0: ;
                                                        if (((int)*(string.pointer) & 0x80) == 0x00) {
                                                          yaml_char_t *tmp_2;
                                                          yaml_char_t *tmp_3;
                                                          tmp_2 = emitter->buffer.pointer;
                                                          (emitter->buffer.pointer) ++;
                                                          tmp_3 = string.pointer;
                                                          (string.pointer) ++;
                                                          *tmp_2 = *tmp_3;
                                                          yaml_char_t tmp_28 =
                                                            *tmp_2;
                                                        }
                                                        else 
                                                          if (((int)*(string.pointer) & 0xE0) == 0xC0) {
                                                            yaml_char_t *tmp_4;
                                                            yaml_char_t *tmp_5;
                                                            yaml_char_t *tmp_6;
                                                            yaml_char_t *tmp_7;
                                                            tmp_4 = emitter->buffer.pointer;
                                                            (emitter->buffer.pointer) ++;
                                                            tmp_5 = string.pointer;
                                                            (string.pointer) ++;
                                                            *tmp_4 = *tmp_5;
                                                            tmp_6 = emitter->buffer.pointer;
                                                            (emitter->buffer.pointer) ++;
                                                            tmp_7 = string.pointer;
                                                            (string.pointer) ++;
                                                            *tmp_6 = *tmp_7;
                                                            yaml_char_t tmp_26 =
                                                              *tmp_6;
                                                          }
                                                          else 
                                                            if (((int)*(string.pointer) & 0xF0) == 0xE0) {
                                                              yaml_char_t *tmp_8;
                                                              yaml_char_t *tmp_9;
                                                              yaml_char_t *tmp_10;
                                                              yaml_char_t *tmp_11;
                                                              yaml_char_t *tmp_12;
                                                              yaml_char_t *tmp_13;
                                                              tmp_8 = emitter->buffer.pointer;
                                                              (emitter->buffer.pointer) ++;
                                                              tmp_9 = string.pointer;
                                                              (string.pointer) ++;
                                                              *tmp_8 = *tmp_9;
                                                              tmp_10 = emitter->buffer.pointer;
                                                              (emitter->buffer.pointer) ++;
                                                              tmp_11 = string.pointer;
                                                              (string.pointer) ++;
                                                              *tmp_10 = *tmp_11;
                                                              tmp_12 = emitter->buffer.pointer;
                                                              (emitter->buffer.pointer) ++;
                                                              tmp_13 = string.pointer;
                                                              (string.pointer) ++;
                                                              *tmp_12 = *tmp_13;
                                                              yaml_char_t tmp_24 =
                                                                *tmp_12;
                                                            }
                                                            else 
                                                              if (((int)*(string.pointer) & 0xF8) == 0xF0) {
                                                                yaml_char_t *tmp_14;
                                                                yaml_char_t *tmp_15;
                                                                yaml_char_t *tmp_16;
                                                                yaml_char_t *tmp_17;
                                                                yaml_char_t *tmp_18;
                                                                yaml_char_t *tmp_19;
                                                                yaml_char_t *tmp_20;
                                                                yaml_char_t *tmp_21;
                                                                tmp_14 = emitter->buffer.pointer;
                                                                (emitter->buffer.pointer) ++;
                                                                tmp_15 = string.pointer;
                                                                (string.pointer) ++;
                                                                *tmp_14 = *tmp_15;
                                                                tmp_16 = emitter->buffer.pointer;
                                                                (emitter->buffer.pointer) ++;
                                                                tmp_17 = string.pointer;
                                                                (string.pointer) ++;
                                                                *tmp_16 = *tmp_17;
                                                                tmp_18 = emitter->buffer.pointer;
                                                                (emitter->buffer.pointer) ++;
                                                                tmp_19 = string.pointer;
                                                                (string.pointer) ++;
                                                                *tmp_18 = *tmp_19;
                                                                tmp_20 = emitter->buffer.pointer;
                                                                (emitter->buffer.pointer) ++;
                                                                tmp_21 = string.pointer;
                                                                (string.pointer) ++;
                                                                *tmp_20 = *tmp_21;
                                                                yaml_char_t tmp_22 =
                                                                  *tmp_20;
                                                              }
                                                        (emitter->column) ++;
                                                      }
                                                      else {
                                                        __retres = 0;
                                                        goto return_label;
                                                      }
                                                    }
                                                  }
                                                  else {
                                                    int tmp_25;
                                                    unsigned int value_0;
                                                    if (((int)*(string.pointer + 0) & 0x80) == 0x00) 
                                                      tmp_25 = 1;
                                                    else {
                                                      int tmp_24_0;
                                                      if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) 
                                                        tmp_24_0 = 2;
                                                      else {
                                                        int tmp_23;
                                                        if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) 
                                                          tmp_23 = 3;
                                                        else {
                                                          int tmp_22_1;
                                                          if (((int)*(
                                                               string.pointer + 0) & 0xF8) == 0xF0) 
                                                            tmp_22_1 = 4;
                                                          else tmp_22_1 = 0;
                                                          tmp_23 = tmp_22_1;
                                                        }
                                                        tmp_24_0 = tmp_23;
                                                      }
                                                      tmp_25 = tmp_24_0;
                                                    }
                                                    int width = tmp_25;
                                                    while (1) {
                                                      int tmp_35;
                                                      tmp_35 = width;
                                                      width --;
                                                      ;
                                                      if (! tmp_35) break;
                                                      {
                                                        yaml_char_t *tmp_26_0;
                                                        tmp_26_0 = string.pointer;
                                                        (string.pointer) ++;
                                                        value_0 = (unsigned int)*tmp_26_0;
                                                        if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                                          goto _LOR_1;
                                                        else {
                                                          int tmp_27;
                                                          tmp_27 = yaml_emitter_flush
                                                          (emitter);
                                                          if (tmp_27) {
                                                            yaml_char_t *tmp_28_0;
                                                            _LOR_1:
                                                            { /* sequence */
                                                              tmp_28_0 = emitter->buffer.pointer;
                                                              (emitter->buffer.pointer) ++;
                                                              *tmp_28_0 = (yaml_char_t)'%';
                                                            }
                                                            (emitter->column) ++;
                                                          }
                                                          else {
                                                            __retres = 0;
                                                            goto return_label;
                                                          }
                                                        }
                                                        if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                                          goto _LOR_2;
                                                        else {
                                                          int tmp_29;
                                                          tmp_29 = yaml_emitter_flush
                                                          (emitter);
                                                          if (tmp_29) {
                                                            yaml_char_t *tmp_30;
                                                            int tmp_31;
                                                            _LOR_2:
                                                            { /* sequence */
                                                              tmp_30 = emitter->buffer.pointer;
                                                              (emitter->buffer.pointer) ++;
                                                              if (value_0 >> 4 < (unsigned int)10) 
                                                                tmp_31 = '0';
                                                              else tmp_31 = 
                                                                   'A' - 10;
                                                              *tmp_30 = (yaml_char_t)(
                                                              (value_0 >> 4) + (unsigned int)tmp_31);
                                                            }
                                                            (emitter->column) ++;
                                                          }
                                                          else {
                                                            __retres = 0;
                                                            goto return_label;
                                                          }
                                                        }
                                                        if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                                          goto _LOR_3;
                                                        else {
                                                          int tmp_32;
                                                          tmp_32 = yaml_emitter_flush
                                                          (emitter);
                                                          if (tmp_32) {
                                                            yaml_char_t *tmp_33;
                                                            int tmp_34;
                                                            _LOR_3:
                                                            { /* sequence */
                                                              tmp_33 = emitter->buffer.pointer;
                                                              (emitter->buffer.pointer) ++;
                                                              if ((value_0 & (unsigned int)0x0F) < (unsigned int)10) 
                                                                tmp_34 = '0';
                                                              else tmp_34 = 
                                                                   'A' - 10;
                                                              *tmp_33 = (yaml_char_t)(
                                                              (value_0 & (unsigned int)0x0F) + (unsigned int)tmp_34);
                                                            }
                                                            (emitter->column) ++;
                                                          }
                                                          else {
                                                            __retres = 0;
                                                            goto return_label;
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
        }
      }
    }
  emitter->whitespace = 0;
  emitter->indention = 0;
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_write_plain_scalar(yaml_emitter_t *emitter,
                                           yaml_char_t *value, size_t length,
                                           int allow_breaks)
{
  int __retres;
  yaml_string_t string;
  int spaces = 0;
  int breaks = 0;
  string.start = value;
  string.end = value + length;
  string.pointer = value;
  if (! emitter->whitespace) 
    if (length) goto _LOR_0;
    else 
      if (emitter->flow_level) 
        _LOR_0:
        if (emitter->buffer.pointer + 5 < emitter->buffer.end) goto _LOR;
        else {
          int tmp;
          tmp = yaml_emitter_flush(emitter);
          if (tmp) {
            yaml_char_t *tmp_0;
            _LOR:
            { /* sequence */
              tmp_0 = emitter->buffer.pointer;
              (emitter->buffer.pointer) ++;
              *tmp_0 = (yaml_char_t)' ';
            }
            (emitter->column) ++;
          }
          else {
            __retres = 0;
            goto return_label;
          }
        }
  while (string.pointer != string.end) 
    if ((int)*(string.pointer + 0) == (int)((yaml_char_t)' ')) {
      if (allow_breaks) {
        if (! spaces) {
          if (emitter->column > emitter->best_width) {
            if (! ((int)*(string.pointer + 1) == (int)((yaml_char_t)' '))) {
              int tmp_1;
              int tmp_5;
              tmp_1 = yaml_emitter_write_indent(emitter);
              if (! tmp_1) {
                __retres = 0;
                goto return_label;
              }
              if (((int)*(string.pointer + 0) & 0x80) == 0x00) tmp_5 = 1;
              else {
                int tmp_4;
                if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) tmp_4 = 2;
                else {
                  int tmp_3;
                  if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) tmp_3 = 3;
                  else {
                    int tmp_2;
                    if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) 
                      tmp_2 = 4;
                    else tmp_2 = 0;
                    tmp_3 = tmp_2;
                  }
                  tmp_4 = tmp_3;
                }
                tmp_5 = tmp_4;
              }
              string.pointer += tmp_5;
            }
            else goto _LAND_1;
          }
          else goto _LAND_1;
        }
        else goto _LAND_1;
      }
      else 
        _LAND_1:
        if (emitter->buffer.pointer + 5 < emitter->buffer.end) goto _LOR_1;
        else {
          int tmp_6;
          tmp_6 = yaml_emitter_flush(emitter);
          if (tmp_6) {
            _LOR_1: ;
            if (((int)*(string.pointer) & 0x80) == 0x00) {
              yaml_char_t *tmp_7;
              yaml_char_t *tmp_8;
              tmp_7 = emitter->buffer.pointer;
              (emitter->buffer.pointer) ++;
              tmp_8 = string.pointer;
              (string.pointer) ++;
              *tmp_7 = *tmp_8;
              yaml_char_t tmp_33 = *tmp_7;
            }
            else 
              if (((int)*(string.pointer) & 0xE0) == 0xC0) {
                yaml_char_t *tmp_9;
                yaml_char_t *tmp_10;
                yaml_char_t *tmp_11;
                yaml_char_t *tmp_12;
                tmp_9 = emitter->buffer.pointer;
                (emitter->buffer.pointer) ++;
                tmp_10 = string.pointer;
                (string.pointer) ++;
                *tmp_9 = *tmp_10;
                tmp_11 = emitter->buffer.pointer;
                (emitter->buffer.pointer) ++;
                tmp_12 = string.pointer;
                (string.pointer) ++;
                *tmp_11 = *tmp_12;
                yaml_char_t tmp_31 = *tmp_11;
              }
              else 
                if (((int)*(string.pointer) & 0xF0) == 0xE0) {
                  yaml_char_t *tmp_13;
                  yaml_char_t *tmp_14;
                  yaml_char_t *tmp_15;
                  yaml_char_t *tmp_16;
                  yaml_char_t *tmp_17;
                  yaml_char_t *tmp_18;
                  tmp_13 = emitter->buffer.pointer;
                  (emitter->buffer.pointer) ++;
                  tmp_14 = string.pointer;
                  (string.pointer) ++;
                  *tmp_13 = *tmp_14;
                  tmp_15 = emitter->buffer.pointer;
                  (emitter->buffer.pointer) ++;
                  tmp_16 = string.pointer;
                  (string.pointer) ++;
                  *tmp_15 = *tmp_16;
                  tmp_17 = emitter->buffer.pointer;
                  (emitter->buffer.pointer) ++;
                  tmp_18 = string.pointer;
                  (string.pointer) ++;
                  *tmp_17 = *tmp_18;
                  yaml_char_t tmp_29 = *tmp_17;
                }
                else 
                  if (((int)*(string.pointer) & 0xF8) == 0xF0) {
                    yaml_char_t *tmp_19;
                    yaml_char_t *tmp_20;
                    yaml_char_t *tmp_21;
                    yaml_char_t *tmp_22;
                    yaml_char_t *tmp_23;
                    yaml_char_t *tmp_24;
                    yaml_char_t *tmp_25;
                    yaml_char_t *tmp_26;
                    tmp_19 = emitter->buffer.pointer;
                    (emitter->buffer.pointer) ++;
                    tmp_20 = string.pointer;
                    (string.pointer) ++;
                    *tmp_19 = *tmp_20;
                    tmp_21 = emitter->buffer.pointer;
                    (emitter->buffer.pointer) ++;
                    tmp_22 = string.pointer;
                    (string.pointer) ++;
                    *tmp_21 = *tmp_22;
                    tmp_23 = emitter->buffer.pointer;
                    (emitter->buffer.pointer) ++;
                    tmp_24 = string.pointer;
                    (string.pointer) ++;
                    *tmp_23 = *tmp_24;
                    tmp_25 = emitter->buffer.pointer;
                    (emitter->buffer.pointer) ++;
                    tmp_26 = string.pointer;
                    (string.pointer) ++;
                    *tmp_25 = *tmp_26;
                    yaml_char_t tmp_27 = *tmp_25;
                  }
            (emitter->column) ++;
          }
          else {
            __retres = 0;
            goto return_label;
          }
        }
      spaces = 1;
    }
    else 
      if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\r')) goto _LOR_6;
      else 
        if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\n')) goto _LOR_6;
        else 
          if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\302')) {
            if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\205')) 
              goto _LOR_6;
            else goto _LAND_6;
          }
          else {
            _LAND_6: ;
            if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\342')) {
              if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                if ((int)*(string.pointer + (0 + 2)) == (int)((yaml_char_t)'\250')) 
                  goto _LOR_6;
                else goto _LAND_5;
              }
              else goto _LAND_5;
            }
            else {
              _LAND_5: ;
              if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\342')) {
                if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                  if ((int)*(string.pointer + (0 + 2)) == (int)((yaml_char_t)'\251')) {
                    _LOR_6:
                    {
                      if (! breaks) 
                        if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\n')) 
                          if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                            goto _LOR_2;
                          else {
                            int tmp_27_0;
                            tmp_27_0 = yaml_emitter_flush(emitter);
                            if (tmp_27_0) {
                              _LOR_2: ;
                              if (emitter->line_break == (unsigned int)YAML_CR_BREAK) {
                                yaml_char_t *tmp_28;
                                tmp_28 = emitter->buffer.pointer;
                                (emitter->buffer.pointer) ++;
                                *tmp_28 = (yaml_char_t)'\r';
                                yaml_char_t tmp_39 = *tmp_28;
                              }
                              else 
                                if (emitter->line_break == (unsigned int)YAML_LN_BREAK) {
                                  yaml_char_t *tmp_29_0;
                                  tmp_29_0 = emitter->buffer.pointer;
                                  (emitter->buffer.pointer) ++;
                                  *tmp_29_0 = (yaml_char_t)'\n';
                                  yaml_char_t tmp_37 = *tmp_29_0;
                                }
                                else 
                                  if (emitter->line_break == (unsigned int)YAML_CRLN_BREAK) {
                                    yaml_char_t *tmp_30;
                                    yaml_char_t *tmp_31_0;
                                    tmp_30 = emitter->buffer.pointer;
                                    (emitter->buffer.pointer) ++;
                                    *tmp_30 = (yaml_char_t)'\r';
                                    tmp_31_0 = emitter->buffer.pointer;
                                    (emitter->buffer.pointer) ++;
                                    *tmp_31_0 = (yaml_char_t)'\n';
                                    yaml_char_t tmp_35 = *tmp_31_0;
                                  }
                              emitter->column = 0;
                              (emitter->line) ++;
                            }
                            else {
                              __retres = 0;
                              goto return_label;
                            }
                          }
                      if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                        goto _LOR_4;
                      else {
                        int tmp_32;
                        tmp_32 = yaml_emitter_flush(emitter);
                        if (tmp_32) {
                          int tmp_59_0;
                          _LOR_4: ;
                          if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\n')) {
                            int tmp_38;
                            if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                              goto _LOR_3;
                            else {
                              int tmp_33_0;
                              tmp_33_0 = yaml_emitter_flush(emitter);
                              if (tmp_33_0) {
                                _LOR_3: ;
                                if (emitter->line_break == (unsigned int)YAML_CR_BREAK) {
                                  yaml_char_t *tmp_34;
                                  tmp_34 = emitter->buffer.pointer;
                                  (emitter->buffer.pointer) ++;
                                  *tmp_34 = (yaml_char_t)'\r';
                                  yaml_char_t tmp_45 = *tmp_34;
                                }
                                else 
                                  if (emitter->line_break == (unsigned int)YAML_LN_BREAK) {
                                    yaml_char_t *tmp_35_0;
                                    tmp_35_0 = emitter->buffer.pointer;
                                    (emitter->buffer.pointer) ++;
                                    *tmp_35_0 = (yaml_char_t)'\n';
                                    yaml_char_t tmp_43 = *tmp_35_0;
                                  }
                                  else 
                                    if (emitter->line_break == (unsigned int)YAML_CRLN_BREAK) {
                                      yaml_char_t *tmp_36;
                                      yaml_char_t *tmp_37_0;
                                      tmp_36 = emitter->buffer.pointer;
                                      (emitter->buffer.pointer) ++;
                                      *tmp_36 = (yaml_char_t)'\r';
                                      tmp_37_0 = emitter->buffer.pointer;
                                      (emitter->buffer.pointer) ++;
                                      *tmp_37_0 = (yaml_char_t)'\n';
                                      yaml_char_t tmp_41 = *tmp_37_0;
                                    }
                                emitter->column = 0;
                                (emitter->line) ++;
                                tmp_38 = 1;
                              }
                              else tmp_38 = 0;
                            }
                            (string.pointer) ++;
                            tmp_59_0 = 1;
                          }
                          else {
                            if (((int)*(string.pointer) & 0x80) == 0x00) {
                              yaml_char_t *tmp_39_0;
                              yaml_char_t *tmp_40;
                              tmp_39_0 = emitter->buffer.pointer;
                              (emitter->buffer.pointer) ++;
                              tmp_40 = string.pointer;
                              (string.pointer) ++;
                              *tmp_39_0 = *tmp_40;
                              yaml_char_t tmp_65 = *tmp_39_0;
                            }
                            else 
                              if (((int)*(string.pointer) & 0xE0) == 0xC0) {
                                yaml_char_t *tmp_41_0;
                                yaml_char_t *tmp_42;
                                yaml_char_t *tmp_43_0;
                                yaml_char_t *tmp_44;
                                tmp_41_0 = emitter->buffer.pointer;
                                (emitter->buffer.pointer) ++;
                                tmp_42 = string.pointer;
                                (string.pointer) ++;
                                *tmp_41_0 = *tmp_42;
                                tmp_43_0 = emitter->buffer.pointer;
                                (emitter->buffer.pointer) ++;
                                tmp_44 = string.pointer;
                                (string.pointer) ++;
                                *tmp_43_0 = *tmp_44;
                                yaml_char_t tmp_63 = *tmp_43_0;
                              }
                              else 
                                if (((int)*(string.pointer) & 0xF0) == 0xE0) {
                                  yaml_char_t *tmp_45_0;
                                  yaml_char_t *tmp_46;
                                  yaml_char_t *tmp_47;
                                  yaml_char_t *tmp_48;
                                  yaml_char_t *tmp_49;
                                  yaml_char_t *tmp_50;
                                  tmp_45_0 = emitter->buffer.pointer;
                                  (emitter->buffer.pointer) ++;
                                  tmp_46 = string.pointer;
                                  (string.pointer) ++;
                                  *tmp_45_0 = *tmp_46;
                                  tmp_47 = emitter->buffer.pointer;
                                  (emitter->buffer.pointer) ++;
                                  tmp_48 = string.pointer;
                                  (string.pointer) ++;
                                  *tmp_47 = *tmp_48;
                                  tmp_49 = emitter->buffer.pointer;
                                  (emitter->buffer.pointer) ++;
                                  tmp_50 = string.pointer;
                                  (string.pointer) ++;
                                  *tmp_49 = *tmp_50;
                                  yaml_char_t tmp_61 = *tmp_49;
                                }
                                else 
                                  if (((int)*(string.pointer) & 0xF8) == 0xF0) {
                                    yaml_char_t *tmp_51;
                                    yaml_char_t *tmp_52;
                                    yaml_char_t *tmp_53;
                                    yaml_char_t *tmp_54;
                                    yaml_char_t *tmp_55;
                                    yaml_char_t *tmp_56;
                                    yaml_char_t *tmp_57;
                                    yaml_char_t *tmp_58;
                                    tmp_51 = emitter->buffer.pointer;
                                    (emitter->buffer.pointer) ++;
                                    tmp_52 = string.pointer;
                                    (string.pointer) ++;
                                    *tmp_51 = *tmp_52;
                                    tmp_53 = emitter->buffer.pointer;
                                    (emitter->buffer.pointer) ++;
                                    tmp_54 = string.pointer;
                                    (string.pointer) ++;
                                    *tmp_53 = *tmp_54;
                                    tmp_55 = emitter->buffer.pointer;
                                    (emitter->buffer.pointer) ++;
                                    tmp_56 = string.pointer;
                                    (string.pointer) ++;
                                    *tmp_55 = *tmp_56;
                                    tmp_57 = emitter->buffer.pointer;
                                    (emitter->buffer.pointer) ++;
                                    tmp_58 = string.pointer;
                                    (string.pointer) ++;
                                    *tmp_57 = *tmp_58;
                                    yaml_char_t tmp_59 = *tmp_57;
                                  }
                            emitter->column = 0;
                            (emitter->line) ++;
                            tmp_59_0 = 1;
                          }
                          if (! tmp_59_0) {
                            __retres = 0;
                            goto return_label;
                          }
                        }
                        else {
                          __retres = 0;
                          goto return_label;
                        }
                      }
                      emitter->indention = 1;
                      breaks = 1;
                    }
                  }
                  else goto _LAND_3;
                }
                else goto _LAND_3;
              }
              else {
                _LAND_3:
                {
                  if (breaks) {
                    int tmp_60;
                    tmp_60 = yaml_emitter_write_indent(emitter);
                    if (! tmp_60) {
                      __retres = 0;
                      goto return_label;
                    }
                  }
                  if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                    goto _LOR_5;
                  else {
                    int tmp_61_0;
                    tmp_61_0 = yaml_emitter_flush(emitter);
                    if (tmp_61_0) {
                      _LOR_5: ;
                      if (((int)*(string.pointer) & 0x80) == 0x00) {
                        yaml_char_t *tmp_62;
                        yaml_char_t *tmp_63_0;
                        tmp_62 = emitter->buffer.pointer;
                        (emitter->buffer.pointer) ++;
                        tmp_63_0 = string.pointer;
                        (string.pointer) ++;
                        *tmp_62 = *tmp_63_0;
                        yaml_char_t tmp_88 = *tmp_62;
                      }
                      else 
                        if (((int)*(string.pointer) & 0xE0) == 0xC0) {
                          yaml_char_t *tmp_64;
                          yaml_char_t *tmp_65_0;
                          yaml_char_t *tmp_66;
                          yaml_char_t *tmp_67;
                          tmp_64 = emitter->buffer.pointer;
                          (emitter->buffer.pointer) ++;
                          tmp_65_0 = string.pointer;
                          (string.pointer) ++;
                          *tmp_64 = *tmp_65_0;
                          tmp_66 = emitter->buffer.pointer;
                          (emitter->buffer.pointer) ++;
                          tmp_67 = string.pointer;
                          (string.pointer) ++;
                          *tmp_66 = *tmp_67;
                          yaml_char_t tmp_86 = *tmp_66;
                        }
                        else 
                          if (((int)*(string.pointer) & 0xF0) == 0xE0) {
                            yaml_char_t *tmp_68;
                            yaml_char_t *tmp_69;
                            yaml_char_t *tmp_70;
                            yaml_char_t *tmp_71;
                            yaml_char_t *tmp_72;
                            yaml_char_t *tmp_73;
                            tmp_68 = emitter->buffer.pointer;
                            (emitter->buffer.pointer) ++;
                            tmp_69 = string.pointer;
                            (string.pointer) ++;
                            *tmp_68 = *tmp_69;
                            tmp_70 = emitter->buffer.pointer;
                            (emitter->buffer.pointer) ++;
                            tmp_71 = string.pointer;
                            (string.pointer) ++;
                            *tmp_70 = *tmp_71;
                            tmp_72 = emitter->buffer.pointer;
                            (emitter->buffer.pointer) ++;
                            tmp_73 = string.pointer;
                            (string.pointer) ++;
                            *tmp_72 = *tmp_73;
                            yaml_char_t tmp_84 = *tmp_72;
                          }
                          else 
                            if (((int)*(string.pointer) & 0xF8) == 0xF0) {
                              yaml_char_t *tmp_74;
                              yaml_char_t *tmp_75;
                              yaml_char_t *tmp_76;
                              yaml_char_t *tmp_77;
                              yaml_char_t *tmp_78;
                              yaml_char_t *tmp_79;
                              yaml_char_t *tmp_80;
                              yaml_char_t *tmp_81;
                              tmp_74 = emitter->buffer.pointer;
                              (emitter->buffer.pointer) ++;
                              tmp_75 = string.pointer;
                              (string.pointer) ++;
                              *tmp_74 = *tmp_75;
                              tmp_76 = emitter->buffer.pointer;
                              (emitter->buffer.pointer) ++;
                              tmp_77 = string.pointer;
                              (string.pointer) ++;
                              *tmp_76 = *tmp_77;
                              tmp_78 = emitter->buffer.pointer;
                              (emitter->buffer.pointer) ++;
                              tmp_79 = string.pointer;
                              (string.pointer) ++;
                              *tmp_78 = *tmp_79;
                              tmp_80 = emitter->buffer.pointer;
                              (emitter->buffer.pointer) ++;
                              tmp_81 = string.pointer;
                              (string.pointer) ++;
                              *tmp_80 = *tmp_81;
                              yaml_char_t tmp_82 = *tmp_80;
                            }
                      (emitter->column) ++;
                    }
                    else {
                      __retres = 0;
                      goto return_label;
                    }
                  }
                  emitter->indention = 0;
                  spaces = 0;
                  breaks = 0;
                }
              }
            }
          }
  emitter->whitespace = 0;
  emitter->indention = 0;
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_write_single_quoted_scalar(yaml_emitter_t *emitter,
                                                   yaml_char_t *value,
                                                   size_t length,
                                                   int allow_breaks)
{
  int __retres;
  yaml_string_t string;
  int tmp;
  int tmp_84;
  int spaces = 0;
  int breaks = 0;
  string.start = value;
  string.end = value + length;
  string.pointer = value;
  tmp = yaml_emitter_write_indicator(emitter,"\'",1,0,0);
  if (! tmp) {
    __retres = 0;
    goto return_label;
  }
  while (string.pointer != string.end) 
    if ((int)*(string.pointer + 0) == (int)((yaml_char_t)' ')) {
      if (allow_breaks) {
        if (! spaces) {
          if (emitter->column > emitter->best_width) {
            if (string.pointer != string.start) {
              if (string.pointer != string.end - 1) {
                if (! ((int)*(string.pointer + 1) == (int)((yaml_char_t)' '))) {
                  int tmp_0;
                  int tmp_4;
                  tmp_0 = yaml_emitter_write_indent(emitter);
                  if (! tmp_0) {
                    __retres = 0;
                    goto return_label;
                  }
                  if (((int)*(string.pointer + 0) & 0x80) == 0x00) tmp_4 = 1;
                  else {
                    int tmp_3;
                    if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) 
                      tmp_3 = 2;
                    else {
                      int tmp_2;
                      if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) 
                        tmp_2 = 3;
                      else {
                        int tmp_1;
                        if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) 
                          tmp_1 = 4;
                        else tmp_1 = 0;
                        tmp_2 = tmp_1;
                      }
                      tmp_3 = tmp_2;
                    }
                    tmp_4 = tmp_3;
                  }
                  string.pointer += tmp_4;
                }
                else goto _LAND_3;
              }
              else goto _LAND_3;
            }
            else goto _LAND_3;
          }
          else goto _LAND_3;
        }
        else goto _LAND_3;
      }
      else 
        _LAND_3:
        if (emitter->buffer.pointer + 5 < emitter->buffer.end) goto _LOR;
        else {
          int tmp_5;
          tmp_5 = yaml_emitter_flush(emitter);
          if (tmp_5) {
            _LOR: ;
            if (((int)*(string.pointer) & 0x80) == 0x00) {
              yaml_char_t *tmp_6;
              yaml_char_t *tmp_7;
              tmp_6 = emitter->buffer.pointer;
              (emitter->buffer.pointer) ++;
              tmp_7 = string.pointer;
              (string.pointer) ++;
              *tmp_6 = *tmp_7;
              yaml_char_t tmp_32 = *tmp_6;
            }
            else 
              if (((int)*(string.pointer) & 0xE0) == 0xC0) {
                yaml_char_t *tmp_8;
                yaml_char_t *tmp_9;
                yaml_char_t *tmp_10;
                yaml_char_t *tmp_11;
                tmp_8 = emitter->buffer.pointer;
                (emitter->buffer.pointer) ++;
                tmp_9 = string.pointer;
                (string.pointer) ++;
                *tmp_8 = *tmp_9;
                tmp_10 = emitter->buffer.pointer;
                (emitter->buffer.pointer) ++;
                tmp_11 = string.pointer;
                (string.pointer) ++;
                *tmp_10 = *tmp_11;
                yaml_char_t tmp_30 = *tmp_10;
              }
              else 
                if (((int)*(string.pointer) & 0xF0) == 0xE0) {
                  yaml_char_t *tmp_12;
                  yaml_char_t *tmp_13;
                  yaml_char_t *tmp_14;
                  yaml_char_t *tmp_15;
                  yaml_char_t *tmp_16;
                  yaml_char_t *tmp_17;
                  tmp_12 = emitter->buffer.pointer;
                  (emitter->buffer.pointer) ++;
                  tmp_13 = string.pointer;
                  (string.pointer) ++;
                  *tmp_12 = *tmp_13;
                  tmp_14 = emitter->buffer.pointer;
                  (emitter->buffer.pointer) ++;
                  tmp_15 = string.pointer;
                  (string.pointer) ++;
                  *tmp_14 = *tmp_15;
                  tmp_16 = emitter->buffer.pointer;
                  (emitter->buffer.pointer) ++;
                  tmp_17 = string.pointer;
                  (string.pointer) ++;
                  *tmp_16 = *tmp_17;
                  yaml_char_t tmp_28 = *tmp_16;
                }
                else 
                  if (((int)*(string.pointer) & 0xF8) == 0xF0) {
                    yaml_char_t *tmp_18;
                    yaml_char_t *tmp_19;
                    yaml_char_t *tmp_20;
                    yaml_char_t *tmp_21;
                    yaml_char_t *tmp_22;
                    yaml_char_t *tmp_23;
                    yaml_char_t *tmp_24;
                    yaml_char_t *tmp_25;
                    tmp_18 = emitter->buffer.pointer;
                    (emitter->buffer.pointer) ++;
                    tmp_19 = string.pointer;
                    (string.pointer) ++;
                    *tmp_18 = *tmp_19;
                    tmp_20 = emitter->buffer.pointer;
                    (emitter->buffer.pointer) ++;
                    tmp_21 = string.pointer;
                    (string.pointer) ++;
                    *tmp_20 = *tmp_21;
                    tmp_22 = emitter->buffer.pointer;
                    (emitter->buffer.pointer) ++;
                    tmp_23 = string.pointer;
                    (string.pointer) ++;
                    *tmp_22 = *tmp_23;
                    tmp_24 = emitter->buffer.pointer;
                    (emitter->buffer.pointer) ++;
                    tmp_25 = string.pointer;
                    (string.pointer) ++;
                    *tmp_24 = *tmp_25;
                    yaml_char_t tmp_26 = *tmp_24;
                  }
            (emitter->column) ++;
          }
          else {
            __retres = 0;
            goto return_label;
          }
        }
      spaces = 1;
    }
    else 
      if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\r')) goto _LOR_5;
      else 
        if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\n')) goto _LOR_5;
        else 
          if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\302')) {
            if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\205')) 
              goto _LOR_5;
            else goto _LAND_8;
          }
          else {
            _LAND_8: ;
            if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\342')) {
              if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                if ((int)*(string.pointer + (0 + 2)) == (int)((yaml_char_t)'\250')) 
                  goto _LOR_5;
                else goto _LAND_7;
              }
              else goto _LAND_7;
            }
            else {
              _LAND_7: ;
              if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\342')) {
                if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                  if ((int)*(string.pointer + (0 + 2)) == (int)((yaml_char_t)'\251')) {
                    _LOR_5:
                    {
                      if (! breaks) 
                        if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\n')) 
                          if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                            goto _LOR_0;
                          else {
                            int tmp_26_1;
                            tmp_26_1 = yaml_emitter_flush(emitter);
                            if (tmp_26_1) {
                              _LOR_0: ;
                              if (emitter->line_break == (unsigned int)YAML_CR_BREAK) {
                                yaml_char_t *tmp_27;
                                tmp_27 = emitter->buffer.pointer;
                                (emitter->buffer.pointer) ++;
                                *tmp_27 = (yaml_char_t)'\r';
                                yaml_char_t tmp_38 = *tmp_27;
                              }
                              else 
                                if (emitter->line_break == (unsigned int)YAML_LN_BREAK) {
                                  yaml_char_t *tmp_28_1;
                                  tmp_28_1 = emitter->buffer.pointer;
                                  (emitter->buffer.pointer) ++;
                                  *tmp_28_1 = (yaml_char_t)'\n';
                                  yaml_char_t tmp_36 = *tmp_28_1;
                                }
                                else 
                                  if (emitter->line_break == (unsigned int)YAML_CRLN_BREAK) {
                                    yaml_char_t *tmp_29;
                                    yaml_char_t *tmp_30_0;
                                    tmp_29 = emitter->buffer.pointer;
                                    (emitter->buffer.pointer) ++;
                                    *tmp_29 = (yaml_char_t)'\r';
                                    tmp_30_0 = emitter->buffer.pointer;
                                    (emitter->buffer.pointer) ++;
                                    *tmp_30_0 = (yaml_char_t)'\n';
                                    yaml_char_t tmp_34 = *tmp_30_0;
                                  }
                              emitter->column = 0;
                              (emitter->line) ++;
                            }
                            else {
                              __retres = 0;
                              goto return_label;
                            }
                          }
                      if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                        goto _LOR_2;
                      else {
                        int tmp_31;
                        tmp_31 = yaml_emitter_flush(emitter);
                        if (tmp_31) {
                          int tmp_58_0;
                          _LOR_2: ;
                          if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\n')) {
                            int tmp_37;
                            if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                              goto _LOR_1;
                            else {
                              int tmp_32_0;
                              tmp_32_0 = yaml_emitter_flush(emitter);
                              if (tmp_32_0) {
                                _LOR_1: ;
                                if (emitter->line_break == (unsigned int)YAML_CR_BREAK) {
                                  yaml_char_t *tmp_33;
                                  tmp_33 = emitter->buffer.pointer;
                                  (emitter->buffer.pointer) ++;
                                  *tmp_33 = (yaml_char_t)'\r';
                                  yaml_char_t tmp_44 = *tmp_33;
                                }
                                else 
                                  if (emitter->line_break == (unsigned int)YAML_LN_BREAK) {
                                    yaml_char_t *tmp_34_0;
                                    tmp_34_0 = emitter->buffer.pointer;
                                    (emitter->buffer.pointer) ++;
                                    *tmp_34_0 = (yaml_char_t)'\n';
                                    yaml_char_t tmp_42 = *tmp_34_0;
                                  }
                                  else 
                                    if (emitter->line_break == (unsigned int)YAML_CRLN_BREAK) {
                                      yaml_char_t *tmp_35;
                                      yaml_char_t *tmp_36_0;
                                      tmp_35 = emitter->buffer.pointer;
                                      (emitter->buffer.pointer) ++;
                                      *tmp_35 = (yaml_char_t)'\r';
                                      tmp_36_0 = emitter->buffer.pointer;
                                      (emitter->buffer.pointer) ++;
                                      *tmp_36_0 = (yaml_char_t)'\n';
                                      yaml_char_t tmp_40 = *tmp_36_0;
                                    }
                                emitter->column = 0;
                                (emitter->line) ++;
                                tmp_37 = 1;
                              }
                              else tmp_37 = 0;
                            }
                            (string.pointer) ++;
                            tmp_58_0 = 1;
                          }
                          else {
                            if (((int)*(string.pointer) & 0x80) == 0x00) {
                              yaml_char_t *tmp_38_0;
                              yaml_char_t *tmp_39;
                              tmp_38_0 = emitter->buffer.pointer;
                              (emitter->buffer.pointer) ++;
                              tmp_39 = string.pointer;
                              (string.pointer) ++;
                              *tmp_38_0 = *tmp_39;
                              yaml_char_t tmp_64 = *tmp_38_0;
                            }
                            else 
                              if (((int)*(string.pointer) & 0xE0) == 0xC0) {
                                yaml_char_t *tmp_40_0;
                                yaml_char_t *tmp_41;
                                yaml_char_t *tmp_42_0;
                                yaml_char_t *tmp_43;
                                tmp_40_0 = emitter->buffer.pointer;
                                (emitter->buffer.pointer) ++;
                                tmp_41 = string.pointer;
                                (string.pointer) ++;
                                *tmp_40_0 = *tmp_41;
                                tmp_42_0 = emitter->buffer.pointer;
                                (emitter->buffer.pointer) ++;
                                tmp_43 = string.pointer;
                                (string.pointer) ++;
                                *tmp_42_0 = *tmp_43;
                                yaml_char_t tmp_62 = *tmp_42_0;
                              }
                              else 
                                if (((int)*(string.pointer) & 0xF0) == 0xE0) {
                                  yaml_char_t *tmp_44_0;
                                  yaml_char_t *tmp_45;
                                  yaml_char_t *tmp_46;
                                  yaml_char_t *tmp_47;
                                  yaml_char_t *tmp_48;
                                  yaml_char_t *tmp_49;
                                  tmp_44_0 = emitter->buffer.pointer;
                                  (emitter->buffer.pointer) ++;
                                  tmp_45 = string.pointer;
                                  (string.pointer) ++;
                                  *tmp_44_0 = *tmp_45;
                                  tmp_46 = emitter->buffer.pointer;
                                  (emitter->buffer.pointer) ++;
                                  tmp_47 = string.pointer;
                                  (string.pointer) ++;
                                  *tmp_46 = *tmp_47;
                                  tmp_48 = emitter->buffer.pointer;
                                  (emitter->buffer.pointer) ++;
                                  tmp_49 = string.pointer;
                                  (string.pointer) ++;
                                  *tmp_48 = *tmp_49;
                                  yaml_char_t tmp_60 = *tmp_48;
                                }
                                else 
                                  if (((int)*(string.pointer) & 0xF8) == 0xF0) {
                                    yaml_char_t *tmp_50;
                                    yaml_char_t *tmp_51;
                                    yaml_char_t *tmp_52;
                                    yaml_char_t *tmp_53;
                                    yaml_char_t *tmp_54;
                                    yaml_char_t *tmp_55;
                                    yaml_char_t *tmp_56;
                                    yaml_char_t *tmp_57;
                                    tmp_50 = emitter->buffer.pointer;
                                    (emitter->buffer.pointer) ++;
                                    tmp_51 = string.pointer;
                                    (string.pointer) ++;
                                    *tmp_50 = *tmp_51;
                                    tmp_52 = emitter->buffer.pointer;
                                    (emitter->buffer.pointer) ++;
                                    tmp_53 = string.pointer;
                                    (string.pointer) ++;
                                    *tmp_52 = *tmp_53;
                                    tmp_54 = emitter->buffer.pointer;
                                    (emitter->buffer.pointer) ++;
                                    tmp_55 = string.pointer;
                                    (string.pointer) ++;
                                    *tmp_54 = *tmp_55;
                                    tmp_56 = emitter->buffer.pointer;
                                    (emitter->buffer.pointer) ++;
                                    tmp_57 = string.pointer;
                                    (string.pointer) ++;
                                    *tmp_56 = *tmp_57;
                                    yaml_char_t tmp_58 = *tmp_56;
                                  }
                            emitter->column = 0;
                            (emitter->line) ++;
                            tmp_58_0 = 1;
                          }
                          if (! tmp_58_0) {
                            __retres = 0;
                            goto return_label;
                          }
                        }
                        else {
                          __retres = 0;
                          goto return_label;
                        }
                      }
                      emitter->indention = 1;
                      breaks = 1;
                    }
                  }
                  else goto _LAND_5;
                }
                else goto _LAND_5;
              }
              else {
                _LAND_5:
                {
                  if (breaks) {
                    int tmp_59;
                    tmp_59 = yaml_emitter_write_indent(emitter);
                    if (! tmp_59) {
                      __retres = 0;
                      goto return_label;
                    }
                  }
                  if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\'')) 
                    if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                      goto _LOR_3;
                    else {
                      int tmp_60_0;
                      tmp_60_0 = yaml_emitter_flush(emitter);
                      if (tmp_60_0) {
                        yaml_char_t *tmp_61;
                        _LOR_3:
                        { /* sequence */
                          tmp_61 = emitter->buffer.pointer;
                          (emitter->buffer.pointer) ++;
                          *tmp_61 = (yaml_char_t)'\'';
                        }
                        (emitter->column) ++;
                      }
                      else {
                        __retres = 0;
                        goto return_label;
                      }
                    }
                  if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                    goto _LOR_4;
                  else {
                    int tmp_62_0;
                    tmp_62_0 = yaml_emitter_flush(emitter);
                    if (tmp_62_0) {
                      _LOR_4: ;
                      if (((int)*(string.pointer) & 0x80) == 0x00) {
                        yaml_char_t *tmp_63;
                        yaml_char_t *tmp_64_0;
                        tmp_63 = emitter->buffer.pointer;
                        (emitter->buffer.pointer) ++;
                        tmp_64_0 = string.pointer;
                        (string.pointer) ++;
                        *tmp_63 = *tmp_64_0;
                        yaml_char_t tmp_89 = *tmp_63;
                      }
                      else 
                        if (((int)*(string.pointer) & 0xE0) == 0xC0) {
                          yaml_char_t *tmp_65;
                          yaml_char_t *tmp_66;
                          yaml_char_t *tmp_67;
                          yaml_char_t *tmp_68;
                          tmp_65 = emitter->buffer.pointer;
                          (emitter->buffer.pointer) ++;
                          tmp_66 = string.pointer;
                          (string.pointer) ++;
                          *tmp_65 = *tmp_66;
                          tmp_67 = emitter->buffer.pointer;
                          (emitter->buffer.pointer) ++;
                          tmp_68 = string.pointer;
                          (string.pointer) ++;
                          *tmp_67 = *tmp_68;
                          yaml_char_t tmp_87 = *tmp_67;
                        }
                        else 
                          if (((int)*(string.pointer) & 0xF0) == 0xE0) {
                            yaml_char_t *tmp_69;
                            yaml_char_t *tmp_70;
                            yaml_char_t *tmp_71;
                            yaml_char_t *tmp_72;
                            yaml_char_t *tmp_73;
                            yaml_char_t *tmp_74;
                            tmp_69 = emitter->buffer.pointer;
                            (emitter->buffer.pointer) ++;
                            tmp_70 = string.pointer;
                            (string.pointer) ++;
                            *tmp_69 = *tmp_70;
                            tmp_71 = emitter->buffer.pointer;
                            (emitter->buffer.pointer) ++;
                            tmp_72 = string.pointer;
                            (string.pointer) ++;
                            *tmp_71 = *tmp_72;
                            tmp_73 = emitter->buffer.pointer;
                            (emitter->buffer.pointer) ++;
                            tmp_74 = string.pointer;
                            (string.pointer) ++;
                            *tmp_73 = *tmp_74;
                            yaml_char_t tmp_85 = *tmp_73;
                          }
                          else 
                            if (((int)*(string.pointer) & 0xF8) == 0xF0) {
                              yaml_char_t *tmp_75;
                              yaml_char_t *tmp_76;
                              yaml_char_t *tmp_77;
                              yaml_char_t *tmp_78;
                              yaml_char_t *tmp_79;
                              yaml_char_t *tmp_80;
                              yaml_char_t *tmp_81;
                              yaml_char_t *tmp_82;
                              tmp_75 = emitter->buffer.pointer;
                              (emitter->buffer.pointer) ++;
                              tmp_76 = string.pointer;
                              (string.pointer) ++;
                              *tmp_75 = *tmp_76;
                              tmp_77 = emitter->buffer.pointer;
                              (emitter->buffer.pointer) ++;
                              tmp_78 = string.pointer;
                              (string.pointer) ++;
                              *tmp_77 = *tmp_78;
                              tmp_79 = emitter->buffer.pointer;
                              (emitter->buffer.pointer) ++;
                              tmp_80 = string.pointer;
                              (string.pointer) ++;
                              *tmp_79 = *tmp_80;
                              tmp_81 = emitter->buffer.pointer;
                              (emitter->buffer.pointer) ++;
                              tmp_82 = string.pointer;
                              (string.pointer) ++;
                              *tmp_81 = *tmp_82;
                              yaml_char_t tmp_83 = *tmp_81;
                            }
                      (emitter->column) ++;
                    }
                    else {
                      __retres = 0;
                      goto return_label;
                    }
                  }
                  emitter->indention = 0;
                  spaces = 0;
                  breaks = 0;
                }
              }
            }
          }
  if (breaks) {
    int tmp_83_0;
    tmp_83_0 = yaml_emitter_write_indent(emitter);
    if (! tmp_83_0) {
      __retres = 0;
      goto return_label;
    }
  }
  tmp_84 = yaml_emitter_write_indicator(emitter,"\'",0,0,0);
  if (! tmp_84) {
    __retres = 0;
    goto return_label;
  }
  emitter->whitespace = 0;
  emitter->indention = 0;
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_write_double_quoted_scalar(yaml_emitter_t *emitter,
                                                   yaml_char_t *value,
                                                   size_t length,
                                                   int allow_breaks)
{
  int __retres;
  yaml_string_t string;
  int tmp;
  int tmp_96_0;
  int spaces = 0;
  string.start = value;
  string.end = value + length;
  string.pointer = value;
  tmp = yaml_emitter_write_indicator(emitter,"\"",1,0,0);
  if (! tmp) {
    __retres = 0;
    goto return_label;
  }
  while (string.pointer != string.end) 
    if ((int)*(string.pointer + 0) == 0x0A) goto _LAND_11;
    else 
      if ((int)*(string.pointer + 0) >= 0x20) {
        if ((int)*(string.pointer + 0) <= 0x7E) goto _LAND_11;
        else goto _LAND_16;
      }
      else {
        _LAND_16: ;
        if ((int)*(string.pointer + 0) == 0xC2) {
          if ((int)*(string.pointer + (0 + 1)) >= 0xA0) goto _LAND_11;
          else goto _LAND_15;
        }
        else {
          _LAND_15: ;
          if ((int)*(string.pointer + 0) > 0xC2) {
            if ((int)*(string.pointer + 0) < 0xED) goto _LAND_11;
            else goto _LAND_14;
          }
          else {
            _LAND_14: ;
            if ((int)*(string.pointer + 0) == 0xED) {
              if ((int)*(string.pointer + (0 + 1)) < 0xA0) goto _LAND_11;
              else goto _LAND_13;
            }
            else {
              _LAND_13: ;
              if ((int)*(string.pointer + 0) == 0xEE) goto _LAND_11;
              else 
                if ((int)*(string.pointer + 0) == 0xEF) 
                  if ((int)*(string.pointer + (0 + 1)) == 0xBB) {
                    if ((int)*(string.pointer + (0 + 2)) == 0xBF) goto _LOR_22;
                    else goto _LAND_12;
                  }
                  else {
                    _LAND_12: ;
                    if ((int)*(string.pointer + (0 + 1)) == 0xBF) {
                      if ((int)*(string.pointer + (0 + 2)) == 0xBE) goto _LOR_22;
                      else 
                        if ((int)*(string.pointer + (0 + 2)) == 0xBF) 
                          goto _LOR_22;
                        else goto _LAND_11;
                    }
                    else 
                      _LAND_11:
                      if (! emitter->unicode) {
                        if (! ((int)*(string.pointer + 0) <= (int)((yaml_char_t)'\177'))) 
                          goto _LOR_22;
                        else goto _LAND_10;
                      }
                      else {
                        _LAND_10: ;
                        if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\357')) {
                          if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\273')) {
                            if ((int)*(string.pointer + (0 + 2)) == (int)((yaml_char_t)'\277')) 
                              goto _LOR_22;
                            else goto _LAND_9;
                          }
                          else goto _LAND_9;
                        }
                        else {
                          _LAND_9: ;
                          if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\r')) 
                            goto _LOR_22;
                          else 
                            if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\n')) 
                              goto _LOR_22;
                            else 
                              if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\302')) {
                                if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\205')) 
                                  goto _LOR_22;
                                else goto _LAND_7;
                              }
                              else {
                                _LAND_7: ;
                                if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\342')) {
                                  if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                                    if ((int)*(string.pointer + (0 + 2)) == (int)((yaml_char_t)'\250')) 
                                      goto _LOR_22;
                                    else goto _LAND_6;
                                  }
                                  else goto _LAND_6;
                                }
                                else {
                                  _LAND_6: ;
                                  if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\342')) {
                                    if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                                      if ((int)*(string.pointer + (0 + 2)) == (int)((yaml_char_t)'\251')) 
                                        goto _LOR_22;
                                      else goto _LAND_4;
                                    }
                                    else goto _LAND_4;
                                  }
                                  else {
                                    _LAND_4: ;
                                    if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\"')) 
                                      goto _LOR_22;
                                    else 
                                      if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\\')) {
                                        _LOR_22:
                                        {
                                          unsigned char octet;
                                          unsigned int width;
                                          unsigned int value_0;
                                          int k;
                                          octet = *(string.pointer + 0);
                                          if (((int)octet & 0x80) == 0x00) 
                                            width = (unsigned int)1;
                                          else {
                                            int tmp_2;
                                            if (((int)octet & 0xE0) == 0xC0) 
                                              tmp_2 = 2;
                                            else {
                                              int tmp_1;
                                              if (((int)octet & 0xF0) == 0xE0) 
                                                tmp_1 = 3;
                                              else {
                                                int tmp_0;
                                                if (((int)octet & 0xF8) == 0xF0) 
                                                  tmp_0 = 4;
                                                else tmp_0 = 0;
                                                tmp_1 = tmp_0;
                                              }
                                              tmp_2 = tmp_1;
                                            }
                                            width = (unsigned int)tmp_2;
                                          }
                                          if (((int)octet & 0x80) == 0x00) 
                                            value_0 = (unsigned int)(
                                            (int)octet & 0x7F);
                                          else {
                                            int tmp_5;
                                            if (((int)octet & 0xE0) == 0xC0) 
                                              tmp_5 = (int)octet & 0x1F;
                                            else {
                                              int tmp_4;
                                              if (((int)octet & 0xF0) == 0xE0) 
                                                tmp_4 = (int)octet & 0x0F;
                                              else {
                                                int tmp_3;
                                                if (((int)octet & 0xF8) == 0xF0) 
                                                  tmp_3 = (int)octet & 0x07;
                                                else tmp_3 = 0;
                                                tmp_4 = tmp_3;
                                              }
                                              tmp_5 = tmp_4;
                                            }
                                            value_0 = (unsigned int)tmp_5;
                                          }
                                          k = 1;
                                          while (k < (int)width) {
                                            octet = *(string.pointer + k);
                                            value_0 = (value_0 << 6) + (unsigned int)(
                                                      (int)octet & 0x3F);
                                            k ++;
                                          }
                                          string.pointer += width;
                                          if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                            goto _LOR;
                                          else {
                                            int tmp_6;
                                            tmp_6 = yaml_emitter_flush
                                            (emitter);
                                            if (tmp_6) {
                                              yaml_char_t *tmp_7;
                                              _LOR:
                                              { /* sequence */
                                                tmp_7 = emitter->buffer.pointer;
                                                (emitter->buffer.pointer) ++;
                                                *tmp_7 = (yaml_char_t)'\\';
                                              }
                                              (emitter->column) ++;
                                            }
                                            else {
                                              __retres = 0;
                                              goto return_label;
                                            }
                                          }
                                          switch (value_0) {
                                            case (unsigned int)0x00: ;
                                            if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                              goto _LOR_0;
                                            else {
                                              int tmp_8;
                                              tmp_8 = yaml_emitter_flush
                                              (emitter);
                                              if (tmp_8) {
                                                yaml_char_t *tmp_9;
                                                _LOR_0:
                                                { /* sequence */
                                                  tmp_9 = emitter->buffer.pointer;
                                                  (emitter->buffer.pointer) ++;
                                                  *tmp_9 = (yaml_char_t)'0';
                                                }
                                                (emitter->column) ++;
                                              }
                                              else {
                                                __retres = 0;
                                                goto return_label;
                                              }
                                            }
                                            break;
                                            case (unsigned int)0x07: ;
                                            if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                              goto _LOR_1;
                                            else {
                                              int tmp_10;
                                              tmp_10 = yaml_emitter_flush
                                              (emitter);
                                              if (tmp_10) {
                                                yaml_char_t *tmp_11;
                                                _LOR_1:
                                                { /* sequence */
                                                  tmp_11 = emitter->buffer.pointer;
                                                  (emitter->buffer.pointer) ++;
                                                  *tmp_11 = (yaml_char_t)'a';
                                                }
                                                (emitter->column) ++;
                                              }
                                              else {
                                                __retres = 0;
                                                goto return_label;
                                              }
                                            }
                                            break;
                                            case (unsigned int)0x08: ;
                                            if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                              goto _LOR_2;
                                            else {
                                              int tmp_12;
                                              tmp_12 = yaml_emitter_flush
                                              (emitter);
                                              if (tmp_12) {
                                                yaml_char_t *tmp_13;
                                                _LOR_2:
                                                { /* sequence */
                                                  tmp_13 = emitter->buffer.pointer;
                                                  (emitter->buffer.pointer) ++;
                                                  *tmp_13 = (yaml_char_t)'b';
                                                }
                                                (emitter->column) ++;
                                              }
                                              else {
                                                __retres = 0;
                                                goto return_label;
                                              }
                                            }
                                            break;
                                            case (unsigned int)0x09: ;
                                            if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                              goto _LOR_3;
                                            else {
                                              int tmp_14;
                                              tmp_14 = yaml_emitter_flush
                                              (emitter);
                                              if (tmp_14) {
                                                yaml_char_t *tmp_15;
                                                _LOR_3:
                                                { /* sequence */
                                                  tmp_15 = emitter->buffer.pointer;
                                                  (emitter->buffer.pointer) ++;
                                                  *tmp_15 = (yaml_char_t)'t';
                                                }
                                                (emitter->column) ++;
                                              }
                                              else {
                                                __retres = 0;
                                                goto return_label;
                                              }
                                            }
                                            break;
                                            case (unsigned int)0x0A: ;
                                            if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                              goto _LOR_4;
                                            else {
                                              int tmp_16;
                                              tmp_16 = yaml_emitter_flush
                                              (emitter);
                                              if (tmp_16) {
                                                yaml_char_t *tmp_17;
                                                _LOR_4:
                                                { /* sequence */
                                                  tmp_17 = emitter->buffer.pointer;
                                                  (emitter->buffer.pointer) ++;
                                                  *tmp_17 = (yaml_char_t)'n';
                                                }
                                                (emitter->column) ++;
                                              }
                                              else {
                                                __retres = 0;
                                                goto return_label;
                                              }
                                            }
                                            break;
                                            case (unsigned int)0x0B: ;
                                            if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                              goto _LOR_5;
                                            else {
                                              int tmp_18;
                                              tmp_18 = yaml_emitter_flush
                                              (emitter);
                                              if (tmp_18) {
                                                yaml_char_t *tmp_19;
                                                _LOR_5:
                                                { /* sequence */
                                                  tmp_19 = emitter->buffer.pointer;
                                                  (emitter->buffer.pointer) ++;
                                                  *tmp_19 = (yaml_char_t)'v';
                                                }
                                                (emitter->column) ++;
                                              }
                                              else {
                                                __retres = 0;
                                                goto return_label;
                                              }
                                            }
                                            break;
                                            case (unsigned int)0x0C: ;
                                            if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                              goto _LOR_6;
                                            else {
                                              int tmp_20;
                                              tmp_20 = yaml_emitter_flush
                                              (emitter);
                                              if (tmp_20) {
                                                yaml_char_t *tmp_21;
                                                _LOR_6:
                                                { /* sequence */
                                                  tmp_21 = emitter->buffer.pointer;
                                                  (emitter->buffer.pointer) ++;
                                                  *tmp_21 = (yaml_char_t)'f';
                                                }
                                                (emitter->column) ++;
                                              }
                                              else {
                                                __retres = 0;
                                                goto return_label;
                                              }
                                            }
                                            break;
                                            case (unsigned int)0x0D: ;
                                            if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                              goto _LOR_7;
                                            else {
                                              int tmp_22;
                                              tmp_22 = yaml_emitter_flush
                                              (emitter);
                                              if (tmp_22) {
                                                yaml_char_t *tmp_23;
                                                _LOR_7:
                                                { /* sequence */
                                                  tmp_23 = emitter->buffer.pointer;
                                                  (emitter->buffer.pointer) ++;
                                                  *tmp_23 = (yaml_char_t)'r';
                                                }
                                                (emitter->column) ++;
                                              }
                                              else {
                                                __retres = 0;
                                                goto return_label;
                                              }
                                            }
                                            break;
                                            case (unsigned int)0x1B: ;
                                            if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                              goto _LOR_8;
                                            else {
                                              int tmp_24;
                                              tmp_24 = yaml_emitter_flush
                                              (emitter);
                                              if (tmp_24) {
                                                yaml_char_t *tmp_25;
                                                _LOR_8:
                                                { /* sequence */
                                                  tmp_25 = emitter->buffer.pointer;
                                                  (emitter->buffer.pointer) ++;
                                                  *tmp_25 = (yaml_char_t)'e';
                                                }
                                                (emitter->column) ++;
                                              }
                                              else {
                                                __retres = 0;
                                                goto return_label;
                                              }
                                            }
                                            break;
                                            case (unsigned int)0x22: ;
                                            if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                              goto _LOR_9;
                                            else {
                                              int tmp_26;
                                              tmp_26 = yaml_emitter_flush
                                              (emitter);
                                              if (tmp_26) {
                                                yaml_char_t *tmp_27;
                                                _LOR_9:
                                                { /* sequence */
                                                  tmp_27 = emitter->buffer.pointer;
                                                  (emitter->buffer.pointer) ++;
                                                  *tmp_27 = (yaml_char_t)'\"';
                                                }
                                                (emitter->column) ++;
                                              }
                                              else {
                                                __retres = 0;
                                                goto return_label;
                                              }
                                            }
                                            break;
                                            case (unsigned int)0x5C: ;
                                            if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                              goto _LOR_10;
                                            else {
                                              int tmp_28;
                                              tmp_28 = yaml_emitter_flush
                                              (emitter);
                                              if (tmp_28) {
                                                yaml_char_t *tmp_29;
                                                _LOR_10:
                                                { /* sequence */
                                                  tmp_29 = emitter->buffer.pointer;
                                                  (emitter->buffer.pointer) ++;
                                                  *tmp_29 = (yaml_char_t)'\\';
                                                }
                                                (emitter->column) ++;
                                              }
                                              else {
                                                __retres = 0;
                                                goto return_label;
                                              }
                                            }
                                            break;
                                            case (unsigned int)0x85: ;
                                            if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                              goto _LOR_11;
                                            else {
                                              int tmp_30;
                                              tmp_30 = yaml_emitter_flush
                                              (emitter);
                                              if (tmp_30) {
                                                yaml_char_t *tmp_31;
                                                _LOR_11:
                                                { /* sequence */
                                                  tmp_31 = emitter->buffer.pointer;
                                                  (emitter->buffer.pointer) ++;
                                                  *tmp_31 = (yaml_char_t)'N';
                                                }
                                                (emitter->column) ++;
                                              }
                                              else {
                                                __retres = 0;
                                                goto return_label;
                                              }
                                            }
                                            break;
                                            case (unsigned int)0xA0: ;
                                            if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                              goto _LOR_12;
                                            else {
                                              int tmp_32;
                                              tmp_32 = yaml_emitter_flush
                                              (emitter);
                                              if (tmp_32) {
                                                yaml_char_t *tmp_33;
                                                _LOR_12:
                                                { /* sequence */
                                                  tmp_33 = emitter->buffer.pointer;
                                                  (emitter->buffer.pointer) ++;
                                                  *tmp_33 = (yaml_char_t)'_';
                                                }
                                                (emitter->column) ++;
                                              }
                                              else {
                                                __retres = 0;
                                                goto return_label;
                                              }
                                            }
                                            break;
                                            case (unsigned int)0x2028: ;
                                            if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                              goto _LOR_13;
                                            else {
                                              int tmp_34;
                                              tmp_34 = yaml_emitter_flush
                                              (emitter);
                                              if (tmp_34) {
                                                yaml_char_t *tmp_35;
                                                _LOR_13:
                                                { /* sequence */
                                                  tmp_35 = emitter->buffer.pointer;
                                                  (emitter->buffer.pointer) ++;
                                                  *tmp_35 = (yaml_char_t)'L';
                                                }
                                                (emitter->column) ++;
                                              }
                                              else {
                                                __retres = 0;
                                                goto return_label;
                                              }
                                            }
                                            break;
                                            case (unsigned int)0x2029: ;
                                            if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                              goto _LOR_14;
                                            else {
                                              int tmp_36;
                                              tmp_36 = yaml_emitter_flush
                                              (emitter);
                                              if (tmp_36) {
                                                yaml_char_t *tmp_37;
                                                _LOR_14:
                                                { /* sequence */
                                                  tmp_37 = emitter->buffer.pointer;
                                                  (emitter->buffer.pointer) ++;
                                                  *tmp_37 = (yaml_char_t)'P';
                                                }
                                                (emitter->column) ++;
                                              }
                                              else {
                                                __retres = 0;
                                                goto return_label;
                                              }
                                            }
                                            break;
                                            default: ;
                                            if (value_0 <= (unsigned int)0xFF) {
                                              if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                                goto _LOR_15;
                                              else {
                                                int tmp_38;
                                                tmp_38 = yaml_emitter_flush
                                                (emitter);
                                                if (tmp_38) {
                                                  yaml_char_t *tmp_39;
                                                  _LOR_15:
                                                  { /* sequence */
                                                    tmp_39 = emitter->buffer.pointer;
                                                    (emitter->buffer.pointer) ++;
                                                    *tmp_39 = (yaml_char_t)'x';
                                                  }
                                                  (emitter->column) ++;
                                                }
                                                else {
                                                  __retres = 0;
                                                  goto return_label;
                                                }
                                              }
                                              width = (unsigned int)2;
                                            }
                                            else 
                                              if (value_0 <= (unsigned int)0xFFFF) {
                                                if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                                  goto _LOR_16;
                                                else {
                                                  int tmp_40;
                                                  tmp_40 = yaml_emitter_flush
                                                  (emitter);
                                                  if (tmp_40) {
                                                    yaml_char_t *tmp_41;
                                                    _LOR_16:
                                                    { /* sequence */
                                                      tmp_41 = emitter->buffer.pointer;
                                                      (emitter->buffer.pointer) ++;
                                                      *tmp_41 = (yaml_char_t)'u';
                                                    }
                                                    (emitter->column) ++;
                                                  }
                                                  else {
                                                    __retres = 0;
                                                    goto return_label;
                                                  }
                                                }
                                                width = (unsigned int)4;
                                              }
                                              else {
                                                if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                                  goto _LOR_17;
                                                else {
                                                  int tmp_42;
                                                  tmp_42 = yaml_emitter_flush
                                                  (emitter);
                                                  if (tmp_42) {
                                                    yaml_char_t *tmp_43;
                                                    _LOR_17:
                                                    { /* sequence */
                                                      tmp_43 = emitter->buffer.pointer;
                                                      (emitter->buffer.pointer) ++;
                                                      *tmp_43 = (yaml_char_t)'U';
                                                    }
                                                    (emitter->column) ++;
                                                  }
                                                  else {
                                                    __retres = 0;
                                                    goto return_label;
                                                  }
                                                }
                                                width = (unsigned int)8;
                                              }
                                            k = (int)((width - (unsigned int)1) * (unsigned int)4);
                                            while (k >= 0) {
                                              {
                                                int digit =
                                                  (int)((value_0 >> k) & (unsigned int)0x0F);
                                                if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                                  goto _LOR_18;
                                                else {
                                                  int tmp_44;
                                                  tmp_44 = yaml_emitter_flush
                                                  (emitter);
                                                  if (tmp_44) {
                                                    yaml_char_t *tmp_45;
                                                    int tmp_46;
                                                    _LOR_18:
                                                    { /* sequence */
                                                      tmp_45 = emitter->buffer.pointer;
                                                      (emitter->buffer.pointer) ++;
                                                      if (digit < 10) 
                                                        tmp_46 = '0';
                                                      else tmp_46 = 'A' - 10;
                                                      *tmp_45 = (yaml_char_t)(
                                                      digit + tmp_46);
                                                    }
                                                    (emitter->column) ++;
                                                  }
                                                  else {
                                                    __retres = 0;
                                                    goto return_label;
                                                  }
                                                }
                                              }
                                              k -= 4;
                                            }
                                          }
                                          spaces = 0;
                                        }
                                      }
                                      else 
                                        if ((int)*(string.pointer + 0) == (int)((yaml_char_t)' ')) {
                                          if (allow_breaks) {
                                            if (! spaces) {
                                              if (emitter->column > emitter->best_width) {
                                                if (string.pointer != string.start) {
                                                  if (string.pointer != 
                                                      string.end - 1) {
                                                    int tmp_47;
                                                    int tmp_53;
                                                    tmp_47 = yaml_emitter_write_indent
                                                    (emitter);
                                                    if (! tmp_47) {
                                                      __retres = 0;
                                                      goto return_label;
                                                    }
                                                    if ((int)*(string.pointer + 1) == (int)((yaml_char_t)' ')) 
                                                      if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                                        goto _LOR_19;
                                                      else {
                                                        int tmp_48;
                                                        tmp_48 = yaml_emitter_flush
                                                        (emitter);
                                                        if (tmp_48) {
                                                          yaml_char_t *tmp_49;
                                                          _LOR_19:
                                                          { /* sequence */
                                                            tmp_49 = emitter->buffer.pointer;
                                                            (emitter->buffer.pointer) ++;
                                                            *tmp_49 = (yaml_char_t)'\\';
                                                          }
                                                          (emitter->column) ++;
                                                        }
                                                        else {
                                                          __retres = 0;
                                                          goto return_label;
                                                        }
                                                      }
                                                    if (((int)*(string.pointer + 0) & 0x80) == 0x00) 
                                                      tmp_53 = 1;
                                                    else {
                                                      int tmp_52;
                                                      if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) 
                                                        tmp_52 = 2;
                                                      else {
                                                        int tmp_51;
                                                        if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) 
                                                          tmp_51 = 3;
                                                        else {
                                                          int tmp_50;
                                                          if (((int)*(
                                                               string.pointer + 0) & 0xF8) == 0xF0) 
                                                            tmp_50 = 4;
                                                          else tmp_50 = 0;
                                                          tmp_51 = tmp_50;
                                                        }
                                                        tmp_52 = tmp_51;
                                                      }
                                                      tmp_53 = tmp_52;
                                                    }
                                                    string.pointer += tmp_53;
                                                  }
                                                  else goto _LAND_2;
                                                }
                                                else goto _LAND_2;
                                              }
                                              else goto _LAND_2;
                                            }
                                            else goto _LAND_2;
                                          }
                                          else 
                                            _LAND_2:
                                            if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                              goto _LOR_20;
                                            else {
                                              int tmp_54;
                                              tmp_54 = yaml_emitter_flush
                                              (emitter);
                                              if (tmp_54) {
                                                _LOR_20: ;
                                                if (((int)*(string.pointer) & 0x80) == 0x00) {
                                                  yaml_char_t *tmp_55;
                                                  yaml_char_t *tmp_56;
                                                  tmp_55 = emitter->buffer.pointer;
                                                  (emitter->buffer.pointer) ++;
                                                  tmp_56 = string.pointer;
                                                  (string.pointer) ++;
                                                  *tmp_55 = *tmp_56;
                                                  yaml_char_t tmp_81 =
                                                    *tmp_55;
                                                }
                                                else 
                                                  if (((int)*(string.pointer) & 0xE0) == 0xC0) {
                                                    yaml_char_t *tmp_57;
                                                    yaml_char_t *tmp_58;
                                                    yaml_char_t *tmp_59;
                                                    yaml_char_t *tmp_60;
                                                    tmp_57 = emitter->buffer.pointer;
                                                    (emitter->buffer.pointer) ++;
                                                    tmp_58 = string.pointer;
                                                    (string.pointer) ++;
                                                    *tmp_57 = *tmp_58;
                                                    tmp_59 = emitter->buffer.pointer;
                                                    (emitter->buffer.pointer) ++;
                                                    tmp_60 = string.pointer;
                                                    (string.pointer) ++;
                                                    *tmp_59 = *tmp_60;
                                                    yaml_char_t tmp_79 =
                                                      *tmp_59;
                                                  }
                                                  else 
                                                    if (((int)*(string.pointer) & 0xF0) == 0xE0) {
                                                      yaml_char_t *tmp_61;
                                                      yaml_char_t *tmp_62;
                                                      yaml_char_t *tmp_63;
                                                      yaml_char_t *tmp_64;
                                                      yaml_char_t *tmp_65;
                                                      yaml_char_t *tmp_66;
                                                      tmp_61 = emitter->buffer.pointer;
                                                      (emitter->buffer.pointer) ++;
                                                      tmp_62 = string.pointer;
                                                      (string.pointer) ++;
                                                      *tmp_61 = *tmp_62;
                                                      tmp_63 = emitter->buffer.pointer;
                                                      (emitter->buffer.pointer) ++;
                                                      tmp_64 = string.pointer;
                                                      (string.pointer) ++;
                                                      *tmp_63 = *tmp_64;
                                                      tmp_65 = emitter->buffer.pointer;
                                                      (emitter->buffer.pointer) ++;
                                                      tmp_66 = string.pointer;
                                                      (string.pointer) ++;
                                                      *tmp_65 = *tmp_66;
                                                      yaml_char_t tmp_77 =
                                                        *tmp_65;
                                                    }
                                                    else 
                                                      if (((int)*(string.pointer) & 0xF8) == 0xF0) {
                                                        yaml_char_t *tmp_67;
                                                        yaml_char_t *tmp_68;
                                                        yaml_char_t *tmp_69;
                                                        yaml_char_t *tmp_70;
                                                        yaml_char_t *tmp_71;
                                                        yaml_char_t *tmp_72;
                                                        yaml_char_t *tmp_73;
                                                        yaml_char_t *tmp_74;
                                                        tmp_67 = emitter->buffer.pointer;
                                                        (emitter->buffer.pointer) ++;
                                                        tmp_68 = string.pointer;
                                                        (string.pointer) ++;
                                                        *tmp_67 = *tmp_68;
                                                        tmp_69 = emitter->buffer.pointer;
                                                        (emitter->buffer.pointer) ++;
                                                        tmp_70 = string.pointer;
                                                        (string.pointer) ++;
                                                        *tmp_69 = *tmp_70;
                                                        tmp_71 = emitter->buffer.pointer;
                                                        (emitter->buffer.pointer) ++;
                                                        tmp_72 = string.pointer;
                                                        (string.pointer) ++;
                                                        *tmp_71 = *tmp_72;
                                                        tmp_73 = emitter->buffer.pointer;
                                                        (emitter->buffer.pointer) ++;
                                                        tmp_74 = string.pointer;
                                                        (string.pointer) ++;
                                                        *tmp_73 = *tmp_74;
                                                        yaml_char_t tmp_75 =
                                                          *tmp_73;
                                                      }
                                                (emitter->column) ++;
                                              }
                                              else {
                                                __retres = 0;
                                                goto return_label;
                                              }
                                            }
                                          spaces = 1;
                                        }
                                        else {
                                          if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                            goto _LOR_21;
                                          else {
                                            int tmp_75_0;
                                            tmp_75_0 = yaml_emitter_flush
                                            (emitter);
                                            if (tmp_75_0) {
                                              _LOR_21: ;
                                              if (((int)*(string.pointer) & 0x80) == 0x00) {
                                                yaml_char_t *tmp_76;
                                                yaml_char_t *tmp_77_0;
                                                tmp_76 = emitter->buffer.pointer;
                                                (emitter->buffer.pointer) ++;
                                                tmp_77_0 = string.pointer;
                                                (string.pointer) ++;
                                                *tmp_76 = *tmp_77_0;
                                                yaml_char_t tmp_102 =
                                                  *tmp_76;
                                              }
                                              else 
                                                if (((int)*(string.pointer) & 0xE0) == 0xC0) {
                                                  yaml_char_t *tmp_78;
                                                  yaml_char_t *tmp_79_0;
                                                  yaml_char_t *tmp_80;
                                                  yaml_char_t *tmp_81_0;
                                                  tmp_78 = emitter->buffer.pointer;
                                                  (emitter->buffer.pointer) ++;
                                                  tmp_79_0 = string.pointer;
                                                  (string.pointer) ++;
                                                  *tmp_78 = *tmp_79_0;
                                                  tmp_80 = emitter->buffer.pointer;
                                                  (emitter->buffer.pointer) ++;
                                                  tmp_81_0 = string.pointer;
                                                  (string.pointer) ++;
                                                  *tmp_80 = *tmp_81_0;
                                                  yaml_char_t tmp_100 =
                                                    *tmp_80;
                                                }
                                                else 
                                                  if (((int)*(string.pointer) & 0xF0) == 0xE0) {
                                                    yaml_char_t *tmp_82;
                                                    yaml_char_t *tmp_83;
                                                    yaml_char_t *tmp_84;
                                                    yaml_char_t *tmp_85;
                                                    yaml_char_t *tmp_86;
                                                    yaml_char_t *tmp_87;
                                                    tmp_82 = emitter->buffer.pointer;
                                                    (emitter->buffer.pointer) ++;
                                                    tmp_83 = string.pointer;
                                                    (string.pointer) ++;
                                                    *tmp_82 = *tmp_83;
                                                    tmp_84 = emitter->buffer.pointer;
                                                    (emitter->buffer.pointer) ++;
                                                    tmp_85 = string.pointer;
                                                    (string.pointer) ++;
                                                    *tmp_84 = *tmp_85;
                                                    tmp_86 = emitter->buffer.pointer;
                                                    (emitter->buffer.pointer) ++;
                                                    tmp_87 = string.pointer;
                                                    (string.pointer) ++;
                                                    *tmp_86 = *tmp_87;
                                                    yaml_char_t tmp_98 =
                                                      *tmp_86;
                                                  }
                                                  else 
                                                    if (((int)*(string.pointer) & 0xF8) == 0xF0) {
                                                      yaml_char_t *tmp_88;
                                                      yaml_char_t *tmp_89;
                                                      yaml_char_t *tmp_90;
                                                      yaml_char_t *tmp_91;
                                                      yaml_char_t *tmp_92;
                                                      yaml_char_t *tmp_93;
                                                      yaml_char_t *tmp_94;
                                                      yaml_char_t *tmp_95;
                                                      tmp_88 = emitter->buffer.pointer;
                                                      (emitter->buffer.pointer) ++;
                                                      tmp_89 = string.pointer;
                                                      (string.pointer) ++;
                                                      *tmp_88 = *tmp_89;
                                                      tmp_90 = emitter->buffer.pointer;
                                                      (emitter->buffer.pointer) ++;
                                                      tmp_91 = string.pointer;
                                                      (string.pointer) ++;
                                                      *tmp_90 = *tmp_91;
                                                      tmp_92 = emitter->buffer.pointer;
                                                      (emitter->buffer.pointer) ++;
                                                      tmp_93 = string.pointer;
                                                      (string.pointer) ++;
                                                      *tmp_92 = *tmp_93;
                                                      tmp_94 = emitter->buffer.pointer;
                                                      (emitter->buffer.pointer) ++;
                                                      tmp_95 = string.pointer;
                                                      (string.pointer) ++;
                                                      *tmp_94 = *tmp_95;
                                                      yaml_char_t tmp_96 =
                                                        *tmp_94;
                                                    }
                                              (emitter->column) ++;
                                            }
                                            else {
                                              __retres = 0;
                                              goto return_label;
                                            }
                                          }
                                          spaces = 0;
                                        }
                                  }
                                }
                              }
                        }
                      }
                  }
                else goto _LOR_22;
            }
          }
        }
      }
  tmp_96_0 = yaml_emitter_write_indicator(emitter,"\"",0,0,0);
  if (! tmp_96_0) {
    __retres = 0;
    goto return_label;
  }
  emitter->whitespace = 0;
  emitter->indention = 0;
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_write_block_scalar_hints(yaml_emitter_t *emitter,
                                                 yaml_string_t string)
{
  int __retres;
  char indent_hint[2];
  char const *chomp_hint = (char const *)0;
  if ((int)*(string.pointer + 0) == (int)((yaml_char_t)' ')) goto _LOR_0;
  else 
    if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\r')) goto _LOR_0;
    else 
      if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\n')) goto _LOR_0;
      else 
        if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\302')) {
          if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\205')) 
            goto _LOR_0;
          else goto _LAND_1;
        }
        else {
          _LAND_1: ;
          if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\342')) {
            if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
              if ((int)*(string.pointer + (0 + 2)) == (int)((yaml_char_t)'\250')) 
                goto _LOR_0;
              else goto _LAND_0;
            }
            else goto _LAND_0;
          }
          else {
            _LAND_0: ;
            if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\342')) 
              if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) 
                if ((int)*(string.pointer + (0 + 2)) == (int)((yaml_char_t)'\251')) {
                  _LOR_0:
                  {
                    int tmp;
                    indent_hint[0] = (char)('0' + (int)((char)emitter->best_indent));
                    indent_hint[1] = (char)'\000';
                    tmp = yaml_emitter_write_indicator(emitter,
                                                       (char const *)(indent_hint),
                                                       0,0,0);
                    if (! tmp) {
                      __retres = 0;
                      goto return_label;
                    }
                  }
                }
          }
        }
  emitter->open_ended = 0;
  string.pointer = string.end;
  if (string.start == string.pointer) chomp_hint = "-";
  else {
    while (1) {
      (string.pointer) --;
      if (! (((int)*(string.pointer) & 0xC0) == 0x80)) break;
    }
    if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\r')) goto _LOR_2;
    else 
      if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\n')) goto _LOR_2;
      else 
        if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\302')) {
          if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\205')) 
            goto _LOR_2;
          else goto _LAND_9;
        }
        else {
          _LAND_9: ;
          if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\342')) {
            if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
              if ((int)*(string.pointer + (0 + 2)) == (int)((yaml_char_t)'\250')) 
                goto _LOR_2;
              else goto _LAND_8;
            }
            else goto _LAND_8;
          }
          else {
            _LAND_8: ;
            if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\342')) {
              if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                if ((int)*(string.pointer + (0 + 2)) == (int)((yaml_char_t)'\251')) {
                  _LOR_2: ;
                  if (string.start == string.pointer) {
                    chomp_hint = "+";
                    emitter->open_ended = 2;
                  }
                  else {
                    while (1) {
                      (string.pointer) --;
                      if (! (((int)*(string.pointer) & 0xC0) == 0x80)) 
                        break;
                    }
                    if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\r')) 
                      goto _LOR_1;
                    else 
                      if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\n')) 
                        goto _LOR_1;
                      else 
                        if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\302')) {
                          if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\205')) 
                            goto _LOR_1;
                          else goto _LAND_4;
                        }
                        else {
                          _LAND_4: ;
                          if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\342')) {
                            if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                              if ((int)*(string.pointer + (0 + 2)) == (int)((yaml_char_t)'\250')) 
                                goto _LOR_1;
                              else goto _LAND_3;
                            }
                            else goto _LAND_3;
                          }
                          else {
                            _LAND_3: ;
                            if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\342')) 
                              if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) 
                                if ((int)*(string.pointer + (0 + 2)) == (int)((yaml_char_t)'\251')) {
                                  _LOR_1:
                                  {
                                    chomp_hint = "+";
                                    emitter->open_ended = 2;
                                  }
                                }
                          }
                        }
                  }
                }
                else goto _LAND_6;
              }
              else goto _LAND_6;
            }
            else _LAND_6: chomp_hint = "-";
          }
        }
  }
  if (chomp_hint) {
    int tmp_0;
    tmp_0 = yaml_emitter_write_indicator(emitter,chomp_hint,0,0,0);
    if (! tmp_0) {
      __retres = 0;
      goto return_label;
    }
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_write_literal_scalar(yaml_emitter_t *emitter,
                                             yaml_char_t *value,
                                             size_t length)
{
  int __retres;
  yaml_string_t string;
  int tmp;
  int tmp_0;
  int breaks = 1;
  string.start = value;
  string.end = value + length;
  string.pointer = value;
  tmp = yaml_emitter_write_indicator(emitter,"|",1,0,0);
  if (! tmp) {
    __retres = 0;
    goto return_label;
  }
  tmp_0 = yaml_emitter_write_block_scalar_hints(emitter,string);
  if (! tmp_0) {
    __retres = 0;
    goto return_label;
  }
  if (emitter->buffer.pointer + 5 < emitter->buffer.end) goto _LOR;
  else {
    int tmp_1;
    tmp_1 = yaml_emitter_flush(emitter);
    if (tmp_1) {
      _LOR: ;
      if (emitter->line_break == (unsigned int)YAML_CR_BREAK) {
        yaml_char_t *tmp_2;
        tmp_2 = emitter->buffer.pointer;
        (emitter->buffer.pointer) ++;
        *tmp_2 = (yaml_char_t)'\r';
        yaml_char_t tmp_10 = *tmp_2;
      }
      else 
        if (emitter->line_break == (unsigned int)YAML_LN_BREAK) {
          yaml_char_t *tmp_3;
          tmp_3 = emitter->buffer.pointer;
          (emitter->buffer.pointer) ++;
          *tmp_3 = (yaml_char_t)'\n';
          yaml_char_t tmp_8 = *tmp_3;
        }
        else 
          if (emitter->line_break == (unsigned int)YAML_CRLN_BREAK) {
            yaml_char_t *tmp_4;
            yaml_char_t *tmp_5;
            tmp_4 = emitter->buffer.pointer;
            (emitter->buffer.pointer) ++;
            *tmp_4 = (yaml_char_t)'\r';
            tmp_5 = emitter->buffer.pointer;
            (emitter->buffer.pointer) ++;
            *tmp_5 = (yaml_char_t)'\n';
            yaml_char_t tmp_6 = *tmp_5;
          }
      emitter->column = 0;
      (emitter->line) ++;
    }
    else {
      __retres = 0;
      goto return_label;
    }
  }
  emitter->indention = 1;
  emitter->whitespace = 1;
  while (string.pointer != string.end) 
    if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\r')) goto _LOR_3;
    else 
      if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\n')) goto _LOR_3;
      else 
        if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\302')) {
          if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\205')) 
            goto _LOR_3;
          else goto _LAND_3;
        }
        else {
          _LAND_3: ;
          if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\342')) {
            if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
              if ((int)*(string.pointer + (0 + 2)) == (int)((yaml_char_t)'\250')) 
                goto _LOR_3;
              else goto _LAND_2;
            }
            else goto _LAND_2;
          }
          else {
            _LAND_2: ;
            if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\342')) {
              if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                if ((int)*(string.pointer + (0 + 2)) == (int)((yaml_char_t)'\251')) {
                  _LOR_3:
                  {
                    if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                      goto _LOR_1;
                    else {
                      int tmp_6_0;
                      tmp_6_0 = yaml_emitter_flush(emitter);
                      if (tmp_6_0) {
                        int tmp_33_1;
                        _LOR_1: ;
                        if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\n')) {
                          int tmp_12_0;
                          if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                            goto _LOR_0;
                          else {
                            int tmp_7;
                            tmp_7 = yaml_emitter_flush(emitter);
                            if (tmp_7) {
                              _LOR_0: ;
                              if (emitter->line_break == (unsigned int)YAML_CR_BREAK) {
                                yaml_char_t *tmp_8_0;
                                tmp_8_0 = emitter->buffer.pointer;
                                (emitter->buffer.pointer) ++;
                                *tmp_8_0 = (yaml_char_t)'\r';
                                yaml_char_t tmp_16 = *tmp_8_0;
                              }
                              else 
                                if (emitter->line_break == (unsigned int)YAML_LN_BREAK) {
                                  yaml_char_t *tmp_9;
                                  tmp_9 = emitter->buffer.pointer;
                                  (emitter->buffer.pointer) ++;
                                  *tmp_9 = (yaml_char_t)'\n';
                                  yaml_char_t tmp_14 = *tmp_9;
                                }
                                else 
                                  if (emitter->line_break == (unsigned int)YAML_CRLN_BREAK) {
                                    yaml_char_t *tmp_10_0;
                                    yaml_char_t *tmp_11;
                                    tmp_10_0 = emitter->buffer.pointer;
                                    (emitter->buffer.pointer) ++;
                                    *tmp_10_0 = (yaml_char_t)'\r';
                                    tmp_11 = emitter->buffer.pointer;
                                    (emitter->buffer.pointer) ++;
                                    *tmp_11 = (yaml_char_t)'\n';
                                    yaml_char_t tmp_12 = *tmp_11;
                                  }
                              emitter->column = 0;
                              (emitter->line) ++;
                              tmp_12_0 = 1;
                            }
                            else tmp_12_0 = 0;
                          }
                          (string.pointer) ++;
                          tmp_33_1 = 1;
                        }
                        else {
                          if (((int)*(string.pointer) & 0x80) == 0x00) {
                            yaml_char_t *tmp_13;
                            yaml_char_t *tmp_14_0;
                            tmp_13 = emitter->buffer.pointer;
                            (emitter->buffer.pointer) ++;
                            tmp_14_0 = string.pointer;
                            (string.pointer) ++;
                            *tmp_13 = *tmp_14_0;
                            yaml_char_t tmp_39 = *tmp_13;
                          }
                          else 
                            if (((int)*(string.pointer) & 0xE0) == 0xC0) {
                              yaml_char_t *tmp_15;
                              yaml_char_t *tmp_16_0;
                              yaml_char_t *tmp_17;
                              yaml_char_t *tmp_18;
                              tmp_15 = emitter->buffer.pointer;
                              (emitter->buffer.pointer) ++;
                              tmp_16_0 = string.pointer;
                              (string.pointer) ++;
                              *tmp_15 = *tmp_16_0;
                              tmp_17 = emitter->buffer.pointer;
                              (emitter->buffer.pointer) ++;
                              tmp_18 = string.pointer;
                              (string.pointer) ++;
                              *tmp_17 = *tmp_18;
                              yaml_char_t tmp_37 = *tmp_17;
                            }
                            else 
                              if (((int)*(string.pointer) & 0xF0) == 0xE0) {
                                yaml_char_t *tmp_19;
                                yaml_char_t *tmp_20;
                                yaml_char_t *tmp_21;
                                yaml_char_t *tmp_22;
                                yaml_char_t *tmp_23;
                                yaml_char_t *tmp_24;
                                tmp_19 = emitter->buffer.pointer;
                                (emitter->buffer.pointer) ++;
                                tmp_20 = string.pointer;
                                (string.pointer) ++;
                                *tmp_19 = *tmp_20;
                                tmp_21 = emitter->buffer.pointer;
                                (emitter->buffer.pointer) ++;
                                tmp_22 = string.pointer;
                                (string.pointer) ++;
                                *tmp_21 = *tmp_22;
                                tmp_23 = emitter->buffer.pointer;
                                (emitter->buffer.pointer) ++;
                                tmp_24 = string.pointer;
                                (string.pointer) ++;
                                *tmp_23 = *tmp_24;
                                yaml_char_t tmp_35 = *tmp_23;
                              }
                              else 
                                if (((int)*(string.pointer) & 0xF8) == 0xF0) {
                                  yaml_char_t *tmp_25;
                                  yaml_char_t *tmp_26;
                                  yaml_char_t *tmp_27;
                                  yaml_char_t *tmp_28;
                                  yaml_char_t *tmp_29;
                                  yaml_char_t *tmp_30;
                                  yaml_char_t *tmp_31;
                                  yaml_char_t *tmp_32;
                                  tmp_25 = emitter->buffer.pointer;
                                  (emitter->buffer.pointer) ++;
                                  tmp_26 = string.pointer;
                                  (string.pointer) ++;
                                  *tmp_25 = *tmp_26;
                                  tmp_27 = emitter->buffer.pointer;
                                  (emitter->buffer.pointer) ++;
                                  tmp_28 = string.pointer;
                                  (string.pointer) ++;
                                  *tmp_27 = *tmp_28;
                                  tmp_29 = emitter->buffer.pointer;
                                  (emitter->buffer.pointer) ++;
                                  tmp_30 = string.pointer;
                                  (string.pointer) ++;
                                  *tmp_29 = *tmp_30;
                                  tmp_31 = emitter->buffer.pointer;
                                  (emitter->buffer.pointer) ++;
                                  tmp_32 = string.pointer;
                                  (string.pointer) ++;
                                  *tmp_31 = *tmp_32;
                                  yaml_char_t tmp_33 = *tmp_31;
                                }
                          emitter->column = 0;
                          (emitter->line) ++;
                          tmp_33_1 = 1;
                        }
                        if (! tmp_33_1) {
                          __retres = 0;
                          goto return_label;
                        }
                      }
                      else {
                        __retres = 0;
                        goto return_label;
                      }
                    }
                    emitter->indention = 1;
                    breaks = 1;
                  }
                }
                else goto _LAND_0;
              }
              else goto _LAND_0;
            }
            else {
              _LAND_0:
              {
                if (breaks) {
                  int tmp_34;
                  tmp_34 = yaml_emitter_write_indent(emitter);
                  if (! tmp_34) {
                    __retres = 0;
                    goto return_label;
                  }
                }
                if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                  goto _LOR_2;
                else {
                  int tmp_35_1;
                  tmp_35_1 = yaml_emitter_flush(emitter);
                  if (tmp_35_1) {
                    _LOR_2: ;
                    if (((int)*(string.pointer) & 0x80) == 0x00) {
                      yaml_char_t *tmp_36;
                      yaml_char_t *tmp_37_1;
                      tmp_36 = emitter->buffer.pointer;
                      (emitter->buffer.pointer) ++;
                      tmp_37_1 = string.pointer;
                      (string.pointer) ++;
                      *tmp_36 = *tmp_37_1;
                      yaml_char_t tmp_62 = *tmp_36;
                    }
                    else 
                      if (((int)*(string.pointer) & 0xE0) == 0xC0) {
                        yaml_char_t *tmp_38;
                        yaml_char_t *tmp_39_1;
                        yaml_char_t *tmp_40;
                        yaml_char_t *tmp_41;
                        tmp_38 = emitter->buffer.pointer;
                        (emitter->buffer.pointer) ++;
                        tmp_39_1 = string.pointer;
                        (string.pointer) ++;
                        *tmp_38 = *tmp_39_1;
                        tmp_40 = emitter->buffer.pointer;
                        (emitter->buffer.pointer) ++;
                        tmp_41 = string.pointer;
                        (string.pointer) ++;
                        *tmp_40 = *tmp_41;
                        yaml_char_t tmp_60 = *tmp_40;
                      }
                      else 
                        if (((int)*(string.pointer) & 0xF0) == 0xE0) {
                          yaml_char_t *tmp_42;
                          yaml_char_t *tmp_43;
                          yaml_char_t *tmp_44;
                          yaml_char_t *tmp_45;
                          yaml_char_t *tmp_46;
                          yaml_char_t *tmp_47;
                          tmp_42 = emitter->buffer.pointer;
                          (emitter->buffer.pointer) ++;
                          tmp_43 = string.pointer;
                          (string.pointer) ++;
                          *tmp_42 = *tmp_43;
                          tmp_44 = emitter->buffer.pointer;
                          (emitter->buffer.pointer) ++;
                          tmp_45 = string.pointer;
                          (string.pointer) ++;
                          *tmp_44 = *tmp_45;
                          tmp_46 = emitter->buffer.pointer;
                          (emitter->buffer.pointer) ++;
                          tmp_47 = string.pointer;
                          (string.pointer) ++;
                          *tmp_46 = *tmp_47;
                          yaml_char_t tmp_58 = *tmp_46;
                        }
                        else 
                          if (((int)*(string.pointer) & 0xF8) == 0xF0) {
                            yaml_char_t *tmp_48;
                            yaml_char_t *tmp_49;
                            yaml_char_t *tmp_50;
                            yaml_char_t *tmp_51;
                            yaml_char_t *tmp_52;
                            yaml_char_t *tmp_53;
                            yaml_char_t *tmp_54;
                            yaml_char_t *tmp_55;
                            tmp_48 = emitter->buffer.pointer;
                            (emitter->buffer.pointer) ++;
                            tmp_49 = string.pointer;
                            (string.pointer) ++;
                            *tmp_48 = *tmp_49;
                            tmp_50 = emitter->buffer.pointer;
                            (emitter->buffer.pointer) ++;
                            tmp_51 = string.pointer;
                            (string.pointer) ++;
                            *tmp_50 = *tmp_51;
                            tmp_52 = emitter->buffer.pointer;
                            (emitter->buffer.pointer) ++;
                            tmp_53 = string.pointer;
                            (string.pointer) ++;
                            *tmp_52 = *tmp_53;
                            tmp_54 = emitter->buffer.pointer;
                            (emitter->buffer.pointer) ++;
                            tmp_55 = string.pointer;
                            (string.pointer) ++;
                            *tmp_54 = *tmp_55;
                            yaml_char_t tmp_56 = *tmp_54;
                          }
                    (emitter->column) ++;
                  }
                  else {
                    __retres = 0;
                    goto return_label;
                  }
                }
                emitter->indention = 0;
                breaks = 0;
              }
            }
          }
        }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_emitter_write_folded_scalar(yaml_emitter_t *emitter,
                                            yaml_char_t *value, size_t length)
{
  int __retres;
  yaml_string_t string;
  int tmp;
  int tmp_0;
  int breaks = 1;
  int leading_spaces = 1;
  string.start = value;
  string.end = value + length;
  string.pointer = value;
  tmp = yaml_emitter_write_indicator(emitter,">",1,0,0);
  if (! tmp) {
    __retres = 0;
    goto return_label;
  }
  tmp_0 = yaml_emitter_write_block_scalar_hints(emitter,string);
  if (! tmp_0) {
    __retres = 0;
    goto return_label;
  }
  if (emitter->buffer.pointer + 5 < emitter->buffer.end) goto _LOR;
  else {
    int tmp_1;
    tmp_1 = yaml_emitter_flush(emitter);
    if (tmp_1) {
      _LOR: ;
      if (emitter->line_break == (unsigned int)YAML_CR_BREAK) {
        yaml_char_t *tmp_2;
        tmp_2 = emitter->buffer.pointer;
        (emitter->buffer.pointer) ++;
        *tmp_2 = (yaml_char_t)'\r';
        yaml_char_t tmp_10 = *tmp_2;
      }
      else 
        if (emitter->line_break == (unsigned int)YAML_LN_BREAK) {
          yaml_char_t *tmp_3;
          tmp_3 = emitter->buffer.pointer;
          (emitter->buffer.pointer) ++;
          *tmp_3 = (yaml_char_t)'\n';
          yaml_char_t tmp_8 = *tmp_3;
        }
        else 
          if (emitter->line_break == (unsigned int)YAML_CRLN_BREAK) {
            yaml_char_t *tmp_4;
            yaml_char_t *tmp_5;
            tmp_4 = emitter->buffer.pointer;
            (emitter->buffer.pointer) ++;
            *tmp_4 = (yaml_char_t)'\r';
            tmp_5 = emitter->buffer.pointer;
            (emitter->buffer.pointer) ++;
            *tmp_5 = (yaml_char_t)'\n';
            yaml_char_t tmp_6 = *tmp_5;
          }
      emitter->column = 0;
      (emitter->line) ++;
    }
    else {
      __retres = 0;
      goto return_label;
    }
  }
  emitter->indention = 1;
  emitter->whitespace = 1;
  while (string.pointer != string.end) 
    if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\r')) goto _LOR_4;
    else 
      if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\n')) goto _LOR_4;
      else 
        if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\302')) {
          if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\205')) 
            goto _LOR_4;
          else goto _LAND_14;
        }
        else {
          _LAND_14: ;
          if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\342')) {
            if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
              if ((int)*(string.pointer + (0 + 2)) == (int)((yaml_char_t)'\250')) 
                goto _LOR_4;
              else goto _LAND_13;
            }
            else goto _LAND_13;
          }
          else {
            _LAND_13: ;
            if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\342')) {
              if ((int)*(string.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                if ((int)*(string.pointer + (0 + 2)) == (int)((yaml_char_t)'\251')) {
                  _LOR_4:
                  {
                    if (! breaks) 
                      if (! leading_spaces) 
                        if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\n')) {
                          int k = 0;
                          while (1) {
                            if (! ((int)*(string.pointer + k) == (int)((yaml_char_t)'\r'))) 
                              if (! ((int)*(string.pointer + k) == (int)((yaml_char_t)'\n'))) 
                                if ((int)*(string.pointer + k) == (int)((yaml_char_t)'\302')) {
                                  if (! ((int)*(string.pointer + (k + 1)) == (int)((yaml_char_t)'\205'))) 
                                    goto _LAND_1;
                                }
                                else {
                                  _LAND_1: ;
                                  if ((int)*(string.pointer + k) == (int)((yaml_char_t)'\342')) {
                                    if ((int)*(string.pointer + (k + 1)) == (int)((yaml_char_t)'\200')) {
                                      if (! ((int)*(string.pointer + (k + 2)) == (int)((yaml_char_t)'\250'))) 
                                        goto _LAND_0;
                                    }
                                    else goto _LAND_0;
                                  }
                                  else {
                                    _LAND_0: ;
                                    if ((int)*(string.pointer + k) == (int)((yaml_char_t)'\342')) 
                                      if ((int)*(string.pointer + (k + 1)) == (int)((yaml_char_t)'\200')) {
                                        if (! ((int)*(string.pointer + (
                                                      k + 2)) == (int)((yaml_char_t)'\251'))) 
                                          break;
                                      }
                                      else break;
                                    else break;
                                  }
                                }
                            {
                              int tmp_9;
                              if (((int)*(string.pointer + k) & 0x80) == 0x00) 
                                tmp_9 = 1;
                              else {
                                int tmp_8_1;
                                if (((int)*(string.pointer + k) & 0xE0) == 0xC0) 
                                  tmp_8_1 = 2;
                                else {
                                  int tmp_7;
                                  if (((int)*(string.pointer + k) & 0xF0) == 0xE0) 
                                    tmp_7 = 3;
                                  else {
                                    int tmp_6_1;
                                    if (((int)*(string.pointer + k) & 0xF8) == 0xF0) 
                                      tmp_6_1 = 4;
                                    else tmp_6_1 = 0;
                                    tmp_7 = tmp_6_1;
                                  }
                                  tmp_8_1 = tmp_7;
                                }
                                tmp_9 = tmp_8_1;
                              }
                              k += tmp_9;
                            }
                          }
                          if (! ((int)*(string.pointer + k) == (int)((yaml_char_t)' '))) 
                            if (! ((int)*(string.pointer + k) == (int)((yaml_char_t)'\t'))) 
                              if (! ((int)*(string.pointer + k) == (int)((yaml_char_t)'\r'))) 
                                if (! ((int)*(string.pointer + k) == (int)((yaml_char_t)'\n'))) 
                                  if ((int)*(string.pointer + k) == (int)((yaml_char_t)'\302')) {
                                    if (! ((int)*(string.pointer + (k + 1)) == (int)((yaml_char_t)'\205'))) 
                                      goto _LAND_6;
                                  }
                                  else {
                                    _LAND_6: ;
                                    if ((int)*(string.pointer + k) == (int)((yaml_char_t)'\342')) {
                                      if ((int)*(string.pointer + (k + 1)) == (int)((yaml_char_t)'\200')) {
                                        if (! ((int)*(string.pointer + (
                                                      k + 2)) == (int)((yaml_char_t)'\250'))) 
                                          goto _LAND_5;
                                      }
                                      else goto _LAND_5;
                                    }
                                    else {
                                      _LAND_5: ;
                                      if ((int)*(string.pointer + k) == (int)((yaml_char_t)'\342')) {
                                        if ((int)*(string.pointer + (k + 1)) == (int)((yaml_char_t)'\200')) {
                                          if (! ((int)*(string.pointer + (
                                                        k + 2)) == (int)((yaml_char_t)'\251'))) 
                                            goto _LAND_3;
                                        }
                                        else goto _LAND_3;
                                      }
                                      else {
                                        _LAND_3: ;
                                        if (! ((int)*(string.pointer + k) == (int)((yaml_char_t)'\000'))) 
                                          if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                                            goto _LOR_0;
                                          else {
                                            int tmp_10_1;
                                            tmp_10_1 = yaml_emitter_flush
                                            (emitter);
                                            if (tmp_10_1) {
                                              _LOR_0: ;
                                              if (emitter->line_break == (unsigned int)YAML_CR_BREAK) {
                                                yaml_char_t *tmp_11;
                                                tmp_11 = emitter->buffer.pointer;
                                                (emitter->buffer.pointer) ++;
                                                *tmp_11 = (yaml_char_t)'\r';
                                                yaml_char_t tmp_19 = *tmp_11;
                                              }
                                              else 
                                                if (emitter->line_break == (unsigned int)YAML_LN_BREAK) {
                                                  yaml_char_t *tmp_12;
                                                  tmp_12 = emitter->buffer.pointer;
                                                  (emitter->buffer.pointer) ++;
                                                  *tmp_12 = (yaml_char_t)'\n';
                                                  yaml_char_t tmp_17 =
                                                    *tmp_12;
                                                }
                                                else 
                                                  if (emitter->line_break == (unsigned int)YAML_CRLN_BREAK) {
                                                    yaml_char_t *tmp_13;
                                                    yaml_char_t *tmp_14;
                                                    tmp_13 = emitter->buffer.pointer;
                                                    (emitter->buffer.pointer) ++;
                                                    *tmp_13 = (yaml_char_t)'\r';
                                                    tmp_14 = emitter->buffer.pointer;
                                                    (emitter->buffer.pointer) ++;
                                                    *tmp_14 = (yaml_char_t)'\n';
                                                    yaml_char_t tmp_15 =
                                                      *tmp_14;
                                                  }
                                              emitter->column = 0;
                                              (emitter->line) ++;
                                            }
                                            else {
                                              __retres = 0;
                                              goto return_label;
                                            }
                                          }
                                      }
                                    }
                                  }
                        }
                    if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                      goto _LOR_2;
                    else {
                      int tmp_15_0;
                      tmp_15_0 = yaml_emitter_flush(emitter);
                      if (tmp_15_0) {
                        int tmp_42_1;
                        _LOR_2: ;
                        if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\n')) {
                          int tmp_21_0;
                          if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                            goto _LOR_1;
                          else {
                            int tmp_16;
                            tmp_16 = yaml_emitter_flush(emitter);
                            if (tmp_16) {
                              _LOR_1: ;
                              if (emitter->line_break == (unsigned int)YAML_CR_BREAK) {
                                yaml_char_t *tmp_17_0;
                                tmp_17_0 = emitter->buffer.pointer;
                                (emitter->buffer.pointer) ++;
                                *tmp_17_0 = (yaml_char_t)'\r';
                                yaml_char_t tmp_25 = *tmp_17_0;
                              }
                              else 
                                if (emitter->line_break == (unsigned int)YAML_LN_BREAK) {
                                  yaml_char_t *tmp_18;
                                  tmp_18 = emitter->buffer.pointer;
                                  (emitter->buffer.pointer) ++;
                                  *tmp_18 = (yaml_char_t)'\n';
                                  yaml_char_t tmp_23 = *tmp_18;
                                }
                                else 
                                  if (emitter->line_break == (unsigned int)YAML_CRLN_BREAK) {
                                    yaml_char_t *tmp_19_0;
                                    yaml_char_t *tmp_20;
                                    tmp_19_0 = emitter->buffer.pointer;
                                    (emitter->buffer.pointer) ++;
                                    *tmp_19_0 = (yaml_char_t)'\r';
                                    tmp_20 = emitter->buffer.pointer;
                                    (emitter->buffer.pointer) ++;
                                    *tmp_20 = (yaml_char_t)'\n';
                                    yaml_char_t tmp_21 = *tmp_20;
                                  }
                              emitter->column = 0;
                              (emitter->line) ++;
                              tmp_21_0 = 1;
                            }
                            else tmp_21_0 = 0;
                          }
                          (string.pointer) ++;
                          tmp_42_1 = 1;
                        }
                        else {
                          if (((int)*(string.pointer) & 0x80) == 0x00) {
                            yaml_char_t *tmp_22;
                            yaml_char_t *tmp_23_0;
                            tmp_22 = emitter->buffer.pointer;
                            (emitter->buffer.pointer) ++;
                            tmp_23_0 = string.pointer;
                            (string.pointer) ++;
                            *tmp_22 = *tmp_23_0;
                            yaml_char_t tmp_48 = *tmp_22;
                          }
                          else 
                            if (((int)*(string.pointer) & 0xE0) == 0xC0) {
                              yaml_char_t *tmp_24;
                              yaml_char_t *tmp_25_0;
                              yaml_char_t *tmp_26;
                              yaml_char_t *tmp_27;
                              tmp_24 = emitter->buffer.pointer;
                              (emitter->buffer.pointer) ++;
                              tmp_25_0 = string.pointer;
                              (string.pointer) ++;
                              *tmp_24 = *tmp_25_0;
                              tmp_26 = emitter->buffer.pointer;
                              (emitter->buffer.pointer) ++;
                              tmp_27 = string.pointer;
                              (string.pointer) ++;
                              *tmp_26 = *tmp_27;
                              yaml_char_t tmp_46 = *tmp_26;
                            }
                            else 
                              if (((int)*(string.pointer) & 0xF0) == 0xE0) {
                                yaml_char_t *tmp_28;
                                yaml_char_t *tmp_29;
                                yaml_char_t *tmp_30;
                                yaml_char_t *tmp_31;
                                yaml_char_t *tmp_32;
                                yaml_char_t *tmp_33;
                                tmp_28 = emitter->buffer.pointer;
                                (emitter->buffer.pointer) ++;
                                tmp_29 = string.pointer;
                                (string.pointer) ++;
                                *tmp_28 = *tmp_29;
                                tmp_30 = emitter->buffer.pointer;
                                (emitter->buffer.pointer) ++;
                                tmp_31 = string.pointer;
                                (string.pointer) ++;
                                *tmp_30 = *tmp_31;
                                tmp_32 = emitter->buffer.pointer;
                                (emitter->buffer.pointer) ++;
                                tmp_33 = string.pointer;
                                (string.pointer) ++;
                                *tmp_32 = *tmp_33;
                                yaml_char_t tmp_44 = *tmp_32;
                              }
                              else 
                                if (((int)*(string.pointer) & 0xF8) == 0xF0) {
                                  yaml_char_t *tmp_34;
                                  yaml_char_t *tmp_35;
                                  yaml_char_t *tmp_36;
                                  yaml_char_t *tmp_37;
                                  yaml_char_t *tmp_38;
                                  yaml_char_t *tmp_39;
                                  yaml_char_t *tmp_40;
                                  yaml_char_t *tmp_41;
                                  tmp_34 = emitter->buffer.pointer;
                                  (emitter->buffer.pointer) ++;
                                  tmp_35 = string.pointer;
                                  (string.pointer) ++;
                                  *tmp_34 = *tmp_35;
                                  tmp_36 = emitter->buffer.pointer;
                                  (emitter->buffer.pointer) ++;
                                  tmp_37 = string.pointer;
                                  (string.pointer) ++;
                                  *tmp_36 = *tmp_37;
                                  tmp_38 = emitter->buffer.pointer;
                                  (emitter->buffer.pointer) ++;
                                  tmp_39 = string.pointer;
                                  (string.pointer) ++;
                                  *tmp_38 = *tmp_39;
                                  tmp_40 = emitter->buffer.pointer;
                                  (emitter->buffer.pointer) ++;
                                  tmp_41 = string.pointer;
                                  (string.pointer) ++;
                                  *tmp_40 = *tmp_41;
                                  yaml_char_t tmp_42 = *tmp_40;
                                }
                          emitter->column = 0;
                          (emitter->line) ++;
                          tmp_42_1 = 1;
                        }
                        if (! tmp_42_1) {
                          __retres = 0;
                          goto return_label;
                        }
                      }
                      else {
                        __retres = 0;
                        goto return_label;
                      }
                    }
                    emitter->indention = 1;
                    breaks = 1;
                  }
                }
                else goto _LAND_11;
              }
              else goto _LAND_11;
            }
            else {
              _LAND_11:
              {
                if (breaks) {
                  int tmp_43;
                  int tmp_44_1;
                  tmp_43 = yaml_emitter_write_indent(emitter);
                  if (! tmp_43) {
                    __retres = 0;
                    goto return_label;
                  }
                  if ((int)*(string.pointer + 0) == (int)((yaml_char_t)' ')) 
                    tmp_44_1 = 1;
                  else 
                    if ((int)*(string.pointer + 0) == (int)((yaml_char_t)'\t')) 
                      tmp_44_1 = 1;
                    else tmp_44_1 = 0;
                  leading_spaces = tmp_44_1;
                }
                if (! breaks) {
                  if ((int)*(string.pointer + 0) == (int)((yaml_char_t)' ')) {
                    if (! ((int)*(string.pointer + 1) == (int)((yaml_char_t)' '))) {
                      if (emitter->column > emitter->best_width) {
                        int tmp_45;
                        int tmp_49;
                        tmp_45 = yaml_emitter_write_indent(emitter);
                        if (! tmp_45) {
                          __retres = 0;
                          goto return_label;
                        }
                        if (((int)*(string.pointer + 0) & 0x80) == 0x00) 
                          tmp_49 = 1;
                        else {
                          int tmp_48_0;
                          if (((int)*(string.pointer + 0) & 0xE0) == 0xC0) 
                            tmp_48_0 = 2;
                          else {
                            int tmp_47;
                            if (((int)*(string.pointer + 0) & 0xF0) == 0xE0) 
                              tmp_47 = 3;
                            else {
                              int tmp_46_0;
                              if (((int)*(string.pointer + 0) & 0xF8) == 0xF0) 
                                tmp_46_0 = 4;
                              else tmp_46_0 = 0;
                              tmp_47 = tmp_46_0;
                            }
                            tmp_48_0 = tmp_47;
                          }
                          tmp_49 = tmp_48_0;
                        }
                        string.pointer += tmp_49;
                      }
                      else goto _LAND_9;
                    }
                    else goto _LAND_9;
                  }
                  else goto _LAND_9;
                }
                else 
                  _LAND_9:
                  if (emitter->buffer.pointer + 5 < emitter->buffer.end) 
                    goto _LOR_3;
                  else {
                    int tmp_50;
                    tmp_50 = yaml_emitter_flush(emitter);
                    if (tmp_50) {
                      _LOR_3: ;
                      if (((int)*(string.pointer) & 0x80) == 0x00) {
                        yaml_char_t *tmp_51;
                        yaml_char_t *tmp_52;
                        tmp_51 = emitter->buffer.pointer;
                        (emitter->buffer.pointer) ++;
                        tmp_52 = string.pointer;
                        (string.pointer) ++;
                        *tmp_51 = *tmp_52;
                        yaml_char_t tmp_77 = *tmp_51;
                      }
                      else 
                        if (((int)*(string.pointer) & 0xE0) == 0xC0) {
                          yaml_char_t *tmp_53;
                          yaml_char_t *tmp_54;
                          yaml_char_t *tmp_55;
                          yaml_char_t *tmp_56;
                          tmp_53 = emitter->buffer.pointer;
                          (emitter->buffer.pointer) ++;
                          tmp_54 = string.pointer;
                          (string.pointer) ++;
                          *tmp_53 = *tmp_54;
                          tmp_55 = emitter->buffer.pointer;
                          (emitter->buffer.pointer) ++;
                          tmp_56 = string.pointer;
                          (string.pointer) ++;
                          *tmp_55 = *tmp_56;
                          yaml_char_t tmp_75 = *tmp_55;
                        }
                        else 
                          if (((int)*(string.pointer) & 0xF0) == 0xE0) {
                            yaml_char_t *tmp_57;
                            yaml_char_t *tmp_58;
                            yaml_char_t *tmp_59;
                            yaml_char_t *tmp_60;
                            yaml_char_t *tmp_61;
                            yaml_char_t *tmp_62;
                            tmp_57 = emitter->buffer.pointer;
                            (emitter->buffer.pointer) ++;
                            tmp_58 = string.pointer;
                            (string.pointer) ++;
                            *tmp_57 = *tmp_58;
                            tmp_59 = emitter->buffer.pointer;
                            (emitter->buffer.pointer) ++;
                            tmp_60 = string.pointer;
                            (string.pointer) ++;
                            *tmp_59 = *tmp_60;
                            tmp_61 = emitter->buffer.pointer;
                            (emitter->buffer.pointer) ++;
                            tmp_62 = string.pointer;
                            (string.pointer) ++;
                            *tmp_61 = *tmp_62;
                            yaml_char_t tmp_73 = *tmp_61;
                          }
                          else 
                            if (((int)*(string.pointer) & 0xF8) == 0xF0) {
                              yaml_char_t *tmp_63;
                              yaml_char_t *tmp_64;
                              yaml_char_t *tmp_65;
                              yaml_char_t *tmp_66;
                              yaml_char_t *tmp_67;
                              yaml_char_t *tmp_68;
                              yaml_char_t *tmp_69;
                              yaml_char_t *tmp_70;
                              tmp_63 = emitter->buffer.pointer;
                              (emitter->buffer.pointer) ++;
                              tmp_64 = string.pointer;
                              (string.pointer) ++;
                              *tmp_63 = *tmp_64;
                              tmp_65 = emitter->buffer.pointer;
                              (emitter->buffer.pointer) ++;
                              tmp_66 = string.pointer;
                              (string.pointer) ++;
                              *tmp_65 = *tmp_66;
                              tmp_67 = emitter->buffer.pointer;
                              (emitter->buffer.pointer) ++;
                              tmp_68 = string.pointer;
                              (string.pointer) ++;
                              *tmp_67 = *tmp_68;
                              tmp_69 = emitter->buffer.pointer;
                              (emitter->buffer.pointer) ++;
                              tmp_70 = string.pointer;
                              (string.pointer) ++;
                              *tmp_69 = *tmp_70;
                              yaml_char_t tmp_71 = *tmp_69;
                            }
                      (emitter->column) ++;
                    }
                    else {
                      __retres = 0;
                      goto return_label;
                    }
                  }
                emitter->indention = 0;
                breaks = 0;
              }
            }
          }
        }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_set_composer_error(yaml_parser_t *parser,
                                          char const *problem,
                                          yaml_mark_t problem_mark);

static int yaml_parser_set_composer_error_context(yaml_parser_t *parser,
                                                  char const *context,
                                                  yaml_mark_t context_mark,
                                                  char const *problem,
                                                  yaml_mark_t problem_mark);

static int yaml_parser_register_anchor(yaml_parser_t *parser, int index_0,
                                       yaml_char_t *anchor);

static void yaml_parser_delete_aliases(yaml_parser_t *parser);

static int yaml_parser_load_nodes(yaml_parser_t *parser,
                                  struct loader_ctx *ctx);

static int yaml_parser_load_document(yaml_parser_t *parser,
                                     yaml_event_t *event);

static int yaml_parser_load_alias(yaml_parser_t *parser, yaml_event_t *event,
                                  struct loader_ctx *ctx);

static int yaml_parser_load_scalar(yaml_parser_t *parser,
                                   yaml_event_t *event,
                                   struct loader_ctx *ctx);

static int yaml_parser_load_sequence(yaml_parser_t *parser,
                                     yaml_event_t *event,
                                     struct loader_ctx *ctx);

static int yaml_parser_load_mapping(yaml_parser_t *parser,
                                    yaml_event_t *event,
                                    struct loader_ctx *ctx);

static int yaml_parser_load_sequence_end(yaml_parser_t *parser,
                                         yaml_event_t *event,
                                         struct loader_ctx *ctx);

static int yaml_parser_load_mapping_end(yaml_parser_t *parser,
                                        yaml_event_t *event,
                                        struct loader_ctx *ctx);

int yaml_parser_load(yaml_parser_t *parser, yaml_document_t *document)
{
  int __retres;
  yaml_event_t event;
  int tmp_1;
  yaml_node_t *tmp;
  int tmp_3;
  int tmp_6;
  yaml_alias_data_t *tmp_4;
  int tmp_7;
  __FC_assert(parser != (yaml_parser_t *)0,"src/loader.c",91,"parser");
  __FC_assert(document != (yaml_document_t *)0,"src/loader.c",92,"document");
  memset((void *)document,0,sizeof(yaml_document_t));
  tmp = (yaml_node_t *)yaml_malloc((unsigned long)16 * sizeof(*(document->nodes.start)));
  document->nodes.start = tmp;
  if (tmp) {
    document->nodes.top = document->nodes.start;
    document->nodes.end = document->nodes.start + 16;
    tmp_1 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_1 = 0;
  }
  if (! tmp_1) goto error;
  if (! parser->stream_start_produced) {
    int tmp_2;
    tmp_2 = yaml_parser_parse(parser,& event);
    if (! tmp_2) goto error;
    __FC_assert((event.type == (unsigned int)YAML_STREAM_START_EVENT) != 0,
                "src/loader.c",100,"event.type == YAML_STREAM_START_EVENT");
  }
  if (parser->stream_end_produced) {
    __retres = 1;
    goto return_label;
  }
  tmp_3 = yaml_parser_parse(parser,& event);
  if (! tmp_3) goto error;
  if (event.type == (unsigned int)YAML_STREAM_END_EVENT) {
    __retres = 1;
    goto return_label;
  }
  tmp_4 = (yaml_alias_data_t *)yaml_malloc((unsigned long)16 * sizeof(*(parser->aliases.start)));
  parser->aliases.start = tmp_4;
  if (tmp_4) {
    parser->aliases.top = parser->aliases.start;
    parser->aliases.end = parser->aliases.start + 16;
    tmp_6 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_6 = 0;
  }
  if (! tmp_6) goto error;
  parser->document = document;
  tmp_7 = yaml_parser_load_document(parser,& event);
  if (! tmp_7) goto error;
  yaml_parser_delete_aliases(parser);
  parser->document = (yaml_document_t *)0;
  __retres = 1;
  goto return_label;
  error: yaml_parser_delete_aliases(parser);
  yaml_document_delete(document);
  parser->document = (yaml_document_t *)0;
  __retres = 0;
  return_label: return __retres;
}

static int yaml_parser_set_composer_error(yaml_parser_t *parser,
                                          char const *problem,
                                          yaml_mark_t problem_mark)
{
  int __retres;
  parser->error = YAML_COMPOSER_ERROR;
  parser->problem = problem;
  parser->problem_mark = problem_mark;
  __retres = 0;
  return __retres;
}

static int yaml_parser_set_composer_error_context(yaml_parser_t *parser,
                                                  char const *context,
                                                  yaml_mark_t context_mark,
                                                  char const *problem,
                                                  yaml_mark_t problem_mark)
{
  int __retres;
  parser->error = YAML_COMPOSER_ERROR;
  parser->context = context;
  parser->context_mark = context_mark;
  parser->problem = problem;
  parser->problem_mark = problem_mark;
  __retres = 0;
  return __retres;
}

static void yaml_parser_delete_aliases(yaml_parser_t *parser)
{
  yaml_alias_data_t *tmp_0;
  yaml_alias_data_t *tmp;
  while (! (parser->aliases.start == parser->aliases.top)) {
    (parser->aliases.top) --;
    ;
    yaml_free((void *)(parser->aliases.top)->anchor);
  }
  yaml_free((void *)parser->aliases.start);
  tmp_0 = (yaml_alias_data_t *)0;
  parser->aliases.end = tmp_0;
  tmp = tmp_0;
  parser->aliases.top = tmp;
  parser->aliases.start = tmp;
  return;
}

static int yaml_parser_load_document(yaml_parser_t *parser,
                                     yaml_event_t *event)
{
  int __retres;
  int tmp_0;
  int tmp_1;
  struct loader_ctx ctx =
    {.start = (int *)0, .end = (int *)0, .top = (int *)0};
  __FC_assert((event->type == (unsigned int)YAML_DOCUMENT_START_EVENT) != 0,
              "src/loader.c",189,"event->type == YAML_DOCUMENT_START_EVENT");
  (parser->document)->version_directive = event->data.document_start.version_directive;
  (parser->document)->tag_directives.start = event->data.document_start.tag_directives.start;
  (parser->document)->tag_directives.end = event->data.document_start.tag_directives.end;
  (parser->document)->start_implicit = event->data.document_start.implicit;
  (parser->document)->start_mark = event->start_mark;
  ctx.start = (int *)yaml_malloc((unsigned long)16 * sizeof(*(ctx.start)));
  if (ctx.start) {
    ctx.top = ctx.start;
    ctx.end = ctx.start + 16;
    tmp_0 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_0 = 0;
  }
  if (! tmp_0) {
    __retres = 0;
    goto return_label;
  }
  tmp_1 = yaml_parser_load_nodes(parser,& ctx);
  if (! tmp_1) {
    yaml_free((void *)ctx.start);
    ctx.end = (int *)0;
    ctx.top = ctx.end;
    ctx.start = ctx.top;
    __retres = 0;
    goto return_label;
  }
  yaml_free((void *)ctx.start);
  ctx.end = (int *)0;
  ctx.top = ctx.end;
  ctx.start = ctx.top;
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_load_nodes(yaml_parser_t *parser,
                                  struct loader_ctx *ctx)
{
  int __retres;
  yaml_event_t event;
  while (1) {
    {
      int tmp;
      tmp = yaml_parser_parse(parser,& event);
      if (! tmp) {
        __retres = 0;
        goto return_label;
      }
      switch (event.type) {
        int tmp_0;
        int tmp_1;
        int tmp_2;
        int tmp_3;
        int tmp_4;
        int tmp_5;
        case YAML_ALIAS_EVENT:
        tmp_0 = yaml_parser_load_alias(parser,& event,ctx);
        if (! tmp_0) {
          __retres = 0;
          goto return_label;
        }
        break;
        case YAML_SCALAR_EVENT:
        tmp_1 = yaml_parser_load_scalar(parser,& event,ctx);
        if (! tmp_1) {
          __retres = 0;
          goto return_label;
        }
        break;
        case YAML_SEQUENCE_START_EVENT:
        tmp_2 = yaml_parser_load_sequence(parser,& event,ctx);
        if (! tmp_2) {
          __retres = 0;
          goto return_label;
        }
        break;
        case YAML_SEQUENCE_END_EVENT:
        tmp_3 = yaml_parser_load_sequence_end(parser,& event,ctx);
        if (! tmp_3) {
          __retres = 0;
          goto return_label;
        }
        break;
        case YAML_MAPPING_START_EVENT:
        tmp_4 = yaml_parser_load_mapping(parser,& event,ctx);
        if (! tmp_4) {
          __retres = 0;
          goto return_label;
        }
        break;
        case YAML_MAPPING_END_EVENT:
        tmp_5 = yaml_parser_load_mapping_end(parser,& event,ctx);
        if (! tmp_5) {
          __retres = 0;
          goto return_label;
        }
        break;
        default: __FC_assert(0 != 0,"src/loader.c",246,"0");
        __retres = 0;
        goto return_label;
        case YAML_DOCUMENT_END_EVENT: break;
      }
    }
    if (! (event.type != (unsigned int)YAML_DOCUMENT_END_EVENT)) break;
  }
  (parser->document)->end_implicit = event.data.document_end.implicit;
  (parser->document)->end_mark = event.end_mark;
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_register_anchor(yaml_parser_t *parser, int index_0,
                                       yaml_char_t *anchor)
{
  int __retres;
  yaml_alias_data_t data;
  yaml_alias_data_t *alias_data;
  int tmp_3;
  if (! anchor) {
    __retres = 1;
    goto return_label;
  }
  data.anchor = anchor;
  data.index = index_0;
  data.mark = ((parser->document)->nodes.start + (index_0 - 1))->start_mark;
  alias_data = parser->aliases.start;
  while (alias_data != parser->aliases.top) {
    {
      int tmp_0;
      tmp_0 = strcmp((char const *)alias_data->anchor,(char const *)anchor);
      if (tmp_0 == 0) {
        int tmp;
        yaml_free((void *)anchor);
        tmp = yaml_parser_set_composer_error_context(parser,
                                                     "found duplicate anchor; first occurrence",
                                                     alias_data->mark,
                                                     "second occurrence",
                                                     data.mark);
        __retres = tmp;
        goto return_label;
      }
    }
    alias_data ++;
  }
  if (parser->aliases.top != parser->aliases.end) goto _LOR;
  else {
    int tmp_1;
    tmp_1 = yaml_stack_extend((void **)(& parser->aliases.start),
                              (void **)(& parser->aliases.top),
                              (void **)(& parser->aliases.end));
    if (tmp_1) {
      yaml_alias_data_t *tmp_2;
      _LOR: tmp_2 = parser->aliases.top;
      (parser->aliases.top) ++;
      *tmp_2 = data;
      tmp_3 = 1;
    }
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp_3 = 0;
    }
  }
  if (! tmp_3) {
    yaml_free((void *)anchor);
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_load_node_add(yaml_parser_t *parser,
                                     struct loader_ctx *ctx, int index_0)
{
  int __retres;
  struct yaml_node_s *parent;
  int parent_index;
  if (ctx->start == ctx->top) {
    __retres = 1;
    goto return_label;
  }
  parent_index = *(ctx->top - 1);
  parent = (parser->document)->nodes.start + (parent_index - 1);
  switch (parent->type) {
    int tmp;
    int tmp_2;
    case YAML_SEQUENCE_NODE: ;
    if (parent->data.sequence.items.top - parent->data.sequence.items.start < (long)(
        2147483647 - 1)) tmp = 1;
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp = 0;
    }
    if (! tmp) {
      __retres = 0;
      goto return_label;
    }
    if (parent->data.sequence.items.top != parent->data.sequence.items.end) 
      goto _LOR;
    else {
      int tmp_0;
      tmp_0 = yaml_stack_extend((void **)(& parent->data.sequence.items.start),
                                (void **)(& parent->data.sequence.items.top),
                                (void **)(& parent->data.sequence.items.end));
      if (tmp_0) {
        yaml_node_item_t *tmp_1;
        _LOR: tmp_1 = parent->data.sequence.items.top;
        (parent->data.sequence.items.top) ++;
        *tmp_1 = index_0;
        tmp_2 = 1;
      }
      else {
        parser->error = YAML_MEMORY_ERROR;
        tmp_2 = 0;
      }
    }
    if (! tmp_2) {
      __retres = 0;
      goto return_label;
    }
    break;
    case YAML_MAPPING_NODE:
    {
      yaml_node_pair_t pair;
      int tmp_3;
      int tmp_6;
      if (! (parent->data.mapping.pairs.start == parent->data.mapping.pairs.top)) {
        yaml_node_pair_t *p = parent->data.mapping.pairs.top - 1;
        if (p->key != 0) 
          if (p->value == 0) {
            p->value = index_0;
            break;
          }
      }
      pair.key = index_0;
      pair.value = 0;
      if (parent->data.mapping.pairs.top - parent->data.mapping.pairs.start < (long)(
          2147483647 - 1)) tmp_3 = 1;
      else {
        parser->error = YAML_MEMORY_ERROR;
        tmp_3 = 0;
      }
      if (! tmp_3) {
        __retres = 0;
        goto return_label;
      }
      if (parent->data.mapping.pairs.top != parent->data.mapping.pairs.end) 
        goto _LOR_0;
      else {
        int tmp_4;
        tmp_4 = yaml_stack_extend((void **)(& parent->data.mapping.pairs.start),
                                  (void **)(& parent->data.mapping.pairs.top),
                                  (void **)(& parent->data.mapping.pairs.end));
        if (tmp_4) {
          yaml_node_pair_t *tmp_5;
          _LOR_0: tmp_5 = parent->data.mapping.pairs.top;
          (parent->data.mapping.pairs.top) ++;
          *tmp_5 = pair;
          tmp_6 = 1;
        }
        else {
          parser->error = YAML_MEMORY_ERROR;
          tmp_6 = 0;
        }
      }
      if (! tmp_6) {
        __retres = 0;
        goto return_label;
      }
      break;
    }
    default: __FC_assert(0 != 0,"src/loader.c",340,"0");
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_load_alias(yaml_parser_t *parser, yaml_event_t *event,
                                  struct loader_ctx *ctx)
{
  int __retres;
  yaml_alias_data_t *alias_data;
  int tmp_1;
  yaml_char_t *anchor = event->data.alias.anchor;
  alias_data = parser->aliases.start;
  while (alias_data != parser->aliases.top) {
    {
      int tmp_0;
      tmp_0 = strcmp((char const *)alias_data->anchor,(char const *)anchor);
      if (tmp_0 == 0) {
        int tmp;
        yaml_free((void *)anchor);
        tmp = yaml_parser_load_node_add(parser,ctx,alias_data->index);
        __retres = tmp;
        goto return_label;
      }
    }
    alias_data ++;
  }
  yaml_free((void *)anchor);
  tmp_1 = yaml_parser_set_composer_error(parser,"found undefined alias",
                                         event->start_mark);
  __retres = tmp_1;
  return_label: return __retres;
}

static int yaml_parser_load_scalar(yaml_parser_t *parser,
                                   yaml_event_t *event,
                                   struct loader_ctx *ctx)
{
  int __retres;
  yaml_node_t node;
  int index_0;
  int tmp;
  int tmp_3;
  int tmp_4;
  int tmp_5;
  yaml_char_t *tag = event->data.scalar.tag;
  if ((parser->document)->nodes.top - (parser->document)->nodes.start < (long)(
      2147483647 - 1)) tmp = 1;
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp = 0;
  }
  if (! tmp) goto error;
  if (! tag) goto _LOR;
  else {
    int tmp_0;
    tmp_0 = strcmp((char const *)tag,"!");
    if (tmp_0 == 0) {
      _LOR:
      {
        yaml_free((void *)tag);
        tag = yaml_strdup((yaml_char_t const *)"tag:yaml.org,2002:str");
        if (! tag) goto error;
      }
    }
  }
  memset((void *)(& node),0,sizeof(yaml_node_t));
  node.type = YAML_SCALAR_NODE;
  node.tag = tag;
  node.start_mark = event->start_mark;
  node.end_mark = event->end_mark;
  node.data.scalar.value = event->data.scalar.value;
  node.data.scalar.length = event->data.scalar.length;
  node.data.scalar.style = event->data.scalar.style;
  if ((parser->document)->nodes.top != (parser->document)->nodes.end) 
    goto _LOR_0;
  else {
    int tmp_1;
    tmp_1 = yaml_stack_extend((void **)(& (parser->document)->nodes.start),
                              (void **)(& (parser->document)->nodes.top),
                              (void **)(& (parser->document)->nodes.end));
    if (tmp_1) {
      yaml_node_t *tmp_2;
      _LOR_0: tmp_2 = (parser->document)->nodes.top;
      ((parser->document)->nodes.top) ++;
      *tmp_2 = node;
      tmp_3 = 1;
    }
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp_3 = 0;
    }
  }
  if (! tmp_3) goto error;
  index_0 = (int)((parser->document)->nodes.top - (parser->document)->nodes.start);
  tmp_4 = yaml_parser_register_anchor(parser,index_0,
                                      event->data.scalar.anchor);
  if (! tmp_4) {
    __retres = 0;
    goto return_label;
  }
  tmp_5 = yaml_parser_load_node_add(parser,ctx,index_0);
  __retres = tmp_5;
  goto return_label;
  error: yaml_free((void *)tag);
  yaml_free((void *)event->data.scalar.anchor);
  yaml_free((void *)event->data.scalar.value);
  __retres = 0;
  return_label: return __retres;
}

static int yaml_parser_load_sequence(yaml_parser_t *parser,
                                     yaml_event_t *event,
                                     struct loader_ctx *ctx)
{
  int __retres;
  yaml_node_t node;
  int index_0;
  int tmp;
  int tmp_2;
  int tmp_5;
  int tmp_6;
  int tmp_7;
  int tmp_8;
  int tmp_11;
  struct __anonstruct_items_49 items =
    {.start = (yaml_node_item_t *)0,
     .end = (yaml_node_item_t *)0,
     .top = (yaml_node_item_t *)0};
  yaml_char_t *tag = event->data.sequence_start.tag;
  if ((parser->document)->nodes.top - (parser->document)->nodes.start < (long)(
      2147483647 - 1)) tmp = 1;
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp = 0;
  }
  if (! tmp) goto error;
  if (! tag) goto _LOR;
  else {
    int tmp_0;
    tmp_0 = strcmp((char const *)tag,"!");
    if (tmp_0 == 0) {
      _LOR:
      {
        yaml_free((void *)tag);
        tag = yaml_strdup((yaml_char_t const *)"tag:yaml.org,2002:seq");
        if (! tag) goto error;
      }
    }
  }
  items.start = (yaml_node_item_t *)yaml_malloc((unsigned long)16 * sizeof(*(items.start)));
  if (items.start) {
    items.top = items.start;
    items.end = items.start + 16;
    tmp_2 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_2 = 0;
  }
  if (! tmp_2) goto error;
  memset((void *)(& node),0,sizeof(yaml_node_t));
  node.type = YAML_SEQUENCE_NODE;
  node.tag = tag;
  node.start_mark = event->start_mark;
  node.end_mark = event->end_mark;
  node.data.sequence.items.start = items.start;
  node.data.sequence.items.end = items.end;
  node.data.sequence.items.top = items.start;
  node.data.sequence.style = event->data.sequence_start.style;
  if ((parser->document)->nodes.top != (parser->document)->nodes.end) 
    goto _LOR_0;
  else {
    int tmp_3;
    tmp_3 = yaml_stack_extend((void **)(& (parser->document)->nodes.start),
                              (void **)(& (parser->document)->nodes.top),
                              (void **)(& (parser->document)->nodes.end));
    if (tmp_3) {
      yaml_node_t *tmp_4;
      _LOR_0: tmp_4 = (parser->document)->nodes.top;
      ((parser->document)->nodes.top) ++;
      *tmp_4 = node;
      tmp_5 = 1;
    }
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp_5 = 0;
    }
  }
  if (! tmp_5) goto error;
  index_0 = (int)((parser->document)->nodes.top - (parser->document)->nodes.start);
  tmp_6 = yaml_parser_register_anchor(parser,index_0,
                                      event->data.sequence_start.anchor);
  if (! tmp_6) {
    __retres = 0;
    goto return_label;
  }
  tmp_7 = yaml_parser_load_node_add(parser,ctx,index_0);
  if (! tmp_7) {
    __retres = 0;
    goto return_label;
  }
  if (ctx->top - ctx->start < (long)(2147483647 - 1)) tmp_8 = 1;
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_8 = 0;
  }
  if (! tmp_8) {
    __retres = 0;
    goto return_label;
  }
  if (ctx->top != ctx->end) goto _LOR_1;
  else {
    int tmp_9;
    tmp_9 = yaml_stack_extend((void **)(& ctx->start),(void **)(& ctx->top),
                              (void **)(& ctx->end));
    if (tmp_9) {
      int *tmp_10;
      _LOR_1: tmp_10 = ctx->top;
      (ctx->top) ++;
      *tmp_10 = index_0;
      tmp_11 = 1;
    }
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp_11 = 0;
    }
  }
  if (! tmp_11) {
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  goto return_label;
  error: yaml_free((void *)tag);
  yaml_free((void *)event->data.sequence_start.anchor);
  __retres = 0;
  return_label: return __retres;
}

static int yaml_parser_load_sequence_end(yaml_parser_t *parser,
                                         yaml_event_t *event,
                                         struct loader_ctx *ctx)
{
  int __retres;
  int index_0;
  __FC_assert((ctx->top - ctx->start > (long)0) != 0,"src/loader.c",467,
              "((*ctx).top - (*ctx).start) > 0");
  index_0 = *(ctx->top - 1);
  __FC_assert((((parser->document)->nodes.start + (index_0 - 1))->type == (unsigned int)YAML_SEQUENCE_NODE) != 0,
              "src/loader.c",470,
              "parser->document->nodes.start[index-1].type == YAML_SEQUENCE_NODE");
  ((parser->document)->nodes.start + (index_0 - 1))->end_mark = event->end_mark;
  (ctx->top) --;
  ;
  __retres = 1;
  return __retres;
}

static int yaml_parser_load_mapping(yaml_parser_t *parser,
                                    yaml_event_t *event,
                                    struct loader_ctx *ctx)
{
  int __retres;
  yaml_node_t node;
  int index_0;
  int tmp;
  int tmp_2;
  int tmp_5;
  int tmp_6;
  int tmp_7;
  int tmp_8;
  int tmp_11;
  struct __anonstruct_pairs_50 pairs =
    {.start = (yaml_node_pair_t *)0,
     .end = (yaml_node_pair_t *)0,
     .top = (yaml_node_pair_t *)0};
  yaml_char_t *tag = event->data.mapping_start.tag;
  if ((parser->document)->nodes.top - (parser->document)->nodes.start < (long)(
      2147483647 - 1)) tmp = 1;
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp = 0;
  }
  if (! tmp) goto error;
  if (! tag) goto _LOR;
  else {
    int tmp_0;
    tmp_0 = strcmp((char const *)tag,"!");
    if (tmp_0 == 0) {
      _LOR:
      {
        yaml_free((void *)tag);
        tag = yaml_strdup((yaml_char_t const *)"tag:yaml.org,2002:map");
        if (! tag) goto error;
      }
    }
  }
  pairs.start = (yaml_node_pair_t *)yaml_malloc((unsigned long)16 * sizeof(*(pairs.start)));
  if (pairs.start) {
    pairs.top = pairs.start;
    pairs.end = pairs.start + 16;
    tmp_2 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_2 = 0;
  }
  if (! tmp_2) goto error;
  memset((void *)(& node),0,sizeof(yaml_node_t));
  node.type = YAML_MAPPING_NODE;
  node.tag = tag;
  node.start_mark = event->start_mark;
  node.end_mark = event->end_mark;
  node.data.mapping.pairs.start = pairs.start;
  node.data.mapping.pairs.end = pairs.end;
  node.data.mapping.pairs.top = pairs.start;
  node.data.mapping.style = event->data.mapping_start.style;
  if ((parser->document)->nodes.top != (parser->document)->nodes.end) 
    goto _LOR_0;
  else {
    int tmp_3;
    tmp_3 = yaml_stack_extend((void **)(& (parser->document)->nodes.start),
                              (void **)(& (parser->document)->nodes.top),
                              (void **)(& (parser->document)->nodes.end));
    if (tmp_3) {
      yaml_node_t *tmp_4;
      _LOR_0: tmp_4 = (parser->document)->nodes.top;
      ((parser->document)->nodes.top) ++;
      *tmp_4 = node;
      tmp_5 = 1;
    }
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp_5 = 0;
    }
  }
  if (! tmp_5) goto error;
  index_0 = (int)((parser->document)->nodes.top - (parser->document)->nodes.start);
  tmp_6 = yaml_parser_register_anchor(parser,index_0,
                                      event->data.mapping_start.anchor);
  if (! tmp_6) {
    __retres = 0;
    goto return_label;
  }
  tmp_7 = yaml_parser_load_node_add(parser,ctx,index_0);
  if (! tmp_7) {
    __retres = 0;
    goto return_label;
  }
  if (ctx->top - ctx->start < (long)(2147483647 - 1)) tmp_8 = 1;
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_8 = 0;
  }
  if (! tmp_8) {
    __retres = 0;
    goto return_label;
  }
  if (ctx->top != ctx->end) goto _LOR_1;
  else {
    int tmp_9;
    tmp_9 = yaml_stack_extend((void **)(& ctx->start),(void **)(& ctx->top),
                              (void **)(& ctx->end));
    if (tmp_9) {
      int *tmp_10;
      _LOR_1: tmp_10 = ctx->top;
      (ctx->top) ++;
      *tmp_10 = index_0;
      tmp_11 = 1;
    }
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp_11 = 0;
    }
  }
  if (! tmp_11) {
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  goto return_label;
  error: yaml_free((void *)tag);
  yaml_free((void *)event->data.mapping_start.anchor);
  __retres = 0;
  return_label: return __retres;
}

static int yaml_parser_load_mapping_end(yaml_parser_t *parser,
                                        yaml_event_t *event,
                                        struct loader_ctx *ctx)
{
  int __retres;
  int index_0;
  __FC_assert((ctx->top - ctx->start > (long)0) != 0,"src/loader.c",535,
              "((*ctx).top - (*ctx).start) > 0");
  index_0 = *(ctx->top - 1);
  __FC_assert((((parser->document)->nodes.start + (index_0 - 1))->type == (unsigned int)YAML_MAPPING_NODE) != 0,
              "src/loader.c",538,
              "parser->document->nodes.start[index-1].type == YAML_MAPPING_NODE");
  ((parser->document)->nodes.start + (index_0 - 1))->end_mark = event->end_mark;
  (ctx->top) --;
  ;
  __retres = 1;
  return __retres;
}

static int yaml_parser_set_parser_error(yaml_parser_t *parser,
                                        char const *problem,
                                        yaml_mark_t problem_mark);

static int yaml_parser_set_parser_error_context(yaml_parser_t *parser,
                                                char const *context,
                                                yaml_mark_t context_mark,
                                                char const *problem,
                                                yaml_mark_t problem_mark);

static int yaml_parser_state_machine(yaml_parser_t *parser,
                                     yaml_event_t *event);

static int yaml_parser_parse_stream_start(yaml_parser_t *parser,
                                          yaml_event_t *event);

static int yaml_parser_parse_document_start(yaml_parser_t *parser,
                                            yaml_event_t *event, int implicit);

static int yaml_parser_parse_document_content(yaml_parser_t *parser,
                                              yaml_event_t *event);

static int yaml_parser_parse_document_end(yaml_parser_t *parser,
                                          yaml_event_t *event);

static int yaml_parser_parse_node(yaml_parser_t *parser, yaml_event_t *event,
                                  int block, int indentless_sequence);

static int yaml_parser_parse_block_sequence_entry(yaml_parser_t *parser,
                                                  yaml_event_t *event,
                                                  int first);

static int yaml_parser_parse_indentless_sequence_entry(yaml_parser_t *parser,
                                                       yaml_event_t *event);

static int yaml_parser_parse_block_mapping_key(yaml_parser_t *parser,
                                               yaml_event_t *event, int first);

static int yaml_parser_parse_block_mapping_value(yaml_parser_t *parser,
                                                 yaml_event_t *event);

static int yaml_parser_parse_flow_sequence_entry(yaml_parser_t *parser,
                                                 yaml_event_t *event,
                                                 int first);

static int yaml_parser_parse_flow_sequence_entry_mapping_key(yaml_parser_t *parser,
                                                             yaml_event_t *event);

static int yaml_parser_parse_flow_sequence_entry_mapping_value(yaml_parser_t *parser,
                                                               yaml_event_t *event);

static int yaml_parser_parse_flow_sequence_entry_mapping_end(yaml_parser_t *parser,
                                                             yaml_event_t *event);

static int yaml_parser_parse_flow_mapping_key(yaml_parser_t *parser,
                                              yaml_event_t *event, int first);

static int yaml_parser_parse_flow_mapping_value(yaml_parser_t *parser,
                                                yaml_event_t *event,
                                                int empty);

static int yaml_parser_process_empty_scalar(yaml_parser_t *parser,
                                            yaml_event_t *event,
                                            yaml_mark_t mark);

static int yaml_parser_process_directives(yaml_parser_t *parser,
                                          yaml_version_directive_t **version_directive_ref,
                                          yaml_tag_directive_t **tag_directives_start_ref,
                                          yaml_tag_directive_t **tag_directives_end_ref);

static int yaml_parser_append_tag_directive(yaml_parser_t *parser,
                                            yaml_tag_directive_t value,
                                            int allow_duplicates,
                                            yaml_mark_t mark);

int yaml_parser_parse(yaml_parser_t *parser, yaml_event_t *event)
{
  int __retres;
  int tmp;
  __FC_assert(parser != (yaml_parser_t *)0,"src/parser.c",172,"parser");
  __FC_assert(event != (yaml_event_t *)0,"src/parser.c",173,"event");
  memset((void *)event,0,sizeof(yaml_event_t));
  if (parser->stream_end_produced) goto _LOR;
  else 
    if (parser->error) goto _LOR;
    else 
      if (parser->state == (unsigned int)YAML_PARSE_END_STATE) {
        _LOR: {
                __retres = 1;
                goto return_label;
              }
      }
  tmp = yaml_parser_state_machine(parser,event);
  __retres = tmp;
  return_label: return __retres;
}

static int yaml_parser_set_parser_error(yaml_parser_t *parser,
                                        char const *problem,
                                        yaml_mark_t problem_mark)
{
  int __retres;
  parser->error = YAML_PARSER_ERROR;
  parser->problem = problem;
  parser->problem_mark = problem_mark;
  __retres = 0;
  return __retres;
}

static int yaml_parser_set_parser_error_context(yaml_parser_t *parser,
                                                char const *context,
                                                yaml_mark_t context_mark,
                                                char const *problem,
                                                yaml_mark_t problem_mark)
{
  int __retres;
  parser->error = YAML_PARSER_ERROR;
  parser->context = context;
  parser->context_mark = context_mark;
  parser->problem = problem;
  parser->problem_mark = problem_mark;
  __retres = 0;
  return __retres;
}

static int yaml_parser_state_machine(yaml_parser_t *parser,
                                     yaml_event_t *event)
{
  int __retres;
  switch (parser->state) {
    int tmp;
    int tmp_0;
    int tmp_1;
    int tmp_2;
    int tmp_3;
    int tmp_4;
    int tmp_5;
    int tmp_6;
    int tmp_7;
    int tmp_8;
    int tmp_9;
    int tmp_10;
    int tmp_11;
    int tmp_12;
    int tmp_13;
    int tmp_14;
    int tmp_15;
    int tmp_16;
    int tmp_17;
    int tmp_18;
    int tmp_19;
    int tmp_20;
    int tmp_21;
    case YAML_PARSE_STREAM_START_STATE:
    tmp = yaml_parser_parse_stream_start(parser,event);
    __retres = tmp;
    goto return_label;
    case YAML_PARSE_IMPLICIT_DOCUMENT_START_STATE:
    tmp_0 = yaml_parser_parse_document_start(parser,event,1);
    __retres = tmp_0;
    goto return_label;
    case YAML_PARSE_DOCUMENT_START_STATE:
    tmp_1 = yaml_parser_parse_document_start(parser,event,0);
    __retres = tmp_1;
    goto return_label;
    case YAML_PARSE_DOCUMENT_CONTENT_STATE:
    tmp_2 = yaml_parser_parse_document_content(parser,event);
    __retres = tmp_2;
    goto return_label;
    case YAML_PARSE_DOCUMENT_END_STATE:
    tmp_3 = yaml_parser_parse_document_end(parser,event);
    __retres = tmp_3;
    goto return_label;
    case YAML_PARSE_BLOCK_NODE_STATE:
    tmp_4 = yaml_parser_parse_node(parser,event,1,0);
    __retres = tmp_4;
    goto return_label;
    case YAML_PARSE_BLOCK_NODE_OR_INDENTLESS_SEQUENCE_STATE:
    tmp_5 = yaml_parser_parse_node(parser,event,1,1);
    __retres = tmp_5;
    goto return_label;
    case YAML_PARSE_FLOW_NODE_STATE:
    tmp_6 = yaml_parser_parse_node(parser,event,0,0);
    __retres = tmp_6;
    goto return_label;
    case YAML_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE:
    tmp_7 = yaml_parser_parse_block_sequence_entry(parser,event,1);
    __retres = tmp_7;
    goto return_label;
    case YAML_PARSE_BLOCK_SEQUENCE_ENTRY_STATE:
    tmp_8 = yaml_parser_parse_block_sequence_entry(parser,event,0);
    __retres = tmp_8;
    goto return_label;
    case YAML_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE:
    tmp_9 = yaml_parser_parse_indentless_sequence_entry(parser,event);
    __retres = tmp_9;
    goto return_label;
    case YAML_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE:
    tmp_10 = yaml_parser_parse_block_mapping_key(parser,event,1);
    __retres = tmp_10;
    goto return_label;
    case YAML_PARSE_BLOCK_MAPPING_KEY_STATE:
    tmp_11 = yaml_parser_parse_block_mapping_key(parser,event,0);
    __retres = tmp_11;
    goto return_label;
    case YAML_PARSE_BLOCK_MAPPING_VALUE_STATE:
    tmp_12 = yaml_parser_parse_block_mapping_value(parser,event);
    __retres = tmp_12;
    goto return_label;
    case YAML_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE:
    tmp_13 = yaml_parser_parse_flow_sequence_entry(parser,event,1);
    __retres = tmp_13;
    goto return_label;
    case YAML_PARSE_FLOW_SEQUENCE_ENTRY_STATE:
    tmp_14 = yaml_parser_parse_flow_sequence_entry(parser,event,0);
    __retres = tmp_14;
    goto return_label;
    case YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE:
    tmp_15 = yaml_parser_parse_flow_sequence_entry_mapping_key(parser,event);
    __retres = tmp_15;
    goto return_label;
    case YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE:
    tmp_16 = yaml_parser_parse_flow_sequence_entry_mapping_value(parser,
                                                                 event);
    __retres = tmp_16;
    goto return_label;
    case YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE:
    tmp_17 = yaml_parser_parse_flow_sequence_entry_mapping_end(parser,event);
    __retres = tmp_17;
    goto return_label;
    case YAML_PARSE_FLOW_MAPPING_FIRST_KEY_STATE:
    tmp_18 = yaml_parser_parse_flow_mapping_key(parser,event,1);
    __retres = tmp_18;
    goto return_label;
    case YAML_PARSE_FLOW_MAPPING_KEY_STATE:
    tmp_19 = yaml_parser_parse_flow_mapping_key(parser,event,0);
    __retres = tmp_19;
    goto return_label;
    case YAML_PARSE_FLOW_MAPPING_VALUE_STATE:
    tmp_20 = yaml_parser_parse_flow_mapping_value(parser,event,0);
    __retres = tmp_20;
    goto return_label;
    case YAML_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE:
    tmp_21 = yaml_parser_parse_flow_mapping_value(parser,event,1);
    __retres = tmp_21;
    goto return_label;
    default: __FC_assert(1 != 0,"src/parser.c",300,"1");
  }
  __retres = 0;
  return_label: return __retres;
}

static int yaml_parser_parse_stream_start(yaml_parser_t *parser,
                                          yaml_event_t *event)
{
  int __retres;
  yaml_token_t *token;
  if (parser->token_available) token = parser->tokens.head;
  else {
    int tmp;
    tmp = yaml_parser_fetch_more_tokens(parser);
    if (tmp) token = parser->tokens.head; else token = (yaml_token_t *)0;
  }
  if (! token) {
    __retres = 0;
    goto return_label;
  }
  if (token->type != (unsigned int)YAML_STREAM_START_TOKEN) {
    int tmp_0;
    tmp_0 = yaml_parser_set_parser_error(parser,
                                         "did not find expected <stream-start>",
                                         token->start_mark);
    __retres = tmp_0;
    goto return_label;
  }
  parser->state = YAML_PARSE_IMPLICIT_DOCUMENT_START_STATE;
  memset((void *)event,0,sizeof(yaml_event_t));
  event->type = YAML_STREAM_START_EVENT;
  event->start_mark = token->start_mark;
  event->end_mark = token->start_mark;
  event->data.stream_start.encoding = token->data.stream_start.encoding;
  parser->token_available = 0;
  (parser->tokens_parsed) ++;
  parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
  (parser->tokens.head) ++;
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_parse_document_start(yaml_parser_t *parser,
                                            yaml_event_t *event, int implicit)
{
  int __retres;
  yaml_token_t *token;
  yaml_version_directive_t *version_directive =
    (yaml_version_directive_t *)0;
  struct __anonstruct_tag_directives_49 tag_directives =
    {.start = (yaml_tag_directive_t *)0, .end = (yaml_tag_directive_t *)0};
  if (parser->token_available) token = parser->tokens.head;
  else {
    int tmp;
    tmp = yaml_parser_fetch_more_tokens(parser);
    if (tmp) token = parser->tokens.head; else token = (yaml_token_t *)0;
  }
  if (! token) {
    __retres = 0;
    goto return_label;
  }
  if (! implicit) 
    while (token->type == (unsigned int)YAML_DOCUMENT_END_TOKEN) {
      parser->token_available = 0;
      (parser->tokens_parsed) ++;
      parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
      (parser->tokens.head) ++;
      if (parser->token_available) token = parser->tokens.head;
      else {
        int tmp_0;
        tmp_0 = yaml_parser_fetch_more_tokens(parser);
        if (tmp_0) token = parser->tokens.head;
        else token = (yaml_token_t *)0;
      }
      if (! token) {
        __retres = 0;
        goto return_label;
      }
    }
  if (implicit) {
    if (token->type != (unsigned int)YAML_VERSION_DIRECTIVE_TOKEN) {
      if (token->type != (unsigned int)YAML_TAG_DIRECTIVE_TOKEN) {
        if (token->type != (unsigned int)YAML_DOCUMENT_START_TOKEN) {
          if (token->type != (unsigned int)YAML_STREAM_END_TOKEN) {
            int tmp_1;
            int tmp_4;
            tmp_1 = yaml_parser_process_directives(parser,
                                                   (yaml_version_directive_t **)0,
                                                   (yaml_tag_directive_t **)0,
                                                   (yaml_tag_directive_t **)0);
            if (! tmp_1) {
              __retres = 0;
              goto return_label;
            }
            if (parser->states.top != parser->states.end) goto _LOR;
            else {
              int tmp_2;
              tmp_2 = yaml_stack_extend((void **)(& parser->states.start),
                                        (void **)(& parser->states.top),
                                        (void **)(& parser->states.end));
              if (tmp_2) {
                yaml_parser_state_t *tmp_3;
                _LOR: tmp_3 = parser->states.top;
                (parser->states.top) ++;
                *tmp_3 = YAML_PARSE_DOCUMENT_END_STATE;
                tmp_4 = 1;
              }
              else {
                parser->error = YAML_MEMORY_ERROR;
                tmp_4 = 0;
              }
            }
            if (! tmp_4) {
              __retres = 0;
              goto return_label;
            }
            parser->state = YAML_PARSE_BLOCK_NODE_STATE;
            memset((void *)event,0,sizeof(yaml_event_t));
            event->type = YAML_DOCUMENT_START_EVENT;
            event->start_mark = token->start_mark;
            event->end_mark = token->start_mark;
            event->data.document_start.version_directive = (yaml_version_directive_t *)0;
            event->data.document_start.tag_directives.start = (yaml_tag_directive_t *)0;
            event->data.document_start.tag_directives.end = (yaml_tag_directive_t *)0;
            event->data.document_start.implicit = 1;
            __retres = 1;
            goto return_label;
          }
          else goto _LAND_2;
        }
        else goto _LAND_2;
      }
      else goto _LAND_2;
    }
    else goto _LAND_2;
  }
  else {
    _LAND_2: ;
    if (token->type != (unsigned int)YAML_STREAM_END_TOKEN) {
      yaml_mark_t start_mark;
      yaml_mark_t end_mark;
      int tmp_5;
      int tmp_9;
      start_mark = token->start_mark;
      tmp_5 = yaml_parser_process_directives(parser,& version_directive,
                                             & tag_directives.start,
                                             & tag_directives.end);
      if (! tmp_5) {
        __retres = 0;
        goto return_label;
      }
      if (parser->token_available) token = parser->tokens.head;
      else {
        int tmp_6;
        tmp_6 = yaml_parser_fetch_more_tokens(parser);
        if (tmp_6) token = parser->tokens.head;
        else token = (yaml_token_t *)0;
      }
      if (! token) goto error;
      if (token->type != (unsigned int)YAML_DOCUMENT_START_TOKEN) {
        yaml_parser_set_parser_error(parser,
                                     "did not find expected <document start>",
                                     token->start_mark);
        goto error;
      }
      if (parser->states.top != parser->states.end) goto _LOR_0;
      else {
        int tmp_7;
        tmp_7 = yaml_stack_extend((void **)(& parser->states.start),
                                  (void **)(& parser->states.top),
                                  (void **)(& parser->states.end));
        if (tmp_7) {
          yaml_parser_state_t *tmp_8;
          _LOR_0: tmp_8 = parser->states.top;
          (parser->states.top) ++;
          *tmp_8 = YAML_PARSE_DOCUMENT_END_STATE;
          tmp_9 = 1;
        }
        else {
          parser->error = YAML_MEMORY_ERROR;
          tmp_9 = 0;
        }
      }
      if (! tmp_9) goto error;
      parser->state = YAML_PARSE_DOCUMENT_CONTENT_STATE;
      end_mark = token->end_mark;
      memset((void *)event,0,sizeof(yaml_event_t));
      event->type = YAML_DOCUMENT_START_EVENT;
      event->start_mark = start_mark;
      event->end_mark = end_mark;
      event->data.document_start.version_directive = version_directive;
      event->data.document_start.tag_directives.start = tag_directives.start;
      event->data.document_start.tag_directives.end = tag_directives.end;
      event->data.document_start.implicit = 0;
      parser->token_available = 0;
      (parser->tokens_parsed) ++;
      parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
      (parser->tokens.head) ++;
      version_directive = (yaml_version_directive_t *)0;
      tag_directives.end = (yaml_tag_directive_t *)0;
      tag_directives.start = tag_directives.end;
      __retres = 1;
      goto return_label;
    }
    else {
      parser->state = YAML_PARSE_END_STATE;
      memset((void *)event,0,sizeof(yaml_event_t));
      event->type = YAML_STREAM_END_EVENT;
      event->start_mark = token->start_mark;
      event->end_mark = token->end_mark;
      parser->token_available = 0;
      (parser->tokens_parsed) ++;
      parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
      (parser->tokens.head) ++;
      __retres = 1;
      goto return_label;
    }
  }
  error: yaml_free((void *)version_directive);
  while (tag_directives.start != tag_directives.end) {
    yaml_free((void *)(tag_directives.end + -1)->handle);
    yaml_free((void *)(tag_directives.end + -1)->prefix);
    (tag_directives.end) --;
  }
  yaml_free((void *)tag_directives.start);
  __retres = 0;
  return_label: return __retres;
}

static int yaml_parser_parse_document_content(yaml_parser_t *parser,
                                              yaml_event_t *event)
{
  int __retres;
  yaml_token_t *token;
  if (parser->token_available) token = parser->tokens.head;
  else {
    int tmp;
    tmp = yaml_parser_fetch_more_tokens(parser);
    if (tmp) token = parser->tokens.head; else token = (yaml_token_t *)0;
  }
  if (! token) {
    __retres = 0;
    goto return_label;
  }
  if (token->type == (unsigned int)YAML_VERSION_DIRECTIVE_TOKEN) goto _LOR;
  else 
    if (token->type == (unsigned int)YAML_TAG_DIRECTIVE_TOKEN) goto _LOR;
    else 
      if (token->type == (unsigned int)YAML_DOCUMENT_START_TOKEN) goto _LOR;
      else 
        if (token->type == (unsigned int)YAML_DOCUMENT_END_TOKEN) goto _LOR;
        else 
          if (token->type == (unsigned int)YAML_STREAM_END_TOKEN) {
            _LOR:
            {
              int tmp_0;
              (parser->states.top) --;
              parser->state = *(parser->states.top);
              tmp_0 = yaml_parser_process_empty_scalar(parser,event,
                                                       token->start_mark);
              __retres = tmp_0;
              goto return_label;
            }
          }
          else {
            int tmp_1;
            tmp_1 = yaml_parser_parse_node(parser,event,1,0);
            __retres = tmp_1;
            goto return_label;
          }
  return_label: return __retres;
}

static int yaml_parser_parse_document_end(yaml_parser_t *parser,
                                          yaml_event_t *event)
{
  int __retres;
  yaml_token_t *token;
  yaml_mark_t start_mark;
  yaml_mark_t end_mark;
  int implicit = 1;
  if (parser->token_available) token = parser->tokens.head;
  else {
    int tmp;
    tmp = yaml_parser_fetch_more_tokens(parser);
    if (tmp) token = parser->tokens.head; else token = (yaml_token_t *)0;
  }
  if (! token) {
    __retres = 0;
    goto return_label;
  }
  end_mark = token->start_mark;
  start_mark = end_mark;
  if (token->type == (unsigned int)YAML_DOCUMENT_END_TOKEN) {
    end_mark = token->end_mark;
    parser->token_available = 0;
    (parser->tokens_parsed) ++;
    parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
    (parser->tokens.head) ++;
    implicit = 0;
  }
  while (! (parser->tag_directives.start == parser->tag_directives.top)) {
    (parser->tag_directives.top) --;
    yaml_tag_directive_t tag_directive = *(parser->tag_directives.top);
    yaml_free((void *)tag_directive.handle);
    yaml_free((void *)tag_directive.prefix);
  }
  parser->state = YAML_PARSE_DOCUMENT_START_STATE;
  memset((void *)event,0,sizeof(yaml_event_t));
  event->type = YAML_DOCUMENT_END_EVENT;
  event->start_mark = start_mark;
  event->end_mark = end_mark;
  event->data.document_end.implicit = implicit;
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_parse_node(yaml_parser_t *parser, yaml_event_t *event,
                                  int block, int indentless_sequence)
{
  int __retres;
  yaml_token_t *token;
  yaml_mark_t start_mark;
  yaml_mark_t end_mark;
  yaml_mark_t tag_mark;
  int implicit;
  yaml_char_t *anchor = (yaml_char_t *)0;
  yaml_char_t *tag_handle = (yaml_char_t *)0;
  yaml_char_t *tag_suffix = (yaml_char_t *)0;
  yaml_char_t *tag = (yaml_char_t *)0;
  if (parser->token_available) token = parser->tokens.head;
  else {
    int tmp;
    tmp = yaml_parser_fetch_more_tokens(parser);
    if (tmp) token = parser->tokens.head; else token = (yaml_token_t *)0;
  }
  if (! token) {
    __retres = 0;
    goto return_label;
  }
  if (token->type == (unsigned int)YAML_ALIAS_TOKEN) {
    (parser->states.top) --;
    parser->state = *(parser->states.top);
    memset((void *)event,0,sizeof(yaml_event_t));
    event->type = YAML_ALIAS_EVENT;
    event->start_mark = token->start_mark;
    event->end_mark = token->end_mark;
    event->data.alias.anchor = token->data.alias.value;
    parser->token_available = 0;
    (parser->tokens_parsed) ++;
    parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
    (parser->tokens.head) ++;
    __retres = 1;
    goto return_label;
  }
  else {
    int tmp_8;
    end_mark = token->start_mark;
    start_mark = end_mark;
    if (token->type == (unsigned int)YAML_ANCHOR_TOKEN) {
      anchor = token->data.anchor.value;
      start_mark = token->start_mark;
      end_mark = token->end_mark;
      parser->token_available = 0;
      (parser->tokens_parsed) ++;
      parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
      (parser->tokens.head) ++;
      if (parser->token_available) token = parser->tokens.head;
      else {
        int tmp_0;
        tmp_0 = yaml_parser_fetch_more_tokens(parser);
        if (tmp_0) token = parser->tokens.head;
        else token = (yaml_token_t *)0;
      }
      if (! token) goto error;
      if (token->type == (unsigned int)YAML_TAG_TOKEN) {
        tag_handle = token->data.tag.handle;
        tag_suffix = token->data.tag.suffix;
        tag_mark = token->start_mark;
        end_mark = token->end_mark;
        parser->token_available = 0;
        (parser->tokens_parsed) ++;
        parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
        (parser->tokens.head) ++;
        if (parser->token_available) token = parser->tokens.head;
        else {
          int tmp_1;
          tmp_1 = yaml_parser_fetch_more_tokens(parser);
          if (tmp_1) token = parser->tokens.head;
          else token = (yaml_token_t *)0;
        }
        if (! token) goto error;
      }
    }
    else 
      if (token->type == (unsigned int)YAML_TAG_TOKEN) {
        tag_handle = token->data.tag.handle;
        tag_suffix = token->data.tag.suffix;
        tag_mark = token->start_mark;
        start_mark = tag_mark;
        end_mark = token->end_mark;
        parser->token_available = 0;
        (parser->tokens_parsed) ++;
        parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
        (parser->tokens.head) ++;
        if (parser->token_available) token = parser->tokens.head;
        else {
          int tmp_2;
          tmp_2 = yaml_parser_fetch_more_tokens(parser);
          if (tmp_2) token = parser->tokens.head;
          else token = (yaml_token_t *)0;
        }
        if (! token) goto error;
        if (token->type == (unsigned int)YAML_ANCHOR_TOKEN) {
          anchor = token->data.anchor.value;
          end_mark = token->end_mark;
          parser->token_available = 0;
          (parser->tokens_parsed) ++;
          parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
          (parser->tokens.head) ++;
          if (parser->token_available) token = parser->tokens.head;
          else {
            int tmp_3;
            tmp_3 = yaml_parser_fetch_more_tokens(parser);
            if (tmp_3) token = parser->tokens.head;
            else token = (yaml_token_t *)0;
          }
          if (! token) goto error;
        }
      }
    if (tag_handle) 
      if (! *tag_handle) {
        tag = tag_suffix;
        yaml_free((void *)tag_handle);
        tag_suffix = (yaml_char_t *)0;
        tag_handle = tag_suffix;
      }
      else {
        yaml_tag_directive_t *tag_directive;
        tag_directive = parser->tag_directives.start;
        while (tag_directive != parser->tag_directives.top) {
          {
            int tmp_7;
            tmp_7 = strcmp((char const *)tag_directive->handle,
                           (char const *)tag_handle);
            if (tmp_7 == 0) {
              size_t prefix_len =
                strlen((char const *)tag_directive->prefix);
              size_t suffix_len = strlen((char const *)tag_suffix);
              tag = (yaml_char_t *)yaml_malloc((prefix_len + suffix_len) + (size_t)1);
              if (! tag) {
                parser->error = YAML_MEMORY_ERROR;
                goto error;
              }
              memcpy((void *)tag,(void const *)tag_directive->prefix,
                     prefix_len);
              memcpy((void *)(tag + prefix_len),(void const *)tag_suffix,
                     suffix_len);
              *(tag + (prefix_len + suffix_len)) = (yaml_char_t)'\000';
              yaml_free((void *)tag_handle);
              yaml_free((void *)tag_suffix);
              tag_suffix = (yaml_char_t *)0;
              tag_handle = tag_suffix;
              break;
            }
          }
          tag_directive ++;
        }
        if (! tag) {
          yaml_parser_set_parser_error_context(parser,"while parsing a node",
                                               start_mark,
                                               "found undefined tag handle",
                                               tag_mark);
          goto error;
        }
      }
    if (! tag) tmp_8 = 1;
    else 
      if (! *tag) tmp_8 = 1; else tmp_8 = 0;
    implicit = tmp_8;
    if (indentless_sequence) {
      if (token->type == (unsigned int)YAML_BLOCK_ENTRY_TOKEN) {
        end_mark = token->end_mark;
        parser->state = YAML_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE;
        memset((void *)event,0,sizeof(yaml_event_t));
        event->type = YAML_SEQUENCE_START_EVENT;
        event->start_mark = start_mark;
        event->end_mark = end_mark;
        event->data.sequence_start.anchor = anchor;
        event->data.sequence_start.tag = tag;
        event->data.sequence_start.implicit = implicit;
        event->data.sequence_start.style = YAML_BLOCK_SEQUENCE_STYLE;
        __retres = 1;
        goto return_label;
      }
      else goto _LAND_3;
    }
    else 
      _LAND_3:
      if (token->type == (unsigned int)YAML_SCALAR_TOKEN) {
        int plain_implicit = 0;
        int quoted_implicit = 0;
        end_mark = token->end_mark;
        if (token->data.scalar.style == (unsigned int)YAML_PLAIN_SCALAR_STYLE) {
          if (! tag) goto _LOR; else goto _LAND_0;
        }
        else {
          _LAND_0: ;
          if (tag) {
            int tmp_9;
            tmp_9 = strcmp((char const *)tag,"!");
            if (tmp_9 == 0) _LOR: plain_implicit = 1; else goto _LAND;
          }
          else 
            _LAND: if (! tag) quoted_implicit = 1;
        }
        (parser->states.top) --;
        parser->state = *(parser->states.top);
        memset((void *)event,0,sizeof(yaml_event_t));
        event->type = YAML_SCALAR_EVENT;
        event->start_mark = start_mark;
        event->end_mark = end_mark;
        event->data.scalar.anchor = anchor;
        event->data.scalar.tag = tag;
        event->data.scalar.value = token->data.scalar.value;
        event->data.scalar.length = token->data.scalar.length;
        event->data.scalar.plain_implicit = plain_implicit;
        event->data.scalar.quoted_implicit = quoted_implicit;
        event->data.scalar.style = token->data.scalar.style;
        parser->token_available = 0;
        (parser->tokens_parsed) ++;
        parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
        (parser->tokens.head) ++;
        __retres = 1;
        goto return_label;
      }
      else 
        if (token->type == (unsigned int)YAML_FLOW_SEQUENCE_START_TOKEN) {
          end_mark = token->end_mark;
          parser->state = YAML_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE;
          memset((void *)event,0,sizeof(yaml_event_t));
          event->type = YAML_SEQUENCE_START_EVENT;
          event->start_mark = start_mark;
          event->end_mark = end_mark;
          event->data.sequence_start.anchor = anchor;
          event->data.sequence_start.tag = tag;
          event->data.sequence_start.implicit = implicit;
          event->data.sequence_start.style = YAML_FLOW_SEQUENCE_STYLE;
          __retres = 1;
          goto return_label;
        }
        else 
          if (token->type == (unsigned int)YAML_FLOW_MAPPING_START_TOKEN) {
            end_mark = token->end_mark;
            parser->state = YAML_PARSE_FLOW_MAPPING_FIRST_KEY_STATE;
            memset((void *)event,0,sizeof(yaml_event_t));
            event->type = YAML_MAPPING_START_EVENT;
            event->start_mark = start_mark;
            event->end_mark = end_mark;
            event->data.mapping_start.anchor = anchor;
            event->data.mapping_start.tag = tag;
            event->data.mapping_start.implicit = implicit;
            event->data.mapping_start.style = YAML_FLOW_MAPPING_STYLE;
            __retres = 1;
            goto return_label;
          }
          else 
            if (block) {
              if (token->type == (unsigned int)YAML_BLOCK_SEQUENCE_START_TOKEN) {
                end_mark = token->end_mark;
                parser->state = YAML_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE;
                memset((void *)event,0,sizeof(yaml_event_t));
                event->type = YAML_SEQUENCE_START_EVENT;
                event->start_mark = start_mark;
                event->end_mark = end_mark;
                event->data.sequence_start.anchor = anchor;
                event->data.sequence_start.tag = tag;
                event->data.sequence_start.implicit = implicit;
                event->data.sequence_start.style = YAML_BLOCK_SEQUENCE_STYLE;
                __retres = 1;
                goto return_label;
              }
              else goto _LAND_2;
            }
            else {
              _LAND_2: ;
              if (block) {
                if (token->type == (unsigned int)YAML_BLOCK_MAPPING_START_TOKEN) {
                  end_mark = token->end_mark;
                  parser->state = YAML_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE;
                  memset((void *)event,0,sizeof(yaml_event_t));
                  event->type = YAML_MAPPING_START_EVENT;
                  event->start_mark = start_mark;
                  event->end_mark = end_mark;
                  event->data.mapping_start.anchor = anchor;
                  event->data.mapping_start.tag = tag;
                  event->data.mapping_start.implicit = implicit;
                  event->data.mapping_start.style = YAML_BLOCK_MAPPING_STYLE;
                  __retres = 1;
                  goto return_label;
                }
                else goto _LAND_1;
              }
              else {
                _LAND_1: ;
                if (anchor) goto _LOR_0;
                else 
                  if (tag) {
                    _LOR_0:
                    {
                      yaml_char_t *value = yaml_malloc((size_t)1);
                      if (! value) {
                        parser->error = YAML_MEMORY_ERROR;
                        goto error;
                      }
                      *(value + 0) = (yaml_char_t)'\000';
                      (parser->states.top) --;
                      parser->state = *(parser->states.top);
                      memset((void *)event,0,sizeof(yaml_event_t));
                      event->type = YAML_SCALAR_EVENT;
                      event->start_mark = start_mark;
                      event->end_mark = end_mark;
                      event->data.scalar.anchor = anchor;
                      event->data.scalar.tag = tag;
                      event->data.scalar.value = value;
                      event->data.scalar.length = (size_t)0;
                      event->data.scalar.plain_implicit = implicit;
                      event->data.scalar.quoted_implicit = 0;
                      event->data.scalar.style = YAML_PLAIN_SCALAR_STYLE;
                      __retres = 1;
                      goto return_label;
                    }
                  }
                  else {
                    char const *tmp_11;
                    ;
                    ;
                    if (block) tmp_11 = "while parsing a block node";
                    else tmp_11 = "while parsing a flow node";
                    ;
                    yaml_parser_set_parser_error_context(parser,tmp_11,
                                                         start_mark,
                                                         "did not find expected node content",
                                                         token->start_mark);
                    goto error;
                  }
              }
            }
  }
  error: yaml_free((void *)anchor);
  yaml_free((void *)tag_handle);
  yaml_free((void *)tag_suffix);
  yaml_free((void *)tag);
  __retres = 0;
  return_label: return __retres;
}

static int yaml_parser_parse_block_sequence_entry(yaml_parser_t *parser,
                                                  yaml_event_t *event,
                                                  int first)
{
  int __retres;
  yaml_token_t *token;
  if (first) {
    int tmp_2;
    if (parser->token_available) token = parser->tokens.head;
    else {
      int tmp;
      tmp = yaml_parser_fetch_more_tokens(parser);
      if (tmp) token = parser->tokens.head; else token = (yaml_token_t *)0;
    }
    if (parser->marks.top != parser->marks.end) goto _LOR;
    else {
      int tmp_0;
      tmp_0 = yaml_stack_extend((void **)(& parser->marks.start),
                                (void **)(& parser->marks.top),
                                (void **)(& parser->marks.end));
      if (tmp_0) {
        yaml_mark_t *tmp_1;
        _LOR: tmp_1 = parser->marks.top;
        (parser->marks.top) ++;
        *tmp_1 = token->start_mark;
        tmp_2 = 1;
      }
      else {
        parser->error = YAML_MEMORY_ERROR;
        tmp_2 = 0;
      }
    }
    if (! tmp_2) {
      __retres = 0;
      goto return_label;
    }
    parser->token_available = 0;
    (parser->tokens_parsed) ++;
    parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
    (parser->tokens.head) ++;
  }
  if (parser->token_available) token = parser->tokens.head;
  else {
    int tmp_3;
    tmp_3 = yaml_parser_fetch_more_tokens(parser);
    if (tmp_3) token = parser->tokens.head; else token = (yaml_token_t *)0;
  }
  if (! token) {
    __retres = 0;
    goto return_label;
  }
  if (token->type == (unsigned int)YAML_BLOCK_ENTRY_TOKEN) {
    yaml_mark_t mark = token->end_mark;
    parser->token_available = 0;
    (parser->tokens_parsed) ++;
    parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
    (parser->tokens.head) ++;
    if (parser->token_available) token = parser->tokens.head;
    else {
      int tmp_4;
      tmp_4 = yaml_parser_fetch_more_tokens(parser);
      if (tmp_4) token = parser->tokens.head; else token = (yaml_token_t *)0;
    }
    if (! token) {
      __retres = 0;
      goto return_label;
    }
    if (token->type != (unsigned int)YAML_BLOCK_ENTRY_TOKEN) {
      if (token->type != (unsigned int)YAML_BLOCK_END_TOKEN) {
        int tmp_7;
        int tmp_8;
        if (parser->states.top != parser->states.end) goto _LOR_0;
        else {
          int tmp_5;
          tmp_5 = yaml_stack_extend((void **)(& parser->states.start),
                                    (void **)(& parser->states.top),
                                    (void **)(& parser->states.end));
          if (tmp_5) {
            yaml_parser_state_t *tmp_6;
            _LOR_0: tmp_6 = parser->states.top;
            (parser->states.top) ++;
            *tmp_6 = YAML_PARSE_BLOCK_SEQUENCE_ENTRY_STATE;
            tmp_7 = 1;
          }
          else {
            parser->error = YAML_MEMORY_ERROR;
            tmp_7 = 0;
          }
        }
        if (! tmp_7) {
          __retres = 0;
          goto return_label;
        }
        tmp_8 = yaml_parser_parse_node(parser,event,1,0);
        __retres = tmp_8;
        goto return_label;
      }
      else goto _LAND;
    }
    else {
      _LAND:
      {
        int tmp_9;
        parser->state = YAML_PARSE_BLOCK_SEQUENCE_ENTRY_STATE;
        tmp_9 = yaml_parser_process_empty_scalar(parser,event,mark);
        __retres = tmp_9;
        goto return_label;
      }
    }
  }
  else 
    if (token->type == (unsigned int)YAML_BLOCK_END_TOKEN) {
      (parser->states.top) --;
      parser->state = *(parser->states.top);
      (parser->marks.top) --;
      ;
      memset((void *)event,0,sizeof(yaml_event_t));
      event->type = YAML_SEQUENCE_END_EVENT;
      event->start_mark = token->start_mark;
      event->end_mark = token->end_mark;
      parser->token_available = 0;
      (parser->tokens_parsed) ++;
      parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
      (parser->tokens.head) ++;
      __retres = 1;
      goto return_label;
    }
    else {
      int tmp_10;
      ;
      (parser->marks.top) --;
      ;
      ;
      tmp_10 = yaml_parser_set_parser_error_context(parser,
                                                    "while parsing a block collection",
                                                    *(parser->marks.top),
                                                    "did not find expected \'-\' indicator",
                                                    token->start_mark);
      __retres = tmp_10;
      goto return_label;
    }
  return_label: return __retres;
}

static int yaml_parser_parse_indentless_sequence_entry(yaml_parser_t *parser,
                                                       yaml_event_t *event)
{
  int __retres;
  yaml_token_t *token;
  if (parser->token_available) token = parser->tokens.head;
  else {
    int tmp;
    tmp = yaml_parser_fetch_more_tokens(parser);
    if (tmp) token = parser->tokens.head; else token = (yaml_token_t *)0;
  }
  if (! token) {
    __retres = 0;
    goto return_label;
  }
  if (token->type == (unsigned int)YAML_BLOCK_ENTRY_TOKEN) {
    yaml_mark_t mark = token->end_mark;
    parser->token_available = 0;
    (parser->tokens_parsed) ++;
    parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
    (parser->tokens.head) ++;
    if (parser->token_available) token = parser->tokens.head;
    else {
      int tmp_0;
      tmp_0 = yaml_parser_fetch_more_tokens(parser);
      if (tmp_0) token = parser->tokens.head; else token = (yaml_token_t *)0;
    }
    if (! token) {
      __retres = 0;
      goto return_label;
    }
    if (token->type != (unsigned int)YAML_BLOCK_ENTRY_TOKEN) {
      if (token->type != (unsigned int)YAML_KEY_TOKEN) {
        if (token->type != (unsigned int)YAML_VALUE_TOKEN) {
          if (token->type != (unsigned int)YAML_BLOCK_END_TOKEN) {
            int tmp_3;
            int tmp_4;
            if (parser->states.top != parser->states.end) goto _LOR;
            else {
              int tmp_1;
              tmp_1 = yaml_stack_extend((void **)(& parser->states.start),
                                        (void **)(& parser->states.top),
                                        (void **)(& parser->states.end));
              if (tmp_1) {
                yaml_parser_state_t *tmp_2;
                _LOR: tmp_2 = parser->states.top;
                (parser->states.top) ++;
                *tmp_2 = YAML_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE;
                tmp_3 = 1;
              }
              else {
                parser->error = YAML_MEMORY_ERROR;
                tmp_3 = 0;
              }
            }
            if (! tmp_3) {
              __retres = 0;
              goto return_label;
            }
            tmp_4 = yaml_parser_parse_node(parser,event,1,0);
            __retres = tmp_4;
            goto return_label;
          }
          else goto _LAND_1;
        }
        else goto _LAND_1;
      }
      else goto _LAND_1;
    }
    else {
      _LAND_1:
      {
        int tmp_5;
        parser->state = YAML_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE;
        tmp_5 = yaml_parser_process_empty_scalar(parser,event,mark);
        __retres = tmp_5;
        goto return_label;
      }
    }
  }
  else {
    (parser->states.top) --;
    parser->state = *(parser->states.top);
    memset((void *)event,0,sizeof(yaml_event_t));
    event->type = YAML_SEQUENCE_END_EVENT;
    event->start_mark = token->start_mark;
    event->end_mark = token->start_mark;
    __retres = 1;
    goto return_label;
  }
  return_label: return __retres;
}

static int yaml_parser_parse_block_mapping_key(yaml_parser_t *parser,
                                               yaml_event_t *event, int first)
{
  int __retres;
  yaml_token_t *token;
  if (first) {
    int tmp_2;
    if (parser->token_available) token = parser->tokens.head;
    else {
      int tmp;
      tmp = yaml_parser_fetch_more_tokens(parser);
      if (tmp) token = parser->tokens.head; else token = (yaml_token_t *)0;
    }
    if (parser->marks.top != parser->marks.end) goto _LOR;
    else {
      int tmp_0;
      tmp_0 = yaml_stack_extend((void **)(& parser->marks.start),
                                (void **)(& parser->marks.top),
                                (void **)(& parser->marks.end));
      if (tmp_0) {
        yaml_mark_t *tmp_1;
        _LOR: tmp_1 = parser->marks.top;
        (parser->marks.top) ++;
        *tmp_1 = token->start_mark;
        tmp_2 = 1;
      }
      else {
        parser->error = YAML_MEMORY_ERROR;
        tmp_2 = 0;
      }
    }
    if (! tmp_2) {
      __retres = 0;
      goto return_label;
    }
    parser->token_available = 0;
    (parser->tokens_parsed) ++;
    parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
    (parser->tokens.head) ++;
  }
  if (parser->token_available) token = parser->tokens.head;
  else {
    int tmp_3;
    tmp_3 = yaml_parser_fetch_more_tokens(parser);
    if (tmp_3) token = parser->tokens.head; else token = (yaml_token_t *)0;
  }
  if (! token) {
    __retres = 0;
    goto return_label;
  }
  if (token->type == (unsigned int)YAML_KEY_TOKEN) {
    yaml_mark_t mark = token->end_mark;
    parser->token_available = 0;
    (parser->tokens_parsed) ++;
    parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
    (parser->tokens.head) ++;
    if (parser->token_available) token = parser->tokens.head;
    else {
      int tmp_4;
      tmp_4 = yaml_parser_fetch_more_tokens(parser);
      if (tmp_4) token = parser->tokens.head; else token = (yaml_token_t *)0;
    }
    if (! token) {
      __retres = 0;
      goto return_label;
    }
    if (token->type != (unsigned int)YAML_KEY_TOKEN) {
      if (token->type != (unsigned int)YAML_VALUE_TOKEN) {
        if (token->type != (unsigned int)YAML_BLOCK_END_TOKEN) {
          int tmp_7;
          int tmp_8;
          if (parser->states.top != parser->states.end) goto _LOR_0;
          else {
            int tmp_5;
            tmp_5 = yaml_stack_extend((void **)(& parser->states.start),
                                      (void **)(& parser->states.top),
                                      (void **)(& parser->states.end));
            if (tmp_5) {
              yaml_parser_state_t *tmp_6;
              _LOR_0: tmp_6 = parser->states.top;
              (parser->states.top) ++;
              *tmp_6 = YAML_PARSE_BLOCK_MAPPING_VALUE_STATE;
              tmp_7 = 1;
            }
            else {
              parser->error = YAML_MEMORY_ERROR;
              tmp_7 = 0;
            }
          }
          if (! tmp_7) {
            __retres = 0;
            goto return_label;
          }
          tmp_8 = yaml_parser_parse_node(parser,event,1,1);
          __retres = tmp_8;
          goto return_label;
        }
        else goto _LAND_0;
      }
      else goto _LAND_0;
    }
    else {
      _LAND_0:
      {
        int tmp_9;
        parser->state = YAML_PARSE_BLOCK_MAPPING_VALUE_STATE;
        tmp_9 = yaml_parser_process_empty_scalar(parser,event,mark);
        __retres = tmp_9;
        goto return_label;
      }
    }
  }
  else 
    if (token->type == (unsigned int)YAML_BLOCK_END_TOKEN) {
      (parser->states.top) --;
      parser->state = *(parser->states.top);
      (parser->marks.top) --;
      ;
      memset((void *)event,0,sizeof(yaml_event_t));
      event->type = YAML_MAPPING_END_EVENT;
      event->start_mark = token->start_mark;
      event->end_mark = token->end_mark;
      parser->token_available = 0;
      (parser->tokens_parsed) ++;
      parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
      (parser->tokens.head) ++;
      __retres = 1;
      goto return_label;
    }
    else {
      int tmp_10;
      ;
      (parser->marks.top) --;
      ;
      ;
      tmp_10 = yaml_parser_set_parser_error_context(parser,
                                                    "while parsing a block mapping",
                                                    *(parser->marks.top),
                                                    "did not find expected key",
                                                    token->start_mark);
      __retres = tmp_10;
      goto return_label;
    }
  return_label: return __retres;
}

static int yaml_parser_parse_block_mapping_value(yaml_parser_t *parser,
                                                 yaml_event_t *event)
{
  int __retres;
  yaml_token_t *token;
  if (parser->token_available) token = parser->tokens.head;
  else {
    int tmp;
    tmp = yaml_parser_fetch_more_tokens(parser);
    if (tmp) token = parser->tokens.head; else token = (yaml_token_t *)0;
  }
  if (! token) {
    __retres = 0;
    goto return_label;
  }
  if (token->type == (unsigned int)YAML_VALUE_TOKEN) {
    yaml_mark_t mark = token->end_mark;
    parser->token_available = 0;
    (parser->tokens_parsed) ++;
    parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
    (parser->tokens.head) ++;
    if (parser->token_available) token = parser->tokens.head;
    else {
      int tmp_0;
      tmp_0 = yaml_parser_fetch_more_tokens(parser);
      if (tmp_0) token = parser->tokens.head; else token = (yaml_token_t *)0;
    }
    if (! token) {
      __retres = 0;
      goto return_label;
    }
    if (token->type != (unsigned int)YAML_KEY_TOKEN) {
      if (token->type != (unsigned int)YAML_VALUE_TOKEN) {
        if (token->type != (unsigned int)YAML_BLOCK_END_TOKEN) {
          int tmp_3;
          int tmp_4;
          if (parser->states.top != parser->states.end) goto _LOR;
          else {
            int tmp_1;
            tmp_1 = yaml_stack_extend((void **)(& parser->states.start),
                                      (void **)(& parser->states.top),
                                      (void **)(& parser->states.end));
            if (tmp_1) {
              yaml_parser_state_t *tmp_2;
              _LOR: tmp_2 = parser->states.top;
              (parser->states.top) ++;
              *tmp_2 = YAML_PARSE_BLOCK_MAPPING_KEY_STATE;
              tmp_3 = 1;
            }
            else {
              parser->error = YAML_MEMORY_ERROR;
              tmp_3 = 0;
            }
          }
          if (! tmp_3) {
            __retres = 0;
            goto return_label;
          }
          tmp_4 = yaml_parser_parse_node(parser,event,1,1);
          __retres = tmp_4;
          goto return_label;
        }
        else goto _LAND_0;
      }
      else goto _LAND_0;
    }
    else {
      _LAND_0:
      {
        int tmp_5;
        parser->state = YAML_PARSE_BLOCK_MAPPING_KEY_STATE;
        tmp_5 = yaml_parser_process_empty_scalar(parser,event,mark);
        __retres = tmp_5;
        goto return_label;
      }
    }
  }
  else {
    int tmp_6;
    parser->state = YAML_PARSE_BLOCK_MAPPING_KEY_STATE;
    tmp_6 = yaml_parser_process_empty_scalar(parser,event,token->start_mark);
    __retres = tmp_6;
    goto return_label;
  }
  return_label: return __retres;
}

static int yaml_parser_parse_flow_sequence_entry(yaml_parser_t *parser,
                                                 yaml_event_t *event,
                                                 int first)
{
  int __retres;
  yaml_token_t *token;
  if (first) {
    int tmp_2;
    if (parser->token_available) token = parser->tokens.head;
    else {
      int tmp;
      tmp = yaml_parser_fetch_more_tokens(parser);
      if (tmp) token = parser->tokens.head; else token = (yaml_token_t *)0;
    }
    if (parser->marks.top != parser->marks.end) goto _LOR;
    else {
      int tmp_0;
      tmp_0 = yaml_stack_extend((void **)(& parser->marks.start),
                                (void **)(& parser->marks.top),
                                (void **)(& parser->marks.end));
      if (tmp_0) {
        yaml_mark_t *tmp_1;
        _LOR: tmp_1 = parser->marks.top;
        (parser->marks.top) ++;
        *tmp_1 = token->start_mark;
        tmp_2 = 1;
      }
      else {
        parser->error = YAML_MEMORY_ERROR;
        tmp_2 = 0;
      }
    }
    if (! tmp_2) {
      __retres = 0;
      goto return_label;
    }
    parser->token_available = 0;
    (parser->tokens_parsed) ++;
    parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
    (parser->tokens.head) ++;
  }
  if (parser->token_available) token = parser->tokens.head;
  else {
    int tmp_3;
    tmp_3 = yaml_parser_fetch_more_tokens(parser);
    if (tmp_3) token = parser->tokens.head; else token = (yaml_token_t *)0;
  }
  if (! token) {
    __retres = 0;
    goto return_label;
  }
  if (token->type != (unsigned int)YAML_FLOW_SEQUENCE_END_TOKEN) {
    if (! first) 
      if (token->type == (unsigned int)YAML_FLOW_ENTRY_TOKEN) {
        parser->token_available = 0;
        (parser->tokens_parsed) ++;
        parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
        (parser->tokens.head) ++;
        if (parser->token_available) token = parser->tokens.head;
        else {
          int tmp_4;
          tmp_4 = yaml_parser_fetch_more_tokens(parser);
          if (tmp_4) token = parser->tokens.head;
          else token = (yaml_token_t *)0;
        }
        if (! token) {
          __retres = 0;
          goto return_label;
        }
      }
      else {
        int tmp_5;
        ;
        (parser->marks.top) --;
        ;
        ;
        tmp_5 = yaml_parser_set_parser_error_context(parser,
                                                     "while parsing a flow sequence",
                                                     *(parser->marks.top),
                                                     "did not find expected \',\' or \']\'",
                                                     token->start_mark);
        __retres = tmp_5;
        goto return_label;
      }
    if (token->type == (unsigned int)YAML_KEY_TOKEN) {
      parser->state = YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE;
      memset((void *)event,0,sizeof(yaml_event_t));
      event->type = YAML_MAPPING_START_EVENT;
      event->start_mark = token->start_mark;
      event->end_mark = token->end_mark;
      event->data.mapping_start.anchor = (yaml_char_t *)0;
      event->data.mapping_start.tag = (yaml_char_t *)0;
      event->data.mapping_start.implicit = 1;
      event->data.mapping_start.style = YAML_FLOW_MAPPING_STYLE;
      parser->token_available = 0;
      (parser->tokens_parsed) ++;
      parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
      (parser->tokens.head) ++;
      __retres = 1;
      goto return_label;
    }
    else 
      if (token->type != (unsigned int)YAML_FLOW_SEQUENCE_END_TOKEN) {
        int tmp_8;
        int tmp_9;
        if (parser->states.top != parser->states.end) goto _LOR_0;
        else {
          int tmp_6;
          tmp_6 = yaml_stack_extend((void **)(& parser->states.start),
                                    (void **)(& parser->states.top),
                                    (void **)(& parser->states.end));
          if (tmp_6) {
            yaml_parser_state_t *tmp_7;
            _LOR_0: tmp_7 = parser->states.top;
            (parser->states.top) ++;
            *tmp_7 = YAML_PARSE_FLOW_SEQUENCE_ENTRY_STATE;
            tmp_8 = 1;
          }
          else {
            parser->error = YAML_MEMORY_ERROR;
            tmp_8 = 0;
          }
        }
        if (! tmp_8) {
          __retres = 0;
          goto return_label;
        }
        tmp_9 = yaml_parser_parse_node(parser,event,0,0);
        __retres = tmp_9;
        goto return_label;
      }
  }
  (parser->states.top) --;
  parser->state = *(parser->states.top);
  (parser->marks.top) --;
  ;
  memset((void *)event,0,sizeof(yaml_event_t));
  event->type = YAML_SEQUENCE_END_EVENT;
  event->start_mark = token->start_mark;
  event->end_mark = token->end_mark;
  parser->token_available = 0;
  (parser->tokens_parsed) ++;
  parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
  (parser->tokens.head) ++;
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_parse_flow_sequence_entry_mapping_key(yaml_parser_t *parser,
                                                             yaml_event_t *event)
{
  int __retres;
  yaml_token_t *token;
  if (parser->token_available) token = parser->tokens.head;
  else {
    int tmp;
    tmp = yaml_parser_fetch_more_tokens(parser);
    if (tmp) token = parser->tokens.head; else token = (yaml_token_t *)0;
  }
  if (! token) {
    __retres = 0;
    goto return_label;
  }
  if (token->type != (unsigned int)YAML_VALUE_TOKEN) {
    if (token->type != (unsigned int)YAML_FLOW_ENTRY_TOKEN) {
      if (token->type != (unsigned int)YAML_FLOW_SEQUENCE_END_TOKEN) {
        int tmp_2;
        int tmp_3;
        if (parser->states.top != parser->states.end) goto _LOR;
        else {
          int tmp_0;
          tmp_0 = yaml_stack_extend((void **)(& parser->states.start),
                                    (void **)(& parser->states.top),
                                    (void **)(& parser->states.end));
          if (tmp_0) {
            yaml_parser_state_t *tmp_1;
            _LOR: tmp_1 = parser->states.top;
            (parser->states.top) ++;
            *tmp_1 = YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE;
            tmp_2 = 1;
          }
          else {
            parser->error = YAML_MEMORY_ERROR;
            tmp_2 = 0;
          }
        }
        if (! tmp_2) {
          __retres = 0;
          goto return_label;
        }
        tmp_3 = yaml_parser_parse_node(parser,event,0,0);
        __retres = tmp_3;
        goto return_label;
      }
      else goto _LAND_0;
    }
    else goto _LAND_0;
  }
  else {
    _LAND_0:
    {
      int tmp_4;
      yaml_mark_t mark = token->end_mark;
      parser->token_available = 0;
      (parser->tokens_parsed) ++;
      parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
      (parser->tokens.head) ++;
      parser->state = YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE;
      tmp_4 = yaml_parser_process_empty_scalar(parser,event,mark);
      __retres = tmp_4;
      goto return_label;
    }
  }
  return_label: return __retres;
}

static int yaml_parser_parse_flow_sequence_entry_mapping_value(yaml_parser_t *parser,
                                                               yaml_event_t *event)
{
  int __retres;
  yaml_token_t *token;
  int tmp_5;
  if (parser->token_available) token = parser->tokens.head;
  else {
    int tmp;
    tmp = yaml_parser_fetch_more_tokens(parser);
    if (tmp) token = parser->tokens.head; else token = (yaml_token_t *)0;
  }
  if (! token) {
    __retres = 0;
    goto return_label;
  }
  if (token->type == (unsigned int)YAML_VALUE_TOKEN) {
    parser->token_available = 0;
    (parser->tokens_parsed) ++;
    parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
    (parser->tokens.head) ++;
    if (parser->token_available) token = parser->tokens.head;
    else {
      int tmp_0;
      tmp_0 = yaml_parser_fetch_more_tokens(parser);
      if (tmp_0) token = parser->tokens.head; else token = (yaml_token_t *)0;
    }
    if (! token) {
      __retres = 0;
      goto return_label;
    }
    if (token->type != (unsigned int)YAML_FLOW_ENTRY_TOKEN) 
      if (token->type != (unsigned int)YAML_FLOW_SEQUENCE_END_TOKEN) {
        int tmp_3;
        int tmp_4;
        if (parser->states.top != parser->states.end) goto _LOR;
        else {
          int tmp_1;
          tmp_1 = yaml_stack_extend((void **)(& parser->states.start),
                                    (void **)(& parser->states.top),
                                    (void **)(& parser->states.end));
          if (tmp_1) {
            yaml_parser_state_t *tmp_2;
            _LOR: tmp_2 = parser->states.top;
            (parser->states.top) ++;
            *tmp_2 = YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE;
            tmp_3 = 1;
          }
          else {
            parser->error = YAML_MEMORY_ERROR;
            tmp_3 = 0;
          }
        }
        if (! tmp_3) {
          __retres = 0;
          goto return_label;
        }
        tmp_4 = yaml_parser_parse_node(parser,event,0,0);
        __retres = tmp_4;
        goto return_label;
      }
  }
  parser->state = YAML_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE;
  tmp_5 = yaml_parser_process_empty_scalar(parser,event,token->start_mark);
  __retres = tmp_5;
  return_label: return __retres;
}

static int yaml_parser_parse_flow_sequence_entry_mapping_end(yaml_parser_t *parser,
                                                             yaml_event_t *event)
{
  int __retres;
  yaml_token_t *token;
  if (parser->token_available) token = parser->tokens.head;
  else {
    int tmp;
    tmp = yaml_parser_fetch_more_tokens(parser);
    if (tmp) token = parser->tokens.head; else token = (yaml_token_t *)0;
  }
  if (! token) {
    __retres = 0;
    goto return_label;
  }
  parser->state = YAML_PARSE_FLOW_SEQUENCE_ENTRY_STATE;
  memset((void *)event,0,sizeof(yaml_event_t));
  event->type = YAML_MAPPING_END_EVENT;
  event->start_mark = token->start_mark;
  event->end_mark = token->start_mark;
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_parse_flow_mapping_key(yaml_parser_t *parser,
                                              yaml_event_t *event, int first)
{
  int __retres;
  yaml_token_t *token;
  if (first) {
    int tmp_2;
    if (parser->token_available) token = parser->tokens.head;
    else {
      int tmp;
      tmp = yaml_parser_fetch_more_tokens(parser);
      if (tmp) token = parser->tokens.head; else token = (yaml_token_t *)0;
    }
    if (parser->marks.top != parser->marks.end) goto _LOR;
    else {
      int tmp_0;
      tmp_0 = yaml_stack_extend((void **)(& parser->marks.start),
                                (void **)(& parser->marks.top),
                                (void **)(& parser->marks.end));
      if (tmp_0) {
        yaml_mark_t *tmp_1;
        _LOR: tmp_1 = parser->marks.top;
        (parser->marks.top) ++;
        *tmp_1 = token->start_mark;
        tmp_2 = 1;
      }
      else {
        parser->error = YAML_MEMORY_ERROR;
        tmp_2 = 0;
      }
    }
    if (! tmp_2) {
      __retres = 0;
      goto return_label;
    }
    parser->token_available = 0;
    (parser->tokens_parsed) ++;
    parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
    (parser->tokens.head) ++;
  }
  if (parser->token_available) token = parser->tokens.head;
  else {
    int tmp_3;
    tmp_3 = yaml_parser_fetch_more_tokens(parser);
    if (tmp_3) token = parser->tokens.head; else token = (yaml_token_t *)0;
  }
  if (! token) {
    __retres = 0;
    goto return_label;
  }
  if (token->type != (unsigned int)YAML_FLOW_MAPPING_END_TOKEN) {
    if (! first) 
      if (token->type == (unsigned int)YAML_FLOW_ENTRY_TOKEN) {
        parser->token_available = 0;
        (parser->tokens_parsed) ++;
        parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
        (parser->tokens.head) ++;
        if (parser->token_available) token = parser->tokens.head;
        else {
          int tmp_4;
          tmp_4 = yaml_parser_fetch_more_tokens(parser);
          if (tmp_4) token = parser->tokens.head;
          else token = (yaml_token_t *)0;
        }
        if (! token) {
          __retres = 0;
          goto return_label;
        }
      }
      else {
        int tmp_5;
        ;
        (parser->marks.top) --;
        ;
        ;
        tmp_5 = yaml_parser_set_parser_error_context(parser,
                                                     "while parsing a flow mapping",
                                                     *(parser->marks.top),
                                                     "did not find expected \',\' or \'}\'",
                                                     token->start_mark);
        __retres = tmp_5;
        goto return_label;
      }
    if (token->type == (unsigned int)YAML_KEY_TOKEN) {
      parser->token_available = 0;
      (parser->tokens_parsed) ++;
      parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
      (parser->tokens.head) ++;
      if (parser->token_available) token = parser->tokens.head;
      else {
        int tmp_6;
        tmp_6 = yaml_parser_fetch_more_tokens(parser);
        if (tmp_6) token = parser->tokens.head;
        else token = (yaml_token_t *)0;
      }
      if (! token) {
        __retres = 0;
        goto return_label;
      }
      if (token->type != (unsigned int)YAML_VALUE_TOKEN) {
        if (token->type != (unsigned int)YAML_FLOW_ENTRY_TOKEN) {
          if (token->type != (unsigned int)YAML_FLOW_MAPPING_END_TOKEN) {
            int tmp_9;
            int tmp_10;
            if (parser->states.top != parser->states.end) goto _LOR_0;
            else {
              int tmp_7;
              tmp_7 = yaml_stack_extend((void **)(& parser->states.start),
                                        (void **)(& parser->states.top),
                                        (void **)(& parser->states.end));
              if (tmp_7) {
                yaml_parser_state_t *tmp_8;
                _LOR_0: tmp_8 = parser->states.top;
                (parser->states.top) ++;
                *tmp_8 = YAML_PARSE_FLOW_MAPPING_VALUE_STATE;
                tmp_9 = 1;
              }
              else {
                parser->error = YAML_MEMORY_ERROR;
                tmp_9 = 0;
              }
            }
            if (! tmp_9) {
              __retres = 0;
              goto return_label;
            }
            tmp_10 = yaml_parser_parse_node(parser,event,0,0);
            __retres = tmp_10;
            goto return_label;
          }
          else goto _LAND_0;
        }
        else goto _LAND_0;
      }
      else {
        _LAND_0:
        {
          int tmp_11;
          parser->state = YAML_PARSE_FLOW_MAPPING_VALUE_STATE;
          tmp_11 = yaml_parser_process_empty_scalar(parser,event,
                                                    token->start_mark);
          __retres = tmp_11;
          goto return_label;
        }
      }
    }
    else 
      if (token->type != (unsigned int)YAML_FLOW_MAPPING_END_TOKEN) {
        int tmp_14;
        int tmp_15;
        if (parser->states.top != parser->states.end) goto _LOR_1;
        else {
          int tmp_12;
          tmp_12 = yaml_stack_extend((void **)(& parser->states.start),
                                     (void **)(& parser->states.top),
                                     (void **)(& parser->states.end));
          if (tmp_12) {
            yaml_parser_state_t *tmp_13;
            _LOR_1: tmp_13 = parser->states.top;
            (parser->states.top) ++;
            *tmp_13 = YAML_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE;
            tmp_14 = 1;
          }
          else {
            parser->error = YAML_MEMORY_ERROR;
            tmp_14 = 0;
          }
        }
        if (! tmp_14) {
          __retres = 0;
          goto return_label;
        }
        tmp_15 = yaml_parser_parse_node(parser,event,0,0);
        __retres = tmp_15;
        goto return_label;
      }
  }
  (parser->states.top) --;
  parser->state = *(parser->states.top);
  (parser->marks.top) --;
  ;
  memset((void *)event,0,sizeof(yaml_event_t));
  event->type = YAML_MAPPING_END_EVENT;
  event->start_mark = token->start_mark;
  event->end_mark = token->end_mark;
  parser->token_available = 0;
  (parser->tokens_parsed) ++;
  parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
  (parser->tokens.head) ++;
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_parse_flow_mapping_value(yaml_parser_t *parser,
                                                yaml_event_t *event,
                                                int empty)
{
  int __retres;
  yaml_token_t *token;
  int tmp_6;
  if (parser->token_available) token = parser->tokens.head;
  else {
    int tmp;
    tmp = yaml_parser_fetch_more_tokens(parser);
    if (tmp) token = parser->tokens.head; else token = (yaml_token_t *)0;
  }
  if (! token) {
    __retres = 0;
    goto return_label;
  }
  if (empty) {
    int tmp_0;
    parser->state = YAML_PARSE_FLOW_MAPPING_KEY_STATE;
    tmp_0 = yaml_parser_process_empty_scalar(parser,event,token->start_mark);
    __retres = tmp_0;
    goto return_label;
  }
  if (token->type == (unsigned int)YAML_VALUE_TOKEN) {
    parser->token_available = 0;
    (parser->tokens_parsed) ++;
    parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
    (parser->tokens.head) ++;
    if (parser->token_available) token = parser->tokens.head;
    else {
      int tmp_1;
      tmp_1 = yaml_parser_fetch_more_tokens(parser);
      if (tmp_1) token = parser->tokens.head; else token = (yaml_token_t *)0;
    }
    if (! token) {
      __retres = 0;
      goto return_label;
    }
    if (token->type != (unsigned int)YAML_FLOW_ENTRY_TOKEN) 
      if (token->type != (unsigned int)YAML_FLOW_MAPPING_END_TOKEN) {
        int tmp_4;
        int tmp_5;
        if (parser->states.top != parser->states.end) goto _LOR;
        else {
          int tmp_2;
          tmp_2 = yaml_stack_extend((void **)(& parser->states.start),
                                    (void **)(& parser->states.top),
                                    (void **)(& parser->states.end));
          if (tmp_2) {
            yaml_parser_state_t *tmp_3;
            _LOR: tmp_3 = parser->states.top;
            (parser->states.top) ++;
            *tmp_3 = YAML_PARSE_FLOW_MAPPING_KEY_STATE;
            tmp_4 = 1;
          }
          else {
            parser->error = YAML_MEMORY_ERROR;
            tmp_4 = 0;
          }
        }
        if (! tmp_4) {
          __retres = 0;
          goto return_label;
        }
        tmp_5 = yaml_parser_parse_node(parser,event,0,0);
        __retres = tmp_5;
        goto return_label;
      }
  }
  parser->state = YAML_PARSE_FLOW_MAPPING_KEY_STATE;
  tmp_6 = yaml_parser_process_empty_scalar(parser,event,token->start_mark);
  __retres = tmp_6;
  return_label: return __retres;
}

static int yaml_parser_process_empty_scalar(yaml_parser_t *parser,
                                            yaml_event_t *event,
                                            yaml_mark_t mark)
{
  int __retres;
  yaml_char_t *value;
  value = (yaml_char_t *)yaml_malloc((size_t)1);
  if (! value) {
    parser->error = YAML_MEMORY_ERROR;
    __retres = 0;
    goto return_label;
  }
  *(value + 0) = (yaml_char_t)'\000';
  memset((void *)event,0,sizeof(yaml_event_t));
  event->type = YAML_SCALAR_EVENT;
  event->start_mark = mark;
  event->end_mark = mark;
  event->data.scalar.anchor = (yaml_char_t *)0;
  event->data.scalar.tag = (yaml_char_t *)0;
  event->data.scalar.value = value;
  event->data.scalar.length = (size_t)0;
  event->data.scalar.plain_implicit = 1;
  event->data.scalar.quoted_implicit = 0;
  event->data.scalar.style = YAML_PLAIN_SCALAR_STYLE;
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_process_directives(yaml_parser_t *parser,
                                          yaml_version_directive_t **version_directive_ref,
                                          yaml_tag_directive_t **tag_directives_start_ref,
                                          yaml_tag_directive_t **tag_directives_end_ref)
{
  int __retres;
  yaml_tag_directive_t *default_tag_directive;
  yaml_token_t *token;
  int tmp_0;
  yaml_tag_directive_t default_tag_directives[3] =
    {{.handle = (yaml_char_t *)"!", .prefix = (yaml_char_t *)"!"},
     {.handle = (yaml_char_t *)"!!",
      .prefix = (yaml_char_t *)"tag:yaml.org,2002:"},
     {.handle = (yaml_char_t *)0, .prefix = (yaml_char_t *)0}};
  yaml_version_directive_t *version_directive =
    (yaml_version_directive_t *)0;
  struct __anonstruct_tag_directives_50 tag_directives =
    {.start = (yaml_tag_directive_t *)0,
     .end = (yaml_tag_directive_t *)0,
     .top = (yaml_tag_directive_t *)0};
  tag_directives.start = (yaml_tag_directive_t *)yaml_malloc((unsigned long)16 * sizeof(*(tag_directives.start)));
  if (tag_directives.start) {
    tag_directives.top = tag_directives.start;
    tag_directives.end = tag_directives.start + 16;
    tmp_0 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_0 = 0;
  }
  if (! tmp_0) goto error;
  if (parser->token_available) token = parser->tokens.head;
  else {
    int tmp_1;
    tmp_1 = yaml_parser_fetch_more_tokens(parser);
    if (tmp_1) token = parser->tokens.head; else token = (yaml_token_t *)0;
  }
  if (! token) goto error;
  while (1) {
    if (! (token->type == (unsigned int)YAML_VERSION_DIRECTIVE_TOKEN)) 
      if (! (token->type == (unsigned int)YAML_TAG_DIRECTIVE_TOKEN)) 
        break;
    if (token->type == (unsigned int)YAML_VERSION_DIRECTIVE_TOKEN) {
      if (version_directive) {
        yaml_parser_set_parser_error(parser,
                                     "found duplicate %YAML directive",
                                     token->start_mark);
        goto error;
      }
      if (token->data.version_directive.major != 1) goto _LOR;
      else 
        if (token->data.version_directive.minor != 1) 
          if (token->data.version_directive.minor != 2) {
            _LOR:
            {
              yaml_parser_set_parser_error(parser,
                                           "found incompatible YAML document",
                                           token->start_mark);
              goto error;
            }
          }
      version_directive = (yaml_version_directive_t *)yaml_malloc(sizeof(yaml_version_directive_t));
      if (! version_directive) {
        parser->error = YAML_MEMORY_ERROR;
        goto error;
      }
      version_directive->major = token->data.version_directive.major;
      version_directive->minor = token->data.version_directive.minor;
    }
    else 
      if (token->type == (unsigned int)YAML_TAG_DIRECTIVE_TOKEN) {
        yaml_tag_directive_t value;
        int tmp_3;
        int tmp_6;
        value.handle = token->data.tag_directive.handle;
        value.prefix = token->data.tag_directive.prefix;
        tmp_3 = yaml_parser_append_tag_directive(parser,value,0,
                                                 token->start_mark);
        if (! tmp_3) goto error;
        if (tag_directives.top != tag_directives.end) goto _LOR_0;
        else {
          int tmp_4;
          tmp_4 = yaml_stack_extend((void **)(& tag_directives.start),
                                    (void **)(& tag_directives.top),
                                    (void **)(& tag_directives.end));
          if (tmp_4) {
            yaml_tag_directive_t *tmp_5;
            _LOR_0: tmp_5 = tag_directives.top;
            (tag_directives.top) ++;
            *tmp_5 = value;
            tmp_6 = 1;
          }
          else {
            parser->error = YAML_MEMORY_ERROR;
            tmp_6 = 0;
          }
        }
        if (! tmp_6) goto error;
      }
    parser->token_available = 0;
    (parser->tokens_parsed) ++;
    parser->stream_end_produced = (parser->tokens.head)->type == (unsigned int)YAML_STREAM_END_TOKEN;
    (parser->tokens.head) ++;
    if (parser->token_available) token = parser->tokens.head;
    else {
      int tmp_7;
      tmp_7 = yaml_parser_fetch_more_tokens(parser);
      if (tmp_7) token = parser->tokens.head; else token = (yaml_token_t *)0;
    }
    if (! token) goto error;
  }
  default_tag_directive = default_tag_directives;
  while (default_tag_directive->handle) {
    {
      int tmp_8;
      tmp_8 = yaml_parser_append_tag_directive(parser,*default_tag_directive,
                                               1,token->start_mark);
      if (! tmp_8) goto error;
    }
    default_tag_directive ++;
  }
  if (version_directive_ref) *version_directive_ref = version_directive;
  if (tag_directives_start_ref) 
    if (tag_directives.start == tag_directives.top) {
      yaml_tag_directive_t *tmp_9;
      tmp_9 = (yaml_tag_directive_t *)0;
      *tag_directives_end_ref = tmp_9;
      *tag_directives_start_ref = tmp_9;
      yaml_free((void *)tag_directives.start);
      tag_directives.end = (yaml_tag_directive_t *)0;
      tag_directives.top = tag_directives.end;
      tag_directives.start = tag_directives.top;
    }
    else {
      *tag_directives_start_ref = tag_directives.start;
      *tag_directives_end_ref = tag_directives.top;
    }
  else {
    yaml_free((void *)tag_directives.start);
    tag_directives.end = (yaml_tag_directive_t *)0;
    tag_directives.top = tag_directives.end;
    tag_directives.start = tag_directives.top;
  }
  if (! version_directive_ref) yaml_free((void *)version_directive);
  __retres = 1;
  goto return_label;
  error: yaml_free((void *)version_directive);
  while (! (tag_directives.start == tag_directives.top)) {
    (tag_directives.top) --;
    yaml_tag_directive_t tag_directive = *(tag_directives.top);
    yaml_free((void *)tag_directive.handle);
    yaml_free((void *)tag_directive.prefix);
  }
  yaml_free((void *)tag_directives.start);
  tag_directives.end = (yaml_tag_directive_t *)0;
  tag_directives.top = tag_directives.end;
  tag_directives.start = tag_directives.top;
  __retres = 0;
  return_label: return __retres;
}

static int yaml_parser_append_tag_directive(yaml_parser_t *parser,
                                            yaml_tag_directive_t value,
                                            int allow_duplicates,
                                            yaml_mark_t mark)
{
  int __retres;
  yaml_tag_directive_t *tag_directive;
  int tmp_3;
  yaml_tag_directive_t copy =
    {.handle = (yaml_char_t *)0, .prefix = (yaml_char_t *)0};
  tag_directive = parser->tag_directives.start;
  while (tag_directive != parser->tag_directives.top) {
    {
      int tmp_0;
      tmp_0 = strcmp((char const *)value.handle,
                     (char const *)tag_directive->handle);
      if (tmp_0 == 0) {
        int tmp;
        if (allow_duplicates) {
          __retres = 1;
          goto return_label;
        }
        tmp = yaml_parser_set_parser_error(parser,
                                           "found duplicate %TAG directive",
                                           mark);
        __retres = tmp;
        goto return_label;
      }
    }
    tag_directive ++;
  }
  copy.handle = yaml_strdup((yaml_char_t const *)value.handle);
  copy.prefix = yaml_strdup((yaml_char_t const *)value.prefix);
  if (! copy.handle) goto _LOR;
  else 
    if (! copy.prefix) {
      _LOR: {
              parser->error = YAML_MEMORY_ERROR;
              goto error;
            }
    }
  if (parser->tag_directives.top != parser->tag_directives.end) goto _LOR_0;
  else {
    int tmp_1;
    tmp_1 = yaml_stack_extend((void **)(& parser->tag_directives.start),
                              (void **)(& parser->tag_directives.top),
                              (void **)(& parser->tag_directives.end));
    if (tmp_1) {
      yaml_tag_directive_t *tmp_2;
      _LOR_0: tmp_2 = parser->tag_directives.top;
      (parser->tag_directives.top) ++;
      *tmp_2 = copy;
      tmp_3 = 1;
    }
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp_3 = 0;
    }
  }
  if (! tmp_3) goto error;
  __retres = 1;
  goto return_label;
  error: yaml_free((void *)copy.handle);
  yaml_free((void *)copy.prefix);
  __retres = 0;
  return_label: return __retres;
}

static int yaml_parser_set_reader_error(yaml_parser_t *parser,
                                        char const *problem, size_t offset,
                                        int value);

static int yaml_parser_update_raw_buffer(yaml_parser_t *parser);

static int yaml_parser_determine_encoding(yaml_parser_t *parser);

static int yaml_parser_set_reader_error(yaml_parser_t *parser,
                                        char const *problem, size_t offset,
                                        int value)
{
  int __retres;
  parser->error = YAML_READER_ERROR;
  parser->problem = problem;
  parser->problem_offset = offset;
  parser->problem_value = value;
  __retres = 0;
  return __retres;
}

static int yaml_parser_determine_encoding(yaml_parser_t *parser)
{
  int __retres;
  while (1) {
    if (! parser->eof) {
      if (! (parser->raw_buffer.last - parser->raw_buffer.pointer < (long)3)) 
        break;
    }
    else break;
    {
      int tmp;
      tmp = yaml_parser_update_raw_buffer(parser);
      if (! tmp) {
        __retres = 0;
        goto return_label;
      }
    }
  }
  if (parser->raw_buffer.last - parser->raw_buffer.pointer >= (long)2) {
    int tmp_2;
    tmp_2 = memcmp((void const *)parser->raw_buffer.pointer,
                   (void const *)"\377\376",(size_t)2);
    if (tmp_2) goto _LAND_1;
    else {
      parser->encoding = YAML_UTF16LE_ENCODING;
      parser->raw_buffer.pointer += 2;
      parser->offset += (size_t)2;
    }
  }
  else {
    _LAND_1: ;
    if (parser->raw_buffer.last - parser->raw_buffer.pointer >= (long)2) {
      int tmp_1;
      tmp_1 = memcmp((void const *)parser->raw_buffer.pointer,
                     (void const *)"\376\377",(size_t)2);
      if (tmp_1) goto _LAND_0;
      else {
        parser->encoding = YAML_UTF16BE_ENCODING;
        parser->raw_buffer.pointer += 2;
        parser->offset += (size_t)2;
      }
    }
    else {
      _LAND_0: ;
      if (parser->raw_buffer.last - parser->raw_buffer.pointer >= (long)3) {
        int tmp_0;
        tmp_0 = memcmp((void const *)parser->raw_buffer.pointer,
                       (void const *)"\357\273\277",(size_t)3);
        if (tmp_0) goto _LAND;
        else {
          parser->encoding = YAML_UTF8_ENCODING;
          parser->raw_buffer.pointer += 3;
          parser->offset += (size_t)3;
        }
      }
      else _LAND: parser->encoding = YAML_UTF8_ENCODING;
    }
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_update_raw_buffer(yaml_parser_t *parser)
{
  int __retres;
  int tmp_0;
  size_t size_read = (size_t)0;
  if (parser->raw_buffer.start == parser->raw_buffer.pointer) 
    if (parser->raw_buffer.last == parser->raw_buffer.end) {
      __retres = 1;
      goto return_label;
    }
  if (parser->eof) {
    __retres = 1;
    goto return_label;
  }
  if (parser->raw_buffer.start < parser->raw_buffer.pointer) 
    if (parser->raw_buffer.pointer < parser->raw_buffer.last) memmove
                                                              ((void *)parser->raw_buffer.start,
                                                               (void const *)parser->raw_buffer.pointer,
                                                               (size_t)(
                                                               parser->raw_buffer.last - parser->raw_buffer.pointer));
  parser->raw_buffer.last -= parser->raw_buffer.pointer - parser->raw_buffer.start;
  parser->raw_buffer.pointer = parser->raw_buffer.start;
  tmp_0 = (*(parser->read_handler))(parser->read_handler_data,
                                    parser->raw_buffer.last,
                                    (size_t)(parser->raw_buffer.end - parser->raw_buffer.last),
                                    & size_read);
  if (! tmp_0) {
    int tmp;
    tmp = yaml_parser_set_reader_error(parser,"input error",parser->offset,
                                       -1);
    __retres = tmp;
    goto return_label;
  }
  parser->raw_buffer.last += size_read;
  if (! size_read) parser->eof = 1;
  __retres = 1;
  return_label: return __retres;
}

int yaml_parser_update_buffer(yaml_parser_t *parser, size_t length)
{
  int __retres;
  int first = 1;
  __FC_assert(parser->read_handler != (yaml_read_handler_t *)0,
              "src/reader.c",146,"parser->read_handler");
  if (parser->eof) 
    if (parser->raw_buffer.pointer == parser->raw_buffer.last) {
      __retres = 1;
      goto return_label;
    }
  if (parser->unread >= length) {
    __retres = 1;
    goto return_label;
  }
  if (! parser->encoding) {
    int tmp;
    tmp = yaml_parser_determine_encoding(parser);
    if (! tmp) {
      __retres = 0;
      goto return_label;
    }
  }
  if (parser->buffer.start < parser->buffer.pointer) {
    if (parser->buffer.pointer < parser->buffer.last) {
      size_t size = (size_t)(parser->buffer.last - parser->buffer.pointer);
      memmove((void *)parser->buffer.start,
              (void const *)parser->buffer.pointer,size);
      parser->buffer.pointer = parser->buffer.start;
      parser->buffer.last = parser->buffer.start + size;
    }
    else goto _LAND;
  }
  else {
    _LAND: ;
    if (parser->buffer.pointer == parser->buffer.last) {
      parser->buffer.pointer = parser->buffer.start;
      parser->buffer.last = parser->buffer.start;
    }
  }
  while (parser->unread < length) {
    if (! first) goto _LOR;
    else 
      if (parser->raw_buffer.pointer == parser->raw_buffer.last) {
        _LOR:
        {
          int tmp_0;
          tmp_0 = yaml_parser_update_raw_buffer(parser);
          if (! tmp_0) {
            __retres = 0;
            goto return_label;
          }
        }
      }
    first = 0;
    while (parser->raw_buffer.pointer != parser->raw_buffer.last) {
      unsigned char octet;
      int low;
      int high;
      size_t k;
      unsigned int value = (unsigned int)0;
      unsigned int value2 = (unsigned int)0;
      int incomplete = 0;
      unsigned int width = (unsigned int)0;
      size_t raw_unread =
        (size_t)(parser->raw_buffer.last - parser->raw_buffer.pointer);
      switch (parser->encoding) {
        case YAML_UTF8_ENCODING: octet = *(parser->raw_buffer.pointer + 0);
        if (((int)octet & 0x80) == 0x00) width = (unsigned int)1;
        else {
          int tmp_3;
          if (((int)octet & 0xE0) == 0xC0) tmp_3 = 2;
          else {
            int tmp_2;
            if (((int)octet & 0xF0) == 0xE0) tmp_2 = 3;
            else {
              int tmp_1;
              if (((int)octet & 0xF8) == 0xF0) tmp_1 = 4; else tmp_1 = 0;
              tmp_2 = tmp_1;
            }
            tmp_3 = tmp_2;
          }
          width = (unsigned int)tmp_3;
        }
        if (! width) {
          int tmp_4;
          tmp_4 = yaml_parser_set_reader_error(parser,
                                               "invalid leading UTF-8 octet",
                                               parser->offset,(int)octet);
          __retres = tmp_4;
          goto return_label;
        }
        if ((size_t)width > raw_unread) {
          if (parser->eof) {
            int tmp_5;
            tmp_5 = yaml_parser_set_reader_error(parser,
                                                 "incomplete UTF-8 octet sequence",
                                                 parser->offset,-1);
            __retres = tmp_5;
            goto return_label;
          }
          incomplete = 1;
          break;
        }
        if (((int)octet & 0x80) == 0x00) value = (unsigned int)((int)octet & 0x7F);
        else {
          int tmp_8;
          if (((int)octet & 0xE0) == 0xC0) tmp_8 = (int)octet & 0x1F;
          else {
            int tmp_7;
            if (((int)octet & 0xF0) == 0xE0) tmp_7 = (int)octet & 0x0F;
            else {
              int tmp_6;
              if (((int)octet & 0xF8) == 0xF0) tmp_6 = (int)octet & 0x07;
              else tmp_6 = 0;
              tmp_7 = tmp_6;
            }
            tmp_8 = tmp_7;
          }
          value = (unsigned int)tmp_8;
        }
        k = (size_t)1;
        while (k < (size_t)width) {
          octet = *(parser->raw_buffer.pointer + k);
          if (((int)octet & 0xC0) != 0x80) {
            int tmp_9;
            tmp_9 = yaml_parser_set_reader_error(parser,
                                                 "invalid trailing UTF-8 octet",
                                                 parser->offset + k,
                                                 (int)octet);
            __retres = tmp_9;
            goto return_label;
          }
          value = (value << 6) + (unsigned int)((int)octet & 0x3F);
          k ++;
        }
        if (! (width == (unsigned int)1)) 
          if (width == (unsigned int)2) {
            if (! (value >= (unsigned int)0x80)) goto _LAND_2;
          }
          else {
            _LAND_2: ;
            if (width == (unsigned int)3) {
              if (! (value >= (unsigned int)0x800)) goto _LAND_1;
            }
            else {
              _LAND_1: ;
              if (width == (unsigned int)4) {
                if (! (value >= (unsigned int)0x10000)) goto _LAND_0;
              }
              else {
                int tmp_10;
                _LAND_0:
                tmp_10 = yaml_parser_set_reader_error(parser,
                                                      "invalid length of a UTF-8 sequence",
                                                      parser->offset,-1);
                __retres = tmp_10;
                goto return_label;
              }
            }
          }
        if (value >= (unsigned int)0xD800) {
          if (value <= (unsigned int)0xDFFF) goto _LOR_0; else goto _LAND_3;
        }
        else {
          _LAND_3: ;
          if (value > (unsigned int)0x10FFFF) {
            int tmp_11;
            _LOR_0:
            tmp_11 = yaml_parser_set_reader_error(parser,
                                                  "invalid Unicode character",
                                                  parser->offset,(int)value);
            __retres = tmp_11;
            goto return_label;
          }
        }
        break;
        case YAML_UTF16LE_ENCODING: case YAML_UTF16BE_ENCODING:
        if (parser->encoding == (unsigned int)YAML_UTF16LE_ENCODING) 
          low = 0;
        else low = 1;
        if (parser->encoding == (unsigned int)YAML_UTF16LE_ENCODING) 
          high = 1;
        else high = 0;
        if (raw_unread < (size_t)2) {
          if (parser->eof) {
            int tmp_12;
            tmp_12 = yaml_parser_set_reader_error(parser,
                                                  "incomplete UTF-16 character",
                                                  parser->offset,-1);
            __retres = tmp_12;
            goto return_label;
          }
          incomplete = 1;
          break;
        }
        value = (unsigned int)((int)*(parser->raw_buffer.pointer + low) + (
                               (int)*(parser->raw_buffer.pointer + high) << 8));
        if ((value & (unsigned int)0xFC00) == (unsigned int)0xDC00) {
          int tmp_13;
          tmp_13 = yaml_parser_set_reader_error(parser,
                                                "unexpected low surrogate area",
                                                parser->offset,(int)value);
          __retres = tmp_13;
          goto return_label;
        }
        if ((value & (unsigned int)0xFC00) == (unsigned int)0xD800) {
          width = (unsigned int)4;
          if (raw_unread < (size_t)4) {
            if (parser->eof) {
              int tmp_14;
              tmp_14 = yaml_parser_set_reader_error(parser,
                                                    "incomplete UTF-16 surrogate pair",
                                                    parser->offset,-1);
              __retres = tmp_14;
              goto return_label;
            }
            incomplete = 1;
            break;
          }
          value2 = (unsigned int)((int)*(parser->raw_buffer.pointer + (
                                         low + 2)) + ((int)*(parser->raw_buffer.pointer + (
                                                             high + 2)) << 8));
          if ((value2 & (unsigned int)0xFC00) != (unsigned int)0xDC00) {
            int tmp_15;
            tmp_15 = yaml_parser_set_reader_error(parser,
                                                  "expected low surrogate area",
                                                  parser->offset + (size_t)2,
                                                  (int)value2);
            __retres = tmp_15;
            goto return_label;
          }
          value = ((unsigned int)0x10000 + ((value & (unsigned int)0x3FF) << 10)) + (
                  value2 & (unsigned int)0x3FF);
        }
        else width = (unsigned int)2;
        break;
        default: __FC_assert(1 != 0,"src/reader.c",397,"1");
      }
      if (incomplete) break;
      if (! (value == (unsigned int)0x09)) 
        if (! (value == (unsigned int)0x0A)) 
          if (! (value == (unsigned int)0x0D)) 
            if (value >= (unsigned int)0x20) {
              if (! (value <= (unsigned int)0x7E)) goto _LAND_7;
            }
            else {
              _LAND_7: ;
              if (! (value == (unsigned int)0x85)) 
                if (value >= (unsigned int)0xA0) {
                  if (! (value <= (unsigned int)0xD7FF)) goto _LAND_6;
                }
                else {
                  _LAND_6: ;
                  if (value >= (unsigned int)0xE000) {
                    if (! (value <= (unsigned int)0xFFFD)) goto _LAND_5;
                  }
                  else {
                    _LAND_5: ;
                    if (value >= (unsigned int)0x10000) {
                      if (! (value <= (unsigned int)0x10FFFF)) goto _LAND_4;
                    }
                    else {
                      int tmp_16;
                      _LAND_4:
                      tmp_16 = yaml_parser_set_reader_error(parser,
                                                            "control characters are not allowed",
                                                            parser->offset,
                                                            (int)value);
                      __retres = tmp_16;
                      goto return_label;
                    }
                  }
                }
            }
      parser->raw_buffer.pointer += width;
      parser->offset += (size_t)width;
      if (value <= (unsigned int)0x7F) {
        yaml_char_t *tmp_17;
        tmp_17 = parser->buffer.last;
        (parser->buffer.last) ++;
        *tmp_17 = (yaml_char_t)value;
      }
      else 
        if (value <= (unsigned int)0x7FF) {
          yaml_char_t *tmp_18;
          yaml_char_t *tmp_19;
          tmp_18 = parser->buffer.last;
          (parser->buffer.last) ++;
          *tmp_18 = (yaml_char_t)((unsigned int)0xC0 + (value >> 6));
          tmp_19 = parser->buffer.last;
          (parser->buffer.last) ++;
          *tmp_19 = (yaml_char_t)((unsigned int)0x80 + (value & (unsigned int)0x3F));
        }
        else 
          if (value <= (unsigned int)0xFFFF) {
            yaml_char_t *tmp_20;
            yaml_char_t *tmp_21;
            yaml_char_t *tmp_22;
            tmp_20 = parser->buffer.last;
            (parser->buffer.last) ++;
            *tmp_20 = (yaml_char_t)((unsigned int)0xE0 + (value >> 12));
            tmp_21 = parser->buffer.last;
            (parser->buffer.last) ++;
            *tmp_21 = (yaml_char_t)((unsigned int)0x80 + ((value >> 6) & (unsigned int)0x3F));
            tmp_22 = parser->buffer.last;
            (parser->buffer.last) ++;
            *tmp_22 = (yaml_char_t)((unsigned int)0x80 + (value & (unsigned int)0x3F));
          }
          else {
            yaml_char_t *tmp_23;
            yaml_char_t *tmp_24;
            yaml_char_t *tmp_25;
            yaml_char_t *tmp_26;
            tmp_23 = parser->buffer.last;
            (parser->buffer.last) ++;
            *tmp_23 = (yaml_char_t)((unsigned int)0xF0 + (value >> 18));
            tmp_24 = parser->buffer.last;
            (parser->buffer.last) ++;
            *tmp_24 = (yaml_char_t)((unsigned int)0x80 + ((value >> 12) & (unsigned int)0x3F));
            tmp_25 = parser->buffer.last;
            (parser->buffer.last) ++;
            *tmp_25 = (yaml_char_t)((unsigned int)0x80 + ((value >> 6) & (unsigned int)0x3F));
            tmp_26 = parser->buffer.last;
            (parser->buffer.last) ++;
            *tmp_26 = (yaml_char_t)((unsigned int)0x80 + (value & (unsigned int)0x3F));
          }
      (parser->unread) ++;
    }
    if (parser->eof) {
      yaml_char_t *tmp_27;
      tmp_27 = parser->buffer.last;
      (parser->buffer.last) ++;
      *tmp_27 = (yaml_char_t)'\000';
      (parser->unread) ++;
      __retres = 1;
      goto return_label;
    }
  }
  if (parser->offset >= ~ ((size_t)0) / (size_t)2) {
    int tmp_28;
    tmp_28 = yaml_parser_set_reader_error(parser,"input is too long",
                                          parser->offset,-1);
    __retres = tmp_28;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_set_scanner_error(yaml_parser_t *parser,
                                         char const *context,
                                         yaml_mark_t context_mark,
                                         char const *problem);

static int yaml_parser_fetch_next_token(yaml_parser_t *parser);

static int yaml_parser_stale_simple_keys(yaml_parser_t *parser);

static int yaml_parser_save_simple_key(yaml_parser_t *parser);

static int yaml_parser_remove_simple_key(yaml_parser_t *parser);

static int yaml_parser_increase_flow_level(yaml_parser_t *parser);

static int yaml_parser_decrease_flow_level(yaml_parser_t *parser);

static int yaml_parser_roll_indent(yaml_parser_t *parser, ptrdiff_t column,
                                   ptrdiff_t number, yaml_token_type_t type,
                                   yaml_mark_t mark);

static int yaml_parser_unroll_indent(yaml_parser_t *parser, ptrdiff_t column);

static int yaml_parser_fetch_stream_start(yaml_parser_t *parser);

static int yaml_parser_fetch_stream_end(yaml_parser_t *parser);

static int yaml_parser_fetch_directive(yaml_parser_t *parser);

static int yaml_parser_fetch_document_indicator(yaml_parser_t *parser,
                                                yaml_token_type_t type);

static int yaml_parser_fetch_flow_collection_start(yaml_parser_t *parser,
                                                   yaml_token_type_t type);

static int yaml_parser_fetch_flow_collection_end(yaml_parser_t *parser,
                                                 yaml_token_type_t type);

static int yaml_parser_fetch_flow_entry(yaml_parser_t *parser);

static int yaml_parser_fetch_block_entry(yaml_parser_t *parser);

static int yaml_parser_fetch_key(yaml_parser_t *parser);

static int yaml_parser_fetch_value(yaml_parser_t *parser);

static int yaml_parser_fetch_anchor(yaml_parser_t *parser,
                                    yaml_token_type_t type);

static int yaml_parser_fetch_tag(yaml_parser_t *parser);

static int yaml_parser_fetch_block_scalar(yaml_parser_t *parser, int literal);

static int yaml_parser_fetch_flow_scalar(yaml_parser_t *parser, int single);

static int yaml_parser_fetch_plain_scalar(yaml_parser_t *parser);

static int yaml_parser_scan_to_next_token(yaml_parser_t *parser);

static int yaml_parser_scan_directive(yaml_parser_t *parser,
                                      yaml_token_t *token);

static int yaml_parser_scan_directive_name(yaml_parser_t *parser,
                                           yaml_mark_t start_mark,
                                           yaml_char_t **name);

static int yaml_parser_scan_version_directive_value(yaml_parser_t *parser,
                                                    yaml_mark_t start_mark,
                                                    int *major, int *minor);

static int yaml_parser_scan_version_directive_number(yaml_parser_t *parser,
                                                     yaml_mark_t start_mark,
                                                     int *number);

static int yaml_parser_scan_tag_directive_value(yaml_parser_t *parser,
                                                yaml_mark_t start_mark,
                                                yaml_char_t **handle,
                                                yaml_char_t **prefix);

static int yaml_parser_scan_anchor(yaml_parser_t *parser,
                                   yaml_token_t *token,
                                   yaml_token_type_t type);

static int yaml_parser_scan_tag(yaml_parser_t *parser, yaml_token_t *token);

static int yaml_parser_scan_tag_handle(yaml_parser_t *parser, int directive,
                                       yaml_mark_t start_mark,
                                       yaml_char_t **handle);

static int yaml_parser_scan_tag_uri(yaml_parser_t *parser, int uri_char,
                                    int directive, yaml_char_t *head,
                                    yaml_mark_t start_mark, yaml_char_t **uri);

static int yaml_parser_scan_uri_escapes(yaml_parser_t *parser, int directive,
                                        yaml_mark_t start_mark,
                                        yaml_string_t *string);

static int yaml_parser_scan_block_scalar(yaml_parser_t *parser,
                                         yaml_token_t *token, int literal);

static int yaml_parser_scan_block_scalar_breaks(yaml_parser_t *parser,
                                                int *indent,
                                                yaml_string_t *breaks,
                                                yaml_mark_t start_mark,
                                                yaml_mark_t *end_mark);

static int yaml_parser_scan_flow_scalar(yaml_parser_t *parser,
                                        yaml_token_t *token, int single);

static int yaml_parser_scan_plain_scalar(yaml_parser_t *parser,
                                         yaml_token_t *token);

int yaml_parser_scan(yaml_parser_t *parser, yaml_token_t *token)
{
  int __retres;
  yaml_token_t *tmp_0;
  __FC_assert(parser != (yaml_parser_t *)0,"src/scanner.c",745,"parser");
  __FC_assert(token != (yaml_token_t *)0,"src/scanner.c",746,"token");
  memset((void *)token,0,sizeof(yaml_token_t));
  if (parser->stream_end_produced) goto _LOR;
  else 
    if (parser->error) {
      _LOR: {
              __retres = 1;
              goto return_label;
            }
    }
  if (! parser->token_available) {
    int tmp;
    tmp = yaml_parser_fetch_more_tokens(parser);
    if (! tmp) {
      __retres = 0;
      goto return_label;
    }
  }
  tmp_0 = parser->tokens.head;
  (parser->tokens.head) ++;
  *token = *tmp_0;
  parser->token_available = 0;
  (parser->tokens_parsed) ++;
  if (token->type == (unsigned int)YAML_STREAM_END_TOKEN) parser->stream_end_produced = 1;
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_set_scanner_error(yaml_parser_t *parser,
                                         char const *context,
                                         yaml_mark_t context_mark,
                                         char const *problem)
{
  int __retres;
  parser->error = YAML_SCANNER_ERROR;
  parser->context = context;
  parser->context_mark = context_mark;
  parser->problem = problem;
  parser->problem_mark = parser->mark;
  __retres = 0;
  return __retres;
}

int yaml_parser_fetch_more_tokens(yaml_parser_t *parser)
{
  int __retres;
  int need_more_tokens;
  while (1) {
    {
      int tmp_0;
      need_more_tokens = 0;
      if (parser->tokens.head == parser->tokens.tail) need_more_tokens = 1;
      else {
        yaml_simple_key_t *simple_key;
        int tmp;
        tmp = yaml_parser_stale_simple_keys(parser);
        if (! tmp) {
          __retres = 0;
          goto return_label;
        }
        simple_key = parser->simple_keys.start;
        while (simple_key != parser->simple_keys.top) {
          if (simple_key->possible) 
            if (simple_key->token_number == parser->tokens_parsed) {
              need_more_tokens = 1;
              break;
            }
          simple_key ++;
        }
      }
      if (! need_more_tokens) break;
      tmp_0 = yaml_parser_fetch_next_token(parser);
      if (! tmp_0) {
        __retres = 0;
        goto return_label;
      }
    }
  }
  parser->token_available = 1;
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_fetch_next_token(yaml_parser_t *parser)
{
  int __retres;
  int tmp_0;
  int tmp_2;
  int tmp_3;
  int tmp_4;
  int tmp_6;
  int tmp_27;
  if (parser->unread >= (size_t)1) tmp_0 = 1;
  else tmp_0 = yaml_parser_update_buffer(parser,(size_t)1);
  if (! tmp_0) {
    __retres = 0;
    goto return_label;
  }
  if (! parser->stream_start_produced) {
    int tmp_1;
    tmp_1 = yaml_parser_fetch_stream_start(parser);
    __retres = tmp_1;
    goto return_label;
  }
  tmp_2 = yaml_parser_scan_to_next_token(parser);
  if (! tmp_2) {
    __retres = 0;
    goto return_label;
  }
  tmp_3 = yaml_parser_stale_simple_keys(parser);
  if (! tmp_3) {
    __retres = 0;
    goto return_label;
  }
  tmp_4 = yaml_parser_unroll_indent(parser,(ptrdiff_t)parser->mark.column);
  if (! tmp_4) {
    __retres = 0;
    goto return_label;
  }
  if (parser->unread >= (size_t)4) tmp_6 = 1;
  else tmp_6 = yaml_parser_update_buffer(parser,(size_t)4);
  if (! tmp_6) {
    __retres = 0;
    goto return_label;
  }
  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\000')) {
    int tmp_7;
    tmp_7 = yaml_parser_fetch_stream_end(parser);
    __retres = tmp_7;
    goto return_label;
  }
  if (parser->mark.column == (size_t)0) 
    if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'%')) {
      int tmp_8;
      tmp_8 = yaml_parser_fetch_directive(parser);
      __retres = tmp_8;
      goto return_label;
    }
  if (parser->mark.column == (size_t)0) 
    if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'-')) 
      if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'-')) 
        if ((int)*(parser->buffer.pointer + 2) == (int)((yaml_char_t)'-')) 
          if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)' ')) 
            goto _LOR_0;
          else 
            if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\t')) 
              goto _LOR_0;
            else 
              if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\r')) 
                goto _LOR_0;
              else 
                if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\n')) 
                  goto _LOR_0;
                else 
                  if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\302')) {
                    if ((int)*(parser->buffer.pointer + (3 + 1)) == (int)((yaml_char_t)'\205')) 
                      goto _LOR_0;
                    else goto _LAND_3;
                  }
                  else {
                    _LAND_3: ;
                    if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\342')) {
                      if ((int)*(parser->buffer.pointer + (3 + 1)) == (int)((yaml_char_t)'\200')) {
                        if ((int)*(parser->buffer.pointer + (3 + 2)) == (int)((yaml_char_t)'\250')) 
                          goto _LOR_0;
                        else goto _LAND_2;
                      }
                      else goto _LAND_2;
                    }
                    else {
                      _LAND_2: ;
                      if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\342')) {
                        if ((int)*(parser->buffer.pointer + (3 + 1)) == (int)((yaml_char_t)'\200')) {
                          if ((int)*(parser->buffer.pointer + (3 + 2)) == (int)((yaml_char_t)'\251')) 
                            goto _LOR_0;
                          else goto _LAND_0;
                        }
                        else goto _LAND_0;
                      }
                      else {
                        _LAND_0: ;
                        if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\000')) {
                          int tmp_9;
                          _LOR_0:
                          tmp_9 = yaml_parser_fetch_document_indicator
                          (parser,YAML_DOCUMENT_START_TOKEN);
                          __retres = tmp_9;
                          goto return_label;
                        }
                      }
                    }
                  }
  if (parser->mark.column == (size_t)0) 
    if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'.')) 
      if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'.')) 
        if ((int)*(parser->buffer.pointer + 2) == (int)((yaml_char_t)'.')) 
          if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)' ')) 
            goto _LOR_2;
          else 
            if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\t')) 
              goto _LOR_2;
            else 
              if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\r')) 
                goto _LOR_2;
              else 
                if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\n')) 
                  goto _LOR_2;
                else 
                  if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\302')) {
                    if ((int)*(parser->buffer.pointer + (3 + 1)) == (int)((yaml_char_t)'\205')) 
                      goto _LOR_2;
                    else goto _LAND_8;
                  }
                  else {
                    _LAND_8: ;
                    if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\342')) {
                      if ((int)*(parser->buffer.pointer + (3 + 1)) == (int)((yaml_char_t)'\200')) {
                        if ((int)*(parser->buffer.pointer + (3 + 2)) == (int)((yaml_char_t)'\250')) 
                          goto _LOR_2;
                        else goto _LAND_7;
                      }
                      else goto _LAND_7;
                    }
                    else {
                      _LAND_7: ;
                      if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\342')) {
                        if ((int)*(parser->buffer.pointer + (3 + 1)) == (int)((yaml_char_t)'\200')) {
                          if ((int)*(parser->buffer.pointer + (3 + 2)) == (int)((yaml_char_t)'\251')) 
                            goto _LOR_2;
                          else goto _LAND_5;
                        }
                        else goto _LAND_5;
                      }
                      else {
                        _LAND_5: ;
                        if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\000')) {
                          int tmp_10;
                          _LOR_2:
                          tmp_10 = yaml_parser_fetch_document_indicator
                          (parser,YAML_DOCUMENT_END_TOKEN);
                          __retres = tmp_10;
                          goto return_label;
                        }
                      }
                    }
                  }
  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'[')) {
    int tmp_11;
    tmp_11 = yaml_parser_fetch_flow_collection_start(parser,
                                                     YAML_FLOW_SEQUENCE_START_TOKEN);
    __retres = tmp_11;
    goto return_label;
  }
  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'{')) {
    int tmp_12;
    tmp_12 = yaml_parser_fetch_flow_collection_start(parser,
                                                     YAML_FLOW_MAPPING_START_TOKEN);
    __retres = tmp_12;
    goto return_label;
  }
  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)']')) {
    int tmp_13;
    tmp_13 = yaml_parser_fetch_flow_collection_end(parser,
                                                   YAML_FLOW_SEQUENCE_END_TOKEN);
    __retres = tmp_13;
    goto return_label;
  }
  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'}')) {
    int tmp_14;
    tmp_14 = yaml_parser_fetch_flow_collection_end(parser,
                                                   YAML_FLOW_MAPPING_END_TOKEN);
    __retres = tmp_14;
    goto return_label;
  }
  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)',')) {
    int tmp_15;
    tmp_15 = yaml_parser_fetch_flow_entry(parser);
    __retres = tmp_15;
    goto return_label;
  }
  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'-')) 
    if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)' ')) 
      goto _LOR_4;
    else 
      if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\t')) 
        goto _LOR_4;
      else 
        if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\r')) 
          goto _LOR_4;
        else 
          if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\n')) 
            goto _LOR_4;
          else 
            if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\302')) {
              if ((int)*(parser->buffer.pointer + (1 + 1)) == (int)((yaml_char_t)'\205')) 
                goto _LOR_4;
              else goto _LAND_13;
            }
            else {
              _LAND_13: ;
              if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\342')) {
                if ((int)*(parser->buffer.pointer + (1 + 1)) == (int)((yaml_char_t)'\200')) {
                  if ((int)*(parser->buffer.pointer + (1 + 2)) == (int)((yaml_char_t)'\250')) 
                    goto _LOR_4;
                  else goto _LAND_12;
                }
                else goto _LAND_12;
              }
              else {
                _LAND_12: ;
                if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\342')) {
                  if ((int)*(parser->buffer.pointer + (1 + 1)) == (int)((yaml_char_t)'\200')) {
                    if ((int)*(parser->buffer.pointer + (1 + 2)) == (int)((yaml_char_t)'\251')) 
                      goto _LOR_4;
                    else goto _LAND_10;
                  }
                  else goto _LAND_10;
                }
                else {
                  _LAND_10: ;
                  if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\000')) {
                    int tmp_16;
                    _LOR_4: tmp_16 = yaml_parser_fetch_block_entry(parser);
                    __retres = tmp_16;
                    goto return_label;
                  }
                }
              }
            }
  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'?')) 
    if (parser->flow_level) goto _LOR_7;
    else 
      if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)' ')) 
        goto _LOR_7;
      else 
        if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\t')) 
          goto _LOR_7;
        else 
          if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\r')) 
            goto _LOR_7;
          else 
            if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\n')) 
              goto _LOR_7;
            else 
              if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\302')) {
                if ((int)*(parser->buffer.pointer + (1 + 1)) == (int)((yaml_char_t)'\205')) 
                  goto _LOR_7;
                else goto _LAND_18;
              }
              else {
                _LAND_18: ;
                if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\342')) {
                  if ((int)*(parser->buffer.pointer + (1 + 1)) == (int)((yaml_char_t)'\200')) {
                    if ((int)*(parser->buffer.pointer + (1 + 2)) == (int)((yaml_char_t)'\250')) 
                      goto _LOR_7;
                    else goto _LAND_17;
                  }
                  else goto _LAND_17;
                }
                else {
                  _LAND_17: ;
                  if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\342')) {
                    if ((int)*(parser->buffer.pointer + (1 + 1)) == (int)((yaml_char_t)'\200')) {
                      if ((int)*(parser->buffer.pointer + (1 + 2)) == (int)((yaml_char_t)'\251')) 
                        goto _LOR_7;
                      else goto _LAND_15;
                    }
                    else goto _LAND_15;
                  }
                  else {
                    _LAND_15: ;
                    if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\000')) {
                      int tmp_17;
                      _LOR_7: tmp_17 = yaml_parser_fetch_key(parser);
                      __retres = tmp_17;
                      goto return_label;
                    }
                  }
                }
              }
  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)':')) 
    if (parser->flow_level) goto _LOR_10;
    else 
      if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)' ')) 
        goto _LOR_10;
      else 
        if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\t')) 
          goto _LOR_10;
        else 
          if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\r')) 
            goto _LOR_10;
          else 
            if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\n')) 
              goto _LOR_10;
            else 
              if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\302')) {
                if ((int)*(parser->buffer.pointer + (1 + 1)) == (int)((yaml_char_t)'\205')) 
                  goto _LOR_10;
                else goto _LAND_23;
              }
              else {
                _LAND_23: ;
                if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\342')) {
                  if ((int)*(parser->buffer.pointer + (1 + 1)) == (int)((yaml_char_t)'\200')) {
                    if ((int)*(parser->buffer.pointer + (1 + 2)) == (int)((yaml_char_t)'\250')) 
                      goto _LOR_10;
                    else goto _LAND_22;
                  }
                  else goto _LAND_22;
                }
                else {
                  _LAND_22: ;
                  if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\342')) {
                    if ((int)*(parser->buffer.pointer + (1 + 1)) == (int)((yaml_char_t)'\200')) {
                      if ((int)*(parser->buffer.pointer + (1 + 2)) == (int)((yaml_char_t)'\251')) 
                        goto _LOR_10;
                      else goto _LAND_20;
                    }
                    else goto _LAND_20;
                  }
                  else {
                    _LAND_20: ;
                    if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\000')) {
                      int tmp_18;
                      _LOR_10: tmp_18 = yaml_parser_fetch_value(parser);
                      __retres = tmp_18;
                      goto return_label;
                    }
                  }
                }
              }
  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'*')) {
    int tmp_19;
    tmp_19 = yaml_parser_fetch_anchor(parser,YAML_ALIAS_TOKEN);
    __retres = tmp_19;
    goto return_label;
  }
  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'&')) {
    int tmp_20;
    tmp_20 = yaml_parser_fetch_anchor(parser,YAML_ANCHOR_TOKEN);
    __retres = tmp_20;
    goto return_label;
  }
  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'!')) {
    int tmp_21;
    tmp_21 = yaml_parser_fetch_tag(parser);
    __retres = tmp_21;
    goto return_label;
  }
  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'|')) 
    if (! parser->flow_level) {
      int tmp_22;
      tmp_22 = yaml_parser_fetch_block_scalar(parser,1);
      __retres = tmp_22;
      goto return_label;
    }
  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'>')) 
    if (! parser->flow_level) {
      int tmp_23;
      tmp_23 = yaml_parser_fetch_block_scalar(parser,0);
      __retres = tmp_23;
      goto return_label;
    }
  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\'')) {
    int tmp_24;
    tmp_24 = yaml_parser_fetch_flow_scalar(parser,1);
    __retres = tmp_24;
    goto return_label;
  }
  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\"')) {
    int tmp_25;
    tmp_25 = yaml_parser_fetch_flow_scalar(parser,0);
    __retres = tmp_25;
    goto return_label;
  }
  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)' ')) 
    goto _LOR_13;
  else 
    if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\t')) 
      goto _LOR_13;
    else 
      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) 
        goto _LOR_13;
      else 
        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n')) 
          goto _LOR_13;
        else 
          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
            if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\205')) 
              goto _LOR_13;
            else goto _LAND_34;
          }
          else {
            _LAND_34: ;
            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
              if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                if ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\250')) 
                  goto _LOR_13;
                else goto _LAND_33;
              }
              else goto _LAND_33;
            }
            else {
              _LAND_33: ;
              if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
                if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                  if ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\251')) 
                    goto _LOR_13;
                  else goto _LAND_31;
                }
                else goto _LAND_31;
              }
              else {
                _LAND_31: ;
                if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\000')) 
                  goto _LOR_13;
                else 
                  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'-')) 
                    goto _LOR_13;
                  else 
                    if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'?')) 
                      goto _LOR_13;
                    else 
                      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)':')) 
                        goto _LOR_13;
                      else 
                        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)',')) 
                          goto _LOR_13;
                        else 
                          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'[')) 
                            goto _LOR_13;
                          else 
                            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)']')) 
                              goto _LOR_13;
                            else 
                              if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'{')) 
                                goto _LOR_13;
                              else 
                                if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'}')) 
                                  goto _LOR_13;
                                else 
                                  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'#')) 
                                    goto _LOR_13;
                                  else 
                                    if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'&')) 
                                      goto _LOR_13;
                                    else 
                                      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'*')) 
                                        goto _LOR_13;
                                      else 
                                        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'!')) 
                                          goto _LOR_13;
                                        else 
                                          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'|')) 
                                            goto _LOR_13;
                                          else 
                                            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'>')) 
                                              goto _LOR_13;
                                            else 
                                              if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\'')) 
                                                goto _LOR_13;
                                              else 
                                                if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\"')) 
                                                  goto _LOR_13;
                                                else 
                                                  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'%')) 
                                                    goto _LOR_13;
                                                  else 
                                                    if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'@')) 
                                                      goto _LOR_13;
                                                    else 
                                                      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'`')) {
                                                        _LOR_13: ;
                                                        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'-')) {
                                                          if ((int)*(
                                                              parser->buffer.pointer + 1) == (int)((yaml_char_t)' ')) 
                                                            goto _LAND_29;
                                                          else 
                                                            if ((int)*(
                                                                parser->buffer.pointer + 1) == (int)((yaml_char_t)'\t')) 
                                                              goto _LAND_29;
                                                            else goto _LOR_11;
                                                        }
                                                        else 
                                                          _LAND_29:
                                                          if (! parser->flow_level) 
                                                            if ((int)*(
                                                                parser->buffer.pointer + 0) == (int)((yaml_char_t)'?')) 
                                                              goto _LOR_12;
                                                            else 
                                                              if ((int)*(
                                                                  parser->buffer.pointer + 0) == (int)((yaml_char_t)':')) {
                                                                _LOR_12: ;
                                                                if (! (
                                                                  (int)*(
                                                                  parser->buffer.pointer + 1) == (int)((yaml_char_t)' '))) 
                                                                  if (! (
                                                                    (int)*(
                                                                    parser->buffer.pointer + 1) == (int)((yaml_char_t)'\t'))) 
                                                                    if (! (
                                                                    (int)*(
                                                                    parser->buffer.pointer + 1) == (int)((yaml_char_t)'\r'))) 
                                                                    if (! (
                                                                    (int)*(
                                                                    parser->buffer.pointer + 1) == (int)((yaml_char_t)'\n'))) 
                                                                    if (
                                                                    (int)*(
                                                                    parser->buffer.pointer + 1) == (int)((yaml_char_t)'\302')) {
                                                                    if (! (
                                                                    (int)*(
                                                                    parser->buffer.pointer + (
                                                                    1 + 1)) == (int)((yaml_char_t)'\205'))) 
                                                                    goto _LAND_28;
                                                                    }
                                                                    else {
                                                                    _LAND_28:
                                                                    ;
                                                                    if (
                                                                    (int)*(
                                                                    parser->buffer.pointer + 1) == (int)((yaml_char_t)'\342')) {
                                                                    if (
                                                                    (int)*(
                                                                    parser->buffer.pointer + (
                                                                    1 + 1)) == (int)((yaml_char_t)'\200')) {
                                                                    if (! (
                                                                    (int)*(
                                                                    parser->buffer.pointer + (
                                                                    1 + 2)) == (int)((yaml_char_t)'\250'))) 
                                                                    goto _LAND_27;
                                                                    }
                                                                    else 
                                                                    goto _LAND_27;
                                                                    }
                                                                    else {
                                                                    _LAND_27:
                                                                    ;
                                                                    if (
                                                                    (int)*(
                                                                    parser->buffer.pointer + 1) == (int)((yaml_char_t)'\342')) {
                                                                    if (
                                                                    (int)*(
                                                                    parser->buffer.pointer + (
                                                                    1 + 1)) == (int)((yaml_char_t)'\200')) {
                                                                    if (! (
                                                                    (int)*(
                                                                    parser->buffer.pointer + (
                                                                    1 + 2)) == (int)((yaml_char_t)'\251'))) 
                                                                    goto _LAND_25;
                                                                    }
                                                                    else 
                                                                    goto _LAND_25;
                                                                    }
                                                                    else {
                                                                    _LAND_25:
                                                                    ;
                                                                    if (! (
                                                                    (int)*(
                                                                    parser->buffer.pointer + 1) == (int)((yaml_char_t)'\000'))) {
                                                                    int tmp_26;
                                                                    _LOR_11:
                                                                    tmp_26 = yaml_parser_fetch_plain_scalar
                                                                    (parser);
                                                                    __retres = tmp_26;
                                                                    goto return_label;
                                                                    }
                                                                    }
                                                                    }
                                                                    }
                                                              }
                                                      }
                                                      else goto _LOR_11;
              }
            }
          }
  tmp_27 = yaml_parser_set_scanner_error(parser,
                                         "while scanning for the next token",
                                         parser->mark,
                                         "found character that cannot start any token");
  __retres = tmp_27;
  return_label: return __retres;
}

static int yaml_parser_stale_simple_keys(yaml_parser_t *parser)
{
  int __retres;
  yaml_simple_key_t *simple_key;
  simple_key = parser->simple_keys.start;
  while (simple_key != parser->simple_keys.top) {
    if (simple_key->possible) 
      if (simple_key->mark.line < parser->mark.line) goto _LOR;
      else 
        if (simple_key->mark.index + (size_t)1024 < parser->mark.index) {
          _LOR:
          {
            if (simple_key->required) {
              int tmp;
              tmp = yaml_parser_set_scanner_error(parser,
                                                  "while scanning a simple key",
                                                  simple_key->mark,
                                                  "could not find expected \':\'");
              __retres = tmp;
              goto return_label;
            }
            simple_key->possible = 0;
          }
        }
    simple_key ++;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_save_simple_key(yaml_parser_t *parser)
{
  int __retres;
  int tmp;
  if (! parser->flow_level) 
    if ((ptrdiff_t)parser->indent == (ptrdiff_t)parser->mark.column) 
      tmp = 1;
    else tmp = 0;
  else tmp = 0;
  int required = tmp;
  if (parser->simple_key_allowed) {
    yaml_simple_key_t simple_key;
    int tmp_0;
    simple_key.possible = 1;
    simple_key.required = required;
    simple_key.token_number = parser->tokens_parsed + (size_t)(parser->tokens.tail - parser->tokens.head);
    simple_key.mark = parser->mark;
    tmp_0 = yaml_parser_remove_simple_key(parser);
    if (! tmp_0) {
      __retres = 0;
      goto return_label;
    }
    *(parser->simple_keys.top - 1) = simple_key;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_remove_simple_key(yaml_parser_t *parser)
{
  int __retres;
  yaml_simple_key_t *simple_key = parser->simple_keys.top - 1;
  if (simple_key->possible) 
    if (simple_key->required) {
      int tmp;
      tmp = yaml_parser_set_scanner_error(parser,
                                          "while scanning a simple key",
                                          simple_key->mark,
                                          "could not find expected \':\'");
      __retres = tmp;
      goto return_label;
    }
  simple_key->possible = 0;
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_increase_flow_level(yaml_parser_t *parser)
{
  int __retres;
  int tmp_1;
  yaml_simple_key_t empty_simple_key =
    {.possible = 0,
     .required = 0,
     .token_number = (size_t)0,
     .mark = {.index = (size_t)0, .line = (size_t)0, .column = (size_t)0}};
  if (parser->simple_keys.top != parser->simple_keys.end) goto _LOR;
  else {
    int tmp;
    tmp = yaml_stack_extend((void **)(& parser->simple_keys.start),
                            (void **)(& parser->simple_keys.top),
                            (void **)(& parser->simple_keys.end));
    if (tmp) {
      yaml_simple_key_t *tmp_0;
      _LOR: tmp_0 = parser->simple_keys.top;
      (parser->simple_keys.top) ++;
      *tmp_0 = empty_simple_key;
      tmp_1 = 1;
    }
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp_1 = 0;
    }
  }
  if (! tmp_1) {
    __retres = 0;
    goto return_label;
  }
  if (parser->flow_level == 2147483647) {
    parser->error = YAML_MEMORY_ERROR;
    __retres = 0;
    goto return_label;
  }
  (parser->flow_level) ++;
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_decrease_flow_level(yaml_parser_t *parser)
{
  int __retres;
  if (parser->flow_level) {
    (parser->flow_level) --;
    (parser->simple_keys.top) --;
    ;
  }
  __retres = 1;
  return __retres;
}

static int yaml_parser_roll_indent(yaml_parser_t *parser, ptrdiff_t column,
                                   ptrdiff_t number, yaml_token_type_t type,
                                   yaml_mark_t mark)
{
  int __retres;
  yaml_token_t token;
  if (parser->flow_level) {
    __retres = 1;
    goto return_label;
  }
  if ((ptrdiff_t)parser->indent < column) {
    int tmp_1;
    if (parser->indents.top != parser->indents.end) goto _LOR;
    else {
      int tmp;
      tmp = yaml_stack_extend((void **)(& parser->indents.start),
                              (void **)(& parser->indents.top),
                              (void **)(& parser->indents.end));
      if (tmp) {
        int *tmp_0;
        _LOR: tmp_0 = parser->indents.top;
        (parser->indents.top) ++;
        *tmp_0 = parser->indent;
        tmp_1 = 1;
      }
      else {
        parser->error = YAML_MEMORY_ERROR;
        tmp_1 = 0;
      }
    }
    if (! tmp_1) {
      __retres = 0;
      goto return_label;
    }
    if (column > (ptrdiff_t)2147483647) {
      parser->error = YAML_MEMORY_ERROR;
      __retres = 0;
      goto return_label;
    }
    parser->indent = (int)column;
    memset((void *)(& token),0,sizeof(yaml_token_t));
    token.type = type;
    token.start_mark = mark;
    token.end_mark = mark;
    if (number == (ptrdiff_t)(-1)) {
      int tmp_4;
      if (parser->tokens.tail != parser->tokens.end) goto _LOR_0;
      else {
        int tmp_2;
        tmp_2 = yaml_queue_extend((void **)(& parser->tokens.start),
                                  (void **)(& parser->tokens.head),
                                  (void **)(& parser->tokens.tail),
                                  (void **)(& parser->tokens.end));
        if (tmp_2) {
          yaml_token_t *tmp_3;
          _LOR_0: tmp_3 = parser->tokens.tail;
          (parser->tokens.tail) ++;
          *tmp_3 = token;
          tmp_4 = 1;
        }
        else {
          parser->error = YAML_MEMORY_ERROR;
          tmp_4 = 0;
        }
      }
      if (! tmp_4) {
        __retres = 0;
        goto return_label;
      }
    }
    else {
      int tmp_6;
      if (parser->tokens.tail != parser->tokens.end) goto _LOR_1;
      else {
        int tmp_5;
        tmp_5 = yaml_queue_extend((void **)(& parser->tokens.start),
                                  (void **)(& parser->tokens.head),
                                  (void **)(& parser->tokens.tail),
                                  (void **)(& parser->tokens.end));
        if (tmp_5) {
          _LOR_1:
          {
            memmove((void *)((parser->tokens.head + ((size_t)number - parser->tokens_parsed)) + 1),
                    (void const *)(parser->tokens.head + ((size_t)number - parser->tokens_parsed)),
                    ((size_t)(parser->tokens.tail - parser->tokens.head) - (
                     (size_t)number - parser->tokens_parsed)) * sizeof(*(parser->tokens.start)));
            *(parser->tokens.head + ((size_t)number - parser->tokens_parsed)) = token;
            (parser->tokens.tail) ++;
          }
          tmp_6 = 1;
        }
        else {
          parser->error = YAML_MEMORY_ERROR;
          tmp_6 = 0;
        }
      }
      if (! tmp_6) {
        __retres = 0;
        goto return_label;
      }
    }
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_unroll_indent(yaml_parser_t *parser, ptrdiff_t column)
{
  int __retres;
  yaml_token_t token;
  if (parser->flow_level) {
    __retres = 1;
    goto return_label;
  }
  while ((ptrdiff_t)parser->indent > column) {
    int tmp_1;
    memset((void *)(& token),0,sizeof(yaml_token_t));
    token.type = YAML_BLOCK_END_TOKEN;
    token.start_mark = parser->mark;
    token.end_mark = parser->mark;
    if (parser->tokens.tail != parser->tokens.end) goto _LOR;
    else {
      int tmp;
      tmp = yaml_queue_extend((void **)(& parser->tokens.start),
                              (void **)(& parser->tokens.head),
                              (void **)(& parser->tokens.tail),
                              (void **)(& parser->tokens.end));
      if (tmp) {
        yaml_token_t *tmp_0;
        _LOR: tmp_0 = parser->tokens.tail;
        (parser->tokens.tail) ++;
        *tmp_0 = token;
        tmp_1 = 1;
      }
      else {
        parser->error = YAML_MEMORY_ERROR;
        tmp_1 = 0;
      }
    }
    if (! tmp_1) {
      __retres = 0;
      goto return_label;
    }
    (parser->indents.top) --;
    parser->indent = *(parser->indents.top);
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_fetch_stream_start(yaml_parser_t *parser)
{
  int __retres;
  yaml_token_t token;
  int tmp_1;
  int tmp_4;
  yaml_simple_key_t simple_key =
    {.possible = 0,
     .required = 0,
     .token_number = (size_t)0,
     .mark = {.index = (size_t)0, .line = (size_t)0, .column = (size_t)0}};
  parser->indent = -1;
  if (parser->simple_keys.top != parser->simple_keys.end) goto _LOR;
  else {
    int tmp;
    tmp = yaml_stack_extend((void **)(& parser->simple_keys.start),
                            (void **)(& parser->simple_keys.top),
                            (void **)(& parser->simple_keys.end));
    if (tmp) {
      yaml_simple_key_t *tmp_0;
      _LOR: tmp_0 = parser->simple_keys.top;
      (parser->simple_keys.top) ++;
      *tmp_0 = simple_key;
      tmp_1 = 1;
    }
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp_1 = 0;
    }
  }
  if (! tmp_1) {
    __retres = 0;
    goto return_label;
  }
  parser->simple_key_allowed = 1;
  parser->stream_start_produced = 1;
  memset((void *)(& token),0,sizeof(yaml_token_t));
  token.type = YAML_STREAM_START_TOKEN;
  token.start_mark = parser->mark;
  token.end_mark = parser->mark;
  token.data.stream_start.encoding = parser->encoding;
  if (parser->tokens.tail != parser->tokens.end) goto _LOR_0;
  else {
    int tmp_2;
    tmp_2 = yaml_queue_extend((void **)(& parser->tokens.start),
                              (void **)(& parser->tokens.head),
                              (void **)(& parser->tokens.tail),
                              (void **)(& parser->tokens.end));
    if (tmp_2) {
      yaml_token_t *tmp_3;
      _LOR_0: tmp_3 = parser->tokens.tail;
      (parser->tokens.tail) ++;
      *tmp_3 = token;
      tmp_4 = 1;
    }
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp_4 = 0;
    }
  }
  if (! tmp_4) {
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_fetch_stream_end(yaml_parser_t *parser)
{
  int __retres;
  yaml_token_t token;
  int tmp;
  int tmp_0;
  int tmp_3;
  if (parser->mark.column != (size_t)0) {
    parser->mark.column = (size_t)0;
    (parser->mark.line) ++;
  }
  tmp = yaml_parser_unroll_indent(parser,(ptrdiff_t)(-1));
  if (! tmp) {
    __retres = 0;
    goto return_label;
  }
  tmp_0 = yaml_parser_remove_simple_key(parser);
  if (! tmp_0) {
    __retres = 0;
    goto return_label;
  }
  parser->simple_key_allowed = 0;
  memset((void *)(& token),0,sizeof(yaml_token_t));
  token.type = YAML_STREAM_END_TOKEN;
  token.start_mark = parser->mark;
  token.end_mark = parser->mark;
  if (parser->tokens.tail != parser->tokens.end) goto _LOR;
  else {
    int tmp_1;
    tmp_1 = yaml_queue_extend((void **)(& parser->tokens.start),
                              (void **)(& parser->tokens.head),
                              (void **)(& parser->tokens.tail),
                              (void **)(& parser->tokens.end));
    if (tmp_1) {
      yaml_token_t *tmp_2;
      _LOR: tmp_2 = parser->tokens.tail;
      (parser->tokens.tail) ++;
      *tmp_2 = token;
      tmp_3 = 1;
    }
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp_3 = 0;
    }
  }
  if (! tmp_3) {
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_fetch_directive(yaml_parser_t *parser)
{
  int __retres;
  yaml_token_t token;
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_4;
  tmp = yaml_parser_unroll_indent(parser,(ptrdiff_t)(-1));
  if (! tmp) {
    __retres = 0;
    goto return_label;
  }
  tmp_0 = yaml_parser_remove_simple_key(parser);
  if (! tmp_0) {
    __retres = 0;
    goto return_label;
  }
  parser->simple_key_allowed = 0;
  tmp_1 = yaml_parser_scan_directive(parser,& token);
  if (! tmp_1) {
    __retres = 0;
    goto return_label;
  }
  if (parser->tokens.tail != parser->tokens.end) goto _LOR;
  else {
    int tmp_2;
    tmp_2 = yaml_queue_extend((void **)(& parser->tokens.start),
                              (void **)(& parser->tokens.head),
                              (void **)(& parser->tokens.tail),
                              (void **)(& parser->tokens.end));
    if (tmp_2) {
      yaml_token_t *tmp_3;
      _LOR: tmp_3 = parser->tokens.tail;
      (parser->tokens.tail) ++;
      *tmp_3 = token;
      tmp_4 = 1;
    }
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp_4 = 0;
    }
  }
  if (! tmp_4) {
    yaml_token_delete(& token);
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_fetch_document_indicator(yaml_parser_t *parser,
                                                yaml_token_type_t type)
{
  int __retres;
  yaml_mark_t start_mark;
  yaml_mark_t end_mark;
  yaml_token_t token;
  int tmp;
  int tmp_0;
  int tmp_4;
  int tmp_8;
  int tmp_12;
  int tmp_15;
  tmp = yaml_parser_unroll_indent(parser,(ptrdiff_t)(-1));
  if (! tmp) {
    __retres = 0;
    goto return_label;
  }
  tmp_0 = yaml_parser_remove_simple_key(parser);
  if (! tmp_0) {
    __retres = 0;
    goto return_label;
  }
  parser->simple_key_allowed = 0;
  start_mark = parser->mark;
  (parser->mark.index) ++;
  (parser->mark.column) ++;
  (parser->unread) --;
  if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_4 = 1;
  else {
    int tmp_3;
    if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_3 = 2;
    else {
      int tmp_2;
      if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) tmp_2 = 3;
      else {
        int tmp_1;
        if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) tmp_1 = 4;
        else tmp_1 = 0;
        tmp_2 = tmp_1;
      }
      tmp_3 = tmp_2;
    }
    tmp_4 = tmp_3;
  }
  parser->buffer.pointer += tmp_4;
  (parser->mark.index) ++;
  (parser->mark.column) ++;
  (parser->unread) --;
  if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_8 = 1;
  else {
    int tmp_7;
    if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_7 = 2;
    else {
      int tmp_6;
      if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) tmp_6 = 3;
      else {
        int tmp_5;
        if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) tmp_5 = 4;
        else tmp_5 = 0;
        tmp_6 = tmp_5;
      }
      tmp_7 = tmp_6;
    }
    tmp_8 = tmp_7;
  }
  parser->buffer.pointer += tmp_8;
  (parser->mark.index) ++;
  (parser->mark.column) ++;
  (parser->unread) --;
  if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_12 = 1;
  else {
    int tmp_11;
    if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_11 = 2;
    else {
      int tmp_10;
      if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) tmp_10 = 3;
      else {
        int tmp_9;
        if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) tmp_9 = 4;
        else tmp_9 = 0;
        tmp_10 = tmp_9;
      }
      tmp_11 = tmp_10;
    }
    tmp_12 = tmp_11;
  }
  parser->buffer.pointer += tmp_12;
  end_mark = parser->mark;
  memset((void *)(& token),0,sizeof(yaml_token_t));
  token.type = type;
  token.start_mark = start_mark;
  token.end_mark = end_mark;
  if (parser->tokens.tail != parser->tokens.end) goto _LOR;
  else {
    int tmp_13;
    tmp_13 = yaml_queue_extend((void **)(& parser->tokens.start),
                               (void **)(& parser->tokens.head),
                               (void **)(& parser->tokens.tail),
                               (void **)(& parser->tokens.end));
    if (tmp_13) {
      yaml_token_t *tmp_14;
      _LOR: tmp_14 = parser->tokens.tail;
      (parser->tokens.tail) ++;
      *tmp_14 = token;
      tmp_15 = 1;
    }
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp_15 = 0;
    }
  }
  if (! tmp_15) {
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_fetch_flow_collection_start(yaml_parser_t *parser,
                                                   yaml_token_type_t type)
{
  int __retres;
  yaml_mark_t start_mark;
  yaml_mark_t end_mark;
  yaml_token_t token;
  int tmp;
  int tmp_0;
  int tmp_4;
  int tmp_7;
  tmp = yaml_parser_save_simple_key(parser);
  if (! tmp) {
    __retres = 0;
    goto return_label;
  }
  tmp_0 = yaml_parser_increase_flow_level(parser);
  if (! tmp_0) {
    __retres = 0;
    goto return_label;
  }
  parser->simple_key_allowed = 1;
  start_mark = parser->mark;
  (parser->mark.index) ++;
  (parser->mark.column) ++;
  (parser->unread) --;
  if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_4 = 1;
  else {
    int tmp_3;
    if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_3 = 2;
    else {
      int tmp_2;
      if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) tmp_2 = 3;
      else {
        int tmp_1;
        if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) tmp_1 = 4;
        else tmp_1 = 0;
        tmp_2 = tmp_1;
      }
      tmp_3 = tmp_2;
    }
    tmp_4 = tmp_3;
  }
  parser->buffer.pointer += tmp_4;
  end_mark = parser->mark;
  memset((void *)(& token),0,sizeof(yaml_token_t));
  token.type = type;
  token.start_mark = start_mark;
  token.end_mark = end_mark;
  if (parser->tokens.tail != parser->tokens.end) goto _LOR;
  else {
    int tmp_5;
    tmp_5 = yaml_queue_extend((void **)(& parser->tokens.start),
                              (void **)(& parser->tokens.head),
                              (void **)(& parser->tokens.tail),
                              (void **)(& parser->tokens.end));
    if (tmp_5) {
      yaml_token_t *tmp_6;
      _LOR: tmp_6 = parser->tokens.tail;
      (parser->tokens.tail) ++;
      *tmp_6 = token;
      tmp_7 = 1;
    }
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp_7 = 0;
    }
  }
  if (! tmp_7) {
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_fetch_flow_collection_end(yaml_parser_t *parser,
                                                 yaml_token_type_t type)
{
  int __retres;
  yaml_mark_t start_mark;
  yaml_mark_t end_mark;
  yaml_token_t token;
  int tmp;
  int tmp_0;
  int tmp_4;
  int tmp_7;
  tmp = yaml_parser_remove_simple_key(parser);
  if (! tmp) {
    __retres = 0;
    goto return_label;
  }
  tmp_0 = yaml_parser_decrease_flow_level(parser);
  if (! tmp_0) {
    __retres = 0;
    goto return_label;
  }
  parser->simple_key_allowed = 0;
  start_mark = parser->mark;
  (parser->mark.index) ++;
  (parser->mark.column) ++;
  (parser->unread) --;
  if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_4 = 1;
  else {
    int tmp_3;
    if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_3 = 2;
    else {
      int tmp_2;
      if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) tmp_2 = 3;
      else {
        int tmp_1;
        if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) tmp_1 = 4;
        else tmp_1 = 0;
        tmp_2 = tmp_1;
      }
      tmp_3 = tmp_2;
    }
    tmp_4 = tmp_3;
  }
  parser->buffer.pointer += tmp_4;
  end_mark = parser->mark;
  memset((void *)(& token),0,sizeof(yaml_token_t));
  token.type = type;
  token.start_mark = start_mark;
  token.end_mark = end_mark;
  if (parser->tokens.tail != parser->tokens.end) goto _LOR;
  else {
    int tmp_5;
    tmp_5 = yaml_queue_extend((void **)(& parser->tokens.start),
                              (void **)(& parser->tokens.head),
                              (void **)(& parser->tokens.tail),
                              (void **)(& parser->tokens.end));
    if (tmp_5) {
      yaml_token_t *tmp_6;
      _LOR: tmp_6 = parser->tokens.tail;
      (parser->tokens.tail) ++;
      *tmp_6 = token;
      tmp_7 = 1;
    }
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp_7 = 0;
    }
  }
  if (! tmp_7) {
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_fetch_flow_entry(yaml_parser_t *parser)
{
  int __retres;
  yaml_mark_t start_mark;
  yaml_mark_t end_mark;
  yaml_token_t token;
  int tmp;
  int tmp_3;
  int tmp_6;
  tmp = yaml_parser_remove_simple_key(parser);
  if (! tmp) {
    __retres = 0;
    goto return_label;
  }
  parser->simple_key_allowed = 1;
  start_mark = parser->mark;
  (parser->mark.index) ++;
  (parser->mark.column) ++;
  (parser->unread) --;
  if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_3 = 1;
  else {
    int tmp_2;
    if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_2 = 2;
    else {
      int tmp_1;
      if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) tmp_1 = 3;
      else {
        int tmp_0;
        if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) tmp_0 = 4;
        else tmp_0 = 0;
        tmp_1 = tmp_0;
      }
      tmp_2 = tmp_1;
    }
    tmp_3 = tmp_2;
  }
  parser->buffer.pointer += tmp_3;
  end_mark = parser->mark;
  memset((void *)(& token),0,sizeof(yaml_token_t));
  token.type = YAML_FLOW_ENTRY_TOKEN;
  token.start_mark = start_mark;
  token.end_mark = end_mark;
  if (parser->tokens.tail != parser->tokens.end) goto _LOR;
  else {
    int tmp_4;
    tmp_4 = yaml_queue_extend((void **)(& parser->tokens.start),
                              (void **)(& parser->tokens.head),
                              (void **)(& parser->tokens.tail),
                              (void **)(& parser->tokens.end));
    if (tmp_4) {
      yaml_token_t *tmp_5;
      _LOR: tmp_5 = parser->tokens.tail;
      (parser->tokens.tail) ++;
      *tmp_5 = token;
      tmp_6 = 1;
    }
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp_6 = 0;
    }
  }
  if (! tmp_6) {
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_fetch_block_entry(yaml_parser_t *parser)
{
  int __retres;
  yaml_mark_t start_mark;
  yaml_mark_t end_mark;
  yaml_token_t token;
  int tmp_1;
  int tmp_5;
  int tmp_8;
  if (! parser->flow_level) {
    int tmp_0;
    if (! parser->simple_key_allowed) {
      int tmp;
      tmp = yaml_parser_set_scanner_error(parser,(char const *)0,
                                          parser->mark,
                                          "block sequence entries are not allowed in this context");
      __retres = tmp;
      goto return_label;
    }
    tmp_0 = yaml_parser_roll_indent(parser,(ptrdiff_t)parser->mark.column,
                                    (ptrdiff_t)(-1),
                                    YAML_BLOCK_SEQUENCE_START_TOKEN,
                                    parser->mark);
    if (! tmp_0) {
      __retres = 0;
      goto return_label;
    }
  }
  tmp_1 = yaml_parser_remove_simple_key(parser);
  if (! tmp_1) {
    __retres = 0;
    goto return_label;
  }
  parser->simple_key_allowed = 1;
  start_mark = parser->mark;
  (parser->mark.index) ++;
  (parser->mark.column) ++;
  (parser->unread) --;
  if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_5 = 1;
  else {
    int tmp_4;
    if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_4 = 2;
    else {
      int tmp_3;
      if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) tmp_3 = 3;
      else {
        int tmp_2;
        if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) tmp_2 = 4;
        else tmp_2 = 0;
        tmp_3 = tmp_2;
      }
      tmp_4 = tmp_3;
    }
    tmp_5 = tmp_4;
  }
  parser->buffer.pointer += tmp_5;
  end_mark = parser->mark;
  memset((void *)(& token),0,sizeof(yaml_token_t));
  token.type = YAML_BLOCK_ENTRY_TOKEN;
  token.start_mark = start_mark;
  token.end_mark = end_mark;
  if (parser->tokens.tail != parser->tokens.end) goto _LOR;
  else {
    int tmp_6;
    tmp_6 = yaml_queue_extend((void **)(& parser->tokens.start),
                              (void **)(& parser->tokens.head),
                              (void **)(& parser->tokens.tail),
                              (void **)(& parser->tokens.end));
    if (tmp_6) {
      yaml_token_t *tmp_7;
      _LOR: tmp_7 = parser->tokens.tail;
      (parser->tokens.tail) ++;
      *tmp_7 = token;
      tmp_8 = 1;
    }
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp_8 = 0;
    }
  }
  if (! tmp_8) {
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_fetch_key(yaml_parser_t *parser)
{
  int __retres;
  yaml_mark_t start_mark;
  yaml_mark_t end_mark;
  yaml_token_t token;
  int tmp_1;
  int tmp_5;
  int tmp_8;
  if (! parser->flow_level) {
    int tmp_0;
    if (! parser->simple_key_allowed) {
      int tmp;
      tmp = yaml_parser_set_scanner_error(parser,(char const *)0,
                                          parser->mark,
                                          "mapping keys are not allowed in this context");
      __retres = tmp;
      goto return_label;
    }
    tmp_0 = yaml_parser_roll_indent(parser,(ptrdiff_t)parser->mark.column,
                                    (ptrdiff_t)(-1),
                                    YAML_BLOCK_MAPPING_START_TOKEN,
                                    parser->mark);
    if (! tmp_0) {
      __retres = 0;
      goto return_label;
    }
  }
  tmp_1 = yaml_parser_remove_simple_key(parser);
  if (! tmp_1) {
    __retres = 0;
    goto return_label;
  }
  parser->simple_key_allowed = ! parser->flow_level;
  start_mark = parser->mark;
  (parser->mark.index) ++;
  (parser->mark.column) ++;
  (parser->unread) --;
  if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_5 = 1;
  else {
    int tmp_4;
    if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_4 = 2;
    else {
      int tmp_3;
      if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) tmp_3 = 3;
      else {
        int tmp_2;
        if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) tmp_2 = 4;
        else tmp_2 = 0;
        tmp_3 = tmp_2;
      }
      tmp_4 = tmp_3;
    }
    tmp_5 = tmp_4;
  }
  parser->buffer.pointer += tmp_5;
  end_mark = parser->mark;
  memset((void *)(& token),0,sizeof(yaml_token_t));
  token.type = YAML_KEY_TOKEN;
  token.start_mark = start_mark;
  token.end_mark = end_mark;
  if (parser->tokens.tail != parser->tokens.end) goto _LOR;
  else {
    int tmp_6;
    tmp_6 = yaml_queue_extend((void **)(& parser->tokens.start),
                              (void **)(& parser->tokens.head),
                              (void **)(& parser->tokens.tail),
                              (void **)(& parser->tokens.end));
    if (tmp_6) {
      yaml_token_t *tmp_7;
      _LOR: tmp_7 = parser->tokens.tail;
      (parser->tokens.tail) ++;
      *tmp_7 = token;
      tmp_8 = 1;
    }
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp_8 = 0;
    }
  }
  if (! tmp_8) {
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_fetch_value(yaml_parser_t *parser)
{
  int __retres;
  yaml_mark_t start_mark;
  yaml_mark_t end_mark;
  yaml_token_t token;
  int tmp_7;
  int tmp_10;
  yaml_simple_key_t *simple_key = parser->simple_keys.top - 1;
  if (simple_key->possible) {
    int tmp_0;
    int tmp_1;
    memset((void *)(& token),0,sizeof(yaml_token_t));
    token.type = YAML_KEY_TOKEN;
    token.start_mark = simple_key->mark;
    token.end_mark = simple_key->mark;
    if (parser->tokens.tail != parser->tokens.end) goto _LOR;
    else {
      int tmp;
      tmp = yaml_queue_extend((void **)(& parser->tokens.start),
                              (void **)(& parser->tokens.head),
                              (void **)(& parser->tokens.tail),
                              (void **)(& parser->tokens.end));
      if (tmp) {
        _LOR:
        {
          memmove((void *)((parser->tokens.head + (simple_key->token_number - parser->tokens_parsed)) + 1),
                  (void const *)(parser->tokens.head + (simple_key->token_number - parser->tokens_parsed)),
                  ((size_t)(parser->tokens.tail - parser->tokens.head) - (
                   simple_key->token_number - parser->tokens_parsed)) * sizeof(*(parser->tokens.start)));
          *(parser->tokens.head + (simple_key->token_number - parser->tokens_parsed)) = token;
          (parser->tokens.tail) ++;
        }
        tmp_0 = 1;
      }
      else {
        parser->error = YAML_MEMORY_ERROR;
        tmp_0 = 0;
      }
    }
    if (! tmp_0) {
      __retres = 0;
      goto return_label;
    }
    tmp_1 = yaml_parser_roll_indent(parser,
                                    (ptrdiff_t)simple_key->mark.column,
                                    (ptrdiff_t)simple_key->token_number,
                                    YAML_BLOCK_MAPPING_START_TOKEN,
                                    simple_key->mark);
    if (! tmp_1) {
      __retres = 0;
      goto return_label;
    }
    simple_key->possible = 0;
    parser->simple_key_allowed = 0;
  }
  else {
    if (! parser->flow_level) {
      int tmp_3;
      if (! parser->simple_key_allowed) {
        int tmp_2;
        tmp_2 = yaml_parser_set_scanner_error(parser,(char const *)0,
                                              parser->mark,
                                              "mapping values are not allowed in this context");
        __retres = tmp_2;
        goto return_label;
      }
      tmp_3 = yaml_parser_roll_indent(parser,(ptrdiff_t)parser->mark.column,
                                      (ptrdiff_t)(-1),
                                      YAML_BLOCK_MAPPING_START_TOKEN,
                                      parser->mark);
      if (! tmp_3) {
        __retres = 0;
        goto return_label;
      }
    }
    parser->simple_key_allowed = ! parser->flow_level;
  }
  start_mark = parser->mark;
  (parser->mark.index) ++;
  (parser->mark.column) ++;
  (parser->unread) --;
  if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_7 = 1;
  else {
    int tmp_6;
    if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_6 = 2;
    else {
      int tmp_5;
      if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) tmp_5 = 3;
      else {
        int tmp_4;
        if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) tmp_4 = 4;
        else tmp_4 = 0;
        tmp_5 = tmp_4;
      }
      tmp_6 = tmp_5;
    }
    tmp_7 = tmp_6;
  }
  parser->buffer.pointer += tmp_7;
  end_mark = parser->mark;
  memset((void *)(& token),0,sizeof(yaml_token_t));
  token.type = YAML_VALUE_TOKEN;
  token.start_mark = start_mark;
  token.end_mark = end_mark;
  if (parser->tokens.tail != parser->tokens.end) goto _LOR_0;
  else {
    int tmp_8;
    tmp_8 = yaml_queue_extend((void **)(& parser->tokens.start),
                              (void **)(& parser->tokens.head),
                              (void **)(& parser->tokens.tail),
                              (void **)(& parser->tokens.end));
    if (tmp_8) {
      yaml_token_t *tmp_9;
      _LOR_0: tmp_9 = parser->tokens.tail;
      (parser->tokens.tail) ++;
      *tmp_9 = token;
      tmp_10 = 1;
    }
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp_10 = 0;
    }
  }
  if (! tmp_10) {
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_fetch_anchor(yaml_parser_t *parser,
                                    yaml_token_type_t type)
{
  int __retres;
  yaml_token_t token;
  int tmp;
  int tmp_0;
  int tmp_3;
  tmp = yaml_parser_save_simple_key(parser);
  if (! tmp) {
    __retres = 0;
    goto return_label;
  }
  parser->simple_key_allowed = 0;
  tmp_0 = yaml_parser_scan_anchor(parser,& token,type);
  if (! tmp_0) {
    __retres = 0;
    goto return_label;
  }
  if (parser->tokens.tail != parser->tokens.end) goto _LOR;
  else {
    int tmp_1;
    tmp_1 = yaml_queue_extend((void **)(& parser->tokens.start),
                              (void **)(& parser->tokens.head),
                              (void **)(& parser->tokens.tail),
                              (void **)(& parser->tokens.end));
    if (tmp_1) {
      yaml_token_t *tmp_2;
      _LOR: tmp_2 = parser->tokens.tail;
      (parser->tokens.tail) ++;
      *tmp_2 = token;
      tmp_3 = 1;
    }
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp_3 = 0;
    }
  }
  if (! tmp_3) {
    yaml_token_delete(& token);
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_fetch_tag(yaml_parser_t *parser)
{
  int __retres;
  yaml_token_t token;
  int tmp;
  int tmp_0;
  int tmp_3;
  tmp = yaml_parser_save_simple_key(parser);
  if (! tmp) {
    __retres = 0;
    goto return_label;
  }
  parser->simple_key_allowed = 0;
  tmp_0 = yaml_parser_scan_tag(parser,& token);
  if (! tmp_0) {
    __retres = 0;
    goto return_label;
  }
  if (parser->tokens.tail != parser->tokens.end) goto _LOR;
  else {
    int tmp_1;
    tmp_1 = yaml_queue_extend((void **)(& parser->tokens.start),
                              (void **)(& parser->tokens.head),
                              (void **)(& parser->tokens.tail),
                              (void **)(& parser->tokens.end));
    if (tmp_1) {
      yaml_token_t *tmp_2;
      _LOR: tmp_2 = parser->tokens.tail;
      (parser->tokens.tail) ++;
      *tmp_2 = token;
      tmp_3 = 1;
    }
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp_3 = 0;
    }
  }
  if (! tmp_3) {
    yaml_token_delete(& token);
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_fetch_block_scalar(yaml_parser_t *parser, int literal)
{
  int __retres;
  yaml_token_t token;
  int tmp;
  int tmp_0;
  int tmp_3;
  tmp = yaml_parser_remove_simple_key(parser);
  if (! tmp) {
    __retres = 0;
    goto return_label;
  }
  parser->simple_key_allowed = 1;
  tmp_0 = yaml_parser_scan_block_scalar(parser,& token,literal);
  if (! tmp_0) {
    __retres = 0;
    goto return_label;
  }
  if (parser->tokens.tail != parser->tokens.end) goto _LOR;
  else {
    int tmp_1;
    tmp_1 = yaml_queue_extend((void **)(& parser->tokens.start),
                              (void **)(& parser->tokens.head),
                              (void **)(& parser->tokens.tail),
                              (void **)(& parser->tokens.end));
    if (tmp_1) {
      yaml_token_t *tmp_2;
      _LOR: tmp_2 = parser->tokens.tail;
      (parser->tokens.tail) ++;
      *tmp_2 = token;
      tmp_3 = 1;
    }
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp_3 = 0;
    }
  }
  if (! tmp_3) {
    yaml_token_delete(& token);
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_fetch_flow_scalar(yaml_parser_t *parser, int single)
{
  int __retres;
  yaml_token_t token;
  int tmp;
  int tmp_0;
  int tmp_3;
  tmp = yaml_parser_save_simple_key(parser);
  if (! tmp) {
    __retres = 0;
    goto return_label;
  }
  parser->simple_key_allowed = 0;
  tmp_0 = yaml_parser_scan_flow_scalar(parser,& token,single);
  if (! tmp_0) {
    __retres = 0;
    goto return_label;
  }
  if (parser->tokens.tail != parser->tokens.end) goto _LOR;
  else {
    int tmp_1;
    tmp_1 = yaml_queue_extend((void **)(& parser->tokens.start),
                              (void **)(& parser->tokens.head),
                              (void **)(& parser->tokens.tail),
                              (void **)(& parser->tokens.end));
    if (tmp_1) {
      yaml_token_t *tmp_2;
      _LOR: tmp_2 = parser->tokens.tail;
      (parser->tokens.tail) ++;
      *tmp_2 = token;
      tmp_3 = 1;
    }
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp_3 = 0;
    }
  }
  if (! tmp_3) {
    yaml_token_delete(& token);
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_fetch_plain_scalar(yaml_parser_t *parser)
{
  int __retres;
  yaml_token_t token;
  int tmp;
  int tmp_0;
  int tmp_3;
  tmp = yaml_parser_save_simple_key(parser);
  if (! tmp) {
    __retres = 0;
    goto return_label;
  }
  parser->simple_key_allowed = 0;
  tmp_0 = yaml_parser_scan_plain_scalar(parser,& token);
  if (! tmp_0) {
    __retres = 0;
    goto return_label;
  }
  if (parser->tokens.tail != parser->tokens.end) goto _LOR;
  else {
    int tmp_1;
    tmp_1 = yaml_queue_extend((void **)(& parser->tokens.start),
                              (void **)(& parser->tokens.head),
                              (void **)(& parser->tokens.tail),
                              (void **)(& parser->tokens.end));
    if (tmp_1) {
      yaml_token_t *tmp_2;
      _LOR: tmp_2 = parser->tokens.tail;
      (parser->tokens.tail) ++;
      *tmp_2 = token;
      tmp_3 = 1;
    }
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp_3 = 0;
    }
  }
  if (! tmp_3) {
    yaml_token_delete(& token);
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_scan_to_next_token(yaml_parser_t *parser)
{
  int __retres;
  while (1) {
    {
      int tmp_0;
      int tmp_6;
      if (parser->unread >= (size_t)1) tmp_0 = 1;
      else tmp_0 = yaml_parser_update_buffer(parser,(size_t)1);
      if (! tmp_0) {
        __retres = 0;
        goto return_label;
      }
      if (parser->mark.column == (size_t)0) 
        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\357')) 
          if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\273')) 
            if ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\277')) {
              int tmp_4;
              (parser->mark.index) ++;
              (parser->mark.column) ++;
              (parser->unread) --;
              if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) 
                tmp_4 = 1;
              else {
                int tmp_3;
                if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) 
                  tmp_3 = 2;
                else {
                  int tmp_2;
                  if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) 
                    tmp_2 = 3;
                  else {
                    int tmp_1;
                    if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
                      tmp_1 = 4;
                    else tmp_1 = 0;
                    tmp_2 = tmp_1;
                  }
                  tmp_3 = tmp_2;
                }
                tmp_4 = tmp_3;
              }
              parser->buffer.pointer += tmp_4;
            }
      if (parser->unread >= (size_t)1) tmp_6 = 1;
      else tmp_6 = yaml_parser_update_buffer(parser,(size_t)1);
      if (! tmp_6) {
        __retres = 0;
        goto return_label;
      }
      while (1) {
        if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)' '))) 
          if (parser->flow_level) goto _LOR;
          else 
            if (! parser->simple_key_allowed) {
              _LOR: ;
              if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\t'))) 
                break;
            }
            else break;
        {
          int tmp_10;
          int tmp_12;
          (parser->mark.index) ++;
          (parser->mark.column) ++;
          (parser->unread) --;
          if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_10 = 1;
          else {
            int tmp_9;
            if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) 
              tmp_9 = 2;
            else {
              int tmp_8;
              if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) 
                tmp_8 = 3;
              else {
                int tmp_7;
                if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
                  tmp_7 = 4;
                else tmp_7 = 0;
                tmp_8 = tmp_7;
              }
              tmp_9 = tmp_8;
            }
            tmp_10 = tmp_9;
          }
          parser->buffer.pointer += tmp_10;
          if (parser->unread >= (size_t)1) tmp_12 = 1;
          else tmp_12 = yaml_parser_update_buffer(parser,(size_t)1);
          if (! tmp_12) {
            __retres = 0;
            goto return_label;
          }
        }
      }
      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'#')) 
        while (1) {
          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) 
            break;
          else 
            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n')) 
              break;
            else 
              if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
                if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\205')) 
                  break;
                else goto _LAND_3;
              }
              else {
                _LAND_3: ;
                if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
                  if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                    if ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\250')) 
                      break;
                    else goto _LAND_2;
                  }
                  else goto _LAND_2;
                }
                else {
                  _LAND_2: ;
                  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
                    if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                      if ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\251')) 
                        break;
                      else goto _LAND_0;
                    }
                    else goto _LAND_0;
                  }
                  else {
                    _LAND_0: ;
                    if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\000')) 
                      break;
                  }
                }
              }
          {
            int tmp_16;
            int tmp_18;
            (parser->mark.index) ++;
            (parser->mark.column) ++;
            (parser->unread) --;
            if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) 
              tmp_16 = 1;
            else {
              int tmp_15;
              if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) 
                tmp_15 = 2;
              else {
                int tmp_14;
                if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) 
                  tmp_14 = 3;
                else {
                  int tmp_13;
                  if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
                    tmp_13 = 4;
                  else tmp_13 = 0;
                  tmp_14 = tmp_13;
                }
                tmp_15 = tmp_14;
              }
              tmp_16 = tmp_15;
            }
            parser->buffer.pointer += tmp_16;
            if (parser->unread >= (size_t)1) tmp_18 = 1;
            else tmp_18 = yaml_parser_update_buffer(parser,(size_t)1);
            if (! tmp_18) {
              __retres = 0;
              goto return_label;
            }
          }
        }
      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) 
        goto _LOR_1;
      else 
        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n')) 
          goto _LOR_1;
        else 
          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
            if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\205')) 
              goto _LOR_1;
            else goto _LAND_12;
          }
          else {
            _LAND_12: ;
            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
              if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                if ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\250')) 
                  goto _LOR_1;
                else goto _LAND_11;
              }
              else goto _LAND_11;
            }
            else {
              _LAND_11: ;
              if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
                if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                  if ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\251')) {
                    _LOR_1:
                    {
                      int tmp_20;
                      if (parser->unread >= (size_t)2) tmp_20 = 1;
                      else tmp_20 = yaml_parser_update_buffer(parser,
                                                              (size_t)2);
                      if (! tmp_20) {
                        __retres = 0;
                        goto return_label;
                      }
                      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) {
                        if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\n')) {
                          parser->mark.index += (size_t)2;
                          parser->mark.column = (size_t)0;
                          (parser->mark.line) ++;
                          parser->unread -= (size_t)2;
                          parser->buffer.pointer += 2;
                          yaml_char_t *tmp_27 = parser->buffer.pointer;
                        }
                        else goto _LAND_7;
                      }
                      else {
                        _LAND_7: ;
                        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) 
                          goto _LOR_0;
                        else 
                          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n')) 
                            goto _LOR_0;
                          else 
                            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
                              if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\205')) 
                                goto _LOR_0;
                              else goto _LAND_6;
                            }
                            else {
                              _LAND_6: ;
                              if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
                                if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                                  if ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\250')) 
                                    goto _LOR_0;
                                  else goto _LAND_5;
                                }
                                else goto _LAND_5;
                              }
                              else {
                                _LAND_5: ;
                                if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) 
                                  if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) 
                                    if ((int)*(parser->buffer.pointer + (
                                               0 + 2)) == (int)((yaml_char_t)'\251')) {
                                      int tmp_24;
                                      _LOR_0: (parser->mark.index) ++;
                                      parser->mark.column = (size_t)0;
                                      (parser->mark.line) ++;
                                      (parser->unread) --;
                                      if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) 
                                        tmp_24 = 1;
                                      else {
                                        int tmp_23;
                                        if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) 
                                          tmp_23 = 2;
                                        else {
                                          int tmp_22;
                                          if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) 
                                            tmp_22 = 3;
                                          else {
                                            int tmp_21;
                                            if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
                                              tmp_21 = 4;
                                            else tmp_21 = 0;
                                            tmp_22 = tmp_21;
                                          }
                                          tmp_23 = tmp_22;
                                        }
                                        tmp_24 = tmp_23;
                                      }
                                      parser->buffer.pointer += tmp_24;
                                      yaml_char_t *tmp_25 =
                                        parser->buffer.pointer;
                                    }
                              }
                            }
                      }
                      if (! parser->flow_level) parser->simple_key_allowed = 1;
                    }
                  }
                  else goto _LAND_9;
                }
                else goto _LAND_9;
              }
              else _LAND_9: break;
            }
          }
    }
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_scan_directive(yaml_parser_t *parser,
                                      yaml_token_t *token)
{
  int __retres;
  yaml_mark_t start_mark;
  yaml_mark_t end_mark;
  int major;
  int minor;
  int tmp_2;
  int tmp_3;
  int tmp_7;
  int tmp_9;
  yaml_char_t *name = (yaml_char_t *)0;
  yaml_char_t *handle = (yaml_char_t *)0;
  yaml_char_t *prefix = (yaml_char_t *)0;
  start_mark = parser->mark;
  (parser->mark.index) ++;
  (parser->mark.column) ++;
  (parser->unread) --;
  if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_2 = 1;
  else {
    int tmp_1;
    if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_1 = 2;
    else {
      int tmp_0;
      if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) tmp_0 = 3;
      else {
        int tmp;
        if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) tmp = 4;
        else tmp = 0;
        tmp_0 = tmp;
      }
      tmp_1 = tmp_0;
    }
    tmp_2 = tmp_1;
  }
  parser->buffer.pointer += tmp_2;
  tmp_3 = yaml_parser_scan_directive_name(parser,start_mark,& name);
  if (! tmp_3) goto error;
  tmp_7 = strcmp((char const *)name,"YAML");
  if (tmp_7 == 0) {
    int tmp_4;
    tmp_4 = yaml_parser_scan_version_directive_value(parser,start_mark,
                                                     & major,& minor);
    if (! tmp_4) goto error;
    end_mark = parser->mark;
    memset((void *)token,0,sizeof(yaml_token_t));
    token->type = YAML_VERSION_DIRECTIVE_TOKEN;
    token->start_mark = start_mark;
    token->end_mark = end_mark;
    token->data.version_directive.major = major;
    token->data.version_directive.minor = minor;
  }
  else {
    int tmp_6;
    tmp_6 = strcmp((char const *)name,"TAG");
    if (tmp_6 == 0) {
      int tmp_5;
      tmp_5 = yaml_parser_scan_tag_directive_value(parser,start_mark,
                                                   & handle,& prefix);
      if (! tmp_5) goto error;
      end_mark = parser->mark;
      memset((void *)token,0,sizeof(yaml_token_t));
      token->type = YAML_TAG_DIRECTIVE_TOKEN;
      token->start_mark = start_mark;
      token->end_mark = end_mark;
      token->data.tag_directive.handle = handle;
      token->data.tag_directive.prefix = prefix;
    }
    else {
      yaml_parser_set_scanner_error(parser,"while scanning a directive",
                                    start_mark,
                                    "found unknown directive name");
      goto error;
    }
  }
  if (parser->unread >= (size_t)1) tmp_9 = 1;
  else tmp_9 = yaml_parser_update_buffer(parser,(size_t)1);
  if (! tmp_9) goto error;
  while (1) {
    if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)' '))) 
      if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\t'))) 
        break;
    {
      int tmp_13;
      int tmp_15;
      (parser->mark.index) ++;
      (parser->mark.column) ++;
      (parser->unread) --;
      if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_13 = 1;
      else {
        int tmp_12;
        if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_12 = 2;
        else {
          int tmp_11;
          if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) tmp_11 = 3;
          else {
            int tmp_10;
            if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
              tmp_10 = 4;
            else tmp_10 = 0;
            tmp_11 = tmp_10;
          }
          tmp_12 = tmp_11;
        }
        tmp_13 = tmp_12;
      }
      parser->buffer.pointer += tmp_13;
      if (parser->unread >= (size_t)1) tmp_15 = 1;
      else tmp_15 = yaml_parser_update_buffer(parser,(size_t)1);
      if (! tmp_15) goto error;
    }
  }
  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'#')) 
    while (1) {
      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) 
        break;
      else 
        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n')) 
          break;
        else 
          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
            if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\205')) 
              break;
            else goto _LAND_3;
          }
          else {
            _LAND_3: ;
            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
              if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                if ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\250')) 
                  break;
                else goto _LAND_2;
              }
              else goto _LAND_2;
            }
            else {
              _LAND_2: ;
              if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
                if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                  if ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\251')) 
                    break;
                  else goto _LAND_0;
                }
                else goto _LAND_0;
              }
              else {
                _LAND_0: ;
                if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\000')) 
                  break;
              }
            }
          }
      {
        int tmp_19;
        int tmp_21;
        (parser->mark.index) ++;
        (parser->mark.column) ++;
        (parser->unread) --;
        if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_19 = 1;
        else {
          int tmp_18;
          if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_18 = 2;
          else {
            int tmp_17;
            if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) 
              tmp_17 = 3;
            else {
              int tmp_16;
              if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
                tmp_16 = 4;
              else tmp_16 = 0;
              tmp_17 = tmp_16;
            }
            tmp_18 = tmp_17;
          }
          tmp_19 = tmp_18;
        }
        parser->buffer.pointer += tmp_19;
        if (parser->unread >= (size_t)1) tmp_21 = 1;
        else tmp_21 = yaml_parser_update_buffer(parser,(size_t)1);
        if (! tmp_21) goto error;
      }
    }
  if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r'))) 
    if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n'))) 
      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
        if (! ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\205'))) 
          goto _LAND_8;
      }
      else {
        _LAND_8: ;
        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
          if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
            if (! ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\250'))) 
              goto _LAND_7;
          }
          else goto _LAND_7;
        }
        else {
          _LAND_7: ;
          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
            if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
              if (! ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\251'))) 
                goto _LAND_5;
            }
            else goto _LAND_5;
          }
          else {
            _LAND_5: ;
            if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\000'))) {
              yaml_parser_set_scanner_error(parser,
                                            "while scanning a directive",
                                            start_mark,
                                            "did not find expected comment or line break");
              goto error;
            }
          }
        }
      }
  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) 
    goto _LOR_0;
  else 
    if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n')) 
      goto _LOR_0;
    else 
      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
        if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\205')) 
          goto _LOR_0;
        else goto _LAND_15;
      }
      else {
        _LAND_15: ;
        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
          if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
            if ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\250')) 
              goto _LOR_0;
            else goto _LAND_14;
          }
          else goto _LAND_14;
        }
        else {
          _LAND_14: ;
          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) 
            if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) 
              if ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\251')) {
                _LOR_0:
                {
                  int tmp_23;
                  if (parser->unread >= (size_t)2) tmp_23 = 1;
                  else tmp_23 = yaml_parser_update_buffer(parser,(size_t)2);
                  if (! tmp_23) goto error;
                  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) {
                    if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\n')) {
                      parser->mark.index += (size_t)2;
                      parser->mark.column = (size_t)0;
                      (parser->mark.line) ++;
                      parser->unread -= (size_t)2;
                      parser->buffer.pointer += 2;
                      yaml_char_t *tmp_30 = parser->buffer.pointer;
                    }
                    else goto _LAND_12;
                  }
                  else {
                    _LAND_12: ;
                    if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) 
                      goto _LOR;
                    else 
                      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n')) 
                        goto _LOR;
                      else 
                        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
                          if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\205')) 
                            goto _LOR;
                          else goto _LAND_11;
                        }
                        else {
                          _LAND_11: ;
                          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
                            if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                              if ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\250')) 
                                goto _LOR;
                              else goto _LAND_10;
                            }
                            else goto _LAND_10;
                          }
                          else {
                            _LAND_10: ;
                            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) 
                              if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) 
                                if ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\251')) {
                                  int tmp_27;
                                  _LOR: (parser->mark.index) ++;
                                  parser->mark.column = (size_t)0;
                                  (parser->mark.line) ++;
                                  (parser->unread) --;
                                  if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) 
                                    tmp_27 = 1;
                                  else {
                                    int tmp_26;
                                    if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) 
                                      tmp_26 = 2;
                                    else {
                                      int tmp_25;
                                      if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) 
                                        tmp_25 = 3;
                                      else {
                                        int tmp_24;
                                        if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
                                          tmp_24 = 4;
                                        else tmp_24 = 0;
                                        tmp_25 = tmp_24;
                                      }
                                      tmp_26 = tmp_25;
                                    }
                                    tmp_27 = tmp_26;
                                  }
                                  parser->buffer.pointer += tmp_27;
                                  yaml_char_t *tmp_28 =
                                    parser->buffer.pointer;
                                }
                          }
                        }
                  }
                }
              }
        }
      }
  yaml_free((void *)name);
  __retres = 1;
  goto return_label;
  error: yaml_free((void *)prefix);
  yaml_free((void *)handle);
  yaml_free((void *)name);
  __retres = 0;
  return_label: return __retres;
}

static int yaml_parser_scan_directive_name(yaml_parser_t *parser,
                                           yaml_mark_t start_mark,
                                           yaml_char_t **name)
{
  int __retres;
  int tmp_0;
  int tmp_2;
  yaml_string_t string =
    {.start = (yaml_char_t *)0,
     .end = (yaml_char_t *)0,
     .pointer = (yaml_char_t *)0};
  string.start = (yaml_char_t *)yaml_malloc((size_t)16);
  if (string.start) {
    string.pointer = string.start;
    string.end = string.start + 16;
    memset((void *)string.start,0,(size_t)16);
    tmp_0 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_0 = 0;
  }
  if (! tmp_0) goto error;
  if (parser->unread >= (size_t)1) tmp_2 = 1;
  else tmp_2 = yaml_parser_update_buffer(parser,(size_t)1);
  if (! tmp_2) goto error;
  while (1) {
    if ((int)*(parser->buffer.pointer + 0) >= (int)((yaml_char_t)'0')) {
      if (! ((int)*(parser->buffer.pointer + 0) <= (int)((yaml_char_t)'9'))) 
        goto _LAND_1;
    }
    else {
      _LAND_1: ;
      if ((int)*(parser->buffer.pointer + 0) >= (int)((yaml_char_t)'A')) {
        if (! ((int)*(parser->buffer.pointer + 0) <= (int)((yaml_char_t)'Z'))) 
          goto _LAND_0;
      }
      else {
        _LAND_0: ;
        if ((int)*(parser->buffer.pointer + 0) >= (int)((yaml_char_t)'a')) {
          if (! ((int)*(parser->buffer.pointer + 0) <= (int)((yaml_char_t)'z'))) 
            goto _LAND;
        }
        else {
          _LAND: ;
          if (! ((int)*(parser->buffer.pointer + 0) == '_')) 
            if (! ((int)*(parser->buffer.pointer + 0) == '-')) break;
        }
      }
    }
    {
      int tmp_25_1;
      int tmp_4;
      int tmp_27_1;
      if (string.pointer + 5 < string.end) tmp_4 = 1;
      else {
        int tmp_3;
        tmp_3 = yaml_string_extend(& string.start,& string.pointer,
                                   & string.end);
        if (tmp_3) tmp_4 = 1;
        else {
          parser->error = YAML_MEMORY_ERROR;
          tmp_4 = 0;
        }
      }
      if (tmp_4) {
        if (((int)*(parser->buffer.pointer) & 0x80) == 0x00) {
          yaml_char_t *tmp_5;
          yaml_char_t *tmp_6;
          tmp_5 = string.pointer;
          (string.pointer) ++;
          tmp_6 = parser->buffer.pointer;
          (parser->buffer.pointer) ++;
          *tmp_5 = *tmp_6;
          yaml_char_t tmp_31 = *tmp_5;
        }
        else 
          if (((int)*(parser->buffer.pointer) & 0xE0) == 0xC0) {
            yaml_char_t *tmp_7;
            yaml_char_t *tmp_8;
            yaml_char_t *tmp_9;
            yaml_char_t *tmp_10;
            tmp_7 = string.pointer;
            (string.pointer) ++;
            tmp_8 = parser->buffer.pointer;
            (parser->buffer.pointer) ++;
            *tmp_7 = *tmp_8;
            tmp_9 = string.pointer;
            (string.pointer) ++;
            tmp_10 = parser->buffer.pointer;
            (parser->buffer.pointer) ++;
            *tmp_9 = *tmp_10;
            yaml_char_t tmp_29 = *tmp_9;
          }
          else 
            if (((int)*(parser->buffer.pointer) & 0xF0) == 0xE0) {
              yaml_char_t *tmp_11;
              yaml_char_t *tmp_12;
              yaml_char_t *tmp_13;
              yaml_char_t *tmp_14;
              yaml_char_t *tmp_15;
              yaml_char_t *tmp_16;
              tmp_11 = string.pointer;
              (string.pointer) ++;
              tmp_12 = parser->buffer.pointer;
              (parser->buffer.pointer) ++;
              *tmp_11 = *tmp_12;
              tmp_13 = string.pointer;
              (string.pointer) ++;
              tmp_14 = parser->buffer.pointer;
              (parser->buffer.pointer) ++;
              *tmp_13 = *tmp_14;
              tmp_15 = string.pointer;
              (string.pointer) ++;
              tmp_16 = parser->buffer.pointer;
              (parser->buffer.pointer) ++;
              *tmp_15 = *tmp_16;
              yaml_char_t tmp_27 = *tmp_15;
            }
            else 
              if (((int)*(parser->buffer.pointer) & 0xF8) == 0xF0) {
                yaml_char_t *tmp_17;
                yaml_char_t *tmp_18;
                yaml_char_t *tmp_19;
                yaml_char_t *tmp_20;
                yaml_char_t *tmp_21;
                yaml_char_t *tmp_22;
                yaml_char_t *tmp_23;
                yaml_char_t *tmp_24;
                tmp_17 = string.pointer;
                (string.pointer) ++;
                tmp_18 = parser->buffer.pointer;
                (parser->buffer.pointer) ++;
                *tmp_17 = *tmp_18;
                tmp_19 = string.pointer;
                (string.pointer) ++;
                tmp_20 = parser->buffer.pointer;
                (parser->buffer.pointer) ++;
                *tmp_19 = *tmp_20;
                tmp_21 = string.pointer;
                (string.pointer) ++;
                tmp_22 = parser->buffer.pointer;
                (parser->buffer.pointer) ++;
                *tmp_21 = *tmp_22;
                tmp_23 = string.pointer;
                (string.pointer) ++;
                tmp_24 = parser->buffer.pointer;
                (parser->buffer.pointer) ++;
                *tmp_23 = *tmp_24;
                yaml_char_t tmp_25 = *tmp_23;
              }
        (parser->mark.index) ++;
        (parser->mark.column) ++;
        (parser->unread) --;
        tmp_25_1 = 1;
      }
      else tmp_25_1 = 0;
      if (! tmp_25_1) goto error;
      if (parser->unread >= (size_t)1) tmp_27_1 = 1;
      else tmp_27_1 = yaml_parser_update_buffer(parser,(size_t)1);
      if (! tmp_27_1) goto error;
    }
  }
  if (string.start == string.pointer) {
    yaml_parser_set_scanner_error(parser,"while scanning a directive",
                                  start_mark,
                                  "could not find expected directive name");
    goto error;
  }
  if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)' '))) 
    if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\t'))) 
      if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r'))) 
        if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n'))) 
          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
            if (! ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\205'))) 
              goto _LAND_6;
          }
          else {
            _LAND_6: ;
            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
              if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                if (! ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\250'))) 
                  goto _LAND_5;
              }
              else goto _LAND_5;
            }
            else {
              _LAND_5: ;
              if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
                if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                  if (! ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\251'))) 
                    goto _LAND_3;
                }
                else goto _LAND_3;
              }
              else {
                _LAND_3: ;
                if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\000'))) {
                  yaml_parser_set_scanner_error(parser,
                                                "while scanning a directive",
                                                start_mark,
                                                "found unexpected non-alphabetical character");
                  goto error;
                }
              }
            }
          }
  *name = string.start;
  __retres = 1;
  goto return_label;
  error: yaml_free((void *)string.start);
  string.end = (yaml_char_t *)0;
  string.pointer = string.end;
  string.start = string.pointer;
  __retres = 0;
  return_label: return __retres;
}

static int yaml_parser_scan_version_directive_value(yaml_parser_t *parser,
                                                    yaml_mark_t start_mark,
                                                    int *major, int *minor)
{
  int __retres;
  int tmp_0;
  int tmp_7;
  int tmp_12;
  int tmp_13;
  if (parser->unread >= (size_t)1) tmp_0 = 1;
  else tmp_0 = yaml_parser_update_buffer(parser,(size_t)1);
  if (! tmp_0) {
    __retres = 0;
    goto return_label;
  }
  while (1) {
    if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)' '))) 
      if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\t'))) 
        break;
    {
      int tmp_4;
      int tmp_6;
      (parser->mark.index) ++;
      (parser->mark.column) ++;
      (parser->unread) --;
      if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_4 = 1;
      else {
        int tmp_3;
        if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_3 = 2;
        else {
          int tmp_2;
          if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) tmp_2 = 3;
          else {
            int tmp_1;
            if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
              tmp_1 = 4;
            else tmp_1 = 0;
            tmp_2 = tmp_1;
          }
          tmp_3 = tmp_2;
        }
        tmp_4 = tmp_3;
      }
      parser->buffer.pointer += tmp_4;
      if (parser->unread >= (size_t)1) tmp_6 = 1;
      else tmp_6 = yaml_parser_update_buffer(parser,(size_t)1);
      if (! tmp_6) {
        __retres = 0;
        goto return_label;
      }
    }
  }
  tmp_7 = yaml_parser_scan_version_directive_number(parser,start_mark,major);
  if (! tmp_7) {
    __retres = 0;
    goto return_label;
  }
  if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'.'))) {
    int tmp_8;
    tmp_8 = yaml_parser_set_scanner_error(parser,
                                          "while scanning a %YAML directive",
                                          start_mark,
                                          "did not find expected digit or \'.\' character");
    __retres = tmp_8;
    goto return_label;
  }
  (parser->mark.index) ++;
  (parser->mark.column) ++;
  (parser->unread) --;
  if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_12 = 1;
  else {
    int tmp_11;
    if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_11 = 2;
    else {
      int tmp_10;
      if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) tmp_10 = 3;
      else {
        int tmp_9;
        if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) tmp_9 = 4;
        else tmp_9 = 0;
        tmp_10 = tmp_9;
      }
      tmp_11 = tmp_10;
    }
    tmp_12 = tmp_11;
  }
  parser->buffer.pointer += tmp_12;
  tmp_13 = yaml_parser_scan_version_directive_number(parser,start_mark,minor);
  if (! tmp_13) {
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_scan_version_directive_number(yaml_parser_t *parser,
                                                     yaml_mark_t start_mark,
                                                     int *number)
{
  int __retres;
  int tmp_0;
  int value = 0;
  size_t length = (size_t)0;
  if (parser->unread >= (size_t)1) tmp_0 = 1;
  else tmp_0 = yaml_parser_update_buffer(parser,(size_t)1);
  if (! tmp_0) {
    __retres = 0;
    goto return_label;
  }
  while (1) {
    if ((int)*(parser->buffer.pointer + 0) >= (int)((yaml_char_t)'0')) {
      if (! ((int)*(parser->buffer.pointer + 0) <= (int)((yaml_char_t)'9'))) 
        break;
    }
    else break;
    {
      int tmp_5;
      int tmp_7;
      length ++;
      if (length > (size_t)9) {
        int tmp_1;
        tmp_1 = yaml_parser_set_scanner_error(parser,
                                              "while scanning a %YAML directive",
                                              start_mark,
                                              "found extremely long version number");
        __retres = tmp_1;
        goto return_label;
      }
      value = value * 10 + ((int)*(parser->buffer.pointer + 0) - (int)((yaml_char_t)'0'));
      (parser->mark.index) ++;
      (parser->mark.column) ++;
      (parser->unread) --;
      if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_5 = 1;
      else {
        int tmp_4;
        if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_4 = 2;
        else {
          int tmp_3;
          if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) tmp_3 = 3;
          else {
            int tmp_2;
            if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
              tmp_2 = 4;
            else tmp_2 = 0;
            tmp_3 = tmp_2;
          }
          tmp_4 = tmp_3;
        }
        tmp_5 = tmp_4;
      }
      parser->buffer.pointer += tmp_5;
      if (parser->unread >= (size_t)1) tmp_7 = 1;
      else tmp_7 = yaml_parser_update_buffer(parser,(size_t)1);
      if (! tmp_7) {
        __retres = 0;
        goto return_label;
      }
    }
  }
  if (! length) {
    int tmp_8;
    tmp_8 = yaml_parser_set_scanner_error(parser,
                                          "while scanning a %YAML directive",
                                          start_mark,
                                          "did not find expected version number");
    __retres = tmp_8;
    goto return_label;
  }
  *number = value;
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_scan_tag_directive_value(yaml_parser_t *parser,
                                                yaml_mark_t start_mark,
                                                yaml_char_t **handle,
                                                yaml_char_t **prefix)
{
  int __retres;
  int tmp_0;
  int tmp_7;
  int tmp_9;
  int tmp_16;
  int tmp_18;
  yaml_char_t *handle_value = (yaml_char_t *)0;
  yaml_char_t *prefix_value = (yaml_char_t *)0;
  if (parser->unread >= (size_t)1) tmp_0 = 1;
  else tmp_0 = yaml_parser_update_buffer(parser,(size_t)1);
  if (! tmp_0) goto error;
  while (1) {
    if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)' '))) 
      if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\t'))) 
        break;
    {
      int tmp_4;
      int tmp_6;
      (parser->mark.index) ++;
      (parser->mark.column) ++;
      (parser->unread) --;
      if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_4 = 1;
      else {
        int tmp_3;
        if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_3 = 2;
        else {
          int tmp_2;
          if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) tmp_2 = 3;
          else {
            int tmp_1;
            if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
              tmp_1 = 4;
            else tmp_1 = 0;
            tmp_2 = tmp_1;
          }
          tmp_3 = tmp_2;
        }
        tmp_4 = tmp_3;
      }
      parser->buffer.pointer += tmp_4;
      if (parser->unread >= (size_t)1) tmp_6 = 1;
      else tmp_6 = yaml_parser_update_buffer(parser,(size_t)1);
      if (! tmp_6) goto error;
    }
  }
  tmp_7 = yaml_parser_scan_tag_handle(parser,1,start_mark,& handle_value);
  if (! tmp_7) goto error;
  if (parser->unread >= (size_t)1) tmp_9 = 1;
  else tmp_9 = yaml_parser_update_buffer(parser,(size_t)1);
  if (! tmp_9) goto error;
  if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)' '))) 
    if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\t'))) {
      yaml_parser_set_scanner_error(parser,"while scanning a %TAG directive",
                                    start_mark,
                                    "did not find expected whitespace");
      goto error;
    }
  while (1) {
    if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)' '))) 
      if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\t'))) 
        break;
    {
      int tmp_13;
      int tmp_15;
      (parser->mark.index) ++;
      (parser->mark.column) ++;
      (parser->unread) --;
      if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_13 = 1;
      else {
        int tmp_12;
        if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_12 = 2;
        else {
          int tmp_11;
          if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) tmp_11 = 3;
          else {
            int tmp_10;
            if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
              tmp_10 = 4;
            else tmp_10 = 0;
            tmp_11 = tmp_10;
          }
          tmp_12 = tmp_11;
        }
        tmp_13 = tmp_12;
      }
      parser->buffer.pointer += tmp_13;
      if (parser->unread >= (size_t)1) tmp_15 = 1;
      else tmp_15 = yaml_parser_update_buffer(parser,(size_t)1);
      if (! tmp_15) goto error;
    }
  }
  tmp_16 = yaml_parser_scan_tag_uri(parser,1,1,(yaml_char_t *)0,start_mark,
                                    & prefix_value);
  if (! tmp_16) goto error;
  if (parser->unread >= (size_t)1) tmp_18 = 1;
  else tmp_18 = yaml_parser_update_buffer(parser,(size_t)1);
  if (! tmp_18) goto error;
  if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)' '))) 
    if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\t'))) 
      if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r'))) 
        if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n'))) 
          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
            if (! ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\205'))) 
              goto _LAND_3;
          }
          else {
            _LAND_3: ;
            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
              if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                if (! ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\250'))) 
                  goto _LAND_2;
              }
              else goto _LAND_2;
            }
            else {
              _LAND_2: ;
              if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
                if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                  if (! ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\251'))) 
                    goto _LAND_0;
                }
                else goto _LAND_0;
              }
              else {
                _LAND_0: ;
                if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\000'))) {
                  yaml_parser_set_scanner_error(parser,
                                                "while scanning a %TAG directive",
                                                start_mark,
                                                "did not find expected whitespace or line break");
                  goto error;
                }
              }
            }
          }
  *handle = handle_value;
  *prefix = prefix_value;
  __retres = 1;
  goto return_label;
  error: yaml_free((void *)handle_value);
  yaml_free((void *)prefix_value);
  __retres = 0;
  return_label: return __retres;
}

static int yaml_parser_scan_anchor(yaml_parser_t *parser,
                                   yaml_token_t *token,
                                   yaml_token_type_t type)
{
  int __retres;
  yaml_mark_t start_mark;
  yaml_mark_t end_mark;
  int tmp_0;
  int tmp_4;
  int tmp_6;
  int length = 0;
  yaml_string_t string =
    {.start = (yaml_char_t *)0,
     .end = (yaml_char_t *)0,
     .pointer = (yaml_char_t *)0};
  string.start = (yaml_char_t *)yaml_malloc((size_t)16);
  if (string.start) {
    string.pointer = string.start;
    string.end = string.start + 16;
    memset((void *)string.start,0,(size_t)16);
    tmp_0 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_0 = 0;
  }
  if (! tmp_0) goto error;
  start_mark = parser->mark;
  (parser->mark.index) ++;
  (parser->mark.column) ++;
  (parser->unread) --;
  if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_4 = 1;
  else {
    int tmp_3;
    if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_3 = 2;
    else {
      int tmp_2;
      if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) tmp_2 = 3;
      else {
        int tmp_1;
        if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) tmp_1 = 4;
        else tmp_1 = 0;
        tmp_2 = tmp_1;
      }
      tmp_3 = tmp_2;
    }
    tmp_4 = tmp_3;
  }
  parser->buffer.pointer += tmp_4;
  if (parser->unread >= (size_t)1) tmp_6 = 1;
  else tmp_6 = yaml_parser_update_buffer(parser,(size_t)1);
  if (! tmp_6) goto error;
  while (1) {
    if ((int)*(parser->buffer.pointer + 0) >= (int)((yaml_char_t)'0')) {
      if (! ((int)*(parser->buffer.pointer + 0) <= (int)((yaml_char_t)'9'))) 
        goto _LAND_1;
    }
    else {
      _LAND_1: ;
      if ((int)*(parser->buffer.pointer + 0) >= (int)((yaml_char_t)'A')) {
        if (! ((int)*(parser->buffer.pointer + 0) <= (int)((yaml_char_t)'Z'))) 
          goto _LAND_0;
      }
      else {
        _LAND_0: ;
        if ((int)*(parser->buffer.pointer + 0) >= (int)((yaml_char_t)'a')) {
          if (! ((int)*(parser->buffer.pointer + 0) <= (int)((yaml_char_t)'z'))) 
            goto _LAND;
        }
        else {
          _LAND: ;
          if (! ((int)*(parser->buffer.pointer + 0) == '_')) 
            if (! ((int)*(parser->buffer.pointer + 0) == '-')) break;
        }
      }
    }
    {
      int tmp_29_1;
      int tmp_8;
      int tmp_31_1;
      if (string.pointer + 5 < string.end) tmp_8 = 1;
      else {
        int tmp_7;
        tmp_7 = yaml_string_extend(& string.start,& string.pointer,
                                   & string.end);
        if (tmp_7) tmp_8 = 1;
        else {
          parser->error = YAML_MEMORY_ERROR;
          tmp_8 = 0;
        }
      }
      if (tmp_8) {
        if (((int)*(parser->buffer.pointer) & 0x80) == 0x00) {
          yaml_char_t *tmp_9;
          yaml_char_t *tmp_10;
          tmp_9 = string.pointer;
          (string.pointer) ++;
          tmp_10 = parser->buffer.pointer;
          (parser->buffer.pointer) ++;
          *tmp_9 = *tmp_10;
          yaml_char_t tmp_35 = *tmp_9;
        }
        else 
          if (((int)*(parser->buffer.pointer) & 0xE0) == 0xC0) {
            yaml_char_t *tmp_11;
            yaml_char_t *tmp_12;
            yaml_char_t *tmp_13;
            yaml_char_t *tmp_14;
            tmp_11 = string.pointer;
            (string.pointer) ++;
            tmp_12 = parser->buffer.pointer;
            (parser->buffer.pointer) ++;
            *tmp_11 = *tmp_12;
            tmp_13 = string.pointer;
            (string.pointer) ++;
            tmp_14 = parser->buffer.pointer;
            (parser->buffer.pointer) ++;
            *tmp_13 = *tmp_14;
            yaml_char_t tmp_33 = *tmp_13;
          }
          else 
            if (((int)*(parser->buffer.pointer) & 0xF0) == 0xE0) {
              yaml_char_t *tmp_15;
              yaml_char_t *tmp_16;
              yaml_char_t *tmp_17;
              yaml_char_t *tmp_18;
              yaml_char_t *tmp_19;
              yaml_char_t *tmp_20;
              tmp_15 = string.pointer;
              (string.pointer) ++;
              tmp_16 = parser->buffer.pointer;
              (parser->buffer.pointer) ++;
              *tmp_15 = *tmp_16;
              tmp_17 = string.pointer;
              (string.pointer) ++;
              tmp_18 = parser->buffer.pointer;
              (parser->buffer.pointer) ++;
              *tmp_17 = *tmp_18;
              tmp_19 = string.pointer;
              (string.pointer) ++;
              tmp_20 = parser->buffer.pointer;
              (parser->buffer.pointer) ++;
              *tmp_19 = *tmp_20;
              yaml_char_t tmp_31 = *tmp_19;
            }
            else 
              if (((int)*(parser->buffer.pointer) & 0xF8) == 0xF0) {
                yaml_char_t *tmp_21;
                yaml_char_t *tmp_22;
                yaml_char_t *tmp_23;
                yaml_char_t *tmp_24;
                yaml_char_t *tmp_25;
                yaml_char_t *tmp_26;
                yaml_char_t *tmp_27;
                yaml_char_t *tmp_28;
                tmp_21 = string.pointer;
                (string.pointer) ++;
                tmp_22 = parser->buffer.pointer;
                (parser->buffer.pointer) ++;
                *tmp_21 = *tmp_22;
                tmp_23 = string.pointer;
                (string.pointer) ++;
                tmp_24 = parser->buffer.pointer;
                (parser->buffer.pointer) ++;
                *tmp_23 = *tmp_24;
                tmp_25 = string.pointer;
                (string.pointer) ++;
                tmp_26 = parser->buffer.pointer;
                (parser->buffer.pointer) ++;
                *tmp_25 = *tmp_26;
                tmp_27 = string.pointer;
                (string.pointer) ++;
                tmp_28 = parser->buffer.pointer;
                (parser->buffer.pointer) ++;
                *tmp_27 = *tmp_28;
                yaml_char_t tmp_29 = *tmp_27;
              }
        (parser->mark.index) ++;
        (parser->mark.column) ++;
        (parser->unread) --;
        tmp_29_1 = 1;
      }
      else tmp_29_1 = 0;
      if (! tmp_29_1) goto error;
      if (parser->unread >= (size_t)1) tmp_31_1 = 1;
      else tmp_31_1 = yaml_parser_update_buffer(parser,(size_t)1);
      if (! tmp_31_1) goto error;
      length ++;
    }
  }
  end_mark = parser->mark;
  if (! length) goto _LOR;
  else 
    if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)' '))) 
      if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\t'))) 
        if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r'))) 
          if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n'))) 
            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
              if (! ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\205'))) 
                goto _LAND_6;
            }
            else {
              _LAND_6: ;
              if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
                if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                  if (! ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\250'))) 
                    goto _LAND_5;
                }
                else goto _LAND_5;
              }
              else {
                _LAND_5: ;
                if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
                  if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                    if (! ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\251'))) 
                      goto _LAND_3;
                  }
                  else goto _LAND_3;
                }
                else {
                  _LAND_3: ;
                  if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\000'))) 
                    if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'?'))) 
                      if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)':'))) 
                        if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)','))) 
                          if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)']'))) 
                            if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'}'))) 
                              if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'%'))) 
                                if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'@'))) 
                                  if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'`'))) {
                                    _LOR:
                                    {
                                      char const *tmp_32;
                                      ;
                                      if (type == (unsigned int)YAML_ANCHOR_TOKEN) 
                                        tmp_32 = "while scanning an anchor";
                                      else tmp_32 = "while scanning an alias";
                                      ;
                                      yaml_parser_set_scanner_error(parser,
                                                                    tmp_32,
                                                                    start_mark,
                                                                    "did not find expected alphabetic or numeric character");
                                      goto error;
                                    }
                                  }
                }
              }
            }
  if (type == (unsigned int)YAML_ANCHOR_TOKEN) {
    memset((void *)token,0,sizeof(yaml_token_t));
    token->type = YAML_ANCHOR_TOKEN;
    token->start_mark = start_mark;
    token->end_mark = end_mark;
    token->data.anchor.value = string.start;
  }
  else {
    memset((void *)token,0,sizeof(yaml_token_t));
    token->type = YAML_ALIAS_TOKEN;
    token->start_mark = start_mark;
    token->end_mark = end_mark;
    token->data.alias.value = string.start;
  }
  __retres = 1;
  goto return_label;
  error: yaml_free((void *)string.start);
  string.end = (yaml_char_t *)0;
  string.pointer = string.end;
  string.start = string.pointer;
  __retres = 0;
  return_label: return __retres;
}

static int yaml_parser_scan_tag(yaml_parser_t *parser, yaml_token_t *token)
{
  int __retres;
  yaml_mark_t start_mark;
  yaml_mark_t end_mark;
  int tmp_0;
  int tmp_22;
  yaml_char_t *handle = (yaml_char_t *)0;
  yaml_char_t *suffix = (yaml_char_t *)0;
  start_mark = parser->mark;
  if (parser->unread >= (size_t)2) tmp_0 = 1;
  else tmp_0 = yaml_parser_update_buffer(parser,(size_t)2);
  if (! tmp_0) goto error;
  if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'<')) {
    int tmp_5;
    int tmp_9;
    int tmp_10;
    int tmp_14;
    handle = (yaml_char_t *)yaml_malloc((size_t)1);
    if (! handle) goto error;
    *(handle + 0) = (yaml_char_t)'\000';
    (parser->mark.index) ++;
    (parser->mark.column) ++;
    (parser->unread) --;
    if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_5 = 1;
    else {
      int tmp_4;
      if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_4 = 2;
      else {
        int tmp_3;
        if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) tmp_3 = 3;
        else {
          int tmp_2;
          if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) tmp_2 = 4;
          else tmp_2 = 0;
          tmp_3 = tmp_2;
        }
        tmp_4 = tmp_3;
      }
      tmp_5 = tmp_4;
    }
    parser->buffer.pointer += tmp_5;
    (parser->mark.index) ++;
    (parser->mark.column) ++;
    (parser->unread) --;
    if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_9 = 1;
    else {
      int tmp_8;
      if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_8 = 2;
      else {
        int tmp_7;
        if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) tmp_7 = 3;
        else {
          int tmp_6;
          if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) tmp_6 = 4;
          else tmp_6 = 0;
          tmp_7 = tmp_6;
        }
        tmp_8 = tmp_7;
      }
      tmp_9 = tmp_8;
    }
    parser->buffer.pointer += tmp_9;
    tmp_10 = yaml_parser_scan_tag_uri(parser,1,0,(yaml_char_t *)0,start_mark,
                                      & suffix);
    if (! tmp_10) goto error;
    if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'>'))) {
      yaml_parser_set_scanner_error(parser,"while scanning a tag",start_mark,
                                    "did not find the expected \'>\'");
      goto error;
    }
    (parser->mark.index) ++;
    (parser->mark.column) ++;
    (parser->unread) --;
    if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_14 = 1;
    else {
      int tmp_13;
      if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_13 = 2;
      else {
        int tmp_12;
        if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) tmp_12 = 3;
        else {
          int tmp_11;
          if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) tmp_11 = 4;
          else tmp_11 = 0;
          tmp_12 = tmp_11;
        }
        tmp_13 = tmp_12;
      }
      tmp_14 = tmp_13;
    }
    parser->buffer.pointer += tmp_14;
  }
  else {
    int tmp_15;
    tmp_15 = yaml_parser_scan_tag_handle(parser,0,start_mark,& handle);
    if (! tmp_15) goto error;
    if ((int)*(handle + 0) == '!') {
      if ((int)*(handle + 1) != '\000') {
        size_t tmp_20;
        tmp_20 = strlen((char const *)handle);
        ;
        if ((int)*(handle + (tmp_20 - (size_t)1)) == '!') {
          int tmp_16;
          tmp_16 = yaml_parser_scan_tag_uri(parser,0,0,(yaml_char_t *)0,
                                            start_mark,& suffix);
          if (! tmp_16) goto error;
        }
        else goto _LAND_0;
      }
      else goto _LAND_0;
    }
    else {
      _LAND_0:
      {
        int tmp_17;
        tmp_17 = yaml_parser_scan_tag_uri(parser,0,0,handle,start_mark,
                                          & suffix);
        if (! tmp_17) goto error;
        yaml_free((void *)handle);
        handle = (yaml_char_t *)yaml_malloc((size_t)2);
        if (! handle) goto error;
        *(handle + 0) = (yaml_char_t)'!';
        *(handle + 1) = (yaml_char_t)'\000';
        if ((int)*(suffix + 0) == '\000') {
          yaml_char_t *tmp_19 = handle;
          handle = suffix;
          suffix = tmp_19;
        }
      }
    }
  }
  if (parser->unread >= (size_t)1) tmp_22 = 1;
  else tmp_22 = yaml_parser_update_buffer(parser,(size_t)1);
  if (! tmp_22) goto error;
  if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)' '))) 
    if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\t'))) 
      if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r'))) 
        if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n'))) 
          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
            if (! ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\205'))) 
              goto _LAND_5;
          }
          else {
            _LAND_5: ;
            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
              if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                if (! ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\250'))) 
                  goto _LAND_4;
              }
              else goto _LAND_4;
            }
            else {
              _LAND_4: ;
              if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
                if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                  if (! ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\251'))) 
                    goto _LAND_2;
                }
                else goto _LAND_2;
              }
              else {
                _LAND_2: ;
                if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\000'))) 
                  if (! parser->flow_level) goto _LOR;
                  else 
                    if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)','))) {
                      _LOR:
                      {
                        yaml_parser_set_scanner_error(parser,
                                                      "while scanning a tag",
                                                      start_mark,
                                                      "did not find expected whitespace or line break");
                        goto error;
                      }
                    }
              }
            }
          }
  end_mark = parser->mark;
  memset((void *)token,0,sizeof(yaml_token_t));
  token->type = YAML_TAG_TOKEN;
  token->start_mark = start_mark;
  token->end_mark = end_mark;
  token->data.tag.handle = handle;
  token->data.tag.suffix = suffix;
  __retres = 1;
  goto return_label;
  error: yaml_free((void *)handle);
  yaml_free((void *)suffix);
  __retres = 0;
  return_label: return __retres;
}

static int yaml_parser_scan_tag_handle(yaml_parser_t *parser, int directive,
                                       yaml_mark_t start_mark,
                                       yaml_char_t **handle)
{
  int __retres;
  int tmp_0;
  int tmp_2;
  int tmp_26_2;
  int tmp_5;
  int tmp_28_2;
  yaml_string_t string =
    {.start = (yaml_char_t *)0,
     .end = (yaml_char_t *)0,
     .pointer = (yaml_char_t *)0};
  string.start = (yaml_char_t *)yaml_malloc((size_t)16);
  if (string.start) {
    string.pointer = string.start;
    string.end = string.start + 16;
    memset((void *)string.start,0,(size_t)16);
    tmp_0 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_0 = 0;
  }
  if (! tmp_0) goto error;
  if (parser->unread >= (size_t)1) tmp_2 = 1;
  else tmp_2 = yaml_parser_update_buffer(parser,(size_t)1);
  if (! tmp_2) goto error;
  if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'!'))) {
    char const *tmp_3;
    ;
    if (directive) tmp_3 = "while scanning a tag directive";
    else tmp_3 = "while scanning a tag";
    ;
    yaml_parser_set_scanner_error(parser,tmp_3,start_mark,
                                  "did not find expected \'!\'");
    goto error;
  }
  if (string.pointer + 5 < string.end) tmp_5 = 1;
  else {
    int tmp_4;
    tmp_4 = yaml_string_extend(& string.start,& string.pointer,& string.end);
    if (tmp_4) tmp_5 = 1;
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp_5 = 0;
    }
  }
  if (tmp_5) {
    if (((int)*(parser->buffer.pointer) & 0x80) == 0x00) {
      yaml_char_t *tmp_6;
      yaml_char_t *tmp_7;
      tmp_6 = string.pointer;
      (string.pointer) ++;
      tmp_7 = parser->buffer.pointer;
      (parser->buffer.pointer) ++;
      *tmp_6 = *tmp_7;
      yaml_char_t tmp_32 = *tmp_6;
    }
    else 
      if (((int)*(parser->buffer.pointer) & 0xE0) == 0xC0) {
        yaml_char_t *tmp_8;
        yaml_char_t *tmp_9;
        yaml_char_t *tmp_10;
        yaml_char_t *tmp_11;
        tmp_8 = string.pointer;
        (string.pointer) ++;
        tmp_9 = parser->buffer.pointer;
        (parser->buffer.pointer) ++;
        *tmp_8 = *tmp_9;
        tmp_10 = string.pointer;
        (string.pointer) ++;
        tmp_11 = parser->buffer.pointer;
        (parser->buffer.pointer) ++;
        *tmp_10 = *tmp_11;
        yaml_char_t tmp_30 = *tmp_10;
      }
      else 
        if (((int)*(parser->buffer.pointer) & 0xF0) == 0xE0) {
          yaml_char_t *tmp_12;
          yaml_char_t *tmp_13;
          yaml_char_t *tmp_14;
          yaml_char_t *tmp_15;
          yaml_char_t *tmp_16;
          yaml_char_t *tmp_17;
          tmp_12 = string.pointer;
          (string.pointer) ++;
          tmp_13 = parser->buffer.pointer;
          (parser->buffer.pointer) ++;
          *tmp_12 = *tmp_13;
          tmp_14 = string.pointer;
          (string.pointer) ++;
          tmp_15 = parser->buffer.pointer;
          (parser->buffer.pointer) ++;
          *tmp_14 = *tmp_15;
          tmp_16 = string.pointer;
          (string.pointer) ++;
          tmp_17 = parser->buffer.pointer;
          (parser->buffer.pointer) ++;
          *tmp_16 = *tmp_17;
          yaml_char_t tmp_28 = *tmp_16;
        }
        else 
          if (((int)*(parser->buffer.pointer) & 0xF8) == 0xF0) {
            yaml_char_t *tmp_18;
            yaml_char_t *tmp_19;
            yaml_char_t *tmp_20;
            yaml_char_t *tmp_21;
            yaml_char_t *tmp_22;
            yaml_char_t *tmp_23;
            yaml_char_t *tmp_24;
            yaml_char_t *tmp_25;
            tmp_18 = string.pointer;
            (string.pointer) ++;
            tmp_19 = parser->buffer.pointer;
            (parser->buffer.pointer) ++;
            *tmp_18 = *tmp_19;
            tmp_20 = string.pointer;
            (string.pointer) ++;
            tmp_21 = parser->buffer.pointer;
            (parser->buffer.pointer) ++;
            *tmp_20 = *tmp_21;
            tmp_22 = string.pointer;
            (string.pointer) ++;
            tmp_23 = parser->buffer.pointer;
            (parser->buffer.pointer) ++;
            *tmp_22 = *tmp_23;
            tmp_24 = string.pointer;
            (string.pointer) ++;
            tmp_25 = parser->buffer.pointer;
            (parser->buffer.pointer) ++;
            *tmp_24 = *tmp_25;
            yaml_char_t tmp_26 = *tmp_24;
          }
    (parser->mark.index) ++;
    (parser->mark.column) ++;
    (parser->unread) --;
    tmp_26_2 = 1;
  }
  else tmp_26_2 = 0;
  if (! tmp_26_2) goto error;
  if (parser->unread >= (size_t)1) tmp_28_2 = 1;
  else tmp_28_2 = yaml_parser_update_buffer(parser,(size_t)1);
  if (! tmp_28_2) goto error;
  while (1) {
    if ((int)*(parser->buffer.pointer + 0) >= (int)((yaml_char_t)'0')) {
      if (! ((int)*(parser->buffer.pointer + 0) <= (int)((yaml_char_t)'9'))) 
        goto _LAND_1;
    }
    else {
      _LAND_1: ;
      if ((int)*(parser->buffer.pointer + 0) >= (int)((yaml_char_t)'A')) {
        if (! ((int)*(parser->buffer.pointer + 0) <= (int)((yaml_char_t)'Z'))) 
          goto _LAND_0;
      }
      else {
        _LAND_0: ;
        if ((int)*(parser->buffer.pointer + 0) >= (int)((yaml_char_t)'a')) {
          if (! ((int)*(parser->buffer.pointer + 0) <= (int)((yaml_char_t)'z'))) 
            goto _LAND;
        }
        else {
          _LAND: ;
          if (! ((int)*(parser->buffer.pointer + 0) == '_')) 
            if (! ((int)*(parser->buffer.pointer + 0) == '-')) break;
        }
      }
    }
    {
      int tmp_51_0;
      int tmp_30_1;
      int tmp_53_0;
      if (string.pointer + 5 < string.end) tmp_30_1 = 1;
      else {
        int tmp_29;
        tmp_29 = yaml_string_extend(& string.start,& string.pointer,
                                    & string.end);
        if (tmp_29) tmp_30_1 = 1;
        else {
          parser->error = YAML_MEMORY_ERROR;
          tmp_30_1 = 0;
        }
      }
      if (tmp_30_1) {
        if (((int)*(parser->buffer.pointer) & 0x80) == 0x00) {
          yaml_char_t *tmp_31;
          yaml_char_t *tmp_32_1;
          tmp_31 = string.pointer;
          (string.pointer) ++;
          tmp_32_1 = parser->buffer.pointer;
          (parser->buffer.pointer) ++;
          *tmp_31 = *tmp_32_1;
          yaml_char_t tmp_57 = *tmp_31;
        }
        else 
          if (((int)*(parser->buffer.pointer) & 0xE0) == 0xC0) {
            yaml_char_t *tmp_33;
            yaml_char_t *tmp_34;
            yaml_char_t *tmp_35;
            yaml_char_t *tmp_36;
            tmp_33 = string.pointer;
            (string.pointer) ++;
            tmp_34 = parser->buffer.pointer;
            (parser->buffer.pointer) ++;
            *tmp_33 = *tmp_34;
            tmp_35 = string.pointer;
            (string.pointer) ++;
            tmp_36 = parser->buffer.pointer;
            (parser->buffer.pointer) ++;
            *tmp_35 = *tmp_36;
            yaml_char_t tmp_55 = *tmp_35;
          }
          else 
            if (((int)*(parser->buffer.pointer) & 0xF0) == 0xE0) {
              yaml_char_t *tmp_37;
              yaml_char_t *tmp_38;
              yaml_char_t *tmp_39;
              yaml_char_t *tmp_40;
              yaml_char_t *tmp_41;
              yaml_char_t *tmp_42;
              tmp_37 = string.pointer;
              (string.pointer) ++;
              tmp_38 = parser->buffer.pointer;
              (parser->buffer.pointer) ++;
              *tmp_37 = *tmp_38;
              tmp_39 = string.pointer;
              (string.pointer) ++;
              tmp_40 = parser->buffer.pointer;
              (parser->buffer.pointer) ++;
              *tmp_39 = *tmp_40;
              tmp_41 = string.pointer;
              (string.pointer) ++;
              tmp_42 = parser->buffer.pointer;
              (parser->buffer.pointer) ++;
              *tmp_41 = *tmp_42;
              yaml_char_t tmp_53 = *tmp_41;
            }
            else 
              if (((int)*(parser->buffer.pointer) & 0xF8) == 0xF0) {
                yaml_char_t *tmp_43;
                yaml_char_t *tmp_44;
                yaml_char_t *tmp_45;
                yaml_char_t *tmp_46;
                yaml_char_t *tmp_47;
                yaml_char_t *tmp_48;
                yaml_char_t *tmp_49;
                yaml_char_t *tmp_50;
                tmp_43 = string.pointer;
                (string.pointer) ++;
                tmp_44 = parser->buffer.pointer;
                (parser->buffer.pointer) ++;
                *tmp_43 = *tmp_44;
                tmp_45 = string.pointer;
                (string.pointer) ++;
                tmp_46 = parser->buffer.pointer;
                (parser->buffer.pointer) ++;
                *tmp_45 = *tmp_46;
                tmp_47 = string.pointer;
                (string.pointer) ++;
                tmp_48 = parser->buffer.pointer;
                (parser->buffer.pointer) ++;
                *tmp_47 = *tmp_48;
                tmp_49 = string.pointer;
                (string.pointer) ++;
                tmp_50 = parser->buffer.pointer;
                (parser->buffer.pointer) ++;
                *tmp_49 = *tmp_50;
                yaml_char_t tmp_51 = *tmp_49;
              }
        (parser->mark.index) ++;
        (parser->mark.column) ++;
        (parser->unread) --;
        tmp_51_0 = 1;
      }
      else tmp_51_0 = 0;
      if (! tmp_51_0) goto error;
      if (parser->unread >= (size_t)1) tmp_53_0 = 1;
      else tmp_53_0 = yaml_parser_update_buffer(parser,(size_t)1);
      if (! tmp_53_0) goto error;
    }
  }
  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'!')) {
    int tmp_76_0;
    int tmp_55_0;
    if (string.pointer + 5 < string.end) tmp_55_0 = 1;
    else {
      int tmp_54;
      tmp_54 = yaml_string_extend(& string.start,& string.pointer,
                                  & string.end);
      if (tmp_54) tmp_55_0 = 1;
      else {
        parser->error = YAML_MEMORY_ERROR;
        tmp_55_0 = 0;
      }
    }
    if (tmp_55_0) {
      if (((int)*(parser->buffer.pointer) & 0x80) == 0x00) {
        yaml_char_t *tmp_56;
        yaml_char_t *tmp_57_0;
        tmp_56 = string.pointer;
        (string.pointer) ++;
        tmp_57_0 = parser->buffer.pointer;
        (parser->buffer.pointer) ++;
        *tmp_56 = *tmp_57_0;
        yaml_char_t tmp_82 = *tmp_56;
      }
      else 
        if (((int)*(parser->buffer.pointer) & 0xE0) == 0xC0) {
          yaml_char_t *tmp_58;
          yaml_char_t *tmp_59;
          yaml_char_t *tmp_60;
          yaml_char_t *tmp_61;
          tmp_58 = string.pointer;
          (string.pointer) ++;
          tmp_59 = parser->buffer.pointer;
          (parser->buffer.pointer) ++;
          *tmp_58 = *tmp_59;
          tmp_60 = string.pointer;
          (string.pointer) ++;
          tmp_61 = parser->buffer.pointer;
          (parser->buffer.pointer) ++;
          *tmp_60 = *tmp_61;
          yaml_char_t tmp_80 = *tmp_60;
        }
        else 
          if (((int)*(parser->buffer.pointer) & 0xF0) == 0xE0) {
            yaml_char_t *tmp_62;
            yaml_char_t *tmp_63;
            yaml_char_t *tmp_64;
            yaml_char_t *tmp_65;
            yaml_char_t *tmp_66;
            yaml_char_t *tmp_67;
            tmp_62 = string.pointer;
            (string.pointer) ++;
            tmp_63 = parser->buffer.pointer;
            (parser->buffer.pointer) ++;
            *tmp_62 = *tmp_63;
            tmp_64 = string.pointer;
            (string.pointer) ++;
            tmp_65 = parser->buffer.pointer;
            (parser->buffer.pointer) ++;
            *tmp_64 = *tmp_65;
            tmp_66 = string.pointer;
            (string.pointer) ++;
            tmp_67 = parser->buffer.pointer;
            (parser->buffer.pointer) ++;
            *tmp_66 = *tmp_67;
            yaml_char_t tmp_78 = *tmp_66;
          }
          else 
            if (((int)*(parser->buffer.pointer) & 0xF8) == 0xF0) {
              yaml_char_t *tmp_68;
              yaml_char_t *tmp_69;
              yaml_char_t *tmp_70;
              yaml_char_t *tmp_71;
              yaml_char_t *tmp_72;
              yaml_char_t *tmp_73;
              yaml_char_t *tmp_74;
              yaml_char_t *tmp_75;
              tmp_68 = string.pointer;
              (string.pointer) ++;
              tmp_69 = parser->buffer.pointer;
              (parser->buffer.pointer) ++;
              *tmp_68 = *tmp_69;
              tmp_70 = string.pointer;
              (string.pointer) ++;
              tmp_71 = parser->buffer.pointer;
              (parser->buffer.pointer) ++;
              *tmp_70 = *tmp_71;
              tmp_72 = string.pointer;
              (string.pointer) ++;
              tmp_73 = parser->buffer.pointer;
              (parser->buffer.pointer) ++;
              *tmp_72 = *tmp_73;
              tmp_74 = string.pointer;
              (string.pointer) ++;
              tmp_75 = parser->buffer.pointer;
              (parser->buffer.pointer) ++;
              *tmp_74 = *tmp_75;
              yaml_char_t tmp_76 = *tmp_74;
            }
      (parser->mark.index) ++;
      (parser->mark.column) ++;
      (parser->unread) --;
      tmp_76_0 = 1;
    }
    else tmp_76_0 = 0;
    if (! tmp_76_0) goto error;
  }
  else 
    if (directive) 
      if ((int)*(string.start + 0) == '!') {
        if (! ((int)*(string.start + 1) == '\000')) goto _LAND_2;
      }
      else {
        _LAND_2:
        {
          yaml_parser_set_scanner_error(parser,
                                        "while parsing a tag directive",
                                        start_mark,
                                        "did not find expected \'!\'");
          goto error;
        }
      }
  *handle = string.start;
  __retres = 1;
  goto return_label;
  error: yaml_free((void *)string.start);
  string.end = (yaml_char_t *)0;
  string.pointer = string.end;
  string.start = string.pointer;
  __retres = 0;
  return_label: return __retres;
}

static int yaml_parser_scan_tag_uri(yaml_parser_t *parser, int uri_char,
                                    int directive, yaml_char_t *head,
                                    yaml_mark_t start_mark, yaml_char_t **uri)
{
  int __retres;
  size_t tmp_0;
  int tmp_2;
  int tmp_5;
  if (head) tmp_0 = strlen((char const *)head); else tmp_0 = (size_t)0;
  size_t length = tmp_0;
  yaml_string_t string =
    {.start = (yaml_char_t *)0,
     .end = (yaml_char_t *)0,
     .pointer = (yaml_char_t *)0};
  string.start = (yaml_char_t *)yaml_malloc((size_t)16);
  if (string.start) {
    string.pointer = string.start;
    string.end = string.start + 16;
    memset((void *)string.start,0,(size_t)16);
    tmp_2 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_2 = 0;
  }
  if (! tmp_2) goto error;
  while ((size_t)(string.end - string.start) <= length) {
    int tmp_3;
    tmp_3 = yaml_string_extend(& string.start,& string.pointer,& string.end);
    if (! tmp_3) {
      parser->error = YAML_MEMORY_ERROR;
      goto error;
    }
  }
  if (length > (size_t)1) {
    memcpy((void *)string.start,(void const *)(head + 1),length - (size_t)1);
    string.pointer += length - (size_t)1;
  }
  if (parser->unread >= (size_t)1) tmp_5 = 1;
  else tmp_5 = yaml_parser_update_buffer(parser,(size_t)1);
  if (! tmp_5) goto error;
  while (1) {
    if ((int)*(parser->buffer.pointer + 0) >= (int)((yaml_char_t)'0')) {
      if (! ((int)*(parser->buffer.pointer + 0) <= (int)((yaml_char_t)'9'))) 
        goto _LAND_1;
    }
    else {
      _LAND_1: ;
      if ((int)*(parser->buffer.pointer + 0) >= (int)((yaml_char_t)'A')) {
        if (! ((int)*(parser->buffer.pointer + 0) <= (int)((yaml_char_t)'Z'))) 
          goto _LAND_0;
      }
      else {
        _LAND_0: ;
        if ((int)*(parser->buffer.pointer + 0) >= (int)((yaml_char_t)'a')) {
          if (! ((int)*(parser->buffer.pointer + 0) <= (int)((yaml_char_t)'z'))) 
            goto _LAND;
        }
        else {
          _LAND: ;
          if (! ((int)*(parser->buffer.pointer + 0) == '_')) 
            if (! ((int)*(parser->buffer.pointer + 0) == '-')) 
              if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)';'))) 
                if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'/'))) 
                  if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'?'))) 
                    if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)':'))) 
                      if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'@'))) 
                        if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'&'))) 
                          if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'='))) 
                            if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'+'))) 
                              if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'$'))) 
                                if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'.'))) 
                                  if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'%'))) 
                                    if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'!'))) 
                                      if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'~'))) 
                                        if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'*'))) 
                                          if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\''))) 
                                            if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'('))) 
                                              if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)')'))) 
                                                if (uri_char) {
                                                  if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)','))) 
                                                    if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'['))) 
                                                      if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)']'))) 
                                                        break;
                                                }
                                                else break;
        }
      }
    }
    {
      int tmp_33_2;
      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'%')) {
        int tmp_7;
        int tmp_8;
        if (string.pointer + 5 < string.end) tmp_7 = 1;
        else {
          int tmp_6;
          tmp_6 = yaml_string_extend(& string.start,& string.pointer,
                                     & string.end);
          if (tmp_6) tmp_7 = 1;
          else {
            parser->error = YAML_MEMORY_ERROR;
            tmp_7 = 0;
          }
        }
        if (! tmp_7) goto error;
        tmp_8 = yaml_parser_scan_uri_escapes(parser,directive,start_mark,
                                             & string);
        if (! tmp_8) goto error;
      }
      else {
        int tmp_31_2;
        int tmp_10;
        if (string.pointer + 5 < string.end) tmp_10 = 1;
        else {
          int tmp_9;
          tmp_9 = yaml_string_extend(& string.start,& string.pointer,
                                     & string.end);
          if (tmp_9) tmp_10 = 1;
          else {
            parser->error = YAML_MEMORY_ERROR;
            tmp_10 = 0;
          }
        }
        if (tmp_10) {
          if (((int)*(parser->buffer.pointer) & 0x80) == 0x00) {
            yaml_char_t *tmp_11;
            yaml_char_t *tmp_12;
            tmp_11 = string.pointer;
            (string.pointer) ++;
            tmp_12 = parser->buffer.pointer;
            (parser->buffer.pointer) ++;
            *tmp_11 = *tmp_12;
            yaml_char_t tmp_37 = *tmp_11;
          }
          else 
            if (((int)*(parser->buffer.pointer) & 0xE0) == 0xC0) {
              yaml_char_t *tmp_13;
              yaml_char_t *tmp_14;
              yaml_char_t *tmp_15;
              yaml_char_t *tmp_16;
              tmp_13 = string.pointer;
              (string.pointer) ++;
              tmp_14 = parser->buffer.pointer;
              (parser->buffer.pointer) ++;
              *tmp_13 = *tmp_14;
              tmp_15 = string.pointer;
              (string.pointer) ++;
              tmp_16 = parser->buffer.pointer;
              (parser->buffer.pointer) ++;
              *tmp_15 = *tmp_16;
              yaml_char_t tmp_35 = *tmp_15;
            }
            else 
              if (((int)*(parser->buffer.pointer) & 0xF0) == 0xE0) {
                yaml_char_t *tmp_17;
                yaml_char_t *tmp_18;
                yaml_char_t *tmp_19;
                yaml_char_t *tmp_20;
                yaml_char_t *tmp_21;
                yaml_char_t *tmp_22;
                tmp_17 = string.pointer;
                (string.pointer) ++;
                tmp_18 = parser->buffer.pointer;
                (parser->buffer.pointer) ++;
                *tmp_17 = *tmp_18;
                tmp_19 = string.pointer;
                (string.pointer) ++;
                tmp_20 = parser->buffer.pointer;
                (parser->buffer.pointer) ++;
                *tmp_19 = *tmp_20;
                tmp_21 = string.pointer;
                (string.pointer) ++;
                tmp_22 = parser->buffer.pointer;
                (parser->buffer.pointer) ++;
                *tmp_21 = *tmp_22;
                yaml_char_t tmp_33 = *tmp_21;
              }
              else 
                if (((int)*(parser->buffer.pointer) & 0xF8) == 0xF0) {
                  yaml_char_t *tmp_23;
                  yaml_char_t *tmp_24;
                  yaml_char_t *tmp_25;
                  yaml_char_t *tmp_26;
                  yaml_char_t *tmp_27;
                  yaml_char_t *tmp_28;
                  yaml_char_t *tmp_29;
                  yaml_char_t *tmp_30;
                  tmp_23 = string.pointer;
                  (string.pointer) ++;
                  tmp_24 = parser->buffer.pointer;
                  (parser->buffer.pointer) ++;
                  *tmp_23 = *tmp_24;
                  tmp_25 = string.pointer;
                  (string.pointer) ++;
                  tmp_26 = parser->buffer.pointer;
                  (parser->buffer.pointer) ++;
                  *tmp_25 = *tmp_26;
                  tmp_27 = string.pointer;
                  (string.pointer) ++;
                  tmp_28 = parser->buffer.pointer;
                  (parser->buffer.pointer) ++;
                  *tmp_27 = *tmp_28;
                  tmp_29 = string.pointer;
                  (string.pointer) ++;
                  tmp_30 = parser->buffer.pointer;
                  (parser->buffer.pointer) ++;
                  *tmp_29 = *tmp_30;
                  yaml_char_t tmp_31 = *tmp_29;
                }
          (parser->mark.index) ++;
          (parser->mark.column) ++;
          (parser->unread) --;
          tmp_31_2 = 1;
        }
        else tmp_31_2 = 0;
        if (! tmp_31_2) goto error;
      }
      length ++;
      if (parser->unread >= (size_t)1) tmp_33_2 = 1;
      else tmp_33_2 = yaml_parser_update_buffer(parser,(size_t)1);
      if (! tmp_33_2) goto error;
    }
  }
  if (! length) {
    int tmp_35_2;
    char const *tmp_36;
    if (string.pointer + 5 < string.end) tmp_35_2 = 1;
    else {
      int tmp_34;
      tmp_34 = yaml_string_extend(& string.start,& string.pointer,
                                  & string.end);
      if (tmp_34) tmp_35_2 = 1;
      else {
        parser->error = YAML_MEMORY_ERROR;
        tmp_35_2 = 0;
      }
    }
    if (! tmp_35_2) goto error;
    ;
    if (directive) tmp_36 = "while parsing a %TAG directive";
    else tmp_36 = "while parsing a tag";
    ;
    yaml_parser_set_scanner_error(parser,tmp_36,start_mark,
                                  "did not find expected tag URI");
    goto error;
  }
  *uri = string.start;
  __retres = 1;
  goto return_label;
  error: yaml_free((void *)string.start);
  string.end = (yaml_char_t *)0;
  string.pointer = string.end;
  string.start = string.pointer;
  __retres = 0;
  return_label: return __retres;
}

static int yaml_parser_scan_uri_escapes(yaml_parser_t *parser, int directive,
                                        yaml_mark_t start_mark,
                                        yaml_string_t *string)
{
  int __retres;
  int width = 0;
  while (1) {
    {
      int tmp_0;
      int tmp_4;
      int tmp_6;
      yaml_char_t *tmp_14;
      int tmp_18;
      int tmp_22;
      int tmp_26;
      unsigned char octet = (unsigned char)0;
      if (parser->unread >= (size_t)3) tmp_0 = 1;
      else tmp_0 = yaml_parser_update_buffer(parser,(size_t)3);
      if (! tmp_0) {
        __retres = 0;
        goto return_label;
      }
      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'%')) 
        if ((int)*(parser->buffer.pointer + 1) >= (int)((yaml_char_t)'0')) {
          if ((int)*(parser->buffer.pointer + 1) <= (int)((yaml_char_t)'9')) 
            goto _LOR;
          else goto _LAND_4;
        }
        else {
          _LAND_4: ;
          if ((int)*(parser->buffer.pointer + 1) >= (int)((yaml_char_t)'A')) {
            if ((int)*(parser->buffer.pointer + 1) <= (int)((yaml_char_t)'F')) 
              goto _LOR;
            else goto _LAND_3;
          }
          else {
            _LAND_3: ;
            if ((int)*(parser->buffer.pointer + 1) >= (int)((yaml_char_t)'a')) {
              if ((int)*(parser->buffer.pointer + 1) <= (int)((yaml_char_t)'f')) {
                _LOR: ;
                if ((int)*(parser->buffer.pointer + 2) >= (int)((yaml_char_t)'0')) {
                  if (! ((int)*(parser->buffer.pointer + 2) <= (int)((yaml_char_t)'9'))) 
                    goto _LAND_1;
                }
                else {
                  _LAND_1: ;
                  if ((int)*(parser->buffer.pointer + 2) >= (int)((yaml_char_t)'A')) {
                    if (! ((int)*(parser->buffer.pointer + 2) <= (int)((yaml_char_t)'F'))) 
                      goto _LAND_0;
                  }
                  else {
                    _LAND_0: ;
                    if ((int)*(parser->buffer.pointer + 2) >= (int)((yaml_char_t)'a')) {
                      if (! ((int)*(parser->buffer.pointer + 2) <= (int)((yaml_char_t)'f'))) 
                        goto _LAND_2;
                    }
                    else goto _LAND_2;
                  }
                }
              }
              else goto _LAND_2;
            }
            else goto _LAND_2;
          }
        }
      else {
        _LAND_2:
        {
          int tmp_2;
          char const *tmp_1;
          ;
          if (directive) tmp_1 = "while parsing a %TAG directive";
          else tmp_1 = "while parsing a tag";
          ;
          tmp_2 = yaml_parser_set_scanner_error(parser,tmp_1,start_mark,
                                                "did not find URI escaped octet");
          __retres = tmp_2;
          goto return_label;
        }
      }
      if ((int)*(parser->buffer.pointer + 1) >= (int)((yaml_char_t)'A')) {
        if ((int)*(parser->buffer.pointer + 1) <= (int)((yaml_char_t)'F')) 
          tmp_4 = ((int)*(parser->buffer.pointer + 1) - (int)((yaml_char_t)'A')) + 10;
        else goto _LAND_5;
      }
      else {
        int tmp_3;
        _LAND_5:
        if ((int)*(parser->buffer.pointer + 1) >= (int)((yaml_char_t)'a')) 
          if ((int)*(parser->buffer.pointer + 1) <= (int)((yaml_char_t)'f')) 
            tmp_3 = ((int)*(parser->buffer.pointer + 1) - (int)((yaml_char_t)'a')) + 10;
          else tmp_3 = (int)*(parser->buffer.pointer + 1) - (int)((yaml_char_t)'0');
        else tmp_3 = (int)*(parser->buffer.pointer + 1) - (int)((yaml_char_t)'0');
        tmp_4 = tmp_3;
      }
      if ((int)*(parser->buffer.pointer + 2) >= (int)((yaml_char_t)'A')) {
        if ((int)*(parser->buffer.pointer + 2) <= (int)((yaml_char_t)'F')) 
          tmp_6 = ((int)*(parser->buffer.pointer + 2) - (int)((yaml_char_t)'A')) + 10;
        else goto _LAND_6;
      }
      else {
        int tmp_5;
        _LAND_6:
        if ((int)*(parser->buffer.pointer + 2) >= (int)((yaml_char_t)'a')) 
          if ((int)*(parser->buffer.pointer + 2) <= (int)((yaml_char_t)'f')) 
            tmp_5 = ((int)*(parser->buffer.pointer + 2) - (int)((yaml_char_t)'a')) + 10;
          else tmp_5 = (int)*(parser->buffer.pointer + 2) - (int)((yaml_char_t)'0');
        else tmp_5 = (int)*(parser->buffer.pointer + 2) - (int)((yaml_char_t)'0');
        tmp_6 = tmp_5;
      }
      octet = (unsigned char)((tmp_4 << 4) + tmp_6);
      if (! width) {
        if (((int)octet & 0x80) == 0x00) width = 1;
        else {
          int tmp_9;
          if (((int)octet & 0xE0) == 0xC0) tmp_9 = 2;
          else {
            int tmp_8;
            if (((int)octet & 0xF0) == 0xE0) tmp_8 = 3;
            else {
              int tmp_7;
              if (((int)octet & 0xF8) == 0xF0) tmp_7 = 4; else tmp_7 = 0;
              tmp_8 = tmp_7;
            }
            tmp_9 = tmp_8;
          }
          width = tmp_9;
        }
        if (! width) {
          int tmp_11;
          char const *tmp_10;
          ;
          if (directive) tmp_10 = "while parsing a %TAG directive";
          else tmp_10 = "while parsing a tag";
          ;
          tmp_11 = yaml_parser_set_scanner_error(parser,tmp_10,start_mark,
                                                 "found an incorrect leading UTF-8 octet");
          __retres = tmp_11;
          goto return_label;
        }
      }
      else 
        if (((int)octet & 0xC0) != 0x80) {
          int tmp_13;
          char const *tmp_12;
          ;
          if (directive) tmp_12 = "while parsing a %TAG directive";
          else tmp_12 = "while parsing a tag";
          ;
          tmp_13 = yaml_parser_set_scanner_error(parser,tmp_12,start_mark,
                                                 "found an incorrect trailing UTF-8 octet");
          __retres = tmp_13;
          goto return_label;
        }
      tmp_14 = string->pointer;
      (string->pointer) ++;
      *tmp_14 = octet;
      (parser->mark.index) ++;
      (parser->mark.column) ++;
      (parser->unread) --;
      if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_18 = 1;
      else {
        int tmp_17;
        if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_17 = 2;
        else {
          int tmp_16;
          if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) tmp_16 = 3;
          else {
            int tmp_15;
            if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
              tmp_15 = 4;
            else tmp_15 = 0;
            tmp_16 = tmp_15;
          }
          tmp_17 = tmp_16;
        }
        tmp_18 = tmp_17;
      }
      parser->buffer.pointer += tmp_18;
      (parser->mark.index) ++;
      (parser->mark.column) ++;
      (parser->unread) --;
      if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_22 = 1;
      else {
        int tmp_21;
        if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_21 = 2;
        else {
          int tmp_20;
          if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) tmp_20 = 3;
          else {
            int tmp_19;
            if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
              tmp_19 = 4;
            else tmp_19 = 0;
            tmp_20 = tmp_19;
          }
          tmp_21 = tmp_20;
        }
        tmp_22 = tmp_21;
      }
      parser->buffer.pointer += tmp_22;
      (parser->mark.index) ++;
      (parser->mark.column) ++;
      (parser->unread) --;
      if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_26 = 1;
      else {
        int tmp_25;
        if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_25 = 2;
        else {
          int tmp_24;
          if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) tmp_24 = 3;
          else {
            int tmp_23;
            if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
              tmp_23 = 4;
            else tmp_23 = 0;
            tmp_24 = tmp_23;
          }
          tmp_25 = tmp_24;
        }
        tmp_26 = tmp_25;
      }
      parser->buffer.pointer += tmp_26;
    }
    width --;
    if (! width) break;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_scan_block_scalar(yaml_parser_t *parser,
                                         yaml_token_t *token, int literal)
{
  int __retres;
  yaml_mark_t start_mark;
  yaml_mark_t end_mark;
  int tmp_0;
  int tmp_2;
  int tmp_4;
  int tmp_8;
  int tmp_10;
  int tmp_32;
  int tmp_51_1;
  int tmp_53_1;
  yaml_string_t string =
    {.start = (yaml_char_t *)0,
     .end = (yaml_char_t *)0,
     .pointer = (yaml_char_t *)0};
  yaml_string_t leading_break =
    {.start = (yaml_char_t *)0,
     .end = (yaml_char_t *)0,
     .pointer = (yaml_char_t *)0};
  yaml_string_t trailing_breaks =
    {.start = (yaml_char_t *)0,
     .end = (yaml_char_t *)0,
     .pointer = (yaml_char_t *)0};
  int chomping = 0;
  int increment = 0;
  int indent = 0;
  int leading_blank = 0;
  int trailing_blank = 0;
  string.start = (yaml_char_t *)yaml_malloc((size_t)16);
  if (string.start) {
    string.pointer = string.start;
    string.end = string.start + 16;
    memset((void *)string.start,0,(size_t)16);
    tmp_0 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_0 = 0;
  }
  if (! tmp_0) goto error;
  leading_break.start = (yaml_char_t *)yaml_malloc((size_t)16);
  if (leading_break.start) {
    leading_break.pointer = leading_break.start;
    leading_break.end = leading_break.start + 16;
    memset((void *)leading_break.start,0,(size_t)16);
    tmp_2 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_2 = 0;
  }
  if (! tmp_2) goto error;
  trailing_breaks.start = (yaml_char_t *)yaml_malloc((size_t)16);
  if (trailing_breaks.start) {
    trailing_breaks.pointer = trailing_breaks.start;
    trailing_breaks.end = trailing_breaks.start + 16;
    memset((void *)trailing_breaks.start,0,(size_t)16);
    tmp_4 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_4 = 0;
  }
  if (! tmp_4) goto error;
  start_mark = parser->mark;
  (parser->mark.index) ++;
  (parser->mark.column) ++;
  (parser->unread) --;
  if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_8 = 1;
  else {
    int tmp_7;
    if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_7 = 2;
    else {
      int tmp_6;
      if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) tmp_6 = 3;
      else {
        int tmp_5;
        if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) tmp_5 = 4;
        else tmp_5 = 0;
        tmp_6 = tmp_5;
      }
      tmp_7 = tmp_6;
    }
    tmp_8 = tmp_7;
  }
  parser->buffer.pointer += tmp_8;
  if (parser->unread >= (size_t)1) tmp_10 = 1;
  else tmp_10 = yaml_parser_update_buffer(parser,(size_t)1);
  if (! tmp_10) goto error;
  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'+')) 
    goto _LOR_0;
  else 
    if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'-')) {
      _LOR_0:
      {
        int tmp_14;
        int tmp_16;
        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'+')) 
          chomping = 1;
        else chomping = -1;
        (parser->mark.index) ++;
        (parser->mark.column) ++;
        (parser->unread) --;
        if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_14 = 1;
        else {
          int tmp_13;
          if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_13 = 2;
          else {
            int tmp_12;
            if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) 
              tmp_12 = 3;
            else {
              int tmp_11;
              if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
                tmp_11 = 4;
              else tmp_11 = 0;
              tmp_12 = tmp_11;
            }
            tmp_13 = tmp_12;
          }
          tmp_14 = tmp_13;
        }
        parser->buffer.pointer += tmp_14;
        if (parser->unread >= (size_t)1) tmp_16 = 1;
        else tmp_16 = yaml_parser_update_buffer(parser,(size_t)1);
        if (! tmp_16) goto error;
        if ((int)*(parser->buffer.pointer + 0) >= (int)((yaml_char_t)'0')) 
          if ((int)*(parser->buffer.pointer + 0) <= (int)((yaml_char_t)'9')) {
            int tmp_20;
            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'0')) {
              yaml_parser_set_scanner_error(parser,
                                            "while scanning a block scalar",
                                            start_mark,
                                            "found an indentation indicator equal to 0");
              goto error;
            }
            increment = (int)*(parser->buffer.pointer + 0) - (int)((yaml_char_t)'0');
            (parser->mark.index) ++;
            (parser->mark.column) ++;
            (parser->unread) --;
            if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) 
              tmp_20 = 1;
            else {
              int tmp_19;
              if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) 
                tmp_19 = 2;
              else {
                int tmp_18;
                if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) 
                  tmp_18 = 3;
                else {
                  int tmp_17;
                  if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
                    tmp_17 = 4;
                  else tmp_17 = 0;
                  tmp_18 = tmp_17;
                }
                tmp_19 = tmp_18;
              }
              tmp_20 = tmp_19;
            }
            parser->buffer.pointer += tmp_20;
          }
      }
    }
    else 
      if ((int)*(parser->buffer.pointer + 0) >= (int)((yaml_char_t)'0')) 
        if ((int)*(parser->buffer.pointer + 0) <= (int)((yaml_char_t)'9')) {
          int tmp_24;
          int tmp_26;
          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'0')) {
            yaml_parser_set_scanner_error(parser,
                                          "while scanning a block scalar",
                                          start_mark,
                                          "found an indentation indicator equal to 0");
            goto error;
          }
          increment = (int)*(parser->buffer.pointer + 0) - (int)((yaml_char_t)'0');
          (parser->mark.index) ++;
          (parser->mark.column) ++;
          (parser->unread) --;
          if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_24 = 1;
          else {
            int tmp_23;
            if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) 
              tmp_23 = 2;
            else {
              int tmp_22;
              if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) 
                tmp_22 = 3;
              else {
                int tmp_21;
                if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
                  tmp_21 = 4;
                else tmp_21 = 0;
                tmp_22 = tmp_21;
              }
              tmp_23 = tmp_22;
            }
            tmp_24 = tmp_23;
          }
          parser->buffer.pointer += tmp_24;
          if (parser->unread >= (size_t)1) tmp_26 = 1;
          else tmp_26 = yaml_parser_update_buffer(parser,(size_t)1);
          if (! tmp_26) goto error;
          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'+')) 
            goto _LOR;
          else 
            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'-')) {
              _LOR:
              {
                int tmp_30;
                if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'+')) 
                  chomping = 1;
                else chomping = -1;
                (parser->mark.index) ++;
                (parser->mark.column) ++;
                (parser->unread) --;
                if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) 
                  tmp_30 = 1;
                else {
                  int tmp_29;
                  if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) 
                    tmp_29 = 2;
                  else {
                    int tmp_28;
                    if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) 
                      tmp_28 = 3;
                    else {
                      int tmp_27;
                      if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
                        tmp_27 = 4;
                      else tmp_27 = 0;
                      tmp_28 = tmp_27;
                    }
                    tmp_29 = tmp_28;
                  }
                  tmp_30 = tmp_29;
                }
                parser->buffer.pointer += tmp_30;
              }
            }
        }
  if (parser->unread >= (size_t)1) tmp_32 = 1;
  else tmp_32 = yaml_parser_update_buffer(parser,(size_t)1);
  if (! tmp_32) goto error;
  while (1) {
    if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)' '))) 
      if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\t'))) 
        break;
    {
      int tmp_36;
      int tmp_38;
      (parser->mark.index) ++;
      (parser->mark.column) ++;
      (parser->unread) --;
      if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_36 = 1;
      else {
        int tmp_35;
        if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_35 = 2;
        else {
          int tmp_34;
          if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) tmp_34 = 3;
          else {
            int tmp_33;
            if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
              tmp_33 = 4;
            else tmp_33 = 0;
            tmp_34 = tmp_33;
          }
          tmp_35 = tmp_34;
        }
        tmp_36 = tmp_35;
      }
      parser->buffer.pointer += tmp_36;
      if (parser->unread >= (size_t)1) tmp_38 = 1;
      else tmp_38 = yaml_parser_update_buffer(parser,(size_t)1);
      if (! tmp_38) goto error;
    }
  }
  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'#')) 
    while (1) {
      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) 
        break;
      else 
        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n')) 
          break;
        else 
          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
            if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\205')) 
              break;
            else goto _LAND_3;
          }
          else {
            _LAND_3: ;
            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
              if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                if ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\250')) 
                  break;
                else goto _LAND_2;
              }
              else goto _LAND_2;
            }
            else {
              _LAND_2: ;
              if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
                if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                  if ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\251')) 
                    break;
                  else goto _LAND_0;
                }
                else goto _LAND_0;
              }
              else {
                _LAND_0: ;
                if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\000')) 
                  break;
              }
            }
          }
      {
        int tmp_42;
        int tmp_44;
        (parser->mark.index) ++;
        (parser->mark.column) ++;
        (parser->unread) --;
        if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_42 = 1;
        else {
          int tmp_41;
          if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_41 = 2;
          else {
            int tmp_40;
            if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) 
              tmp_40 = 3;
            else {
              int tmp_39;
              if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
                tmp_39 = 4;
              else tmp_39 = 0;
              tmp_40 = tmp_39;
            }
            tmp_41 = tmp_40;
          }
          tmp_42 = tmp_41;
        }
        parser->buffer.pointer += tmp_42;
        if (parser->unread >= (size_t)1) tmp_44 = 1;
        else tmp_44 = yaml_parser_update_buffer(parser,(size_t)1);
        if (! tmp_44) goto error;
      }
    }
  if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r'))) 
    if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n'))) 
      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
        if (! ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\205'))) 
          goto _LAND_8;
      }
      else {
        _LAND_8: ;
        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
          if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
            if (! ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\250'))) 
              goto _LAND_7;
          }
          else goto _LAND_7;
        }
        else {
          _LAND_7: ;
          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
            if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
              if (! ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\251'))) 
                goto _LAND_5;
            }
            else goto _LAND_5;
          }
          else {
            _LAND_5: ;
            if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\000'))) {
              yaml_parser_set_scanner_error(parser,
                                            "while scanning a block scalar",
                                            start_mark,
                                            "did not find expected comment or line break");
              goto error;
            }
          }
        }
      }
  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) 
    goto _LOR_2;
  else 
    if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n')) 
      goto _LOR_2;
    else 
      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
        if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\205')) 
          goto _LOR_2;
        else goto _LAND_15;
      }
      else {
        _LAND_15: ;
        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
          if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
            if ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\250')) 
              goto _LOR_2;
            else goto _LAND_14;
          }
          else goto _LAND_14;
        }
        else {
          _LAND_14: ;
          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) 
            if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) 
              if ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\251')) {
                _LOR_2:
                {
                  int tmp_46;
                  if (parser->unread >= (size_t)2) tmp_46 = 1;
                  else tmp_46 = yaml_parser_update_buffer(parser,(size_t)2);
                  if (! tmp_46) goto error;
                  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) {
                    if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\n')) {
                      parser->mark.index += (size_t)2;
                      parser->mark.column = (size_t)0;
                      (parser->mark.line) ++;
                      parser->unread -= (size_t)2;
                      parser->buffer.pointer += 2;
                      yaml_char_t *tmp_53 = parser->buffer.pointer;
                    }
                    else goto _LAND_12;
                  }
                  else {
                    _LAND_12: ;
                    if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) 
                      goto _LOR_1;
                    else 
                      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n')) 
                        goto _LOR_1;
                      else 
                        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
                          if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\205')) 
                            goto _LOR_1;
                          else goto _LAND_11;
                        }
                        else {
                          _LAND_11: ;
                          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
                            if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                              if ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\250')) 
                                goto _LOR_1;
                              else goto _LAND_10;
                            }
                            else goto _LAND_10;
                          }
                          else {
                            _LAND_10: ;
                            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) 
                              if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) 
                                if ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\251')) {
                                  int tmp_50;
                                  _LOR_1: (parser->mark.index) ++;
                                  parser->mark.column = (size_t)0;
                                  (parser->mark.line) ++;
                                  (parser->unread) --;
                                  if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) 
                                    tmp_50 = 1;
                                  else {
                                    int tmp_49;
                                    if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) 
                                      tmp_49 = 2;
                                    else {
                                      int tmp_48;
                                      if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) 
                                        tmp_48 = 3;
                                      else {
                                        int tmp_47;
                                        if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
                                          tmp_47 = 4;
                                        else tmp_47 = 0;
                                        tmp_48 = tmp_47;
                                      }
                                      tmp_49 = tmp_48;
                                    }
                                    tmp_50 = tmp_49;
                                  }
                                  parser->buffer.pointer += tmp_50;
                                  yaml_char_t *tmp_51 =
                                    parser->buffer.pointer;
                                }
                          }
                        }
                  }
                }
              }
        }
      }
  end_mark = parser->mark;
  if (increment) 
    if (parser->indent >= 0) indent = parser->indent + increment;
    else indent = increment;
  tmp_51_1 = yaml_parser_scan_block_scalar_breaks(parser,& indent,
                                                  & trailing_breaks,
                                                  start_mark,& end_mark);
  if (! tmp_51_1) goto error;
  if (parser->unread >= (size_t)1) tmp_53_1 = 1;
  else tmp_53_1 = yaml_parser_update_buffer(parser,(size_t)1);
  if (! tmp_53_1) goto error;
  while (1) {
    if ((int)parser->mark.column == indent) {
      if (! (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\000')))) 
        break;
    }
    else break;
    {
      int tmp_54;
      int tmp_61;
      int tmp_60;
      int tmp_62;
      int tmp_89_0;
      int tmp_101_0;
      int tmp_91_0;
      int tmp_102;
      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)' ')) 
        tmp_54 = 1;
      else 
        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\t')) 
          tmp_54 = 1;
        else tmp_54 = 0;
      trailing_blank = tmp_54;
      if (! literal) {
        if ((int)*(leading_break.start) == '\n') {
          if (! leading_blank) {
            if (! trailing_blank) {
              if ((int)*(trailing_breaks.start) == '\000') {
                int tmp_56;
                yaml_char_t *tmp_57;
                if (string.pointer + 5 < string.end) tmp_56 = 1;
                else {
                  int tmp_55;
                  tmp_55 = yaml_string_extend(& string.start,
                                              & string.pointer,& string.end);
                  if (tmp_55) tmp_56 = 1;
                  else {
                    parser->error = YAML_MEMORY_ERROR;
                    tmp_56 = 0;
                  }
                }
                if (! tmp_56) goto error;
                tmp_57 = string.pointer;
                (string.pointer) ++;
                *tmp_57 = (yaml_char_t)' ';
              }
              leading_break.pointer = leading_break.start;
              memset((void *)leading_break.start,0,
                     (size_t)(leading_break.end - leading_break.start));
            }
            else goto _LAND_18;
          }
          else goto _LAND_18;
        }
        else goto _LAND_18;
      }
      else {
        _LAND_18:
        {
          int tmp_59;
          int tmp_58;
          tmp_58 = yaml_string_join(& string.start,& string.pointer,
                                    & string.end,& leading_break.start,
                                    & leading_break.pointer,
                                    & leading_break.end);
          if (tmp_58) {
            leading_break.pointer = leading_break.start;
            tmp_59 = 1;
          }
          else {
            parser->error = YAML_MEMORY_ERROR;
            tmp_59 = 0;
          }
          if (! tmp_59) goto error;
          leading_break.pointer = leading_break.start;
          memset((void *)leading_break.start,0,
                 (size_t)(leading_break.end - leading_break.start));
        }
      }
      tmp_60 = yaml_string_join(& string.start,& string.pointer,& string.end,
                                & trailing_breaks.start,
                                & trailing_breaks.pointer,
                                & trailing_breaks.end);
      if (tmp_60) {
        trailing_breaks.pointer = trailing_breaks.start;
        tmp_61 = 1;
      }
      else {
        parser->error = YAML_MEMORY_ERROR;
        tmp_61 = 0;
      }
      if (! tmp_61) goto error;
      trailing_breaks.pointer = trailing_breaks.start;
      memset((void *)trailing_breaks.start,0,
             (size_t)(trailing_breaks.end - trailing_breaks.start));
      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)' ')) 
        tmp_62 = 1;
      else 
        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\t')) 
          tmp_62 = 1;
        else tmp_62 = 0;
      leading_blank = tmp_62;
      while (1) {
        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) 
          break;
        else 
          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n')) 
            break;
          else 
            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
              if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\205')) 
                break;
              else goto _LAND_23;
            }
            else {
              _LAND_23: ;
              if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
                if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                  if ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\250')) 
                    break;
                  else goto _LAND_22;
                }
                else goto _LAND_22;
              }
              else {
                _LAND_22: ;
                if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
                  if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                    if ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\251')) 
                      break;
                    else goto _LAND_20;
                  }
                  else goto _LAND_20;
                }
                else {
                  _LAND_20: ;
                  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\000')) 
                    break;
                }
              }
            }
        {
          int tmp_85_0;
          int tmp_64;
          int tmp_87_0;
          if (string.pointer + 5 < string.end) tmp_64 = 1;
          else {
            int tmp_63;
            tmp_63 = yaml_string_extend(& string.start,& string.pointer,
                                        & string.end);
            if (tmp_63) tmp_64 = 1;
            else {
              parser->error = YAML_MEMORY_ERROR;
              tmp_64 = 0;
            }
          }
          if (tmp_64) {
            if (((int)*(parser->buffer.pointer) & 0x80) == 0x00) {
              yaml_char_t *tmp_65;
              yaml_char_t *tmp_66;
              tmp_65 = string.pointer;
              (string.pointer) ++;
              tmp_66 = parser->buffer.pointer;
              (parser->buffer.pointer) ++;
              *tmp_65 = *tmp_66;
              yaml_char_t tmp_91 = *tmp_65;
            }
            else 
              if (((int)*(parser->buffer.pointer) & 0xE0) == 0xC0) {
                yaml_char_t *tmp_67;
                yaml_char_t *tmp_68;
                yaml_char_t *tmp_69;
                yaml_char_t *tmp_70;
                tmp_67 = string.pointer;
                (string.pointer) ++;
                tmp_68 = parser->buffer.pointer;
                (parser->buffer.pointer) ++;
                *tmp_67 = *tmp_68;
                tmp_69 = string.pointer;
                (string.pointer) ++;
                tmp_70 = parser->buffer.pointer;
                (parser->buffer.pointer) ++;
                *tmp_69 = *tmp_70;
                yaml_char_t tmp_89 = *tmp_69;
              }
              else 
                if (((int)*(parser->buffer.pointer) & 0xF0) == 0xE0) {
                  yaml_char_t *tmp_71;
                  yaml_char_t *tmp_72;
                  yaml_char_t *tmp_73;
                  yaml_char_t *tmp_74;
                  yaml_char_t *tmp_75;
                  yaml_char_t *tmp_76;
                  tmp_71 = string.pointer;
                  (string.pointer) ++;
                  tmp_72 = parser->buffer.pointer;
                  (parser->buffer.pointer) ++;
                  *tmp_71 = *tmp_72;
                  tmp_73 = string.pointer;
                  (string.pointer) ++;
                  tmp_74 = parser->buffer.pointer;
                  (parser->buffer.pointer) ++;
                  *tmp_73 = *tmp_74;
                  tmp_75 = string.pointer;
                  (string.pointer) ++;
                  tmp_76 = parser->buffer.pointer;
                  (parser->buffer.pointer) ++;
                  *tmp_75 = *tmp_76;
                  yaml_char_t tmp_87 = *tmp_75;
                }
                else 
                  if (((int)*(parser->buffer.pointer) & 0xF8) == 0xF0) {
                    yaml_char_t *tmp_77;
                    yaml_char_t *tmp_78;
                    yaml_char_t *tmp_79;
                    yaml_char_t *tmp_80;
                    yaml_char_t *tmp_81;
                    yaml_char_t *tmp_82;
                    yaml_char_t *tmp_83;
                    yaml_char_t *tmp_84;
                    tmp_77 = string.pointer;
                    (string.pointer) ++;
                    tmp_78 = parser->buffer.pointer;
                    (parser->buffer.pointer) ++;
                    *tmp_77 = *tmp_78;
                    tmp_79 = string.pointer;
                    (string.pointer) ++;
                    tmp_80 = parser->buffer.pointer;
                    (parser->buffer.pointer) ++;
                    *tmp_79 = *tmp_80;
                    tmp_81 = string.pointer;
                    (string.pointer) ++;
                    tmp_82 = parser->buffer.pointer;
                    (parser->buffer.pointer) ++;
                    *tmp_81 = *tmp_82;
                    tmp_83 = string.pointer;
                    (string.pointer) ++;
                    tmp_84 = parser->buffer.pointer;
                    (parser->buffer.pointer) ++;
                    *tmp_83 = *tmp_84;
                    yaml_char_t tmp_85 = *tmp_83;
                  }
            (parser->mark.index) ++;
            (parser->mark.column) ++;
            (parser->unread) --;
            tmp_85_0 = 1;
          }
          else tmp_85_0 = 0;
          if (! tmp_85_0) goto error;
          if (parser->unread >= (size_t)1) tmp_87_0 = 1;
          else tmp_87_0 = yaml_parser_update_buffer(parser,(size_t)1);
          if (! tmp_87_0) goto error;
        }
      }
      if (parser->unread >= (size_t)2) tmp_89_0 = 1;
      else tmp_89_0 = yaml_parser_update_buffer(parser,(size_t)2);
      if (! tmp_89_0) goto error;
      if (leading_break.pointer + 5 < leading_break.end) tmp_91_0 = 1;
      else {
        int tmp_90;
        tmp_90 = yaml_string_extend(& leading_break.start,
                                    & leading_break.pointer,
                                    & leading_break.end);
        if (tmp_90) tmp_91_0 = 1;
        else {
          parser->error = YAML_MEMORY_ERROR;
          tmp_91_0 = 0;
        }
      }
      if (tmp_91_0) {
        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) {
          if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\n')) {
            yaml_char_t *tmp_92;
            tmp_92 = leading_break.pointer;
            (leading_break.pointer) ++;
            *tmp_92 = (yaml_char_t)'\n';
            parser->buffer.pointer += 2;
            parser->mark.index += (size_t)2;
            parser->mark.column = (size_t)0;
            (parser->mark.line) ++;
            parser->unread -= (size_t)2;
            size_t tmp_107 = parser->unread;
          }
          else goto _LAND_25;
        }
        else {
          _LAND_25: ;
          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) 
            goto _LOR_4;
          else 
            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n')) {
              yaml_char_t *tmp_93;
              _LOR_4:
              { /* sequence */
                tmp_93 = leading_break.pointer;
                (leading_break.pointer) ++;
                *tmp_93 = (yaml_char_t)'\n';
              }
              (parser->buffer.pointer) ++;
              (parser->mark.index) ++;
              parser->mark.column = (size_t)0;
              (parser->mark.line) ++;
              (parser->unread) --;
              size_t tmp_105 = parser->unread;
            }
            else 
              if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
                if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\205')) {
                  yaml_char_t *tmp_94;
                  tmp_94 = leading_break.pointer;
                  (leading_break.pointer) ++;
                  *tmp_94 = (yaml_char_t)'\n';
                  parser->buffer.pointer += 2;
                  (parser->mark.index) ++;
                  parser->mark.column = (size_t)0;
                  (parser->mark.line) ++;
                  (parser->unread) --;
                  size_t tmp_103 = parser->unread;
                }
                else goto _LAND_24;
              }
              else {
                _LAND_24: ;
                if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) 
                  if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\200')) 
                    if ((int)*(parser->buffer.pointer + 2) == (int)((yaml_char_t)'\250')) 
                      goto _LOR_3;
                    else 
                      if ((int)*(parser->buffer.pointer + 2) == (int)((yaml_char_t)'\251')) {
                        yaml_char_t *tmp_95;
                        yaml_char_t *tmp_96;
                        yaml_char_t *tmp_97;
                        yaml_char_t *tmp_98;
                        yaml_char_t *tmp_99;
                        yaml_char_t *tmp_100;
                        _LOR_3:
                        { /* sequence */
                          tmp_95 = leading_break.pointer;
                          (leading_break.pointer) ++;
                          tmp_96 = parser->buffer.pointer;
                          (parser->buffer.pointer) ++;
                          *tmp_95 = *tmp_96;
                        }
                        tmp_97 = leading_break.pointer;
                        (leading_break.pointer) ++;
                        tmp_98 = parser->buffer.pointer;
                        (parser->buffer.pointer) ++;
                        *tmp_97 = *tmp_98;
                        tmp_99 = leading_break.pointer;
                        (leading_break.pointer) ++;
                        tmp_100 = parser->buffer.pointer;
                        (parser->buffer.pointer) ++;
                        *tmp_99 = *tmp_100;
                        (parser->mark.index) ++;
                        parser->mark.column = (size_t)0;
                        (parser->mark.line) ++;
                        (parser->unread) --;
                        size_t tmp_101 = parser->unread;
                      }
              }
        }
        tmp_101_0 = 1;
      }
      else tmp_101_0 = 0;
      if (! tmp_101_0) goto error;
      tmp_102 = yaml_parser_scan_block_scalar_breaks(parser,& indent,
                                                     & trailing_breaks,
                                                     start_mark,& end_mark);
      if (! tmp_102) goto error;
    }
  }
  if (chomping != -1) {
    int tmp_104;
    int tmp_103_0;
    tmp_103_0 = yaml_string_join(& string.start,& string.pointer,
                                 & string.end,& leading_break.start,
                                 & leading_break.pointer,& leading_break.end);
    if (tmp_103_0) {
      leading_break.pointer = leading_break.start;
      tmp_104 = 1;
    }
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp_104 = 0;
    }
    if (! tmp_104) goto error;
  }
  if (chomping == 1) {
    int tmp_106;
    int tmp_105_0;
    tmp_105_0 = yaml_string_join(& string.start,& string.pointer,
                                 & string.end,& trailing_breaks.start,
                                 & trailing_breaks.pointer,
                                 & trailing_breaks.end);
    if (tmp_105_0) {
      trailing_breaks.pointer = trailing_breaks.start;
      tmp_106 = 1;
    }
    else {
      parser->error = YAML_MEMORY_ERROR;
      tmp_106 = 0;
    }
    if (! tmp_106) goto error;
  }
  memset((void *)token,0,sizeof(yaml_token_t));
  token->type = YAML_SCALAR_TOKEN;
  token->start_mark = start_mark;
  token->end_mark = end_mark;
  token->data.scalar.value = string.start;
  token->data.scalar.length = (size_t)(string.pointer - string.start);
  if (literal) token->data.scalar.style = YAML_LITERAL_SCALAR_STYLE;
  else token->data.scalar.style = YAML_FOLDED_SCALAR_STYLE;
  yaml_free((void *)leading_break.start);
  leading_break.end = (yaml_char_t *)0;
  leading_break.pointer = leading_break.end;
  leading_break.start = leading_break.pointer;
  yaml_free((void *)trailing_breaks.start);
  trailing_breaks.end = (yaml_char_t *)0;
  trailing_breaks.pointer = trailing_breaks.end;
  trailing_breaks.start = trailing_breaks.pointer;
  __retres = 1;
  goto return_label;
  error: yaml_free((void *)string.start);
  string.end = (yaml_char_t *)0;
  string.pointer = string.end;
  string.start = string.pointer;
  yaml_free((void *)leading_break.start);
  leading_break.end = (yaml_char_t *)0;
  leading_break.pointer = leading_break.end;
  leading_break.start = leading_break.pointer;
  yaml_free((void *)trailing_breaks.start);
  trailing_breaks.end = (yaml_char_t *)0;
  trailing_breaks.pointer = trailing_breaks.end;
  trailing_breaks.start = trailing_breaks.pointer;
  __retres = 0;
  return_label: return __retres;
}

static int yaml_parser_scan_block_scalar_breaks(yaml_parser_t *parser,
                                                int *indent,
                                                yaml_string_t *breaks,
                                                yaml_mark_t start_mark,
                                                yaml_mark_t *end_mark)
{
  int __retres;
  int max_indent = 0;
  *end_mark = parser->mark;
  while (1) {
    {
      int tmp_0;
      int tmp_9;
      int tmp_21_1;
      int tmp_11;
      if (parser->unread >= (size_t)1) tmp_0 = 1;
      else tmp_0 = yaml_parser_update_buffer(parser,(size_t)1);
      if (! tmp_0) {
        __retres = 0;
        goto return_label;
      }
      while (1) {
        if (! *indent) goto _LOR;
        else 
          if ((int)parser->mark.column < *indent) {
            _LOR: ;
            if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)' '))) 
              break;
          }
          else break;
        {
          int tmp_4;
          int tmp_6;
          (parser->mark.index) ++;
          (parser->mark.column) ++;
          (parser->unread) --;
          if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_4 = 1;
          else {
            int tmp_3;
            if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) 
              tmp_3 = 2;
            else {
              int tmp_2;
              if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) 
                tmp_2 = 3;
              else {
                int tmp_1;
                if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
                  tmp_1 = 4;
                else tmp_1 = 0;
                tmp_2 = tmp_1;
              }
              tmp_3 = tmp_2;
            }
            tmp_4 = tmp_3;
          }
          parser->buffer.pointer += tmp_4;
          if (parser->unread >= (size_t)1) tmp_6 = 1;
          else tmp_6 = yaml_parser_update_buffer(parser,(size_t)1);
          if (! tmp_6) {
            __retres = 0;
            goto return_label;
          }
        }
      }
      if ((int)parser->mark.column > max_indent) max_indent = (int)parser->mark.column;
      if (! *indent) goto _LOR_0;
      else 
        if ((int)parser->mark.column < *indent) {
          _LOR_0: ;
          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\t')) {
            int tmp_7;
            tmp_7 = yaml_parser_set_scanner_error(parser,
                                                  "while scanning a block scalar",
                                                  start_mark,
                                                  "found a tab character where an indentation space is expected");
            __retres = tmp_7;
            goto return_label;
          }
        }
      if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r'))) 
        if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n'))) 
          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
            if (! ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\205'))) 
              goto _LAND_1;
          }
          else {
            _LAND_1: ;
            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
              if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                if (! ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\250'))) 
                  goto _LAND_0;
              }
              else goto _LAND_0;
            }
            else {
              _LAND_0: ;
              if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) 
                if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                  if (! ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\251'))) 
                    break;
                }
                else break;
              else break;
            }
          }
      if (parser->unread >= (size_t)2) tmp_9 = 1;
      else tmp_9 = yaml_parser_update_buffer(parser,(size_t)2);
      if (! tmp_9) {
        __retres = 0;
        goto return_label;
      }
      if (breaks->pointer + 5 < breaks->end) tmp_11 = 1;
      else {
        int tmp_10;
        tmp_10 = yaml_string_extend(& breaks->start,& breaks->pointer,
                                    & breaks->end);
        if (tmp_10) tmp_11 = 1;
        else {
          parser->error = YAML_MEMORY_ERROR;
          tmp_11 = 0;
        }
      }
      if (tmp_11) {
        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) {
          if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\n')) {
            yaml_char_t *tmp_12;
            tmp_12 = breaks->pointer;
            (breaks->pointer) ++;
            *tmp_12 = (yaml_char_t)'\n';
            parser->buffer.pointer += 2;
            parser->mark.index += (size_t)2;
            parser->mark.column = (size_t)0;
            (parser->mark.line) ++;
            parser->unread -= (size_t)2;
            size_t tmp_27 = parser->unread;
          }
          else goto _LAND_3;
        }
        else {
          _LAND_3: ;
          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) 
            goto _LOR_2;
          else 
            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n')) {
              yaml_char_t *tmp_13;
              _LOR_2:
              { /* sequence */
                tmp_13 = breaks->pointer;
                (breaks->pointer) ++;
                *tmp_13 = (yaml_char_t)'\n';
              }
              (parser->buffer.pointer) ++;
              (parser->mark.index) ++;
              parser->mark.column = (size_t)0;
              (parser->mark.line) ++;
              (parser->unread) --;
              size_t tmp_25 = parser->unread;
            }
            else 
              if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
                if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\205')) {
                  yaml_char_t *tmp_14;
                  tmp_14 = breaks->pointer;
                  (breaks->pointer) ++;
                  *tmp_14 = (yaml_char_t)'\n';
                  parser->buffer.pointer += 2;
                  (parser->mark.index) ++;
                  parser->mark.column = (size_t)0;
                  (parser->mark.line) ++;
                  (parser->unread) --;
                  size_t tmp_23 = parser->unread;
                }
                else goto _LAND_2;
              }
              else {
                _LAND_2: ;
                if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) 
                  if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\200')) 
                    if ((int)*(parser->buffer.pointer + 2) == (int)((yaml_char_t)'\250')) 
                      goto _LOR_1;
                    else 
                      if ((int)*(parser->buffer.pointer + 2) == (int)((yaml_char_t)'\251')) {
                        yaml_char_t *tmp_15;
                        yaml_char_t *tmp_16;
                        yaml_char_t *tmp_17;
                        yaml_char_t *tmp_18;
                        yaml_char_t *tmp_19;
                        yaml_char_t *tmp_20;
                        _LOR_1:
                        { /* sequence */
                          tmp_15 = breaks->pointer;
                          (breaks->pointer) ++;
                          tmp_16 = parser->buffer.pointer;
                          (parser->buffer.pointer) ++;
                          *tmp_15 = *tmp_16;
                        }
                        tmp_17 = breaks->pointer;
                        (breaks->pointer) ++;
                        tmp_18 = parser->buffer.pointer;
                        (parser->buffer.pointer) ++;
                        *tmp_17 = *tmp_18;
                        tmp_19 = breaks->pointer;
                        (breaks->pointer) ++;
                        tmp_20 = parser->buffer.pointer;
                        (parser->buffer.pointer) ++;
                        *tmp_19 = *tmp_20;
                        (parser->mark.index) ++;
                        parser->mark.column = (size_t)0;
                        (parser->mark.line) ++;
                        (parser->unread) --;
                        size_t tmp_21 = parser->unread;
                      }
              }
        }
        tmp_21_1 = 1;
      }
      else tmp_21_1 = 0;
      if (! tmp_21_1) {
        __retres = 0;
        goto return_label;
      }
      *end_mark = parser->mark;
    }
  }
  if (! *indent) {
    *indent = max_indent;
    if (*indent < parser->indent + 1) *indent = parser->indent + 1;
    if (*indent < 1) *indent = 1;
  }
  __retres = 1;
  return_label: return __retres;
}

static int yaml_parser_scan_flow_scalar(yaml_parser_t *parser,
                                        yaml_token_t *token, int single)
{
  int __retres;
  yaml_mark_t start_mark;
  yaml_mark_t end_mark;
  int leading_blanks;
  int tmp_0;
  int tmp_2;
  int tmp_4;
  int tmp_6;
  int tmp_10;
  int tmp_187;
  yaml_string_t string =
    {.start = (yaml_char_t *)0,
     .end = (yaml_char_t *)0,
     .pointer = (yaml_char_t *)0};
  yaml_string_t leading_break =
    {.start = (yaml_char_t *)0,
     .end = (yaml_char_t *)0,
     .pointer = (yaml_char_t *)0};
  yaml_string_t trailing_breaks =
    {.start = (yaml_char_t *)0,
     .end = (yaml_char_t *)0,
     .pointer = (yaml_char_t *)0};
  yaml_string_t whitespaces =
    {.start = (yaml_char_t *)0,
     .end = (yaml_char_t *)0,
     .pointer = (yaml_char_t *)0};
  string.start = (yaml_char_t *)yaml_malloc((size_t)16);
  if (string.start) {
    string.pointer = string.start;
    string.end = string.start + 16;
    memset((void *)string.start,0,(size_t)16);
    tmp_0 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_0 = 0;
  }
  if (! tmp_0) goto error;
  leading_break.start = (yaml_char_t *)yaml_malloc((size_t)16);
  if (leading_break.start) {
    leading_break.pointer = leading_break.start;
    leading_break.end = leading_break.start + 16;
    memset((void *)leading_break.start,0,(size_t)16);
    tmp_2 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_2 = 0;
  }
  if (! tmp_2) goto error;
  trailing_breaks.start = (yaml_char_t *)yaml_malloc((size_t)16);
  if (trailing_breaks.start) {
    trailing_breaks.pointer = trailing_breaks.start;
    trailing_breaks.end = trailing_breaks.start + 16;
    memset((void *)trailing_breaks.start,0,(size_t)16);
    tmp_4 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_4 = 0;
  }
  if (! tmp_4) goto error;
  whitespaces.start = (yaml_char_t *)yaml_malloc((size_t)16);
  if (whitespaces.start) {
    whitespaces.pointer = whitespaces.start;
    whitespaces.end = whitespaces.start + 16;
    memset((void *)whitespaces.start,0,(size_t)16);
    tmp_6 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_6 = 0;
  }
  if (! tmp_6) goto error;
  start_mark = parser->mark;
  (parser->mark.index) ++;
  (parser->mark.column) ++;
  (parser->unread) --;
  if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_10 = 1;
  else {
    int tmp_9;
    if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_9 = 2;
    else {
      int tmp_8;
      if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) tmp_8 = 3;
      else {
        int tmp_7;
        if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) tmp_7 = 4;
        else tmp_7 = 0;
        tmp_8 = tmp_7;
      }
      tmp_9 = tmp_8;
    }
    tmp_10 = tmp_9;
  }
  parser->buffer.pointer += tmp_10;
  while (1) {
    {
      int tmp_12;
      int tmp_14;
      int tmp_114;
      int tmp_115_0;
      int tmp_117;
      if (parser->unread >= (size_t)4) tmp_12 = 1;
      else tmp_12 = yaml_parser_update_buffer(parser,(size_t)4);
      if (! tmp_12) goto error;
      if (parser->mark.column == (size_t)0) 
        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'-')) {
          if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'-')) {
            if ((int)*(parser->buffer.pointer + 2) == (int)((yaml_char_t)'-')) 
              goto _LOR_1;
            else goto _LAND_5;
          }
          else goto _LAND_5;
        }
        else {
          _LAND_5: ;
          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'.')) 
            if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'.')) 
              if ((int)*(parser->buffer.pointer + 2) == (int)((yaml_char_t)'.')) {
                _LOR_1: ;
                if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)' ')) 
                  goto _LOR_0;
                else 
                  if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\t')) 
                    goto _LOR_0;
                  else 
                    if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\r')) 
                      goto _LOR_0;
                    else 
                      if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\n')) 
                        goto _LOR_0;
                      else 
                        if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\302')) {
                          if ((int)*(parser->buffer.pointer + (3 + 1)) == (int)((yaml_char_t)'\205')) 
                            goto _LOR_0;
                          else goto _LAND_3;
                        }
                        else {
                          _LAND_3: ;
                          if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\342')) {
                            if ((int)*(parser->buffer.pointer + (3 + 1)) == (int)((yaml_char_t)'\200')) {
                              if ((int)*(parser->buffer.pointer + (3 + 2)) == (int)((yaml_char_t)'\250')) 
                                goto _LOR_0;
                              else goto _LAND_2;
                            }
                            else goto _LAND_2;
                          }
                          else {
                            _LAND_2: ;
                            if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\342')) {
                              if ((int)*(parser->buffer.pointer + (3 + 1)) == (int)((yaml_char_t)'\200')) {
                                if ((int)*(parser->buffer.pointer + (3 + 2)) == (int)((yaml_char_t)'\251')) 
                                  goto _LOR_0;
                                else goto _LAND_0;
                              }
                              else goto _LAND_0;
                            }
                            else {
                              _LAND_0: ;
                              if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\000')) {
                                _LOR_0:
                                {
                                  yaml_parser_set_scanner_error(parser,
                                                                "while scanning a quoted scalar",
                                                                start_mark,
                                                                "found unexpected document indicator");
                                  goto error;
                                }
                              }
                            }
                          }
                        }
              }
        }
      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\000')) {
        yaml_parser_set_scanner_error(parser,
                                      "while scanning a quoted scalar",
                                      start_mark,
                                      "found unexpected end of stream");
        goto error;
      }
      if (parser->unread >= (size_t)2) tmp_14 = 1;
      else tmp_14 = yaml_parser_update_buffer(parser,(size_t)2);
      if (! tmp_14) goto error;
      leading_blanks = 0;
      while (1) {
        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)' ')) 
          break;
        else 
          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\t')) 
            break;
          else 
            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) 
              break;
            else 
              if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n')) 
                break;
              else 
                if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
                  if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\205')) 
                    break;
                  else goto _LAND_27;
                }
                else {
                  _LAND_27: ;
                  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
                    if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                      if ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\250')) 
                        break;
                      else goto _LAND_26;
                    }
                    else goto _LAND_26;
                  }
                  else {
                    _LAND_26: ;
                    if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
                      if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                        if ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\251')) 
                          break;
                        else goto _LAND_24;
                      }
                      else goto _LAND_24;
                    }
                    else {
                      _LAND_24: ;
                      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\000')) 
                        break;
                    }
                  }
                }
        {
          int tmp_112;
          if (single) {
            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\'')) {
              if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\'')) {
                int tmp_16;
                yaml_char_t *tmp_17;
                int tmp_21;
                int tmp_25;
                if (string.pointer + 5 < string.end) tmp_16 = 1;
                else {
                  int tmp_15;
                  tmp_15 = yaml_string_extend(& string.start,
                                              & string.pointer,& string.end);
                  if (tmp_15) tmp_16 = 1;
                  else {
                    parser->error = YAML_MEMORY_ERROR;
                    tmp_16 = 0;
                  }
                }
                if (! tmp_16) goto error;
                tmp_17 = string.pointer;
                (string.pointer) ++;
                *tmp_17 = (yaml_char_t)'\'';
                (parser->mark.index) ++;
                (parser->mark.column) ++;
                (parser->unread) --;
                if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) 
                  tmp_21 = 1;
                else {
                  int tmp_20;
                  if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) 
                    tmp_20 = 2;
                  else {
                    int tmp_19;
                    if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) 
                      tmp_19 = 3;
                    else {
                      int tmp_18;
                      if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
                        tmp_18 = 4;
                      else tmp_18 = 0;
                      tmp_19 = tmp_18;
                    }
                    tmp_20 = tmp_19;
                  }
                  tmp_21 = tmp_20;
                }
                parser->buffer.pointer += tmp_21;
                (parser->mark.index) ++;
                (parser->mark.column) ++;
                (parser->unread) --;
                if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) 
                  tmp_25 = 1;
                else {
                  int tmp_24;
                  if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) 
                    tmp_24 = 2;
                  else {
                    int tmp_23;
                    if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) 
                      tmp_23 = 3;
                    else {
                      int tmp_22;
                      if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
                        tmp_22 = 4;
                      else tmp_22 = 0;
                      tmp_23 = tmp_22;
                    }
                    tmp_24 = tmp_23;
                  }
                  tmp_25 = tmp_24;
                }
                parser->buffer.pointer += tmp_25;
              }
              else goto _LAND_22;
            }
            else goto _LAND_22;
          }
          else {
            int tmp_110;
            _LAND_22:
            { /* sequence */
              if (single) tmp_110 = '\''; else tmp_110 = '\"';
              ;
            }
            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)tmp_110)) 
              break;
            else 
              if (! single) {
                if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\\')) {
                  if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\r')) 
                    goto _LOR_4;
                  else 
                    if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\n')) 
                      goto _LOR_4;
                    else 
                      if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\302')) {
                        if ((int)*(parser->buffer.pointer + (1 + 1)) == (int)((yaml_char_t)'\205')) 
                          goto _LOR_4;
                        else goto _LAND_19;
                      }
                      else {
                        _LAND_19: ;
                        if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\342')) {
                          if ((int)*(parser->buffer.pointer + (1 + 1)) == (int)((yaml_char_t)'\200')) {
                            if ((int)*(parser->buffer.pointer + (1 + 2)) == (int)((yaml_char_t)'\250')) 
                              goto _LOR_4;
                            else goto _LAND_18;
                          }
                          else goto _LAND_18;
                        }
                        else {
                          _LAND_18: ;
                          if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\342')) {
                            if ((int)*(parser->buffer.pointer + (1 + 1)) == (int)((yaml_char_t)'\200')) {
                              if ((int)*(parser->buffer.pointer + (1 + 2)) == (int)((yaml_char_t)'\251')) {
                                _LOR_4:
                                {
                                  int tmp_27;
                                  int tmp_31;
                                  if (parser->unread >= (size_t)3) tmp_27 = 1;
                                  else tmp_27 = yaml_parser_update_buffer
                                       (parser,(size_t)3);
                                  if (! tmp_27) goto error;
                                  (parser->mark.index) ++;
                                  (parser->mark.column) ++;
                                  (parser->unread) --;
                                  if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) 
                                    tmp_31 = 1;
                                  else {
                                    int tmp_30;
                                    if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) 
                                      tmp_30 = 2;
                                    else {
                                      int tmp_29;
                                      if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) 
                                        tmp_29 = 3;
                                      else {
                                        int tmp_28;
                                        if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
                                          tmp_28 = 4;
                                        else tmp_28 = 0;
                                        tmp_29 = tmp_28;
                                      }
                                      tmp_30 = tmp_29;
                                    }
                                    tmp_31 = tmp_30;
                                  }
                                  parser->buffer.pointer += tmp_31;
                                  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) {
                                    if ((int)*(parser->buffer.pointer + (
                                               0 + 1)) == (int)((yaml_char_t)'\n')) {
                                      parser->mark.index += (size_t)2;
                                      parser->mark.column = (size_t)0;
                                      (parser->mark.line) ++;
                                      parser->unread -= (size_t)2;
                                      parser->buffer.pointer += 2;
                                      yaml_char_t *tmp_38 =
                                        parser->buffer.pointer;
                                    }
                                    else goto _LAND_9;
                                  }
                                  else {
                                    _LAND_9: ;
                                    if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) 
                                      goto _LOR_2;
                                    else 
                                      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n')) 
                                        goto _LOR_2;
                                      else 
                                        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
                                          if ((int)*(parser->buffer.pointer + (
                                                     0 + 1)) == (int)((yaml_char_t)'\205')) 
                                            goto _LOR_2;
                                          else goto _LAND_8;
                                        }
                                        else {
                                          _LAND_8: ;
                                          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
                                            if ((int)*(parser->buffer.pointer + (
                                                       0 + 1)) == (int)((yaml_char_t)'\200')) {
                                              if ((int)*(parser->buffer.pointer + (
                                                         0 + 2)) == (int)((yaml_char_t)'\250')) 
                                                goto _LOR_2;
                                              else goto _LAND_7;
                                            }
                                            else goto _LAND_7;
                                          }
                                          else {
                                            _LAND_7: ;
                                            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) 
                                              if ((int)*(parser->buffer.pointer + (
                                                         0 + 1)) == (int)((yaml_char_t)'\200')) 
                                                if ((int)*(parser->buffer.pointer + (
                                                           0 + 2)) == (int)((yaml_char_t)'\251')) {
                                                  int tmp_35;
                                                  _LOR_2:
                                                  (parser->mark.index) ++;
                                                  parser->mark.column = (size_t)0;
                                                  (parser->mark.line) ++;
                                                  (parser->unread) --;
                                                  if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) 
                                                    tmp_35 = 1;
                                                  else {
                                                    int tmp_34;
                                                    if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) 
                                                      tmp_34 = 2;
                                                    else {
                                                      int tmp_33;
                                                      if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) 
                                                        tmp_33 = 3;
                                                      else {
                                                        int tmp_32;
                                                        if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
                                                          tmp_32 = 4;
                                                        else tmp_32 = 0;
                                                        tmp_33 = tmp_32;
                                                      }
                                                      tmp_34 = tmp_33;
                                                    }
                                                    tmp_35 = tmp_34;
                                                  }
                                                  parser->buffer.pointer += tmp_35;
                                                  yaml_char_t *tmp_36 =
                                                    parser->buffer.pointer;
                                                }
                                          }
                                        }
                                  }
                                  leading_blanks = 1;
                                  break;
                                }
                              }
                              else goto _LAND_20;
                            }
                            else goto _LAND_20;
                          }
                          else goto _LAND_20;
                        }
                      }
                }
                else goto _LAND_20;
              }
              else 
                _LAND_20:
                if (! single) {
                  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\\')) {
                    int tmp_37;
                    int tmp_64;
                    int tmp_68;
                    size_t code_length = (size_t)0;
                    if (string.pointer + 5 < string.end) tmp_37 = 1;
                    else {
                      int tmp_36_1;
                      tmp_36_1 = yaml_string_extend(& string.start,
                                                    & string.pointer,
                                                    & string.end);
                      if (tmp_36_1) tmp_37 = 1;
                      else {
                        parser->error = YAML_MEMORY_ERROR;
                        tmp_37 = 0;
                      }
                    }
                    if (! tmp_37) goto error;
                    switch ((int)*(parser->buffer.pointer + 1)) {
                      yaml_char_t *tmp_38_1;
                      yaml_char_t *tmp_39;
                      yaml_char_t *tmp_40;
                      yaml_char_t *tmp_41;
                      yaml_char_t *tmp_42;
                      yaml_char_t *tmp_43;
                      yaml_char_t *tmp_44;
                      yaml_char_t *tmp_45;
                      yaml_char_t *tmp_46;
                      yaml_char_t *tmp_47;
                      yaml_char_t *tmp_48;
                      yaml_char_t *tmp_49;
                      yaml_char_t *tmp_50;
                      yaml_char_t *tmp_51;
                      yaml_char_t *tmp_52;
                      yaml_char_t *tmp_53;
                      yaml_char_t *tmp_54;
                      yaml_char_t *tmp_55;
                      yaml_char_t *tmp_56;
                      yaml_char_t *tmp_57;
                      yaml_char_t *tmp_58;
                      yaml_char_t *tmp_59;
                      yaml_char_t *tmp_60;
                      case '0':
                      { /* sequence */
                        tmp_38_1 = string.pointer;
                        (string.pointer) ++;
                        *tmp_38_1 = (yaml_char_t)'\000';
                      }
                      break;
                      case 'a':
                      { /* sequence */
                        tmp_39 = string.pointer;
                        (string.pointer) ++;
                        *tmp_39 = (yaml_char_t)'\a';
                      }
                      break;
                      case 'b':
                      { /* sequence */
                        tmp_40 = string.pointer;
                        (string.pointer) ++;
                        *tmp_40 = (yaml_char_t)'\b';
                      }
                      break;
                      case 't': case '\t':
                      { /* sequence */
                        tmp_41 = string.pointer;
                        (string.pointer) ++;
                        *tmp_41 = (yaml_char_t)'\t';
                      }
                      break;
                      case 'n':
                      { /* sequence */
                        tmp_42 = string.pointer;
                        (string.pointer) ++;
                        *tmp_42 = (yaml_char_t)'\n';
                      }
                      break;
                      case 'v':
                      { /* sequence */
                        tmp_43 = string.pointer;
                        (string.pointer) ++;
                        *tmp_43 = (yaml_char_t)'\v';
                      }
                      break;
                      case 'f':
                      { /* sequence */
                        tmp_44 = string.pointer;
                        (string.pointer) ++;
                        *tmp_44 = (yaml_char_t)'\f';
                      }
                      break;
                      case 'r':
                      { /* sequence */
                        tmp_45 = string.pointer;
                        (string.pointer) ++;
                        *tmp_45 = (yaml_char_t)'\r';
                      }
                      break;
                      case 'e':
                      { /* sequence */
                        tmp_46 = string.pointer;
                        (string.pointer) ++;
                        *tmp_46 = (yaml_char_t)'\033';
                      }
                      break;
                      case ' ':
                      { /* sequence */
                        tmp_47 = string.pointer;
                        (string.pointer) ++;
                        *tmp_47 = (yaml_char_t)' ';
                      }
                      break;
                      case '\"':
                      { /* sequence */
                        tmp_48 = string.pointer;
                        (string.pointer) ++;
                        *tmp_48 = (yaml_char_t)'\"';
                      }
                      break;
                      case '/':
                      { /* sequence */
                        tmp_49 = string.pointer;
                        (string.pointer) ++;
                        *tmp_49 = (yaml_char_t)'/';
                      }
                      break;
                      case '\\':
                      { /* sequence */
                        tmp_50 = string.pointer;
                        (string.pointer) ++;
                        *tmp_50 = (yaml_char_t)'\\';
                      }
                      break;
                      case 'N':
                      { /* sequence */
                        tmp_51 = string.pointer;
                        (string.pointer) ++;
                        *tmp_51 = (yaml_char_t)'\302';
                      }
                      tmp_52 = string.pointer;
                      (string.pointer) ++;
                      *tmp_52 = (yaml_char_t)'\205';
                      break;
                      case '_':
                      { /* sequence */
                        tmp_53 = string.pointer;
                        (string.pointer) ++;
                        *tmp_53 = (yaml_char_t)'\302';
                      }
                      tmp_54 = string.pointer;
                      (string.pointer) ++;
                      *tmp_54 = (yaml_char_t)'\240';
                      break;
                      case 'L':
                      { /* sequence */
                        tmp_55 = string.pointer;
                        (string.pointer) ++;
                        *tmp_55 = (yaml_char_t)'\342';
                      }
                      tmp_56 = string.pointer;
                      (string.pointer) ++;
                      *tmp_56 = (yaml_char_t)'\200';
                      tmp_57 = string.pointer;
                      (string.pointer) ++;
                      *tmp_57 = (yaml_char_t)'\250';
                      break;
                      case 'P':
                      { /* sequence */
                        tmp_58 = string.pointer;
                        (string.pointer) ++;
                        *tmp_58 = (yaml_char_t)'\342';
                      }
                      tmp_59 = string.pointer;
                      (string.pointer) ++;
                      *tmp_59 = (yaml_char_t)'\200';
                      tmp_60 = string.pointer;
                      (string.pointer) ++;
                      *tmp_60 = (yaml_char_t)'\251';
                      break;
                      case 'x': code_length = (size_t)2;
                      break;
                      case 'u': code_length = (size_t)4;
                      break;
                      case 'U': code_length = (size_t)8;
                      break;
                      default:
                      yaml_parser_set_scanner_error(parser,
                                                    "while parsing a quoted scalar",
                                                    start_mark,
                                                    "found unknown escape character");
                      goto error;
                    }
                    (parser->mark.index) ++;
                    (parser->mark.column) ++;
                    (parser->unread) --;
                    if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) 
                      tmp_64 = 1;
                    else {
                      int tmp_63;
                      if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) 
                        tmp_63 = 2;
                      else {
                        int tmp_62;
                        if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) 
                          tmp_62 = 3;
                        else {
                          int tmp_61;
                          if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
                            tmp_61 = 4;
                          else tmp_61 = 0;
                          tmp_62 = tmp_61;
                        }
                        tmp_63 = tmp_62;
                      }
                      tmp_64 = tmp_63;
                    }
                    parser->buffer.pointer += tmp_64;
                    (parser->mark.index) ++;
                    (parser->mark.column) ++;
                    (parser->unread) --;
                    if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) 
                      tmp_68 = 1;
                    else {
                      int tmp_67;
                      if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) 
                        tmp_67 = 2;
                      else {
                        int tmp_66;
                        if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) 
                          tmp_66 = 3;
                        else {
                          int tmp_65;
                          if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
                            tmp_65 = 4;
                          else tmp_65 = 0;
                          tmp_66 = tmp_65;
                        }
                        tmp_67 = tmp_66;
                      }
                      tmp_68 = tmp_67;
                    }
                    parser->buffer.pointer += tmp_68;
                    if (code_length) {
                      size_t k;
                      int tmp_70;
                      unsigned int value = (unsigned int)0;
                      if (parser->unread >= code_length) tmp_70 = 1;
                      else tmp_70 = yaml_parser_update_buffer(parser,
                                                              code_length);
                      if (! tmp_70) goto error;
                      k = (size_t)0;
                      while (k < code_length) {
                        {
                          int tmp_72;
                          if ((int)*(parser->buffer.pointer + k) >= (int)((yaml_char_t)'0')) {
                            if (! ((int)*(parser->buffer.pointer + k) <= (int)((yaml_char_t)'9'))) 
                              goto _LAND_12;
                          }
                          else {
                            _LAND_12: ;
                            if ((int)*(parser->buffer.pointer + k) >= (int)((yaml_char_t)'A')) {
                              if (! ((int)*(parser->buffer.pointer + k) <= (int)((yaml_char_t)'F'))) 
                                goto _LAND_11;
                            }
                            else {
                              _LAND_11: ;
                              if ((int)*(parser->buffer.pointer + k) >= (int)((yaml_char_t)'a')) {
                                if (! ((int)*(parser->buffer.pointer + k) <= (int)((yaml_char_t)'f'))) 
                                  goto _LAND_10;
                              }
                              else {
                                _LAND_10:
                                {
                                  yaml_parser_set_scanner_error(parser,
                                                                "while parsing a quoted scalar",
                                                                start_mark,
                                                                "did not find expected hexdecimal number");
                                  goto error;
                                }
                              }
                            }
                          }
                          if ((int)*(parser->buffer.pointer + k) >= (int)((yaml_char_t)'A')) {
                            if ((int)*(parser->buffer.pointer + k) <= (int)((yaml_char_t)'F')) 
                              tmp_72 = ((int)*(parser->buffer.pointer + k) - (int)((yaml_char_t)'A')) + 10;
                            else goto _LAND_13;
                          }
                          else {
                            int tmp_71;
                            _LAND_13:
                            if ((int)*(parser->buffer.pointer + k) >= (int)((yaml_char_t)'a')) 
                              if ((int)*(parser->buffer.pointer + k) <= (int)((yaml_char_t)'f')) 
                                tmp_71 = ((int)*(parser->buffer.pointer + k) - (int)((yaml_char_t)'a')) + 10;
                              else tmp_71 = (int)*(parser->buffer.pointer + k) - (int)((yaml_char_t)'0');
                            else tmp_71 = (int)*(parser->buffer.pointer + k) - (int)((yaml_char_t)'0');
                            tmp_72 = tmp_71;
                          }
                          value = (value << 4) + (unsigned int)tmp_72;
                        }
                        k ++;
                      }
                      if (value >= (unsigned int)0xD800) {
                        if (value <= (unsigned int)0xDFFF) goto _LOR_3;
                        else goto _LAND_14;
                      }
                      else {
                        _LAND_14: ;
                        if (value > (unsigned int)0x10FFFF) {
                          _LOR_3:
                          {
                            yaml_parser_set_scanner_error(parser,
                                                          "while parsing a quoted scalar",
                                                          start_mark,
                                                          "found invalid Unicode character escape code");
                            goto error;
                          }
                        }
                      }
                      if (value <= (unsigned int)0x7F) {
                        yaml_char_t *tmp_73;
                        tmp_73 = string.pointer;
                        (string.pointer) ++;
                        *tmp_73 = (yaml_char_t)value;
                      }
                      else 
                        if (value <= (unsigned int)0x7FF) {
                          yaml_char_t *tmp_74;
                          yaml_char_t *tmp_75;
                          tmp_74 = string.pointer;
                          (string.pointer) ++;
                          *tmp_74 = (yaml_char_t)((unsigned int)0xC0 + (
                                                  value >> 6));
                          tmp_75 = string.pointer;
                          (string.pointer) ++;
                          *tmp_75 = (yaml_char_t)((unsigned int)0x80 + (
                                                  value & (unsigned int)0x3F));
                        }
                        else 
                          if (value <= (unsigned int)0xFFFF) {
                            yaml_char_t *tmp_76;
                            yaml_char_t *tmp_77;
                            yaml_char_t *tmp_78;
                            tmp_76 = string.pointer;
                            (string.pointer) ++;
                            *tmp_76 = (yaml_char_t)((unsigned int)0xE0 + (
                                                    value >> 12));
                            tmp_77 = string.pointer;
                            (string.pointer) ++;
                            *tmp_77 = (yaml_char_t)((unsigned int)0x80 + (
                                                    (value >> 6) & (unsigned int)0x3F));
                            tmp_78 = string.pointer;
                            (string.pointer) ++;
                            *tmp_78 = (yaml_char_t)((unsigned int)0x80 + (
                                                    value & (unsigned int)0x3F));
                          }
                          else {
                            yaml_char_t *tmp_79;
                            yaml_char_t *tmp_80;
                            yaml_char_t *tmp_81;
                            yaml_char_t *tmp_82;
                            tmp_79 = string.pointer;
                            (string.pointer) ++;
                            *tmp_79 = (yaml_char_t)((unsigned int)0xF0 + (
                                                    value >> 18));
                            tmp_80 = string.pointer;
                            (string.pointer) ++;
                            *tmp_80 = (yaml_char_t)((unsigned int)0x80 + (
                                                    (value >> 12) & (unsigned int)0x3F));
                            tmp_81 = string.pointer;
                            (string.pointer) ++;
                            *tmp_81 = (yaml_char_t)((unsigned int)0x80 + (
                                                    (value >> 6) & (unsigned int)0x3F));
                            tmp_82 = string.pointer;
                            (string.pointer) ++;
                            *tmp_82 = (yaml_char_t)((unsigned int)0x80 + (
                                                    value & (unsigned int)0x3F));
                          }
                      k = (size_t)0;
                      while (k < code_length) {
                        {
                          int tmp_86;
                          (parser->mark.index) ++;
                          (parser->mark.column) ++;
                          (parser->unread) --;
                          if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) 
                            tmp_86 = 1;
                          else {
                            int tmp_85;
                            if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) 
                              tmp_85 = 2;
                            else {
                              int tmp_84;
                              if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) 
                                tmp_84 = 3;
                              else {
                                int tmp_83;
                                if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
                                  tmp_83 = 4;
                                else tmp_83 = 0;
                                tmp_84 = tmp_83;
                              }
                              tmp_85 = tmp_84;
                            }
                            tmp_86 = tmp_85;
                          }
                          parser->buffer.pointer += tmp_86;
                        }
                        k ++;
                      }
                    }
                  }
                  else goto _LAND_15;
                }
                else {
                  _LAND_15:
                  {
                    int tmp_109_0;
                    int tmp_88;
                    if (string.pointer + 5 < string.end) tmp_88 = 1;
                    else {
                      int tmp_87;
                      tmp_87 = yaml_string_extend(& string.start,
                                                  & string.pointer,
                                                  & string.end);
                      if (tmp_87) tmp_88 = 1;
                      else {
                        parser->error = YAML_MEMORY_ERROR;
                        tmp_88 = 0;
                      }
                    }
                    if (tmp_88) {
                      if (((int)*(parser->buffer.pointer) & 0x80) == 0x00) {
                        yaml_char_t *tmp_89;
                        yaml_char_t *tmp_90;
                        tmp_89 = string.pointer;
                        (string.pointer) ++;
                        tmp_90 = parser->buffer.pointer;
                        (parser->buffer.pointer) ++;
                        *tmp_89 = *tmp_90;
                        yaml_char_t tmp_115 = *tmp_89;
                      }
                      else 
                        if (((int)*(parser->buffer.pointer) & 0xE0) == 0xC0) {
                          yaml_char_t *tmp_91;
                          yaml_char_t *tmp_92;
                          yaml_char_t *tmp_93;
                          yaml_char_t *tmp_94;
                          tmp_91 = string.pointer;
                          (string.pointer) ++;
                          tmp_92 = parser->buffer.pointer;
                          (parser->buffer.pointer) ++;
                          *tmp_91 = *tmp_92;
                          tmp_93 = string.pointer;
                          (string.pointer) ++;
                          tmp_94 = parser->buffer.pointer;
                          (parser->buffer.pointer) ++;
                          *tmp_93 = *tmp_94;
                          yaml_char_t tmp_113 = *tmp_93;
                        }
                        else 
                          if (((int)*(parser->buffer.pointer) & 0xF0) == 0xE0) {
                            yaml_char_t *tmp_95;
                            yaml_char_t *tmp_96;
                            yaml_char_t *tmp_97;
                            yaml_char_t *tmp_98;
                            yaml_char_t *tmp_99;
                            yaml_char_t *tmp_100;
                            tmp_95 = string.pointer;
                            (string.pointer) ++;
                            tmp_96 = parser->buffer.pointer;
                            (parser->buffer.pointer) ++;
                            *tmp_95 = *tmp_96;
                            tmp_97 = string.pointer;
                            (string.pointer) ++;
                            tmp_98 = parser->buffer.pointer;
                            (parser->buffer.pointer) ++;
                            *tmp_97 = *tmp_98;
                            tmp_99 = string.pointer;
                            (string.pointer) ++;
                            tmp_100 = parser->buffer.pointer;
                            (parser->buffer.pointer) ++;
                            *tmp_99 = *tmp_100;
                            yaml_char_t tmp_111 = *tmp_99;
                          }
                          else 
                            if (((int)*(parser->buffer.pointer) & 0xF8) == 0xF0) {
                              yaml_char_t *tmp_101;
                              yaml_char_t *tmp_102;
                              yaml_char_t *tmp_103;
                              yaml_char_t *tmp_104;
                              yaml_char_t *tmp_105;
                              yaml_char_t *tmp_106;
                              yaml_char_t *tmp_107;
                              yaml_char_t *tmp_108;
                              tmp_101 = string.pointer;
                              (string.pointer) ++;
                              tmp_102 = parser->buffer.pointer;
                              (parser->buffer.pointer) ++;
                              *tmp_101 = *tmp_102;
                              tmp_103 = string.pointer;
                              (string.pointer) ++;
                              tmp_104 = parser->buffer.pointer;
                              (parser->buffer.pointer) ++;
                              *tmp_103 = *tmp_104;
                              tmp_105 = string.pointer;
                              (string.pointer) ++;
                              tmp_106 = parser->buffer.pointer;
                              (parser->buffer.pointer) ++;
                              *tmp_105 = *tmp_106;
                              tmp_107 = string.pointer;
                              (string.pointer) ++;
                              tmp_108 = parser->buffer.pointer;
                              (parser->buffer.pointer) ++;
                              *tmp_107 = *tmp_108;
                              yaml_char_t tmp_109 = *tmp_107;
                            }
                      (parser->mark.index) ++;
                      (parser->mark.column) ++;
                      (parser->unread) --;
                      tmp_109_0 = 1;
                    }
                    else tmp_109_0 = 0;
                    if (! tmp_109_0) goto error;
                  }
                }
          }
          if (parser->unread >= (size_t)2) tmp_112 = 1;
          else tmp_112 = yaml_parser_update_buffer(parser,(size_t)2);
          if (! tmp_112) goto error;
        }
      }
      if (parser->unread >= (size_t)1) tmp_114 = 1;
      else tmp_114 = yaml_parser_update_buffer(parser,(size_t)1);
      if (! tmp_114) goto error;
      if (single) tmp_115_0 = '\''; else tmp_115_0 = '\"';
      ;
      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)tmp_115_0)) 
        break;
      if (parser->unread >= (size_t)1) tmp_117 = 1;
      else tmp_117 = yaml_parser_update_buffer(parser,(size_t)1);
      if (! tmp_117) goto error;
      while (1) {
        if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)' '))) 
          if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\t'))) 
            if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r'))) 
              if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n'))) 
                if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
                  if (! ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\205'))) 
                    goto _LAND_34;
                }
                else {
                  _LAND_34: ;
                  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
                    if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                      if (! ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\250'))) 
                        goto _LAND_33;
                    }
                    else goto _LAND_33;
                  }
                  else {
                    _LAND_33: ;
                    if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) 
                      if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                        if (! ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\251'))) 
                          break;
                      }
                      else break;
                    else break;
                  }
                }
        {
          int tmp_172_0;
          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)' ')) 
            goto _LOR_9;
          else 
            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\t')) 
              _LOR_9:
              if (! leading_blanks) {
                int tmp_140_0;
                int tmp_119;
                if (whitespaces.pointer + 5 < whitespaces.end) tmp_119 = 1;
                else {
                  int tmp_118;
                  tmp_118 = yaml_string_extend(& whitespaces.start,
                                               & whitespaces.pointer,
                                               & whitespaces.end);
                  if (tmp_118) tmp_119 = 1;
                  else {
                    parser->error = YAML_MEMORY_ERROR;
                    tmp_119 = 0;
                  }
                }
                if (tmp_119) {
                  if (((int)*(parser->buffer.pointer) & 0x80) == 0x00) {
                    yaml_char_t *tmp_120;
                    yaml_char_t *tmp_121;
                    tmp_120 = whitespaces.pointer;
                    (whitespaces.pointer) ++;
                    tmp_121 = parser->buffer.pointer;
                    (parser->buffer.pointer) ++;
                    *tmp_120 = *tmp_121;
                    yaml_char_t tmp_146 = *tmp_120;
                  }
                  else 
                    if (((int)*(parser->buffer.pointer) & 0xE0) == 0xC0) {
                      yaml_char_t *tmp_122;
                      yaml_char_t *tmp_123;
                      yaml_char_t *tmp_124;
                      yaml_char_t *tmp_125;
                      tmp_122 = whitespaces.pointer;
                      (whitespaces.pointer) ++;
                      tmp_123 = parser->buffer.pointer;
                      (parser->buffer.pointer) ++;
                      *tmp_122 = *tmp_123;
                      tmp_124 = whitespaces.pointer;
                      (whitespaces.pointer) ++;
                      tmp_125 = parser->buffer.pointer;
                      (parser->buffer.pointer) ++;
                      *tmp_124 = *tmp_125;
                      yaml_char_t tmp_144 = *tmp_124;
                    }
                    else 
                      if (((int)*(parser->buffer.pointer) & 0xF0) == 0xE0) {
                        yaml_char_t *tmp_126;
                        yaml_char_t *tmp_127;
                        yaml_char_t *tmp_128;
                        yaml_char_t *tmp_129;
                        yaml_char_t *tmp_130;
                        yaml_char_t *tmp_131;
                        tmp_126 = whitespaces.pointer;
                        (whitespaces.pointer) ++;
                        tmp_127 = parser->buffer.pointer;
                        (parser->buffer.pointer) ++;
                        *tmp_126 = *tmp_127;
                        tmp_128 = whitespaces.pointer;
                        (whitespaces.pointer) ++;
                        tmp_129 = parser->buffer.pointer;
                        (parser->buffer.pointer) ++;
                        *tmp_128 = *tmp_129;
                        tmp_130 = whitespaces.pointer;
                        (whitespaces.pointer) ++;
                        tmp_131 = parser->buffer.pointer;
                        (parser->buffer.pointer) ++;
                        *tmp_130 = *tmp_131;
                        yaml_char_t tmp_142 = *tmp_130;
                      }
                      else 
                        if (((int)*(parser->buffer.pointer) & 0xF8) == 0xF0) {
                          yaml_char_t *tmp_132;
                          yaml_char_t *tmp_133;
                          yaml_char_t *tmp_134;
                          yaml_char_t *tmp_135;
                          yaml_char_t *tmp_136;
                          yaml_char_t *tmp_137;
                          yaml_char_t *tmp_138;
                          yaml_char_t *tmp_139;
                          tmp_132 = whitespaces.pointer;
                          (whitespaces.pointer) ++;
                          tmp_133 = parser->buffer.pointer;
                          (parser->buffer.pointer) ++;
                          *tmp_132 = *tmp_133;
                          tmp_134 = whitespaces.pointer;
                          (whitespaces.pointer) ++;
                          tmp_135 = parser->buffer.pointer;
                          (parser->buffer.pointer) ++;
                          *tmp_134 = *tmp_135;
                          tmp_136 = whitespaces.pointer;
                          (whitespaces.pointer) ++;
                          tmp_137 = parser->buffer.pointer;
                          (parser->buffer.pointer) ++;
                          *tmp_136 = *tmp_137;
                          tmp_138 = whitespaces.pointer;
                          (whitespaces.pointer) ++;
                          tmp_139 = parser->buffer.pointer;
                          (parser->buffer.pointer) ++;
                          *tmp_138 = *tmp_139;
                          yaml_char_t tmp_140 = *tmp_138;
                        }
                  (parser->mark.index) ++;
                  (parser->mark.column) ++;
                  (parser->unread) --;
                  tmp_140_0 = 1;
                }
                else tmp_140_0 = 0;
                if (! tmp_140_0) goto error;
              }
              else {
                int tmp_144_0;
                (parser->mark.index) ++;
                (parser->mark.column) ++;
                (parser->unread) --;
                if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) 
                  tmp_144_0 = 1;
                else {
                  int tmp_143;
                  if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) 
                    tmp_143 = 2;
                  else {
                    int tmp_142_0;
                    if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) 
                      tmp_142_0 = 3;
                    else {
                      int tmp_141;
                      if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
                        tmp_141 = 4;
                      else tmp_141 = 0;
                      tmp_142_0 = tmp_141;
                    }
                    tmp_143 = tmp_142_0;
                  }
                  tmp_144_0 = tmp_143;
                }
                parser->buffer.pointer += tmp_144_0;
              }
            else {
              int tmp_146_0;
              if (parser->unread >= (size_t)2) tmp_146_0 = 1;
              else tmp_146_0 = yaml_parser_update_buffer(parser,(size_t)2);
              if (! tmp_146_0) goto error;
              if (! leading_blanks) {
                int tmp_158_0;
                int tmp_148;
                whitespaces.pointer = whitespaces.start;
                memset((void *)whitespaces.start,0,
                       (size_t)(whitespaces.end - whitespaces.start));
                if (leading_break.pointer + 5 < leading_break.end) tmp_148 = 1;
                else {
                  int tmp_147;
                  tmp_147 = yaml_string_extend(& leading_break.start,
                                               & leading_break.pointer,
                                               & leading_break.end);
                  if (tmp_147) tmp_148 = 1;
                  else {
                    parser->error = YAML_MEMORY_ERROR;
                    tmp_148 = 0;
                  }
                }
                if (tmp_148) {
                  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) {
                    if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\n')) {
                      yaml_char_t *tmp_149;
                      tmp_149 = leading_break.pointer;
                      (leading_break.pointer) ++;
                      *tmp_149 = (yaml_char_t)'\n';
                      parser->buffer.pointer += 2;
                      parser->mark.index += (size_t)2;
                      parser->mark.column = (size_t)0;
                      (parser->mark.line) ++;
                      parser->unread -= (size_t)2;
                      size_t tmp_164 = parser->unread;
                    }
                    else goto _LAND_29;
                  }
                  else {
                    _LAND_29: ;
                    if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) 
                      goto _LOR_6;
                    else 
                      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n')) {
                        yaml_char_t *tmp_150;
                        _LOR_6:
                        { /* sequence */
                          tmp_150 = leading_break.pointer;
                          (leading_break.pointer) ++;
                          *tmp_150 = (yaml_char_t)'\n';
                        }
                        (parser->buffer.pointer) ++;
                        (parser->mark.index) ++;
                        parser->mark.column = (size_t)0;
                        (parser->mark.line) ++;
                        (parser->unread) --;
                        size_t tmp_162 = parser->unread;
                      }
                      else 
                        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
                          if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\205')) {
                            yaml_char_t *tmp_151;
                            tmp_151 = leading_break.pointer;
                            (leading_break.pointer) ++;
                            *tmp_151 = (yaml_char_t)'\n';
                            parser->buffer.pointer += 2;
                            (parser->mark.index) ++;
                            parser->mark.column = (size_t)0;
                            (parser->mark.line) ++;
                            (parser->unread) --;
                            size_t tmp_160 = parser->unread;
                          }
                          else goto _LAND_28;
                        }
                        else {
                          _LAND_28: ;
                          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) 
                            if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\200')) 
                              if ((int)*(parser->buffer.pointer + 2) == (int)((yaml_char_t)'\250')) 
                                goto _LOR_5;
                              else 
                                if ((int)*(parser->buffer.pointer + 2) == (int)((yaml_char_t)'\251')) {
                                  yaml_char_t *tmp_152;
                                  yaml_char_t *tmp_153;
                                  yaml_char_t *tmp_154;
                                  yaml_char_t *tmp_155;
                                  yaml_char_t *tmp_156;
                                  yaml_char_t *tmp_157;
                                  _LOR_5:
                                  { /* sequence */
                                    tmp_152 = leading_break.pointer;
                                    (leading_break.pointer) ++;
                                    tmp_153 = parser->buffer.pointer;
                                    (parser->buffer.pointer) ++;
                                    *tmp_152 = *tmp_153;
                                  }
                                  tmp_154 = leading_break.pointer;
                                  (leading_break.pointer) ++;
                                  tmp_155 = parser->buffer.pointer;
                                  (parser->buffer.pointer) ++;
                                  *tmp_154 = *tmp_155;
                                  tmp_156 = leading_break.pointer;
                                  (leading_break.pointer) ++;
                                  tmp_157 = parser->buffer.pointer;
                                  (parser->buffer.pointer) ++;
                                  *tmp_156 = *tmp_157;
                                  (parser->mark.index) ++;
                                  parser->mark.column = (size_t)0;
                                  (parser->mark.line) ++;
                                  (parser->unread) --;
                                  size_t tmp_158 = parser->unread;
                                }
                        }
                  }
                  tmp_158_0 = 1;
                }
                else tmp_158_0 = 0;
                if (! tmp_158_0) goto error;
                leading_blanks = 1;
              }
              else {
                int tmp_170_0;
                int tmp_160_0;
                if (trailing_breaks.pointer + 5 < trailing_breaks.end) 
                  tmp_160_0 = 1;
                else {
                  int tmp_159;
                  tmp_159 = yaml_string_extend(& trailing_breaks.start,
                                               & trailing_breaks.pointer,
                                               & trailing_breaks.end);
                  if (tmp_159) tmp_160_0 = 1;
                  else {
                    parser->error = YAML_MEMORY_ERROR;
                    tmp_160_0 = 0;
                  }
                }
                if (tmp_160_0) {
                  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) {
                    if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\n')) {
                      yaml_char_t *tmp_161;
                      tmp_161 = trailing_breaks.pointer;
                      (trailing_breaks.pointer) ++;
                      *tmp_161 = (yaml_char_t)'\n';
                      parser->buffer.pointer += 2;
                      parser->mark.index += (size_t)2;
                      parser->mark.column = (size_t)0;
                      (parser->mark.line) ++;
                      parser->unread -= (size_t)2;
                      size_t tmp_176 = parser->unread;
                    }
                    else goto _LAND_31;
                  }
                  else {
                    _LAND_31: ;
                    if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) 
                      goto _LOR_8;
                    else 
                      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n')) {
                        yaml_char_t *tmp_162_0;
                        _LOR_8:
                        { /* sequence */
                          tmp_162_0 = trailing_breaks.pointer;
                          (trailing_breaks.pointer) ++;
                          *tmp_162_0 = (yaml_char_t)'\n';
                        }
                        (parser->buffer.pointer) ++;
                        (parser->mark.index) ++;
                        parser->mark.column = (size_t)0;
                        (parser->mark.line) ++;
                        (parser->unread) --;
                        size_t tmp_174 = parser->unread;
                      }
                      else 
                        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
                          if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\205')) {
                            yaml_char_t *tmp_163;
                            tmp_163 = trailing_breaks.pointer;
                            (trailing_breaks.pointer) ++;
                            *tmp_163 = (yaml_char_t)'\n';
                            parser->buffer.pointer += 2;
                            (parser->mark.index) ++;
                            parser->mark.column = (size_t)0;
                            (parser->mark.line) ++;
                            (parser->unread) --;
                            size_t tmp_172 = parser->unread;
                          }
                          else goto _LAND_30;
                        }
                        else {
                          _LAND_30: ;
                          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) 
                            if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\200')) 
                              if ((int)*(parser->buffer.pointer + 2) == (int)((yaml_char_t)'\250')) 
                                goto _LOR_7;
                              else 
                                if ((int)*(parser->buffer.pointer + 2) == (int)((yaml_char_t)'\251')) {
                                  yaml_char_t *tmp_164_0;
                                  yaml_char_t *tmp_165;
                                  yaml_char_t *tmp_166;
                                  yaml_char_t *tmp_167;
                                  yaml_char_t *tmp_168;
                                  yaml_char_t *tmp_169;
                                  _LOR_7:
                                  { /* sequence */
                                    tmp_164_0 = trailing_breaks.pointer;
                                    (trailing_breaks.pointer) ++;
                                    tmp_165 = parser->buffer.pointer;
                                    (parser->buffer.pointer) ++;
                                    *tmp_164_0 = *tmp_165;
                                  }
                                  tmp_166 = trailing_breaks.pointer;
                                  (trailing_breaks.pointer) ++;
                                  tmp_167 = parser->buffer.pointer;
                                  (parser->buffer.pointer) ++;
                                  *tmp_166 = *tmp_167;
                                  tmp_168 = trailing_breaks.pointer;
                                  (trailing_breaks.pointer) ++;
                                  tmp_169 = parser->buffer.pointer;
                                  (parser->buffer.pointer) ++;
                                  *tmp_168 = *tmp_169;
                                  (parser->mark.index) ++;
                                  parser->mark.column = (size_t)0;
                                  (parser->mark.line) ++;
                                  (parser->unread) --;
                                  size_t tmp_170 = parser->unread;
                                }
                        }
                  }
                  tmp_170_0 = 1;
                }
                else tmp_170_0 = 0;
                if (! tmp_170_0) goto error;
              }
            }
          if (parser->unread >= (size_t)1) tmp_172_0 = 1;
          else tmp_172_0 = yaml_parser_update_buffer(parser,(size_t)1);
          if (! tmp_172_0) goto error;
        }
      }
      if (leading_blanks) 
        if ((int)*(leading_break.start + 0) == '\n') {
          if ((int)*(trailing_breaks.start + 0) == '\000') {
            int tmp_174_0;
            yaml_char_t *tmp_175;
            if (string.pointer + 5 < string.end) tmp_174_0 = 1;
            else {
              int tmp_173;
              tmp_173 = yaml_string_extend(& string.start,& string.pointer,
                                           & string.end);
              if (tmp_173) tmp_174_0 = 1;
              else {
                parser->error = YAML_MEMORY_ERROR;
                tmp_174_0 = 0;
              }
            }
            if (! tmp_174_0) goto error;
            tmp_175 = string.pointer;
            (string.pointer) ++;
            *tmp_175 = (yaml_char_t)' ';
          }
          else {
            int tmp_177;
            int tmp_176_0;
            tmp_176_0 = yaml_string_join(& string.start,& string.pointer,
                                         & string.end,
                                         & trailing_breaks.start,
                                         & trailing_breaks.pointer,
                                         & trailing_breaks.end);
            if (tmp_176_0) {
              trailing_breaks.pointer = trailing_breaks.start;
              tmp_177 = 1;
            }
            else {
              parser->error = YAML_MEMORY_ERROR;
              tmp_177 = 0;
            }
            if (! tmp_177) goto error;
            trailing_breaks.pointer = trailing_breaks.start;
            memset((void *)trailing_breaks.start,0,
                   (size_t)(trailing_breaks.end - trailing_breaks.start));
          }
          leading_break.pointer = leading_break.start;
          memset((void *)leading_break.start,0,
                 (size_t)(leading_break.end - leading_break.start));
        }
        else {
          int tmp_179;
          int tmp_178;
          int tmp_181;
          int tmp_180;
          tmp_178 = yaml_string_join(& string.start,& string.pointer,
                                     & string.end,& leading_break.start,
                                     & leading_break.pointer,
                                     & leading_break.end);
          if (tmp_178) {
            leading_break.pointer = leading_break.start;
            tmp_179 = 1;
          }
          else {
            parser->error = YAML_MEMORY_ERROR;
            tmp_179 = 0;
          }
          if (! tmp_179) goto error;
          tmp_180 = yaml_string_join(& string.start,& string.pointer,
                                     & string.end,& trailing_breaks.start,
                                     & trailing_breaks.pointer,
                                     & trailing_breaks.end);
          if (tmp_180) {
            trailing_breaks.pointer = trailing_breaks.start;
            tmp_181 = 1;
          }
          else {
            parser->error = YAML_MEMORY_ERROR;
            tmp_181 = 0;
          }
          if (! tmp_181) goto error;
          leading_break.pointer = leading_break.start;
          memset((void *)leading_break.start,0,
                 (size_t)(leading_break.end - leading_break.start));
          trailing_breaks.pointer = trailing_breaks.start;
          memset((void *)trailing_breaks.start,0,
                 (size_t)(trailing_breaks.end - trailing_breaks.start));
        }
      else {
        int tmp_183;
        int tmp_182;
        tmp_182 = yaml_string_join(& string.start,& string.pointer,
                                   & string.end,& whitespaces.start,
                                   & whitespaces.pointer,& whitespaces.end);
        if (tmp_182) {
          whitespaces.pointer = whitespaces.start;
          tmp_183 = 1;
        }
        else {
          parser->error = YAML_MEMORY_ERROR;
          tmp_183 = 0;
        }
        if (! tmp_183) goto error;
        whitespaces.pointer = whitespaces.start;
        memset((void *)whitespaces.start,0,
               (size_t)(whitespaces.end - whitespaces.start));
      }
    }
  }
  (parser->mark.index) ++;
  (parser->mark.column) ++;
  (parser->unread) --;
  if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) tmp_187 = 1;
  else {
    int tmp_186;
    if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) tmp_186 = 2;
    else {
      int tmp_185;
      if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) tmp_185 = 3;
      else {
        int tmp_184;
        if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) tmp_184 = 4;
        else tmp_184 = 0;
        tmp_185 = tmp_184;
      }
      tmp_186 = tmp_185;
    }
    tmp_187 = tmp_186;
  }
  parser->buffer.pointer += tmp_187;
  end_mark = parser->mark;
  memset((void *)token,0,sizeof(yaml_token_t));
  token->type = YAML_SCALAR_TOKEN;
  token->start_mark = start_mark;
  token->end_mark = end_mark;
  token->data.scalar.value = string.start;
  token->data.scalar.length = (size_t)(string.pointer - string.start);
  if (single) token->data.scalar.style = YAML_SINGLE_QUOTED_SCALAR_STYLE;
  else token->data.scalar.style = YAML_DOUBLE_QUOTED_SCALAR_STYLE;
  yaml_free((void *)leading_break.start);
  leading_break.end = (yaml_char_t *)0;
  leading_break.pointer = leading_break.end;
  leading_break.start = leading_break.pointer;
  yaml_free((void *)trailing_breaks.start);
  trailing_breaks.end = (yaml_char_t *)0;
  trailing_breaks.pointer = trailing_breaks.end;
  trailing_breaks.start = trailing_breaks.pointer;
  yaml_free((void *)whitespaces.start);
  whitespaces.end = (yaml_char_t *)0;
  whitespaces.pointer = whitespaces.end;
  whitespaces.start = whitespaces.pointer;
  __retres = 1;
  goto return_label;
  error: yaml_free((void *)string.start);
  string.end = (yaml_char_t *)0;
  string.pointer = string.end;
  string.start = string.pointer;
  yaml_free((void *)leading_break.start);
  leading_break.end = (yaml_char_t *)0;
  leading_break.pointer = leading_break.end;
  leading_break.start = leading_break.pointer;
  yaml_free((void *)trailing_breaks.start);
  trailing_breaks.end = (yaml_char_t *)0;
  trailing_breaks.pointer = trailing_breaks.end;
  trailing_breaks.start = trailing_breaks.pointer;
  yaml_free((void *)whitespaces.start);
  whitespaces.end = (yaml_char_t *)0;
  whitespaces.pointer = whitespaces.end;
  whitespaces.start = whitespaces.pointer;
  __retres = 0;
  return_label: return __retres;
}

static int yaml_parser_scan_plain_scalar(yaml_parser_t *parser,
                                         yaml_token_t *token)
{
  int __retres;
  yaml_mark_t start_mark;
  yaml_mark_t end_mark;
  int tmp_0;
  int tmp_2;
  int tmp_4;
  int tmp_6;
  yaml_string_t string =
    {.start = (yaml_char_t *)0,
     .end = (yaml_char_t *)0,
     .pointer = (yaml_char_t *)0};
  yaml_string_t leading_break =
    {.start = (yaml_char_t *)0,
     .end = (yaml_char_t *)0,
     .pointer = (yaml_char_t *)0};
  yaml_string_t trailing_breaks =
    {.start = (yaml_char_t *)0,
     .end = (yaml_char_t *)0,
     .pointer = (yaml_char_t *)0};
  yaml_string_t whitespaces =
    {.start = (yaml_char_t *)0,
     .end = (yaml_char_t *)0,
     .pointer = (yaml_char_t *)0};
  int leading_blanks = 0;
  int indent = parser->indent + 1;
  string.start = (yaml_char_t *)yaml_malloc((size_t)16);
  if (string.start) {
    string.pointer = string.start;
    string.end = string.start + 16;
    memset((void *)string.start,0,(size_t)16);
    tmp_0 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_0 = 0;
  }
  if (! tmp_0) goto error;
  leading_break.start = (yaml_char_t *)yaml_malloc((size_t)16);
  if (leading_break.start) {
    leading_break.pointer = leading_break.start;
    leading_break.end = leading_break.start + 16;
    memset((void *)leading_break.start,0,(size_t)16);
    tmp_2 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_2 = 0;
  }
  if (! tmp_2) goto error;
  trailing_breaks.start = (yaml_char_t *)yaml_malloc((size_t)16);
  if (trailing_breaks.start) {
    trailing_breaks.pointer = trailing_breaks.start;
    trailing_breaks.end = trailing_breaks.start + 16;
    memset((void *)trailing_breaks.start,0,(size_t)16);
    tmp_4 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_4 = 0;
  }
  if (! tmp_4) goto error;
  whitespaces.start = (yaml_char_t *)yaml_malloc((size_t)16);
  if (whitespaces.start) {
    whitespaces.pointer = whitespaces.start;
    whitespaces.end = whitespaces.start + 16;
    memset((void *)whitespaces.start,0,(size_t)16);
    tmp_6 = 1;
  }
  else {
    parser->error = YAML_MEMORY_ERROR;
    tmp_6 = 0;
  }
  if (! tmp_6) goto error;
  end_mark = parser->mark;
  start_mark = end_mark;
  while (1) {
    {
      int tmp_8;
      int tmp_46_1;
      if (parser->unread >= (size_t)4) tmp_8 = 1;
      else tmp_8 = yaml_parser_update_buffer(parser,(size_t)4);
      if (! tmp_8) goto error;
      if (parser->mark.column == (size_t)0) 
        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'-')) {
          if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'-')) {
            if ((int)*(parser->buffer.pointer + 2) == (int)((yaml_char_t)'-')) 
              goto _LOR;
            else goto _LAND_5;
          }
          else goto _LAND_5;
        }
        else {
          _LAND_5: ;
          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'.')) 
            if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'.')) 
              if ((int)*(parser->buffer.pointer + 2) == (int)((yaml_char_t)'.')) {
                _LOR: ;
                if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)' ')) 
                  break;
                else 
                  if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\t')) 
                    break;
                  else 
                    if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\r')) 
                      break;
                    else 
                      if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\n')) 
                        break;
                      else 
                        if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\302')) {
                          if ((int)*(parser->buffer.pointer + (3 + 1)) == (int)((yaml_char_t)'\205')) 
                            break;
                          else goto _LAND_3;
                        }
                        else {
                          _LAND_3: ;
                          if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\342')) {
                            if ((int)*(parser->buffer.pointer + (3 + 1)) == (int)((yaml_char_t)'\200')) {
                              if ((int)*(parser->buffer.pointer + (3 + 2)) == (int)((yaml_char_t)'\250')) 
                                break;
                              else goto _LAND_2;
                            }
                            else goto _LAND_2;
                          }
                          else {
                            _LAND_2: ;
                            if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\342')) {
                              if ((int)*(parser->buffer.pointer + (3 + 1)) == (int)((yaml_char_t)'\200')) {
                                if ((int)*(parser->buffer.pointer + (3 + 2)) == (int)((yaml_char_t)'\251')) 
                                  break;
                                else goto _LAND_0;
                              }
                              else goto _LAND_0;
                            }
                            else {
                              _LAND_0: ;
                              if ((int)*(parser->buffer.pointer + 3) == (int)((yaml_char_t)'\000')) 
                                break;
                            }
                          }
                        }
              }
        }
      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'#')) 
        break;
      while (1) {
        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)' ')) 
          break;
        else 
          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\t')) 
            break;
          else 
            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) 
              break;
            else 
              if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n')) 
                break;
              else 
                if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
                  if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\205')) 
                    break;
                  else goto _LAND_16;
                }
                else {
                  _LAND_16: ;
                  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
                    if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                      if ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\250')) 
                        break;
                      else goto _LAND_15;
                    }
                    else goto _LAND_15;
                  }
                  else {
                    _LAND_15: ;
                    if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
                      if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                        if ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\251')) 
                          break;
                        else goto _LAND_13;
                      }
                      else goto _LAND_13;
                    }
                    else {
                      _LAND_13: ;
                      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\000')) 
                        break;
                    }
                  }
                }
        {
          int tmp_42_2;
          int tmp_21;
          int tmp_44_2;
          if (parser->flow_level) 
            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)':')) 
              if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)',')) 
                goto _LOR_0;
              else 
                if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'?')) 
                  goto _LOR_0;
                else 
                  if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'[')) 
                    goto _LOR_0;
                  else 
                    if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)']')) 
                      goto _LOR_0;
                    else 
                      if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'{')) 
                        goto _LOR_0;
                      else 
                        if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'}')) {
                          _LOR_0:
                          {
                            yaml_parser_set_scanner_error(parser,
                                                          "while scanning a plain scalar",
                                                          start_mark,
                                                          "found unexpected \':\'");
                            goto error;
                          }
                        }
          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)':')) 
            if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)' ')) 
              break;
            else 
              if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\t')) 
                break;
              else 
                if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\r')) 
                  break;
                else 
                  if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\n')) 
                    break;
                  else 
                    if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\302')) {
                      if ((int)*(parser->buffer.pointer + (1 + 1)) == (int)((yaml_char_t)'\205')) 
                        break;
                      else goto _LAND_11;
                    }
                    else {
                      _LAND_11: ;
                      if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\342')) {
                        if ((int)*(parser->buffer.pointer + (1 + 1)) == (int)((yaml_char_t)'\200')) {
                          if ((int)*(parser->buffer.pointer + (1 + 2)) == (int)((yaml_char_t)'\250')) 
                            break;
                          else goto _LAND_10;
                        }
                        else goto _LAND_10;
                      }
                      else {
                        _LAND_10: ;
                        if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\342')) {
                          if ((int)*(parser->buffer.pointer + (1 + 1)) == (int)((yaml_char_t)'\200')) {
                            if ((int)*(parser->buffer.pointer + (1 + 2)) == (int)((yaml_char_t)'\251')) 
                              break;
                            else goto _LAND_8;
                          }
                          else goto _LAND_8;
                        }
                        else {
                          _LAND_8: ;
                          if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\000')) 
                            break;
                          else goto _LAND_6;
                        }
                      }
                    }
          else {
            _LAND_6: ;
            if (parser->flow_level) 
              if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)',')) 
                break;
              else 
                if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'[')) 
                  break;
                else 
                  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)']')) 
                    break;
                  else 
                    if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'{')) 
                      break;
                    else 
                      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'}')) 
                        break;
          }
          if (leading_blanks) goto _LOR_1;
          else 
            if (whitespaces.start != whitespaces.pointer) 
              _LOR_1:
              if (leading_blanks) {
                if ((int)*(leading_break.start + 0) == '\n') {
                  if ((int)*(trailing_breaks.start + 0) == '\000') {
                    int tmp_10;
                    yaml_char_t *tmp_11;
                    if (string.pointer + 5 < string.end) tmp_10 = 1;
                    else {
                      int tmp_9;
                      tmp_9 = yaml_string_extend(& string.start,
                                                 & string.pointer,
                                                 & string.end);
                      if (tmp_9) tmp_10 = 1;
                      else {
                        parser->error = YAML_MEMORY_ERROR;
                        tmp_10 = 0;
                      }
                    }
                    if (! tmp_10) goto error;
                    tmp_11 = string.pointer;
                    (string.pointer) ++;
                    *tmp_11 = (yaml_char_t)' ';
                  }
                  else {
                    int tmp_13;
                    int tmp_12;
                    tmp_12 = yaml_string_join(& string.start,
                                              & string.pointer,& string.end,
                                              & trailing_breaks.start,
                                              & trailing_breaks.pointer,
                                              & trailing_breaks.end);
                    if (tmp_12) {
                      trailing_breaks.pointer = trailing_breaks.start;
                      tmp_13 = 1;
                    }
                    else {
                      parser->error = YAML_MEMORY_ERROR;
                      tmp_13 = 0;
                    }
                    if (! tmp_13) goto error;
                    trailing_breaks.pointer = trailing_breaks.start;
                    memset((void *)trailing_breaks.start,0,
                           (size_t)(trailing_breaks.end - trailing_breaks.start));
                  }
                  leading_break.pointer = leading_break.start;
                  memset((void *)leading_break.start,0,
                         (size_t)(leading_break.end - leading_break.start));
                }
                else {
                  int tmp_15;
                  int tmp_14;
                  int tmp_17;
                  int tmp_16;
                  tmp_14 = yaml_string_join(& string.start,& string.pointer,
                                            & string.end,
                                            & leading_break.start,
                                            & leading_break.pointer,
                                            & leading_break.end);
                  if (tmp_14) {
                    leading_break.pointer = leading_break.start;
                    tmp_15 = 1;
                  }
                  else {
                    parser->error = YAML_MEMORY_ERROR;
                    tmp_15 = 0;
                  }
                  if (! tmp_15) goto error;
                  tmp_16 = yaml_string_join(& string.start,& string.pointer,
                                            & string.end,
                                            & trailing_breaks.start,
                                            & trailing_breaks.pointer,
                                            & trailing_breaks.end);
                  if (tmp_16) {
                    trailing_breaks.pointer = trailing_breaks.start;
                    tmp_17 = 1;
                  }
                  else {
                    parser->error = YAML_MEMORY_ERROR;
                    tmp_17 = 0;
                  }
                  if (! tmp_17) goto error;
                  leading_break.pointer = leading_break.start;
                  memset((void *)leading_break.start,0,
                         (size_t)(leading_break.end - leading_break.start));
                  trailing_breaks.pointer = trailing_breaks.start;
                  memset((void *)trailing_breaks.start,0,
                         (size_t)(trailing_breaks.end - trailing_breaks.start));
                }
                leading_blanks = 0;
              }
              else {
                int tmp_19;
                int tmp_18;
                tmp_18 = yaml_string_join(& string.start,& string.pointer,
                                          & string.end,& whitespaces.start,
                                          & whitespaces.pointer,
                                          & whitespaces.end);
                if (tmp_18) {
                  whitespaces.pointer = whitespaces.start;
                  tmp_19 = 1;
                }
                else {
                  parser->error = YAML_MEMORY_ERROR;
                  tmp_19 = 0;
                }
                if (! tmp_19) goto error;
                whitespaces.pointer = whitespaces.start;
                memset((void *)whitespaces.start,0,
                       (size_t)(whitespaces.end - whitespaces.start));
              }
          if (string.pointer + 5 < string.end) tmp_21 = 1;
          else {
            int tmp_20;
            tmp_20 = yaml_string_extend(& string.start,& string.pointer,
                                        & string.end);
            if (tmp_20) tmp_21 = 1;
            else {
              parser->error = YAML_MEMORY_ERROR;
              tmp_21 = 0;
            }
          }
          if (tmp_21) {
            if (((int)*(parser->buffer.pointer) & 0x80) == 0x00) {
              yaml_char_t *tmp_22;
              yaml_char_t *tmp_23;
              tmp_22 = string.pointer;
              (string.pointer) ++;
              tmp_23 = parser->buffer.pointer;
              (parser->buffer.pointer) ++;
              *tmp_22 = *tmp_23;
              yaml_char_t tmp_48 = *tmp_22;
            }
            else 
              if (((int)*(parser->buffer.pointer) & 0xE0) == 0xC0) {
                yaml_char_t *tmp_24;
                yaml_char_t *tmp_25;
                yaml_char_t *tmp_26;
                yaml_char_t *tmp_27;
                tmp_24 = string.pointer;
                (string.pointer) ++;
                tmp_25 = parser->buffer.pointer;
                (parser->buffer.pointer) ++;
                *tmp_24 = *tmp_25;
                tmp_26 = string.pointer;
                (string.pointer) ++;
                tmp_27 = parser->buffer.pointer;
                (parser->buffer.pointer) ++;
                *tmp_26 = *tmp_27;
                yaml_char_t tmp_46 = *tmp_26;
              }
              else 
                if (((int)*(parser->buffer.pointer) & 0xF0) == 0xE0) {
                  yaml_char_t *tmp_28;
                  yaml_char_t *tmp_29;
                  yaml_char_t *tmp_30;
                  yaml_char_t *tmp_31;
                  yaml_char_t *tmp_32;
                  yaml_char_t *tmp_33;
                  tmp_28 = string.pointer;
                  (string.pointer) ++;
                  tmp_29 = parser->buffer.pointer;
                  (parser->buffer.pointer) ++;
                  *tmp_28 = *tmp_29;
                  tmp_30 = string.pointer;
                  (string.pointer) ++;
                  tmp_31 = parser->buffer.pointer;
                  (parser->buffer.pointer) ++;
                  *tmp_30 = *tmp_31;
                  tmp_32 = string.pointer;
                  (string.pointer) ++;
                  tmp_33 = parser->buffer.pointer;
                  (parser->buffer.pointer) ++;
                  *tmp_32 = *tmp_33;
                  yaml_char_t tmp_44 = *tmp_32;
                }
                else 
                  if (((int)*(parser->buffer.pointer) & 0xF8) == 0xF0) {
                    yaml_char_t *tmp_34;
                    yaml_char_t *tmp_35;
                    yaml_char_t *tmp_36;
                    yaml_char_t *tmp_37;
                    yaml_char_t *tmp_38;
                    yaml_char_t *tmp_39;
                    yaml_char_t *tmp_40;
                    yaml_char_t *tmp_41;
                    tmp_34 = string.pointer;
                    (string.pointer) ++;
                    tmp_35 = parser->buffer.pointer;
                    (parser->buffer.pointer) ++;
                    *tmp_34 = *tmp_35;
                    tmp_36 = string.pointer;
                    (string.pointer) ++;
                    tmp_37 = parser->buffer.pointer;
                    (parser->buffer.pointer) ++;
                    *tmp_36 = *tmp_37;
                    tmp_38 = string.pointer;
                    (string.pointer) ++;
                    tmp_39 = parser->buffer.pointer;
                    (parser->buffer.pointer) ++;
                    *tmp_38 = *tmp_39;
                    tmp_40 = string.pointer;
                    (string.pointer) ++;
                    tmp_41 = parser->buffer.pointer;
                    (parser->buffer.pointer) ++;
                    *tmp_40 = *tmp_41;
                    yaml_char_t tmp_42 = *tmp_40;
                  }
            (parser->mark.index) ++;
            (parser->mark.column) ++;
            (parser->unread) --;
            tmp_42_2 = 1;
          }
          else tmp_42_2 = 0;
          if (! tmp_42_2) goto error;
          end_mark = parser->mark;
          if (parser->unread >= (size_t)2) tmp_44_2 = 1;
          else tmp_44_2 = yaml_parser_update_buffer(parser,(size_t)2);
          if (! tmp_44_2) goto error;
        }
      }
      if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)' '))) 
        if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\t'))) 
          if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r'))) 
            if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n'))) 
              if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
                if (! ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\205'))) 
                  goto _LAND_19;
              }
              else {
                _LAND_19: ;
                if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
                  if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                    if (! ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\250'))) 
                      goto _LAND_18;
                  }
                  else goto _LAND_18;
                }
                else {
                  _LAND_18: ;
                  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) 
                    if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                      if (! ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\251'))) 
                        break;
                    }
                    else break;
                  else break;
                }
              }
      if (parser->unread >= (size_t)1) tmp_46_1 = 1;
      else tmp_46_1 = yaml_parser_update_buffer(parser,(size_t)1);
      if (! tmp_46_1) goto error;
      while (1) {
        if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)' '))) 
          if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\t'))) 
            if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r'))) 
              if (! ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n'))) 
                if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
                  if (! ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\205'))) 
                    goto _LAND_26;
                }
                else {
                  _LAND_26: ;
                  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) {
                    if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                      if (! ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\250'))) 
                        goto _LAND_25;
                    }
                    else goto _LAND_25;
                  }
                  else {
                    _LAND_25: ;
                    if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) 
                      if ((int)*(parser->buffer.pointer + (0 + 1)) == (int)((yaml_char_t)'\200')) {
                        if (! ((int)*(parser->buffer.pointer + (0 + 2)) == (int)((yaml_char_t)'\251'))) 
                          break;
                      }
                      else break;
                    else break;
                  }
                }
        {
          int tmp_101_1;
          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)' ')) 
            goto _LOR_6;
          else 
            if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\t')) {
              _LOR_6:
              {
                if (leading_blanks) 
                  if ((int)parser->mark.column < indent) 
                    if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\t')) {
                      yaml_parser_set_scanner_error(parser,
                                                    "while scanning a plain scalar",
                                                    start_mark,
                                                    "found a tab character that violates indentation");
                      goto error;
                    }
                if (! leading_blanks) {
                  int tmp_69_0;
                  int tmp_48_1;
                  if (whitespaces.pointer + 5 < whitespaces.end) tmp_48_1 = 1;
                  else {
                    int tmp_47;
                    tmp_47 = yaml_string_extend(& whitespaces.start,
                                                & whitespaces.pointer,
                                                & whitespaces.end);
                    if (tmp_47) tmp_48_1 = 1;
                    else {
                      parser->error = YAML_MEMORY_ERROR;
                      tmp_48_1 = 0;
                    }
                  }
                  if (tmp_48_1) {
                    if (((int)*(parser->buffer.pointer) & 0x80) == 0x00) {
                      yaml_char_t *tmp_49;
                      yaml_char_t *tmp_50;
                      tmp_49 = whitespaces.pointer;
                      (whitespaces.pointer) ++;
                      tmp_50 = parser->buffer.pointer;
                      (parser->buffer.pointer) ++;
                      *tmp_49 = *tmp_50;
                      yaml_char_t tmp_75 = *tmp_49;
                    }
                    else 
                      if (((int)*(parser->buffer.pointer) & 0xE0) == 0xC0) {
                        yaml_char_t *tmp_51;
                        yaml_char_t *tmp_52;
                        yaml_char_t *tmp_53;
                        yaml_char_t *tmp_54;
                        tmp_51 = whitespaces.pointer;
                        (whitespaces.pointer) ++;
                        tmp_52 = parser->buffer.pointer;
                        (parser->buffer.pointer) ++;
                        *tmp_51 = *tmp_52;
                        tmp_53 = whitespaces.pointer;
                        (whitespaces.pointer) ++;
                        tmp_54 = parser->buffer.pointer;
                        (parser->buffer.pointer) ++;
                        *tmp_53 = *tmp_54;
                        yaml_char_t tmp_73 = *tmp_53;
                      }
                      else 
                        if (((int)*(parser->buffer.pointer) & 0xF0) == 0xE0) {
                          yaml_char_t *tmp_55;
                          yaml_char_t *tmp_56;
                          yaml_char_t *tmp_57;
                          yaml_char_t *tmp_58;
                          yaml_char_t *tmp_59;
                          yaml_char_t *tmp_60;
                          tmp_55 = whitespaces.pointer;
                          (whitespaces.pointer) ++;
                          tmp_56 = parser->buffer.pointer;
                          (parser->buffer.pointer) ++;
                          *tmp_55 = *tmp_56;
                          tmp_57 = whitespaces.pointer;
                          (whitespaces.pointer) ++;
                          tmp_58 = parser->buffer.pointer;
                          (parser->buffer.pointer) ++;
                          *tmp_57 = *tmp_58;
                          tmp_59 = whitespaces.pointer;
                          (whitespaces.pointer) ++;
                          tmp_60 = parser->buffer.pointer;
                          (parser->buffer.pointer) ++;
                          *tmp_59 = *tmp_60;
                          yaml_char_t tmp_71 = *tmp_59;
                        }
                        else 
                          if (((int)*(parser->buffer.pointer) & 0xF8) == 0xF0) {
                            yaml_char_t *tmp_61;
                            yaml_char_t *tmp_62;
                            yaml_char_t *tmp_63;
                            yaml_char_t *tmp_64;
                            yaml_char_t *tmp_65;
                            yaml_char_t *tmp_66;
                            yaml_char_t *tmp_67;
                            yaml_char_t *tmp_68;
                            tmp_61 = whitespaces.pointer;
                            (whitespaces.pointer) ++;
                            tmp_62 = parser->buffer.pointer;
                            (parser->buffer.pointer) ++;
                            *tmp_61 = *tmp_62;
                            tmp_63 = whitespaces.pointer;
                            (whitespaces.pointer) ++;
                            tmp_64 = parser->buffer.pointer;
                            (parser->buffer.pointer) ++;
                            *tmp_63 = *tmp_64;
                            tmp_65 = whitespaces.pointer;
                            (whitespaces.pointer) ++;
                            tmp_66 = parser->buffer.pointer;
                            (parser->buffer.pointer) ++;
                            *tmp_65 = *tmp_66;
                            tmp_67 = whitespaces.pointer;
                            (whitespaces.pointer) ++;
                            tmp_68 = parser->buffer.pointer;
                            (parser->buffer.pointer) ++;
                            *tmp_67 = *tmp_68;
                            yaml_char_t tmp_69 = *tmp_67;
                          }
                    (parser->mark.index) ++;
                    (parser->mark.column) ++;
                    (parser->unread) --;
                    tmp_69_0 = 1;
                  }
                  else tmp_69_0 = 0;
                  if (! tmp_69_0) goto error;
                }
                else {
                  int tmp_73_0;
                  (parser->mark.index) ++;
                  (parser->mark.column) ++;
                  (parser->unread) --;
                  if (((int)*(parser->buffer.pointer + 0) & 0x80) == 0x00) 
                    tmp_73_0 = 1;
                  else {
                    int tmp_72;
                    if (((int)*(parser->buffer.pointer + 0) & 0xE0) == 0xC0) 
                      tmp_72 = 2;
                    else {
                      int tmp_71_0;
                      if (((int)*(parser->buffer.pointer + 0) & 0xF0) == 0xE0) 
                        tmp_71_0 = 3;
                      else {
                        int tmp_70;
                        if (((int)*(parser->buffer.pointer + 0) & 0xF8) == 0xF0) 
                          tmp_70 = 4;
                        else tmp_70 = 0;
                        tmp_71_0 = tmp_70;
                      }
                      tmp_72 = tmp_71_0;
                    }
                    tmp_73_0 = tmp_72;
                  }
                  parser->buffer.pointer += tmp_73_0;
                }
              }
            }
            else {
              int tmp_75_1;
              if (parser->unread >= (size_t)2) tmp_75_1 = 1;
              else tmp_75_1 = yaml_parser_update_buffer(parser,(size_t)2);
              if (! tmp_75_1) goto error;
              if (! leading_blanks) {
                int tmp_87_1;
                int tmp_77;
                whitespaces.pointer = whitespaces.start;
                memset((void *)whitespaces.start,0,
                       (size_t)(whitespaces.end - whitespaces.start));
                if (leading_break.pointer + 5 < leading_break.end) tmp_77 = 1;
                else {
                  int tmp_76;
                  tmp_76 = yaml_string_extend(& leading_break.start,
                                              & leading_break.pointer,
                                              & leading_break.end);
                  if (tmp_76) tmp_77 = 1;
                  else {
                    parser->error = YAML_MEMORY_ERROR;
                    tmp_77 = 0;
                  }
                }
                if (tmp_77) {
                  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) {
                    if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\n')) {
                      yaml_char_t *tmp_78;
                      tmp_78 = leading_break.pointer;
                      (leading_break.pointer) ++;
                      *tmp_78 = (yaml_char_t)'\n';
                      parser->buffer.pointer += 2;
                      parser->mark.index += (size_t)2;
                      parser->mark.column = (size_t)0;
                      (parser->mark.line) ++;
                      parser->unread -= (size_t)2;
                      size_t tmp_93 = parser->unread;
                    }
                    else goto _LAND_21;
                  }
                  else {
                    _LAND_21: ;
                    if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) 
                      goto _LOR_3;
                    else 
                      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n')) {
                        yaml_char_t *tmp_79;
                        _LOR_3:
                        { /* sequence */
                          tmp_79 = leading_break.pointer;
                          (leading_break.pointer) ++;
                          *tmp_79 = (yaml_char_t)'\n';
                        }
                        (parser->buffer.pointer) ++;
                        (parser->mark.index) ++;
                        parser->mark.column = (size_t)0;
                        (parser->mark.line) ++;
                        (parser->unread) --;
                        size_t tmp_91 = parser->unread;
                      }
                      else 
                        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
                          if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\205')) {
                            yaml_char_t *tmp_80;
                            tmp_80 = leading_break.pointer;
                            (leading_break.pointer) ++;
                            *tmp_80 = (yaml_char_t)'\n';
                            parser->buffer.pointer += 2;
                            (parser->mark.index) ++;
                            parser->mark.column = (size_t)0;
                            (parser->mark.line) ++;
                            (parser->unread) --;
                            size_t tmp_89 = parser->unread;
                          }
                          else goto _LAND_20;
                        }
                        else {
                          _LAND_20: ;
                          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) 
                            if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\200')) 
                              if ((int)*(parser->buffer.pointer + 2) == (int)((yaml_char_t)'\250')) 
                                goto _LOR_2;
                              else 
                                if ((int)*(parser->buffer.pointer + 2) == (int)((yaml_char_t)'\251')) {
                                  yaml_char_t *tmp_81;
                                  yaml_char_t *tmp_82;
                                  yaml_char_t *tmp_83;
                                  yaml_char_t *tmp_84;
                                  yaml_char_t *tmp_85;
                                  yaml_char_t *tmp_86;
                                  _LOR_2:
                                  { /* sequence */
                                    tmp_81 = leading_break.pointer;
                                    (leading_break.pointer) ++;
                                    tmp_82 = parser->buffer.pointer;
                                    (parser->buffer.pointer) ++;
                                    *tmp_81 = *tmp_82;
                                  }
                                  tmp_83 = leading_break.pointer;
                                  (leading_break.pointer) ++;
                                  tmp_84 = parser->buffer.pointer;
                                  (parser->buffer.pointer) ++;
                                  *tmp_83 = *tmp_84;
                                  tmp_85 = leading_break.pointer;
                                  (leading_break.pointer) ++;
                                  tmp_86 = parser->buffer.pointer;
                                  (parser->buffer.pointer) ++;
                                  *tmp_85 = *tmp_86;
                                  (parser->mark.index) ++;
                                  parser->mark.column = (size_t)0;
                                  (parser->mark.line) ++;
                                  (parser->unread) --;
                                  size_t tmp_87 = parser->unread;
                                }
                        }
                  }
                  tmp_87_1 = 1;
                }
                else tmp_87_1 = 0;
                if (! tmp_87_1) goto error;
                leading_blanks = 1;
              }
              else {
                int tmp_99_0;
                int tmp_89_1;
                if (trailing_breaks.pointer + 5 < trailing_breaks.end) 
                  tmp_89_1 = 1;
                else {
                  int tmp_88;
                  tmp_88 = yaml_string_extend(& trailing_breaks.start,
                                              & trailing_breaks.pointer,
                                              & trailing_breaks.end);
                  if (tmp_88) tmp_89_1 = 1;
                  else {
                    parser->error = YAML_MEMORY_ERROR;
                    tmp_89_1 = 0;
                  }
                }
                if (tmp_89_1) {
                  if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) {
                    if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\n')) {
                      yaml_char_t *tmp_90;
                      tmp_90 = trailing_breaks.pointer;
                      (trailing_breaks.pointer) ++;
                      *tmp_90 = (yaml_char_t)'\n';
                      parser->buffer.pointer += 2;
                      parser->mark.index += (size_t)2;
                      parser->mark.column = (size_t)0;
                      (parser->mark.line) ++;
                      parser->unread -= (size_t)2;
                      size_t tmp_105 = parser->unread;
                    }
                    else goto _LAND_23;
                  }
                  else {
                    _LAND_23: ;
                    if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\r')) 
                      goto _LOR_5;
                    else 
                      if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\n')) {
                        yaml_char_t *tmp_91_1;
                        _LOR_5:
                        { /* sequence */
                          tmp_91_1 = trailing_breaks.pointer;
                          (trailing_breaks.pointer) ++;
                          *tmp_91_1 = (yaml_char_t)'\n';
                        }
                        (parser->buffer.pointer) ++;
                        (parser->mark.index) ++;
                        parser->mark.column = (size_t)0;
                        (parser->mark.line) ++;
                        (parser->unread) --;
                        size_t tmp_103 = parser->unread;
                      }
                      else 
                        if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\302')) {
                          if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\205')) {
                            yaml_char_t *tmp_92;
                            tmp_92 = trailing_breaks.pointer;
                            (trailing_breaks.pointer) ++;
                            *tmp_92 = (yaml_char_t)'\n';
                            parser->buffer.pointer += 2;
                            (parser->mark.index) ++;
                            parser->mark.column = (size_t)0;
                            (parser->mark.line) ++;
                            (parser->unread) --;
                            size_t tmp_101 = parser->unread;
                          }
                          else goto _LAND_22;
                        }
                        else {
                          _LAND_22: ;
                          if ((int)*(parser->buffer.pointer + 0) == (int)((yaml_char_t)'\342')) 
                            if ((int)*(parser->buffer.pointer + 1) == (int)((yaml_char_t)'\200')) 
                              if ((int)*(parser->buffer.pointer + 2) == (int)((yaml_char_t)'\250')) 
                                goto _LOR_4;
                              else 
                                if ((int)*(parser->buffer.pointer + 2) == (int)((yaml_char_t)'\251')) {
                                  yaml_char_t *tmp_93_0;
                                  yaml_char_t *tmp_94;
                                  yaml_char_t *tmp_95;
                                  yaml_char_t *tmp_96;
                                  yaml_char_t *tmp_97;
                                  yaml_char_t *tmp_98;
                                  _LOR_4:
                                  { /* sequence */
                                    tmp_93_0 = trailing_breaks.pointer;
                                    (trailing_breaks.pointer) ++;
                                    tmp_94 = parser->buffer.pointer;
                                    (parser->buffer.pointer) ++;
                                    *tmp_93_0 = *tmp_94;
                                  }
                                  tmp_95 = trailing_breaks.pointer;
                                  (trailing_breaks.pointer) ++;
                                  tmp_96 = parser->buffer.pointer;
                                  (parser->buffer.pointer) ++;
                                  *tmp_95 = *tmp_96;
                                  tmp_97 = trailing_breaks.pointer;
                                  (trailing_breaks.pointer) ++;
                                  tmp_98 = parser->buffer.pointer;
                                  (parser->buffer.pointer) ++;
                                  *tmp_97 = *tmp_98;
                                  (parser->mark.index) ++;
                                  parser->mark.column = (size_t)0;
                                  (parser->mark.line) ++;
                                  (parser->unread) --;
                                  size_t tmp_99 = parser->unread;
                                }
                        }
                  }
                  tmp_99_0 = 1;
                }
                else tmp_99_0 = 0;
                if (! tmp_99_0) goto error;
              }
            }
          if (parser->unread >= (size_t)1) tmp_101_1 = 1;
          else tmp_101_1 = yaml_parser_update_buffer(parser,(size_t)1);
          if (! tmp_101_1) goto error;
        }
      }
      if (! parser->flow_level) 
        if ((int)parser->mark.column < indent) break;
    }
  }
  memset((void *)token,0,sizeof(yaml_token_t));
  token->type = YAML_SCALAR_TOKEN;
  token->start_mark = start_mark;
  token->end_mark = end_mark;
  token->data.scalar.value = string.start;
  token->data.scalar.length = (size_t)(string.pointer - string.start);
  token->data.scalar.style = YAML_PLAIN_SCALAR_STYLE;
  if (leading_blanks) parser->simple_key_allowed = 1;
  yaml_free((void *)leading_break.start);
  leading_break.end = (yaml_char_t *)0;
  leading_break.pointer = leading_break.end;
  leading_break.start = leading_break.pointer;
  yaml_free((void *)trailing_breaks.start);
  trailing_breaks.end = (yaml_char_t *)0;
  trailing_breaks.pointer = trailing_breaks.end;
  trailing_breaks.start = trailing_breaks.pointer;
  yaml_free((void *)whitespaces.start);
  whitespaces.end = (yaml_char_t *)0;
  whitespaces.pointer = whitespaces.end;
  whitespaces.start = whitespaces.pointer;
  __retres = 1;
  goto return_label;
  error: yaml_free((void *)string.start);
  string.end = (yaml_char_t *)0;
  string.pointer = string.end;
  string.start = string.pointer;
  yaml_free((void *)leading_break.start);
  leading_break.end = (yaml_char_t *)0;
  leading_break.pointer = leading_break.end;
  leading_break.start = leading_break.pointer;
  yaml_free((void *)trailing_breaks.start);
  trailing_breaks.end = (yaml_char_t *)0;
  trailing_breaks.pointer = trailing_breaks.end;
  trailing_breaks.start = trailing_breaks.pointer;
  yaml_free((void *)whitespaces.start);
  whitespaces.end = (yaml_char_t *)0;
  whitespaces.pointer = whitespaces.end;
  whitespaces.start = whitespaces.pointer;
  __retres = 0;
  return_label: return __retres;
}

static int yaml_emitter_set_writer_error(yaml_emitter_t *emitter,
                                         char const *problem);

static int yaml_emitter_set_writer_error(yaml_emitter_t *emitter,
                                         char const *problem)
{
  int __retres;
  emitter->error = YAML_WRITER_ERROR;
  emitter->problem = problem;
  __retres = 0;
  return __retres;
}

int yaml_emitter_flush(yaml_emitter_t *emitter)
{
  int __retres;
  int low;
  int high;
  int tmp_8;
  __FC_assert(emitter != (yaml_emitter_t *)0,"src/writer.c",36,"emitter");
  __FC_assert(emitter->write_handler != (yaml_write_handler_t *)0,
              "src/writer.c",37,"emitter->write_handler");
  __FC_assert(emitter->encoding != (unsigned int)0,"src/writer.c",38,
              "emitter->encoding");
  emitter->buffer.last = emitter->buffer.pointer;
  emitter->buffer.pointer = emitter->buffer.start;
  if (emitter->buffer.start == emitter->buffer.last) {
    __retres = 1;
    goto return_label;
  }
  if (emitter->encoding == (unsigned int)YAML_UTF8_ENCODING) {
    int tmp_0;
    tmp_0 = (*(emitter->write_handler))(emitter->write_handler_data,
                                        emitter->buffer.start,
                                        (size_t)(emitter->buffer.last - emitter->buffer.start));
    if (tmp_0) {
      emitter->buffer.last = emitter->buffer.start;
      emitter->buffer.pointer = emitter->buffer.start;
      __retres = 1;
      goto return_label;
    }
    else {
      int tmp;
      tmp = yaml_emitter_set_writer_error(emitter,"write error");
      __retres = tmp;
      goto return_label;
    }
  }
  if (emitter->encoding == (unsigned int)YAML_UTF16LE_ENCODING) low = 0;
  else low = 1;
  if (emitter->encoding == (unsigned int)YAML_UTF16LE_ENCODING) high = 1;
  else high = 0;
  while (emitter->buffer.pointer != emitter->buffer.last) {
    unsigned char octet;
    unsigned int width;
    unsigned int value;
    size_t k;
    octet = *(emitter->buffer.pointer + 0);
    if (((int)octet & 0x80) == 0x00) width = (unsigned int)1;
    else {
      int tmp_3;
      if (((int)octet & 0xE0) == 0xC0) tmp_3 = 2;
      else {
        int tmp_2;
        if (((int)octet & 0xF0) == 0xE0) tmp_2 = 3;
        else {
          int tmp_1;
          if (((int)octet & 0xF8) == 0xF0) tmp_1 = 4; else tmp_1 = 0;
          tmp_2 = tmp_1;
        }
        tmp_3 = tmp_2;
      }
      width = (unsigned int)tmp_3;
    }
    if (((int)octet & 0x80) == 0x00) value = (unsigned int)((int)octet & 0x7F);
    else {
      int tmp_6;
      if (((int)octet & 0xE0) == 0xC0) tmp_6 = (int)octet & 0x1F;
      else {
        int tmp_5;
        if (((int)octet & 0xF0) == 0xE0) tmp_5 = (int)octet & 0x0F;
        else {
          int tmp_4;
          if (((int)octet & 0xF8) == 0xF0) tmp_4 = (int)octet & 0x07;
          else tmp_4 = 0;
          tmp_5 = tmp_4;
        }
        tmp_6 = tmp_5;
      }
      value = (unsigned int)tmp_6;
    }
    k = (size_t)1;
    while (k < (size_t)width) {
      octet = *(emitter->buffer.pointer + k);
      value = (value << 6) + (unsigned int)((int)octet & 0x3F);
      k ++;
    }
    emitter->buffer.pointer += width;
    if (value < (unsigned int)0x10000) {
      *(emitter->raw_buffer.last + high) = (unsigned char)(value >> 8);
      *(emitter->raw_buffer.last + low) = (unsigned char)(value & (unsigned int)0xFF);
      emitter->raw_buffer.last += 2;
    }
    else {
      value -= (unsigned int)0x10000;
      *(emitter->raw_buffer.last + high) = (unsigned char)((unsigned int)0xD8 + (
                                                           value >> 18));
      *(emitter->raw_buffer.last + low) = (unsigned char)((value >> 10) & (unsigned int)0xFF);
      *(emitter->raw_buffer.last + (high + 2)) = (unsigned char)((unsigned int)0xDC + (
                                                                 (value >> 8) & (unsigned int)0xFF));
      *(emitter->raw_buffer.last + (low + 2)) = (unsigned char)(value & (unsigned int)0xFF);
      emitter->raw_buffer.last += 4;
    }
  }
  tmp_8 = (*(emitter->write_handler))(emitter->write_handler_data,
                                      emitter->raw_buffer.start,
                                      (size_t)(emitter->raw_buffer.last - emitter->raw_buffer.start));
  if (tmp_8) {
    emitter->buffer.last = emitter->buffer.start;
    emitter->buffer.pointer = emitter->buffer.start;
    emitter->raw_buffer.last = emitter->raw_buffer.start;
    emitter->raw_buffer.pointer = emitter->raw_buffer.start;
    __retres = 1;
    goto return_label;
  }
  else {
    int tmp_7;
    tmp_7 = yaml_emitter_set_writer_error(emitter,"write error");
    __retres = tmp_7;
    goto return_label;
  }
  return_label: return __retres;
}

test_case utf8_sequences[43] =
  {{.title = (char *)"a simple test",
    .test = (char *)"\'test\' is \'\320\277\321\200\320\276\320\262\320\265\321\200\320\272\320\260\' in Russian!",
    .result = 1},
   {.title = (char *)"an empty line", .test = (char *)"!", .result = 1},
   {.title = (char *)"u-0 is a control character",
    .test = (char *)"\000!",
    .result = 0},
   {.title = (char *)"u-80 is a control character",
    .test = (char *)"\302\200!",
    .result = 0},
   {.title = (char *)"u-800 is valid",
    .test = (char *)"\340\240\200!",
    .result = 1},
   {.title = (char *)"u-10000 is valid",
    .test = (char *)"\360\220\200\200!",
    .result = 1},
   {.title = (char *)"5 bytes sequences are not allowed",
    .test = (char *)"\370\210\200\200\200!",
    .result = 0},
   {.title = (char *)"6 bytes sequences are not allowed",
    .test = (char *)"\374\204\200\200\200\200!",
    .result = 0},
   {.title = (char *)"u-7f is a control character",
    .test = (char *)"\177!",
    .result = 0},
   {.title = (char *)"u-7FF is valid",
    .test = (char *)"\337\277!",
    .result = 1},
   {.title = (char *)"u-FFFF is a control character",
    .test = (char *)"\357\277\277!",
    .result = 0},
   {.title = (char *)"u-1FFFFF is too large",
    .test = (char *)"\367\277\277\277!",
    .result = 0},
   {.title = (char *)"u-3FFFFFF is 5 bytes",
    .test = (char *)"\373\277\277\277\277!",
    .result = 0},
   {.title = (char *)"u-7FFFFFFF is 6 bytes",
    .test = (char *)"\375\277\277\277\277\277!",
    .result = 0},
   {.title = (char *)"u-D7FF", .test = (char *)"\355\237\277!", .result = 1},
   {.title = (char *)"u-E000", .test = (char *)"\356\200\200!", .result = 1},
   {.title = (char *)"u-FFFD", .test = (char *)"\357\277\275!", .result = 1},
   {.title = (char *)"u-10FFFF",
    .test = (char *)"\364\217\277\277!",
    .result = 1},
   {.title = (char *)"u-110000",
    .test = (char *)"\364\220\200\200!",
    .result = 0},
   {.title = (char *)"first continuation byte",
    .test = (char *)"\200!",
    .result = 0},
   {.title = (char *)"last continuation byte",
    .test = (char *)"\277!",
    .result = 0},
   {.title = (char *)"2 continuation bytes",
    .test = (char *)"\200\277!",
    .result = 0},
   {.title = (char *)"3 continuation bytes",
    .test = (char *)"\200\277\200!",
    .result = 0},
   {.title = (char *)"4 continuation bytes",
    .test = (char *)"\200\277\200\277!",
    .result = 0},
   {.title = (char *)"5 continuation bytes",
    .test = (char *)"\200\277\200\277\200!",
    .result = 0},
   {.title = (char *)"6 continuation bytes",
    .test = (char *)"\200\277\200\277\200\277!",
    .result = 0},
   {.title = (char *)"7 continuation bytes",
    .test = (char *)"\200\277\200\277\200\277\200!",
    .result = 0},
   {.title = (char *)"sequence of all 64 possible continuation bytes",
    .test = (char *)"\200|\201|\202|\203|\204|\205|\206|\207|\210|\211|\212|\213|\214|\215|\216|\217|\220|\221|\222|\223|\224|\225|\226|\227|\230|\231|\232|\233|\234|\235|\236|\237|\240|\241|\242|\243|\244|\245|\246|\247|\250|\251|\252|\253|\254|\255|\256|\257|\260|\261|\262|\263|\264|\265|\266|\267|\270|\271|\272|\273|\274|\275|\276|\277!",
    .result = 0},
   {.title = (char *)"32 first bytes of 2-byte sequences {0xc0-0xdf}",
    .test = (char *)"\300 |\301 |\302 |\303 |\304 |\305 |\306 |\307 |\310 |\311 |\312 |\313 |\314 |\315 |\316 |\317 |\320 |\321 |\322 |\323 |\324 |\325 |\326 |\327 |\330 |\331 |\332 |\333 |\334 |\335 |\336 |\337 !",
    .result = 0},
   {.title = (char *)"16 first bytes of 3-byte sequences {0xe0-0xef}",
    .test = (char *)"\340 |\341 |\342 |\343 |\344 |\345 |\346 |\347 |\350 |\351 |\352 |\353 |\354 |\355 |\356 |\357 !",
    .result = 0},
   {.title = (char *)"8 first bytes of 4-byte sequences {0xf0-0xf7}",
    .test = (char *)"\360 |\361 |\362 |\363 |\364 |\365 |\366 |\367 !",
    .result = 0},
   {.title = (char *)"4 first bytes of 5-byte sequences {0xf8-0xfb}",
    .test = (char *)"\370 |\371 |\372 |\373 !",
    .result = 0},
   {.title = (char *)"2 first bytes of 6-byte sequences {0xfc-0xfd}",
    .test = (char *)"\374 |\375 !",
    .result = 0},
   {.title = (char *)"sequences with last byte missing {u-0}",
    .test = (char *)"\300|\340\200|\360\200\200|\370\200\200\200|\374\200\200\200\200!",
    .result = 0},
   {.title = (char *)"sequences with last byte missing {u-...FF}",
    .test = (char *)"\337|\357\277|\367\277\277|\373\277\277\277|\375\277\277\277\277!",
    .result = 0},
   {.title = (char *)"impossible bytes",
    .test = (char *)"\376|\377|\376\376\377\377!",
    .result = 0},
   {.title = (char *)"overlong sequences {u-2f}",
    .test = (char *)"\300\257|\340\200\257|\360\200\200\257|\370\200\200\200\257|\374\200\200\200\200\257!",
    .result = 0},
   {.title = (char *)"maximum overlong sequences",
    .test = (char *)"\301\277|\340\237\277|\360\217\277\277|\370\207\277\277\277|\374\203\277\277\277\277!",
    .result = 0},
   {.title = (char *)"overlong representation of the NUL character",
    .test = (char *)"\300\200|\340\200\200|\360\200\200\200|\370\200\200\200\200|\374\200\200\200\200\200!",
    .result = 0},
   {.title = (char *)"single UTF-16 surrogates",
    .test = (char *)"\355\240\200|\355\255\277|\355\256\200|\355\257\277|\355\260\200|\355\276\200|\355\277\277!",
    .result = 0},
   {.title = (char *)"paired UTF-16 surrogates",
    .test = (char *)"\355\240\200\355\260\200|\355\240\200\355\277\277|\355\255\277\355\260\200|\355\255\277\355\277\277|\355\256\200\355\260\200|\355\256\200\355\277\277|\355\257\277\355\260\200|\355\257\277\355\277\277!",
    .result = 0},
   {.title = (char *)"other illegal code positions",
    .test = (char *)"\357\277\276|\357\277\277!",
    .result = 0},
   {.title = (char *)0, .test = (char *)0, .result = 0}};
test_case boms[5] =
  {{.title = (char *)"no bom (utf-8)",
    .test = (char *)"Hi is \320\237\321\200\320\270\320\262\320\265\321\202!",
    .result = 13},
   {.title = (char *)"bom (utf-8)",
    .test = (char *)"\357\273\277Hi is \320\237\321\200\320\270\320\262\320\265\321\202!",
    .result = 13},
   {.title = (char *)"bom (utf-16-le)",
    .test = (char *)"\377\376H\000i\000 \000i\000s\000 \000\037\004@\0048\0042\0045\004B\004!",
    .result = 13},
   {.title = (char *)"bom (utf-16-be)",
    .test = (char *)"\376\377\000H\000i\000 \000i\000s\000 \004\037\004@\0048\0042\0045\004B!",
    .result = 13},
   {.title = (char *)0, .test = (char *)0, .result = 0}};
char *bom_original =
  (char *)"Hi is \320\237\321\200\320\270\320\262\320\265\321\202";
/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_1(char const * restrict format);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_2(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_3(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_4(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_5(char const * restrict format);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param2),
            (indirect: param1), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param2, param1, *(param0 + (0 ..));
 */
int printf_va_6(char const * restrict format, char *param0,
                unsigned int param1, long param2);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, *(param0 + (0 ..));
 */
int printf_va_7(char const * restrict format, char *param0, long param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_8(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_9(char const * restrict format, int param0);

int check_utf8_sequences(void)
{
  yaml_parser_t parser;
  int k;
  int failed = 0;
  printf("checking utf-8 sequences...\n"); /* printf_va_1 */
  k = 0;
  while (utf8_sequences[k].test) {
    {
      int result;
      char *title = utf8_sequences[k].title;
      int check = utf8_sequences[k].result;
      char *start = utf8_sequences[k].test;
      char *end = start;
      printf("\t%s:\n",title); /* printf_va_2 */
      while (1) {
        while (1) {
          if ((int)*end != '|') {
            if (! ((int)*end != '!')) break;
          }
          else break;
          end ++;
        }
        yaml_parser_initialize(& parser);
        yaml_parser_set_input_string(& parser,(unsigned char const *)start,
                                     (size_t)(end - start));
        result = yaml_parser_update_buffer(& parser,(size_t)(end - start));
        if (result != check) {
          printf("\t\t- "); /* printf_va_3 */
          failed ++;
        }
        else printf("\t\t+ "); /* printf_va_4 */
        if (! parser.error) printf("(no error)\n"); /* printf_va_5 */
        else 
          if (parser.error == (unsigned int)YAML_READER_ERROR) 
            if (parser.problem_value != -1) printf("(reader error: %s: #%X at %ld)\n",
                                                   (char *)parser.problem,
                                                   (unsigned int)parser.problem_value,
                                                   (long)parser.problem_offset); /* printf_va_6 */
            else printf("(reader error: %s at %ld)\n",(char *)parser.problem,
                        (long)parser.problem_offset); /* printf_va_7 */
        if ((int)*end == '!') break;
        end ++;
        start = end;
        yaml_parser_delete(& parser);
      }
      printf("\n"); /* printf_va_8 */
    }
    k ++;
  }
  printf("checking utf-8 sequences: %d fail(s)\n",failed); /* printf_va_9 */
  return failed;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_10(char const * restrict format);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_11(char const * restrict format, char *param0);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, *(param0 + (0 ..));
 */
int printf_va_12(char const * restrict format, char *param0, long param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_13(char const * restrict format, long param0, int param1);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param1 + (0 ..)), *(param0 + (0 ..));
 */
int printf_va_14(char const * restrict format, char *param0, char *param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_15(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_16(char const * restrict format, int param0);

int check_boms(void)
{
  yaml_parser_t parser;
  int k;
  int failed = 0;
  printf("checking boms...\n"); /* printf_va_10 */
  k = 0;
  while (boms[k].test) {
    {
      int result;
      char *title = boms[k].title;
      int check = boms[k].result;
      char *start = boms[k].test;
      char *end = start;
      while ((int)*end != '!') end ++;
      printf("\t%s: ",title); /* printf_va_11 */
      yaml_parser_initialize(& parser);
      yaml_parser_set_input_string(& parser,(unsigned char const *)start,
                                   (size_t)(end - start));
      result = yaml_parser_update_buffer(& parser,(size_t)(end - start));
      if (! result) {
        printf("- (reader error: %s at %ld)\n",(char *)parser.problem,
               (long)parser.problem_offset); /* printf_va_12 */
        failed ++;
      }
      else 
        if (parser.unread != (size_t)check) {
          printf("- (length=%ld while expected length=%d)\n",
                 (long)parser.unread,check); /* printf_va_13 */
          failed ++;
        }
        else {
          int tmp;
          tmp = memcmp((void const *)parser.buffer.start,
                       (void const *)bom_original,(size_t)check);
          if (tmp != 0) {
            printf("- (value \'%s\' does not equal to the original value \'%s\')\n",
                   (char *)parser.buffer.start,bom_original); /* printf_va_14 */
            failed ++;
          }
          else printf("+\n"); /* printf_va_15 */
        }
      yaml_parser_delete(& parser);
    }
    k ++;
  }
  printf("checking boms: %d fail(s)\n",failed); /* printf_va_16 */
  return failed;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_17(char const * restrict format);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, *(param0 + (0 ..));
 */
int printf_va_18(char const * restrict format, char *param0, long param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_19(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param3),
            (indirect: param2), (indirect: param1), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param3, param2, param1, param0;
 */
int printf_va_20(char const * restrict format, unsigned int param0,
                 unsigned int param1, unsigned int param2,
                 unsigned int param3);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param2),
            (indirect: param1), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param2, param1, param0;
 */
int printf_va_21(char const * restrict format, unsigned int param0,
                 int param1, long param2);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, *(param0 + (0 ..));
 */
int printf_va_22(char const * restrict format, char *param0, long param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_23(char const * restrict format, int param0);

int check_long_utf8(void)
{
  yaml_parser_t parser;
  int j;
  unsigned char ch0;
  unsigned char ch1;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int k = 0;
  int failed = 0;
  unsigned char *buffer = malloc((size_t)(3 + 100000 * 2));
  __FC_assert(buffer != (unsigned char *)0,"tests/test-reader.c",215,
              "buffer");
  printf("checking a long utf8 sequence...\n"); /* printf_va_17 */
  tmp_0 = k;
  k ++;
  *(buffer + tmp_0) = (unsigned char)'\357';
  tmp_1 = k;
  k ++;
  *(buffer + tmp_1) = (unsigned char)'\273';
  tmp_2 = k;
  k ++;
  *(buffer + tmp_2) = (unsigned char)'\277';
  j = 0;
  while (j < 100000) {
    if (j % 2) {
      int tmp_3;
      int tmp_4;
      tmp_3 = k;
      k ++;
      *(buffer + tmp_3) = (unsigned char)'\320';
      tmp_4 = k;
      k ++;
      *(buffer + tmp_4) = (unsigned char)'\220';
    }
    else {
      int tmp_5;
      int tmp_6;
      tmp_5 = k;
      k ++;
      *(buffer + tmp_5) = (unsigned char)'\320';
      tmp_6 = k;
      k ++;
      *(buffer + tmp_6) = (unsigned char)'\257';
    }
    j ++;
  }
  yaml_parser_initialize(& parser);
  yaml_parser_set_input_string(& parser,(unsigned char const *)buffer,
                               (size_t)(3 + 100000 * 2));
  k = 0;
  while (k < 100000) {
    if (! parser.unread) {
      int tmp_7;
      tmp_7 = yaml_parser_update_buffer(& parser,(size_t)1);
      if (! tmp_7) {
        printf("\treader error: %s at %ld\n",(char *)parser.problem,
               (long)parser.problem_offset); /* printf_va_18 */
        failed = 1;
        break;
      }
    }
    if (! parser.unread) {
      printf("\tnot enough characters at %d\n",k); /* printf_va_19 */
      failed = 1;
      break;
    }
    if (k % 2) {
      ch0 = (unsigned char)'\320';
      ch1 = (unsigned char)'\220';
    }
    else {
      ch0 = (unsigned char)'\320';
      ch1 = (unsigned char)'\257';
    }
    if ((int)*(parser.buffer.pointer + 0) != (int)ch0) goto _LOR;
    else 
      if ((int)*(parser.buffer.pointer + 1) != (int)ch1) {
        _LOR:
        {
          printf("\tincorrect UTF-8 sequence: %X %X instead of %X %X\n",
                 (unsigned int)((int)*(parser.buffer.pointer + 0)),
                 (unsigned int)((int)*(parser.buffer.pointer + 1)),
                 (unsigned int)((int)ch0),(unsigned int)((int)ch1)); /* printf_va_20 */
          failed = 1;
          break;
        }
      }
    parser.buffer.pointer += 2;
    parser.unread -= (size_t)1;
    k ++;
  }
  if (! failed) {
    int tmp_8;
    tmp_8 = yaml_parser_update_buffer(& parser,(size_t)1);
    if (tmp_8) {
      if ((int)*(parser.buffer.pointer + 0) != '\000') {
        printf("\texpected NUL, found %X (eof=%d, unread=%ld)\n",
               (unsigned int)((int)*(parser.buffer.pointer + 0)),parser.eof,
               (long)parser.unread); /* printf_va_21 */
        failed = 1;
      }
    }
    else {
      printf("\treader error: %s at %ld\n",(char *)parser.problem,
             (long)parser.problem_offset); /* printf_va_22 */
      failed = 1;
    }
  }
  yaml_parser_delete(& parser);
  free((void *)buffer);
  printf("checking a long utf8 sequence: %d fail(s)\n",failed); /* printf_va_23 */
  return failed;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_24(char const * restrict format);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, *(param0 + (0 ..));
 */
int printf_va_25(char const * restrict format, char *param0, long param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_26(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param3),
            (indirect: param2), (indirect: param1), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param3, param2, param1, param0;
 */
int printf_va_27(char const * restrict format, unsigned int param0,
                 unsigned int param1, unsigned int param2,
                 unsigned int param3);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param2),
            (indirect: param1), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param2, param1, param0;
 */
int printf_va_28(char const * restrict format, unsigned int param0,
                 int param1, long param2);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, *(param0 + (0 ..));
 */
int printf_va_29(char const * restrict format, char *param0, long param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_30(char const * restrict format, int param0);

int check_long_utf16(void)
{
  yaml_parser_t parser;
  int j;
  unsigned char ch0;
  unsigned char ch1;
  int tmp_0;
  int tmp_1;
  int k = 0;
  int failed = 0;
  unsigned char *buffer = malloc((size_t)(2 + 100000 * 2));
  __FC_assert(buffer != (unsigned char *)0,"tests/test-reader.c",287,
              "buffer");
  printf("checking a long utf16 sequence...\n"); /* printf_va_24 */
  tmp_0 = k;
  k ++;
  *(buffer + tmp_0) = (unsigned char)'\377';
  tmp_1 = k;
  k ++;
  *(buffer + tmp_1) = (unsigned char)'\376';
  j = 0;
  while (j < 100000) {
    if (j % 2) {
      int tmp_2;
      int tmp_3;
      tmp_2 = k;
      k ++;
      *(buffer + tmp_2) = (unsigned char)'\020';
      tmp_3 = k;
      k ++;
      *(buffer + tmp_3) = (unsigned char)'\004';
    }
    else {
      int tmp_4;
      int tmp_5;
      tmp_4 = k;
      k ++;
      *(buffer + tmp_4) = (unsigned char)'/';
      tmp_5 = k;
      k ++;
      *(buffer + tmp_5) = (unsigned char)'\004';
    }
    j ++;
  }
  yaml_parser_initialize(& parser);
  yaml_parser_set_input_string(& parser,(unsigned char const *)buffer,
                               (size_t)(2 + 100000 * 2));
  k = 0;
  while (k < 100000) {
    if (! parser.unread) {
      int tmp_6;
      tmp_6 = yaml_parser_update_buffer(& parser,(size_t)1);
      if (! tmp_6) {
        printf("\treader error: %s at %ld\n",(char *)parser.problem,
               (long)parser.problem_offset); /* printf_va_25 */
        failed = 1;
        break;
      }
    }
    if (! parser.unread) {
      printf("\tnot enough characters at %d\n",k); /* printf_va_26 */
      failed = 1;
      break;
    }
    if (k % 2) {
      ch0 = (unsigned char)'\320';
      ch1 = (unsigned char)'\220';
    }
    else {
      ch0 = (unsigned char)'\320';
      ch1 = (unsigned char)'\257';
    }
    if ((int)*(parser.buffer.pointer + 0) != (int)ch0) goto _LOR;
    else 
      if ((int)*(parser.buffer.pointer + 1) != (int)ch1) {
        _LOR:
        {
          printf("\tincorrect UTF-8 sequence: %X %X instead of %X %X\n",
                 (unsigned int)((int)*(parser.buffer.pointer + 0)),
                 (unsigned int)((int)*(parser.buffer.pointer + 1)),
                 (unsigned int)((int)ch0),(unsigned int)((int)ch1)); /* printf_va_27 */
          failed = 1;
          break;
        }
      }
    parser.buffer.pointer += 2;
    parser.unread -= (size_t)1;
    k ++;
  }
  if (! failed) {
    int tmp_7;
    tmp_7 = yaml_parser_update_buffer(& parser,(size_t)1);
    if (tmp_7) {
      if ((int)*(parser.buffer.pointer + 0) != '\000') {
        printf("\texpected NUL, found %X (eof=%d, unread=%ld)\n",
               (unsigned int)((int)*(parser.buffer.pointer + 0)),parser.eof,
               (long)parser.unread); /* printf_va_28 */
        failed = 1;
      }
    }
    else {
      printf("\treader error: %s at %ld\n",(char *)parser.problem,
             (long)parser.problem_offset); /* printf_va_29 */
      failed = 1;
    }
  }
  yaml_parser_delete(& parser);
  free((void *)buffer);
  printf("checking a long utf16 sequence: %d fail(s)\n",failed); /* printf_va_30 */
  return failed;
}

int main(void)
{
  int __retres;
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  tmp = check_utf8_sequences();
  tmp_0 = check_boms();
  tmp_1 = check_long_utf8();
  tmp_2 = check_long_utf16();
  __retres = ((tmp + tmp_0) + tmp_1) + tmp_2;
  return __retres;
}


