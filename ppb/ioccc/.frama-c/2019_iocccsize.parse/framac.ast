/* Generated by Frama-C */
#include "ctype.h"
#include "errno.h"
#include "getopt.h"
#include "stdarg.h"
#include "stddef.h"
#include "stdio.h"
#include "string.h"
#include "strings.h"
#include "unistd.h"
struct __anonstruct_Word_1 {
   size_t length ;
   char const *word ;
};
typedef struct __anonstruct_Word_1 Word;
static char usage[319] =
  {(char)'u',
   (char)'s',
   (char)'a',
   (char)'g',
   (char)'e',
   (char)':',
   (char)' ',
   (char)' ',
   (char)'i',
   (char)'o',
   (char)'c',
   (char)'c',
   (char)'c',
   (char)' ',
   (char)'[',
   (char)'-',
   (char)'k',
   (char)'i',
   (char)'r',
   (char)'s',
   (char)'c',
   (char)'h',
   (char)']',
   (char)' ',
   (char)'<',
   (char)' ',
   (char)'p',
   (char)'r',
   (char)'o',
   (char)'g',
   (char)'.',
   (char)'c',
   (char)'\n',
   (char)'\n',
   (char)'-',
   (char)'k',
   (char)'\t',
   (char)'\t',
   (char)'k',
   (char)'e',
   (char)'e',
   (char)'p',
   (char)' ',
   (char)'b',
   (char)'l',
   (char)'o',
   (char)'c',
   (char)'k',
   (char)' ',
   (char)'c',
   (char)'o',
   (char)'m',
   (char)'m',
   (char)'e',
   (char)'n',
   (char)'t',
   (char)'s',
   (char)'\n',
   (char)'-',
   (char)'i',
   (char)'\t',
   (char)'\t',
   (char)'p',
   (char)'r',
   (char)'i',
   (char)'n',
   (char)'t',
   (char)' ',
   (char)'o',
   (char)'f',
   (char)'f',
   (char)'i',
   (char)'c',
   (char)'i',
   (char)'a',
   (char)'l',
   (char)' ',
   (char)'s',
   (char)'e',
   (char)'c',
   (char)'o',
   (char)'n',
   (char)'d',
   (char)'a',
   (char)'r',
   (char)'y',
   (char)' ',
   (char)'I',
   (char)'O',
   (char)'C',
   (char)'C',
   (char)'C',
   (char)' ',
   (char)'s',
   (char)'i',
   (char)'z',
   (char)'e',
   (char)' ',
   (char)'t',
   (char)'o',
   (char)' ',
   (char)'s',
   (char)'t',
   (char)'d',
   (char)'o',
   (char)'u',
   (char)'t',
   (char)'\n',
   (char)'\t',
   (char)'\t',
   (char)'m',
   (char)'a',
   (char)'x',
   (char)'.',
   (char)'s',
   (char)'i',
   (char)'z',
   (char)'e',
   (char)' ',
   (char)'w',
   (char)'a',
   (char)'r',
   (char)'n',
   (char)'i',
   (char)'n',
   (char)'g',
   (char)'s',
   (char)' ',
   (char)'t',
   (char)'o',
   (char)' ',
   (char)'s',
   (char)'t',
   (char)'d',
   (char)'e',
   (char)'r',
   (char)'r',
   (char)',',
   (char)' ',
   (char)'N',
   (char)'O',
   (char)'T',
   (char)'E',
   (char)':',
   (char)' ',
   (char)'i',
   (char)'m',
   (char)'p',
   (char)'l',
   (char)'i',
   (char)'e',
   (char)'s',
   (char)' ',
   (char)'-',
   (char)'r',
   (char)' ',
   (char)'-',
   (char)'s',
   (char)'\n',
   (char)'-',
   (char)'r',
   (char)'\t',
   (char)'\t',
   (char)'c',
   (char)'o',
   (char)'u',
   (char)'n',
   (char)'t',
   (char)' ',
   (char)'C',
   (char)' ',
   (char)'r',
   (char)'e',
   (char)'s',
   (char)'e',
   (char)'r',
   (char)'v',
   (char)'e',
   (char)'d',
   (char)' ',
   (char)'w',
   (char)'o',
   (char)'r',
   (char)'d',
   (char)'s',
   (char)' ',
   (char)'a',
   (char)'s',
   (char)' ',
   (char)'1',
   (char)' ',
   (char)'b',
   (char)'y',
   (char)'t',
   (char)'e',
   (char)'\n',
   (char)'-',
   (char)'s',
   (char)'\t',
   (char)'\t',
   (char)'s',
   (char)'u',
   (char)'p',
   (char)'p',
   (char)'r',
   (char)'e',
   (char)'s',
   (char)'s',
   (char)' ',
   (char)'s',
   (char)'o',
   (char)'u',
   (char)'r',
   (char)'c',
   (char)'e',
   (char)' ',
   (char)'o',
   (char)'u',
   (char)'t',
   (char)'p',
   (char)'u',
   (char)'t',
   (char)',',
   (char)' ',
   (char)'w',
   (char)'r',
   (char)'i',
   (char)'t',
   (char)'e',
   (char)' ',
   (char)'o',
   (char)'n',
   (char)'l',
   (char)'y',
   (char)' ',
   (char)'t',
   (char)'h',
   (char)'e',
   (char)' ',
   (char)'o',
   (char)'f',
   (char)'f',
   (char)'i',
   (char)'c',
   (char)'i',
   (char)'a',
   (char)'l',
   (char)' ',
   (char)'s',
   (char)'i',
   (char)'z',
   (char)'e',
   (char)'\n',
   (char)'-',
   (char)'c',
   (char)'\t',
   (char)'\t',
   (char)'a',
   (char)'n',
   (char)' ',
   (char)'u',
   (char)'n',
   (char)'d',
   (char)'o',
   (char)'c',
   (char)'u',
   (char)'m',
   (char)'e',
   (char)'n',
   (char)'t',
   (char)'e',
   (char)'d',
   (char)' ',
   (char)'f',
   (char)'e',
   (char)'a',
   (char)'t',
   (char)'u',
   (char)'r',
   (char)'e',
   (char)'\n',
   (char)'-',
   (char)'h',
   (char)'\t',
   (char)'\t',
   (char)'y',
   (char)'e',
   (char)'t',
   (char)' ',
   (char)'a',
   (char)'n',
   (char)'o',
   (char)'t',
   (char)'h',
   (char)'e',
   (char)'r',
   (char)' ',
   (char)'u',
   (char)'n',
   (char)'d',
   (char)'o',
   (char)'c',
   (char)'u',
   (char)'m',
   (char)'e',
   (char)'n',
   (char)'t',
   (char)'e',
   (char)'d',
   (char)' ',
   (char)'f',
   (char)'e',
   (char)'a',
   (char)'t',
   (char)'u',
   (char)'r',
   (char)'e',
   (char)'\n',
   (char)'\000'};
static Word cwords[78] =
  {{.length = sizeof("#elif") - (unsigned long)1, .word = "#elif"},
   {.length = sizeof("#else") - (unsigned long)1, .word = "#else"},
   {.length = sizeof("#endif") - (unsigned long)1, .word = "#endif"},
   {.length = sizeof("#error") - (unsigned long)1, .word = "#error"},
   {.length = sizeof("#ident") - (unsigned long)1, .word = "#ident"},
   {.length = sizeof("#if") - (unsigned long)1, .word = "#if"},
   {.length = sizeof("#ifdef") - (unsigned long)1, .word = "#ifdef"},
   {.length = sizeof("#include") - (unsigned long)1, .word = "#include"},
   {.length = sizeof("#line") - (unsigned long)1, .word = "#line"},
   {.length = sizeof("#pragma") - (unsigned long)1, .word = "#pragma"},
   {.length = sizeof("#sccs") - (unsigned long)1, .word = "#sccs"},
   {.length = sizeof("#warning") - (unsigned long)1, .word = "#warning"},
   {.length = sizeof("_Alignas") - (unsigned long)1, .word = "_Alignas"},
   {.length = sizeof("_Alignof") - (unsigned long)1, .word = "_Alignof"},
   {.length = sizeof("_Atomic") - (unsigned long)1, .word = "_Atomic"},
   {.length = sizeof("_Bool") - (unsigned long)1, .word = "_Bool"},
   {.length = sizeof("_Complex") - (unsigned long)1, .word = "_Complex"},
   {.length = sizeof("_Generic") - (unsigned long)1, .word = "_Generic"},
   {.length = sizeof("_Imaginary") - (unsigned long)1, .word = "_Imaginary"},
   {.length = sizeof("_Noreturn") - (unsigned long)1, .word = "_Noreturn"},
   {.length = sizeof("_Pragma") - (unsigned long)1, .word = "_Pragma"},
   {.length = sizeof("_Static_assert") - (unsigned long)1,
    .word = "_Static_assert"},
   {.length = sizeof("_Thread_local") - (unsigned long)1,
    .word = "_Thread_local"},
   {.length = sizeof("alignas") - (unsigned long)1, .word = "alignas"},
   {.length = sizeof("alignof") - (unsigned long)1, .word = "alignof"},
   {.length = sizeof("and") - (unsigned long)1, .word = "and"},
   {.length = sizeof("and_eq") - (unsigned long)1, .word = "and_eq"},
   {.length = sizeof("auto") - (unsigned long)1, .word = "auto"},
   {.length = sizeof("bitand") - (unsigned long)1, .word = "bitand"},
   {.length = sizeof("bitor") - (unsigned long)1, .word = "bitor"},
   {.length = sizeof("bool") - (unsigned long)1, .word = "bool"},
   {.length = sizeof("break") - (unsigned long)1, .word = "break"},
   {.length = sizeof("case") - (unsigned long)1, .word = "case"},
   {.length = sizeof("char") - (unsigned long)1, .word = "char"},
   {.length = sizeof("compl") - (unsigned long)1, .word = "compl"},
   {.length = sizeof("const") - (unsigned long)1, .word = "const"},
   {.length = sizeof("continue") - (unsigned long)1, .word = "continue"},
   {.length = sizeof("default") - (unsigned long)1, .word = "default"},
   {.length = sizeof("do") - (unsigned long)1, .word = "do"},
   {.length = sizeof("double") - (unsigned long)1, .word = "double"},
   {.length = sizeof("else") - (unsigned long)1, .word = "else"},
   {.length = sizeof("enum") - (unsigned long)1, .word = "enum"},
   {.length = sizeof("extern") - (unsigned long)1, .word = "extern"},
   {.length = sizeof("false") - (unsigned long)1, .word = "false"},
   {.length = sizeof("float") - (unsigned long)1, .word = "float"},
   {.length = sizeof("for") - (unsigned long)1, .word = "for"},
   {.length = sizeof("goto") - (unsigned long)1, .word = "goto"},
   {.length = sizeof("I") - (unsigned long)1, .word = "I"},
   {.length = sizeof("if") - (unsigned long)1, .word = "if"},
   {.length = sizeof("inline") - (unsigned long)1, .word = "inline"},
   {.length = sizeof("int") - (unsigned long)1, .word = "int"},
   {.length = sizeof("long") - (unsigned long)1, .word = "long"},
   {.length = sizeof("noreturn") - (unsigned long)1, .word = "noreturn"},
   {.length = sizeof("not") - (unsigned long)1, .word = "not"},
   {.length = sizeof("not_eq") - (unsigned long)1, .word = "not_eq"},
   {.length = sizeof("or") - (unsigned long)1, .word = "or"},
   {.length = sizeof("or_eq") - (unsigned long)1, .word = "or_eq"},
   {.length = sizeof("register") - (unsigned long)1, .word = "register"},
   {.length = sizeof("restrict") - (unsigned long)1, .word = "restrict"},
   {.length = sizeof("return") - (unsigned long)1, .word = "return"},
   {.length = sizeof("short") - (unsigned long)1, .word = "short"},
   {.length = sizeof("signed") - (unsigned long)1, .word = "signed"},
   {.length = sizeof("sizeof") - (unsigned long)1, .word = "sizeof"},
   {.length = sizeof("static") - (unsigned long)1, .word = "static"},
   {.length = sizeof("static_assert") - (unsigned long)1,
    .word = "static_assert"},
   {.length = sizeof("struct") - (unsigned long)1, .word = "struct"},
   {.length = sizeof("switch") - (unsigned long)1, .word = "switch"},
   {.length = sizeof("thread_local") - (unsigned long)1,
    .word = "thread_local"},
   {.length = sizeof("true") - (unsigned long)1, .word = "true"},
   {.length = sizeof("typedef") - (unsigned long)1, .word = "typedef"},
   {.length = sizeof("union") - (unsigned long)1, .word = "union"},
   {.length = sizeof("unsigned") - (unsigned long)1, .word = "unsigned"},
   {.length = sizeof("void") - (unsigned long)1, .word = "void"},
   {.length = sizeof("volatile") - (unsigned long)1, .word = "volatile"},
   {.length = sizeof("while") - (unsigned long)1, .word = "while"},
   {.length = sizeof("xor") - (unsigned long)1, .word = "xor"},
   {.length = sizeof("xor_eq") - (unsigned long)1, .word = "xor_eq"},
   {.length = (size_t)0, .word = (char const *)0}};
static int xlcount = 0;
static int xwcount = 0;
static int xbcount = 0;
static Word *find_member(Word *table, char const *string)
{
  Word *__retres;
  Word *w;
  w = table;
  while (w->length != (size_t)0) {
    {
      int tmp;
      tmp = strncmp(string,w->word,w->length);
      if (tmp == 0) {
        int tmp_0;
        tmp_0 = isalnum((int)*(string + w->length));
        if (! tmp_0) 
          if ((int)*(string + w->length) != '_') {
            __retres = w;
            goto return_label;
          }
      }
    }
    w ++;
  }
  __retres = (Word *)0;
  return_label: return __retres;
}

static char trigraph[10] =
  {(char)'=',
   (char)'(',
   (char)'/',
   (char)')',
   (char)'\'',
   (char)'<',
   (char)'!',
   (char)'>',
   (char)'-',
   (char)'\000'};
static char asciimap[10] =
  {(char)'#',
   (char)'[',
   (char)'\\',
   (char)']',
   (char)'^',
   (char)'{',
   (char)'|',
   (char)'}',
   (char)'~',
   (char)'\000'};
static size_t read_line(char *buf, size_t size)
{
  size_t __retres;
  int ch;
  size_t length;
  if (buf == (char *)0) {
    __retres = (size_t)0;
    goto return_label;
  }
  else 
    if (size == (size_t)0) {
      __retres = (size_t)0;
      goto return_label;
    }
  size --;
  length = (size_t)0;
  while (length < size) {
    {
      size_t tmp;
      ch = fgetc(__fc_stdin);
      if (ch == -1) break;
      if (ch == '\000') ch = ' ';
      if (ch == '\r') {
        xbcount ++;
        goto __Cont;
      }
      if ((size_t)2 <= length) 
        if ((int)*(buf + (length - (size_t)2)) == '?') 
          if ((int)*(buf + (length - (size_t)1)) == '?') {
            char *tri;
            tri = strchr((char const *)(trigraph),ch);
            if (tri != (char *)0) {
              ch = (int)asciimap[tri - trigraph];
              xbcount += 2;
              length -= (size_t)2;
            }
          }
      if (ch == '\n') 
        if ((size_t)1 <= length) 
          if ((int)*(buf + (length - (size_t)1)) == '\\') {
            xbcount += 2;
            xwcount ++;
            xlcount ++;
            length --;
            goto __Cont;
          }
      tmp = length;
      length ++;
      *(buf + tmp) = (char)ch;
      if (ch == '\n') break;
    }
    __Cont: ;
  }
  *(buf + length) = (char)'\000';
  __retres = length;
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_1(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param1, param0;
 */
int fprintf_va_1(FILE * restrict stream, char const * restrict format,
                 int param0, int param1);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param1, param0;
 */
int fprintf_va_2(FILE * restrict stream, char const * restrict format,
                 int param0, int param1);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param6),
            (indirect: param5), (indirect: param4), (indirect: param3),
            (indirect: param2), (indirect: param1), (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param6, param5, param4, param3,
            param2, param1, param0;
 */
int fprintf_va_3(FILE * restrict stream, char const * restrict format,
                 int param0, int param1, int param2, int param3, int param4,
                 int param5, int param6);

static int count(int flags)
{
  Word *w;
  unsigned long span;
  char *p;
  char buf[521];
  int lcount;
  int wcount;
  int bcount;
  int is_comment;
  int is_word;
  int dquote;
  int escape;
  int count_0;
  int keywords;
  int saved;
  int kw_saved;
  buf[0] = (char)' ';
  buf[521 - 1] = (char)0;
  saved = 0;
  count_0 = saved;
  kw_saved = 0;
  keywords = kw_saved;
  bcount = 0;
  wcount = bcount;
  lcount = wcount;
  escape = 0;
  dquote = escape;
  is_word = dquote;
  is_comment = is_word;
  while (1) {
    size_t tmp_4;
    tmp_4 = read_line(& buf[1],sizeof(buf) - (unsigned long)1);
    if (! ((size_t)0 < tmp_4)) break;
    if (! (flags & 2)) {
      span = strspn((char const *)(& buf[1]),"\t ");
      if ((int)buf[(unsigned long)1 + span] == '/') 
        if ((int)buf[(unsigned long)2 + span] == '\000') {
          ungetc('/',__fc_stdin);
          continue;
        }
      if ((int)buf[(unsigned long)1 + span] == '/') 
        if ((int)buf[(unsigned long)2 + span] == '/') continue;
      if ((int)buf[(unsigned long)1 + span] == '/') 
        if ((int)buf[(unsigned long)2 + span] == '*') is_comment = 1;
    }
    p = & buf[1];
    while ((int)*p != '\000') {
      {
        int tmp_1;
        char *tmp_2;
        if (dquote) {
          if (escape) escape = 0;
          else 
            if ((int)*p == '\\') escape = 1;
            else 
              if ((int)*p == '\"') dquote = 0;
        }
        else 
          if (is_comment) {
            if ((int)*p == '*') 
              if ((int)*(p + 1) == '\000') {
                ungetc('*',__fc_stdin);
                break;
              }
            if ((int)*p == '*') 
              if ((int)*(p + 1) == '/') {
                is_comment = 0;
                if (! (flags & 2)) {
                  size_t tmp;
                  tmp = strspn((char const *)(p + 2)," \t\r\n");
                  p += (size_t)1 + tmp;
                }
              }
            if (! (flags & 2)) goto __Cont;
          }
          else 
            if ((int)*p == '/') {
              if ((int)*(p + 1) == '\000') {
                ungetc('/',__fc_stdin);
                break;
              }
              else goto _LAND_3;
            }
            else {
              _LAND_3: ;
              if ((int)*p == '/') {
                if ((int)*(p + 1) == '/') {
                  if (! (flags & 2)) break;
                }
                else goto _LAND_2;
              }
              else {
                _LAND_2: ;
                if ((int)*p == '/') {
                  if ((int)*(p + 1) == '*') {
                    is_comment = 1;
                    if (! (flags & 2)) {
                      p ++;
                      goto __Cont;
                    }
                  }
                  else goto _LAND_1;
                }
                else {
                  int tmp_0;
                  _LAND_1: tmp_0 = isalnum((int)*(p + -1));
                  if (tmp_0) {
                    _LAND_0: ;
                    if ((int)*p == '\"') dquote = 1;
                  }
                  else 
                    if ((int)*(p + -1) != '_') {
                      w = find_member(cwords,(char const *)p);
                      if (w != (Word *)0) {
                        keywords ++;
                        if (flags & 4) {
                          bcount = (int)((size_t)bcount + w->length);
                          if (! is_word) {
                            is_word = 1;
                            wcount ++;
                          }
                          if (! (flags & 1)) fputs(w->word,__fc_stdout);
                          kw_saved = (int)((size_t)kw_saved + (w->length - (size_t)1));
                          p += w->length - (size_t)1;
                          count_0 ++;
                          goto __Cont;
                        }
                      }
                      else goto _LAND_0;
                    }
                    else goto _LAND_0;
                }
              }
            }
        if (! (flags & 1)) fputc((int)*p,__fc_stdout);
        bcount ++;
        if ((int)*p == '\n') lcount ++;
        tmp_1 = isspace((int)*p);
        if (tmp_1) {
          is_word = 0;
          saved ++;
          goto __Cont;
        }
        else 
          if (! is_word) {
            is_word = 1;
            wcount ++;
          }
        tmp_2 = strchr("{;}",(int)*p);
        if (tmp_2 != (char *)0) {
          int tmp_3;
          tmp_3 = isspace((int)*(p + 1));
          if (tmp_3) goto _LOR;
          else 
            if ((int)*(p + 1) == '\000') {
              _LOR: {
                      saved ++;
                      goto __Cont;
                    }
            }
        }
        count_0 ++;
      }
      __Cont: p ++;
    }
  }
  if (flags & 8) {
    printf("%d\n",count_0); /* printf_va_1 */
    if (4096 < bcount) fprintf(__fc_stderr,
                               "WARNING: program size (%d) exceeds IOCCC Rule 2a max. size (%d)\n",
                               bcount,4096); /* fprintf_va_1 */
    if (2053 < count_0) fprintf(__fc_stderr,
                                "WARNING: iocccsize count (%d) exceeds IOCCC Rule 2b max. count (%d)\n",
                                count_0,2053); /* fprintf_va_2 */
  }
  else fprintf(__fc_stderr,"%d %d %d %d %d %d %d\n",lcount + xlcount,
               wcount + xwcount,bcount + xbcount,count_0,saved,keywords,
               kw_saved); /* fprintf_va_3 */
  return count_0;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_4(FILE * restrict stream, char const * restrict format,
                 char *param0);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_5(FILE * restrict stream, char const * restrict format,
                 char *param0);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_6(FILE * restrict stream, char const * restrict format,
                 char *param0);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_7(FILE * restrict stream, char const * restrict format,
                 char *param0);

int main(int argc, char **argv)
{
  int __retres;
  int ch;
  int flags = 0;
  while (1) {
    ch = getopt(argc,(char * const *)argv,"kirsch");
    if (! (ch != -1)) break;
    switch (ch) {
      case 'k': flags |= 2;
      break;
      case 'i': flags |= (8 | 4) | 1;
      break;
      case 'r': flags |= 4;
      break;
      case 's': flags |= 1;
      break;
      case 'c': flags |= 16;
      break;
      case 'h': flags |= 32;
      break;
      default: fprintf(__fc_stderr,"%s\n",usage); /* fprintf_va_4 */
      __retres = 2;
      goto return_label;
    }
  }
  if (flags == (((((2 | 8) | 4) | 1) | 16) | 32)) {
    fprintf(__fc_stderr,
            "The source toasts you a glass to your health!\nBTW: judges have toasted a glass of this at the South Pole.\nNow try using useful flags.\n\n%s\n",
            usage); /* fprintf_va_5 */
    __retres = 3;
    goto return_label;
  }
  else 
    if (flags & 16) {
      fprintf(__fc_stderr,"Do you not see this is C?\n\n%s\n",usage); /* fprintf_va_6 */
      __retres = 4;
      goto return_label;
    }
    else 
      if (flags & 32) {
        fprintf(__fc_stderr,"%s\n",usage); /* fprintf_va_7 */
        __retres = 5;
        goto return_label;
      }
  count(flags);
  __retres = 0;
  return_label: return __retres;
}


