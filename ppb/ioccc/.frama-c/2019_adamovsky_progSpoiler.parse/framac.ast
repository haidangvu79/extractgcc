/* Generated by Frama-C */
#include "errno.h"
#include "stdarg.h"
#include "stdio.h"
#include "stdlib.h"
union Argument {
   union Argument *(*init)(union Argument *f) ;
   union Argument *(*call)(union Argument *f, union Argument *x) ;
   union Argument *a ;
   char c ;
   long p ;
   size_t n ;
};
typedef union Argument Argument;
void X(char *m, int s)
{
  fputs((char const *)m,__fc_stderr);
  exit(s);
  return;
}

void E(void)
{
  X((char *)"syntax error\n",1);
  return;
}

void F(void)
{
  X((char *)"fail\n",-1);
  return;
}

__inline static Argument *Reference(Argument *f)
{
  ((f + (5 - 1))->n) ++;
  return f;
}

Argument *Char(Argument *f);

Argument *Apply(Argument *f);

Argument *fA(Argument *f);

Argument *fD(Argument *f, Argument *x);

Argument *fCont(Argument *f, Argument *x);

Argument *fW(Argument *f, Argument *x);

Argument *fCh(Argument *f, Argument *x);

Argument *rA1(Argument *s, Argument *x);

Argument *rA2(Argument *s, Argument *x);

Argument *rApply1(Argument *s, Argument *x);

Argument *rApply2(Argument *s, Argument *x);

Argument *rS1(Argument *s, Argument *x);

Argument *rS2(Argument *s, Argument *x);

Argument *rD(Argument *s, Argument *x);

Argument *rC(Argument *f, Argument *x);

Argument *rCont(Argument *f, Argument *x);

Argument *rE(Argument *f, Argument *x);

/*@ assigns f->n, *f;
    assigns f->n \from (indirect: *(f + (0 ..)));
    assigns *f \from (indirect: *(f + (0 ..)));
 */
__inline static void Dereference(Argument *f)
{
  if (f) {
    ((f + (5 - 1))->n) --;
    if (! (f + (5 - 1))->n) {
      if ((f + 0)->call != & fW) 
        if ((f + 0)->call != & fCh) Dereference((f + 1)->a);
      if ((f + 0)->call != & fCont) Dereference((f + 2)->a);
      if ((f + 0)->call != & rC) 
        if ((f + 0)->call != & rCont) 
          if ((f + 0)->call != & rE) Dereference((f + 3)->a);
      free((void *)f);
    }
  }
  return;
}

int ch = -1;
int c;
FILE *p;
FILE *o = (FILE *)0;
static Argument T[256][2];

void Next(void)
{
  while (1) {
    if (c == -1) goto return_label;
    if (T[c][0].init) goto return_label;
    if (! T[c][1].c) E();
    if ((int)T[c][1].c == 'c') {
      c = getc(p);
      while (1) {
        if (c != '\n') {
          if (! (c != -1)) break;
        }
        else break;
        c = getc(p);
      }
    }
    c = getc(p);
  }
  return_label: return;
}

/*@ assigns \result;
    assigns \result \from \nothing; */
Argument *I(void)
{
  Argument *tmp;
  if (c == -1) E();
  Argument *f = T[c];
  if ((f + 0)->init != & Char) {
    c = getc(p);
    Next();
  }
  tmp = (*((f + 0)->init))(f + 1);
  return tmp;
}

Argument *Create(Argument *f)
{
  Argument *tmp_0;
  Argument *record = malloc(sizeof(Argument [5]));
  if (! record) X((char *)"memory error\n",-2);
  *(record + 0) = *f;
  {
    int i = 1;
    while (i < 5) {
      Argument __constr_expr_0 =
        {.init = (union Argument *(*)(union Argument *f))0};
      *(record + i) = __constr_expr_0;
      i ++;
    }
  }
  tmp_0 = Reference(record);
  return tmp_0;
}

void Output(Argument *f);

int main(int argc, char const **argv)
{
  int __retres;
  if (argc < 2) F();
  else 
    if (argc > 3) F();
  p = fopen(*(argv + 1),"rb");
  if (! p) F();
  c = getc(p);
  Next();
  if (argc == 3) {
    o = fopen(*(argv + 2),"wb");
    if (! o) F();
  }
  else o = __fc_stderr;
  while (c != -1) {
    Argument *f = I();
    while ((f + 3)->a) 
      if ((f + 0)->call == & rCont) {
        Argument *tmp_0;
        tmp_0 = Reference((f + 1)->a);
        f = (*(((f + 1)->a + 0)->call))(tmp_0,f);
      }
      else 
        if ((f + 0)->call == & rE) {
          T[96][0].init = & Apply;
          Argument *r = Reference((f + 1)->a);
          Dereference(f);
          f = r;
        }
        else {
          Argument *tmp_2;
          long tmp_3;
          Argument *tmp_4;
          Argument __constr_expr_1 = {.call = & fCont};
          tmp_2 = Create(& __constr_expr_1);
          Argument *r_0 = tmp_2;
          (r_0 + 1)->a = f;
          tmp_3 = ftell(p);
          (r_0 + 2)->p = tmp_3 + (long)(c == -1);
          ;
          tmp_4 = Reference(f);
          f = (*((f + 0)->call))(tmp_4,r_0);
        }
    if (o) {
      Output(f);
      fputc('\n',o);
      fflush(o);
    }
    Dereference(f);
  }
  __retres = 0;
  return __retres;
}

Argument *Char(Argument *f)
{
  Argument *r = Create(f);
  c = getc(p);
  if (c == -1) E();
  (r + 1)->c = (char)c;
  c = getc(p);
  Next();
  return r;
}

Argument *NewLine(Argument *f)
{
  Argument *r = Create(f);
  (r + 1)->c = (char)'\n';
  return r;
}

Argument *rCont(Argument *f, Argument *x)
{
  Argument *r = Reference((f + 2)->a);
  Dereference(x);
  Dereference(f);
  return r;
}

Argument *fD0(Argument *f, Argument *x)
{
  Argument *tmp;
  Argument __constr_expr_2 = {.call = & fD};
  tmp = Create(& __constr_expr_2);
  Argument *r = tmp;
  (r + 1)->a = x;
  Dereference(f);
  return r;
}

Argument *fA2(Argument *x, Argument *y)
{
  Argument *__retres;
  Argument *tmp_0;
  if ((y + 3)->a) {
    Argument *tmp;
    if ((y + 0)->call == & rCont) goto _LOR;
    else 
      if ((y + 0)->call == & rE) {
        _LOR: {
                Dereference(x);
                __retres = y;
                goto return_label;
              }
      }
    Argument __constr_expr_3 = {.call = & rA2};
    tmp = Create(& __constr_expr_3);
    Argument *r = tmp;
    (r + 1)->a = x;
    (r + 3)->a = y;
    __retres = r;
    goto return_label;
  }
  tmp_0 = (*((x + 0)->call))(x,y);
  __retres = tmp_0;
  return_label: return __retres;
}

Argument *rA2(Argument *s, Argument *x)
{
  Argument *tmp_2;
  union Argument *tmp_1;
  Argument *a = Reference((s + 1)->a);
  Argument *b = Reference((s + 3)->a);
  Dereference(s);
  tmp_1 = (*((b + 0)->call))(b,x);
  ;
  tmp_2 = fA2(a,tmp_1);
  return tmp_2;
}

Argument *fA1(Argument *f, Argument *x)
{
  Argument *__retres;
  Argument *tmp_2;
  if ((x + 3)->a) {
    Argument *tmp;
    if ((x + 0)->call == & rCont) {
      __retres = x;
      goto return_label;
    }
    else 
      if ((x + 0)->call == & rE) {
        __retres = x;
        goto return_label;
      }
    Argument __constr_expr_4 = {.call = & rA1};
    tmp = Create(& __constr_expr_4);
    Argument *r = tmp;
    (r + 1)->a = f;
    (r + 3)->a = x;
    __retres = r;
    goto return_label;
  }
  if ((x + 0)->call == & fD0) {
    Argument *tmp_0;
    Argument __constr_expr_5 = {.call = & fD};
    tmp_0 = Create(& __constr_expr_5);
    Argument *r_0 = tmp_0;
    (r_0 + 1)->a = Reference((f + 2)->a);
    Dereference(x);
    Dereference(f);
    __retres = r_0;
    goto return_label;
  }
  Argument *y = fA((f + 2)->a);
  Dereference(f);
  tmp_2 = fA2(x,y);
  __retres = tmp_2;
  return_label: return __retres;
}

Argument *rA1(Argument *s, Argument *x)
{
  Argument *tmp_2;
  union Argument *tmp_1;
  Argument *f = Reference((s + 1)->a);
  Argument *a = Reference((s + 3)->a);
  Dereference(s);
  tmp_1 = (*((a + 0)->call))(a,x);
  ;
  tmp_2 = fA1(f,tmp_1);
  return tmp_2;
}

Argument *fA(Argument *f)
{
  Argument *__retres;
  Argument *tmp_0;
  Argument *tmp;
  Reference(f);
  if ((f + 0)->init != & fA) {
    __retres = f;
    goto return_label;
  }
  tmp = fA((f + 1)->a);
  ;
  tmp_0 = fA1(f,tmp);
  __retres = tmp_0;
  return_label: return __retres;
}

Argument *fD1(Argument *a, Argument *x)
{
  Argument *__retres;
  Argument *tmp_0;
  if ((a + 3)->a) {
    Argument *tmp;
    if ((a + 0)->call == & rCont) goto _LOR;
    else 
      if ((a + 0)->call == & rE) {
        _LOR: {
                Dereference(x);
                __retres = a;
                goto return_label;
              }
      }
    Argument __constr_expr_6 = {.call = & rD};
    tmp = Create(& __constr_expr_6);
    Argument *r = tmp;
    (r + 1)->a = x;
    (r + 3)->a = a;
    __retres = r;
    goto return_label;
  }
  tmp_0 = (*((a + 0)->call))(a,x);
  __retres = tmp_0;
  return_label: return __retres;
}

Argument *rD(Argument *s, Argument *x)
{
  Argument *tmp_2;
  union Argument *tmp_1;
  Argument *a = Reference((s + 3)->a);
  Argument *y = Reference((s + 1)->a);
  Dereference(s);
  ;
  tmp_1 = (*((a + 0)->call))(a,x);
  tmp_2 = fD1(tmp_1,y);
  return tmp_2;
}

Argument *fD(Argument *f, Argument *x)
{
  Argument *tmp_0;
  Argument *a = fA((f + 1)->a);
  Dereference(f);
  tmp_0 = fD1(a,x);
  return tmp_0;
}

Argument *ApplyInit(Argument *f)
{
  Argument *tmp;
  Argument __constr_expr_7 = {.init = & fA};
  tmp = Create(& __constr_expr_7);
  Argument *r = tmp;
  (r + 1)->a = I();
  (r + 2)->a = I();
  return r;
}

Argument *ApplyExit(Argument *f)
{
  Argument *tmp;
  Argument *tmp_0;
  tmp = I();
  Dereference(tmp);
  tmp_0 = I();
  return tmp_0;
}

Argument *Apply2(Argument *x, Argument *y)
{
  Argument *__retres;
  Argument *tmp_0;
  if ((y + 3)->a) {
    Argument *tmp;
    if ((y + 0)->call == & rCont) goto _LOR;
    else 
      if ((y + 0)->call == & rE) {
        _LOR: {
                Dereference(x);
                __retres = y;
                goto return_label;
              }
      }
    Argument __constr_expr_8 = {.call = & rApply2};
    tmp = Create(& __constr_expr_8);
    Argument *r = tmp;
    (r + 1)->a = x;
    (r + 3)->a = y;
    __retres = r;
    goto return_label;
  }
  tmp_0 = (*((x + 0)->call))(x,y);
  __retres = tmp_0;
  return_label: return __retres;
}

Argument *rApply2(Argument *s, Argument *x)
{
  Argument *tmp_2;
  union Argument *tmp_1;
  Argument *a = Reference((s + 1)->a);
  Argument *b = Reference((s + 3)->a);
  Dereference(s);
  tmp_1 = (*((b + 0)->call))(b,x);
  ;
  tmp_2 = Apply2(a,tmp_1);
  return tmp_2;
}

Argument *Apply1(Argument *x)
{
  Argument *__retres;
  Argument *tmp_3;
  if ((x + 3)->a) {
    Argument *tmp_0;
    if ((x + 0)->call == & rCont) {
      __retres = x;
      goto return_label;
    }
    if ((x + 0)->call == & rE) {
      Argument *tmp;
      tmp = I();
      Dereference(tmp);
      __retres = x;
      goto return_label;
    }
    Argument __constr_expr_9 = {.call = & rApply1};
    tmp_0 = Create(& __constr_expr_9);
    Argument *r = tmp_0;
    (r + 3)->a = x;
    __retres = r;
    goto return_label;
  }
  if ((x + 0)->call != & fD0) {
    Argument *tmp_2;
    Argument *tmp_1;
    tmp_1 = I();
    ;
    tmp_2 = Apply2(x,tmp_1);
    __retres = tmp_2;
    goto return_label;
  }
  Dereference(x);
  T[96][0].init = & ApplyInit;
  Argument __constr_expr_10 = {.call = & fD};
  tmp_3 = Create(& __constr_expr_10);
  Argument *r_0 = tmp_3;
  (r_0 + 1)->a = I();
  T[96][0].init = & Apply;
  __retres = r_0;
  return_label: return __retres;
}

/*@ assigns \result, *s, *x;
    assigns \result \from *s, *x;
    assigns *s \from *s, *x;
    assigns *x \from *s, *x;
 */
Argument *rApply1(Argument *s, Argument *x)
{
  Argument *tmp_1;
  union Argument *tmp_0;
  Argument *a = Reference((s + 3)->a);
  Dereference(s);
  tmp_0 = (*((a + 0)->call))(a,x);
  tmp_1 = Apply1(tmp_0);
  return tmp_1;
}

Argument *Apply(Argument *f)
{
  Argument *tmp_0;
  Argument *tmp;
  tmp = I();
  tmp_0 = Apply1(tmp);
  return tmp_0;
}

Argument *fK1(Argument *f, Argument *x)
{
  Argument *r = Reference((f + 1)->a);
  Dereference(x);
  Dereference(f);
  return r;
}

Argument *fK0(Argument *f, Argument *x)
{
  Argument *tmp;
  Argument __constr_expr_11 = {.call = & fK1};
  tmp = Create(& __constr_expr_11);
  Argument *r = tmp;
  (r + 1)->a = x;
  Dereference(f);
  return r;
}

Argument *fS22(Argument *a, Argument *b)
{
  Argument *__retres;
  Argument *tmp_0;
  if ((b + 3)->a) {
    Argument *tmp;
    if ((b + 0)->call == & rCont) goto _LOR;
    else 
      if ((b + 0)->call == & rE) {
        _LOR: {
                Dereference(a);
                __retres = b;
                goto return_label;
              }
      }
    Argument __constr_expr_12 = {.call = & rS2};
    tmp = Create(& __constr_expr_12);
    Argument *r = tmp;
    (r + 1)->a = a;
    (r + 3)->a = b;
    __retres = r;
    goto return_label;
  }
  tmp_0 = (*((a + 0)->call))(a,b);
  __retres = tmp_0;
  return_label: return __retres;
}

Argument *rS2(Argument *s, Argument *x)
{
  Argument *tmp_2;
  union Argument *tmp_1;
  Argument *a = Reference((s + 1)->a);
  Argument *b = Reference((s + 3)->a);
  Dereference(s);
  tmp_1 = (*((b + 0)->call))(b,x);
  ;
  tmp_2 = fS22(a,tmp_1);
  return tmp_2;
}

Argument *fS21(Argument *f, Argument *a, Argument *x)
{
  Argument *__retres;
  Argument *tmp_3;
  union Argument *tmp_2;
  if ((a + 3)->a) {
    Argument *tmp;
    if ((a + 0)->call == & rCont) goto _LOR;
    else 
      if ((a + 0)->call == & rE) {
        _LOR:
        {
          Dereference(x);
          Dereference(f);
          __retres = a;
          goto return_label;
        }
      }
    Argument __constr_expr_13 = {.call = & rS1};
    tmp = Create(& __constr_expr_13);
    Argument *r = tmp;
    (r + 1)->a = f;
    (r + 2)->a = x;
    (r + 3)->a = a;
    __retres = r;
    goto return_label;
  }
  if ((a + 0)->call == & fD0) {
    Argument *tmp_0;
    Argument __constr_expr_14 = {.call = & fD};
    tmp_0 = Create(& __constr_expr_14);
    Argument *r_0 = tmp_0;
    Argument __constr_expr_15 = {.init = & fA};
    (r_0 + 1)->a = Create(& __constr_expr_15);
    ((r_0 + 1)->a + 1)->a = Reference((f + 2)->a);
    ((r_0 + 1)->a + 2)->a = x;
    Dereference(f);
    __retres = r_0;
    goto return_label;
  }
  Argument *b = Reference((f + 2)->a);
  Dereference(f);
  tmp_2 = (*((b + 0)->call))(b,x);
  ;
  tmp_3 = fS22(a,tmp_2);
  __retres = tmp_3;
  return_label: return __retres;
}

Argument *rS1(Argument *s, Argument *x)
{
  Argument *tmp_3;
  union Argument *tmp_2;
  Argument *a = Reference((s + 3)->a);
  Argument *y = Reference((s + 2)->a);
  Argument *f = Reference((s + 1)->a);
  Dereference(s);
  ;
  tmp_2 = (*((a + 0)->call))(a,x);
  ;
  tmp_3 = fS21(f,tmp_2,y);
  return tmp_3;
}

Argument *fS2(Argument *f, Argument *x)
{
  Argument *tmp_1;
  union Argument *tmp_0;
  Argument *a = Reference((f + 1)->a);
  Reference(x);
  ;
  tmp_0 = (*((a + 0)->call))(a,x);
  ;
  tmp_1 = fS21(f,tmp_0,x);
  return tmp_1;
}

Argument *fS1(Argument *f, Argument *x)
{
  Argument *tmp;
  Argument __constr_expr_16 = {.call = & fS2};
  tmp = Create(& __constr_expr_16);
  Argument *r = tmp;
  (r + 1)->a = Reference((f + 1)->a);
  (r + 2)->a = x;
  Dereference(f);
  return r;
}

Argument *fS0(Argument *f, Argument *x)
{
  Argument *tmp;
  Argument __constr_expr_17 = {.call = & fS1};
  tmp = Create(& __constr_expr_17);
  Argument *r = tmp;
  (r + 1)->a = x;
  Dereference(f);
  return r;
}

Argument *fI(Argument *f, Argument *x)
{
  Dereference(f);
  return x;
}

Argument *fV(Argument *f, Argument *x)
{
  Dereference(x);
  return f;
}

Argument *fW(Argument *f, Argument *x)
{
  putc((int)(f + 1)->c,__fc_stdout);
  Dereference(f);
  return x;
}

Argument *fR(Argument *f, Argument *x)
{
  Argument *tmp_0;
  Argument *(*tmp)(Argument *f, Argument *x);
  Argument *tmp_1;
  ch = getc(__fc_stdin);
  if (ch != -1) tmp = & fI; else tmp = & fV;
  Argument __constr_expr_18 = {.call = tmp};
  tmp_0 = Create(& __constr_expr_18);
  Argument *r = tmp_0;
  Dereference(f);
  tmp_1 = (*((x + 0)->call))(x,r);
  return tmp_1;
}

Argument *fCh(Argument *f, Argument *x)
{
  Argument *tmp_0;
  Argument *(*tmp)(Argument *f, Argument *x);
  Argument *tmp_1;
  if (ch == (int)(f + 1)->c) tmp = & fI; else tmp = & fV;
  Argument __constr_expr_19 = {.call = tmp};
  tmp_0 = Create(& __constr_expr_19);
  Argument *r = tmp_0;
  Dereference(f);
  tmp_1 = (*((x + 0)->call))(x,r);
  return tmp_1;
}

Argument *fP(Argument *f, Argument *x)
{
  Argument *tmp_0;
  Argument *(*tmp)(Argument *f, Argument *x);
  Argument *tmp_1;
  if (ch != -1) tmp = & fW; else tmp = & fV;
  Argument __constr_expr_20 = {.call = tmp};
  tmp_0 = Create(& __constr_expr_20);
  Argument *r = tmp_0;
  if (ch != -1) (r + 1)->c = (char)ch;
  Dereference(f);
  tmp_1 = (*((x + 0)->call))(x,r);
  return tmp_1;
}

/*@ assigns \result, *f, *x;
    assigns \result \from *f, *x;
    assigns *f \from *f, *x;
    assigns *x \from *f, *x;
 */
Argument *rC(Argument *f, Argument *x)
{
  Argument *__retres;
  Argument *tmp_1;
  if ((x + 3)->a == x) {
    Argument *tmp;
    tmp = (*((x + 0)->call))(x,f);
    __retres = tmp;
    goto return_label;
  }
  Argument *r = Reference((f + 1)->a);
  Dereference(f);
  tmp_1 = (*((r + 0)->call))(r,x);
  __retres = tmp_1;
  return_label: return __retres;
}

Argument *fC(Argument *f, Argument *x)
{
  Argument *tmp;
  Argument __constr_expr_21 = {.call = & rC};
  tmp = Create(& __constr_expr_21);
  Argument *r = tmp;
  (r + 1)->a = x;
  (r + 3)->a = r;
  Dereference(f);
  return r;
}

Argument *fCont(Argument *f, Argument *x)
{
  Argument *tmp;
  int tmp_0;
  Argument __constr_expr_22 = {.call = & rCont};
  tmp = Create(& __constr_expr_22);
  Argument *r = tmp;
  (r + 1)->a = Reference((f + 1)->a);
  (r + 2)->a = x;
  (r + 3)->a = r;
  tmp_0 = fseek(p,(f + 2)->p - (long)1,0);
  if (tmp_0) F();
  c = getc(p);
  Next();
  Dereference(f);
  return r;
}

Argument *rE(Argument *f, Argument *x)
{
  return x;
}

Argument *fE(Argument *f, Argument *x)
{
  Argument *tmp;
  Argument __constr_expr_23 = {.call = & rE};
  tmp = Create(& __constr_expr_23);
  Argument *r = tmp;
  (r + 1)->a = x;
  (r + 3)->a = r;
  T[96][0].init = & ApplyExit;
  Dereference(f);
  return r;
}

static Argument T[256][2] =
  {[9] = {[1] = {.c = (char)'s'}},
   {[1] = {.c = (char)'s'}},
   {[1] = {.c = (char)'s'}},
   {[1] = {.c = (char)'s'}},
   {[1] = {.c = (char)'s'}},
   [32] = {[1] = {.c = (char)'s'}},
   [35] = {[1] = {.c = (char)'c'}},
   [46] = {{.init = & Char}, {.call = & fW}},
   [63] = {{.init = & Char}, {.call = & fCh}},
   {{.init = & Create}, {.call = & fR}},
   [96] = {{.init = & Apply}},
   [99] = {{.init = & Create}, {.call = & fC}},
   {{.init = & Create}, {.call = & fD0}},
   {{.init = & Create}, {.call = & fE}},
   [105] = {{.init = & Create}, {.call = & fI}},
   [107] = {{.init = & Create}, {.call = & fK0}},
   [114] = {{.init = & NewLine}, {.call = & fW}},
   {{.init = & Create}, {.call = & fS0}},
   [118] = {{.init = & Create}, {.call = & fV}},
   [124] = {{.init = & Create}, {.call = & fP}}};
/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_1(FILE * restrict stream, char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_2(FILE * restrict stream, char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_3(FILE * restrict stream, char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_4(FILE * restrict stream, char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), param0;
 */
int fprintf_va_5(FILE * restrict stream, char const * restrict format,
                 long param0);

/*@ requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..)));
 */
int fprintf_va_6(FILE * restrict stream, char const * restrict format);

/*@ assigns \nothing; */
void Output(Argument *f)
{
  if ((f + 0)->call == & fK0) fputc('k',o);
  else 
    if ((f + 0)->call == & fK1) {
      fprintf(o,"`k"); /* fprintf_va_1 */
      Output((f + 1)->a);
    }
    else 
      if ((f + 0)->call == & fS0) fputc('s',o);
      else 
        if ((f + 0)->call == & fS1) {
          fprintf(o,"`s"); /* fprintf_va_2 */
          Output((f + 1)->a);
        }
        else 
          if ((f + 0)->call == & fS2) {
            fprintf(o,"``s"); /* fprintf_va_3 */
            Output((f + 1)->a);
            Output((f + 2)->a);
          }
          else 
            if ((f + 0)->call == & fI) fputc('i',o);
            else 
              if ((f + 0)->call == & fV) fputc('v',o);
              else 
                if ((f + 0)->call == & fW) 
                  if ((int)(f + 1)->c == '\n') fputc('r',o);
                  else {
                    fputc('.',o);
                    fputc((int)(f + 1)->c,o);
                  }
                else 
                  if ((f + 0)->call == & fR) fputc('@',o);
                  else 
                    if ((f + 0)->call == & fCh) {
                      fputc('?',o);
                      fputc((int)(f + 1)->c,o);
                    }
                    else 
                      if ((f + 0)->call == & fP) fputc('|',o);
                      else 
                        if ((f + 0)->call == & fC) fputc('c',o);
                        else 
                          if ((f + 0)->call == & fE) fputc('e',o);
                          else 
                            if ((f + 0)->call == & fD0) fputc('d',o);
                            else 
                              if ((f + 0)->call == & fD) {
                                fprintf(o,"`d"); /* fprintf_va_4 */
                                Output((f + 1)->a);
                              }
                              else 
                                if ((f + 0)->init == & fA) {
                                  fputc('`',o);
                                  Output((f + 1)->a);
                                  Output((f + 2)->a);
                                }
                                else 
                                  if ((f + 0)->call == & fCont) fprintf
                                                                (o,
                                                                 "<cont:%li>",
                                                                 (f + 2)->p); /* fprintf_va_5 */
                                  else fprintf(o,"<unknown>"); /* fprintf_va_6 */
  return;
}


