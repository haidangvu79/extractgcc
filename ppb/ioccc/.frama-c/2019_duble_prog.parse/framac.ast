/* Generated by Frama-C */
#include "errno.h"
#include "fcntl.h"
#include "stdarg.h"
#include "stddef.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "strings.h"
#include "sys/select.h"
#include "sys/socket.h"
#include "sys/time.h"
#include "sys/uio.h"
#include "sys/un.h"
#include "termios.h"
#include "unistd.h"
struct __anonstruct_w_1 {
   int A ;
   int B ;
   int C ;
   int D ;
   int E ;
   int F ;
   int G ;
   int H ;
   int I ;
   int J ;
   int L ;
   int K ;
};
enum __anonenum_2 {
    u = 24 * (11 * 80 + 5) + 16
};
int a;
int b;
int c;
int d;
int e;
int f;
int h;
int i;
int j;
int k;
int l;
int m;
int n;
fd_set p[1];
fd_set q;
struct __anonstruct_w_1 w;
struct __anonstruct_w_1 x;
int r(int r_0)
{
  int tmp;
  b = r_0;
  tmp = FD_ISSET(r_0,(fd_set const *)(p));
  return tmp;
}

int t(int t_0)
{
  int __retres;
  FD_SET(t_0,& q);
  /*@ assert missing_return: \false; */ ;
  __retres = 0;
  return __retres;
}

struct sockaddr_un A;
struct sockaddr_un B;
struct sockaddr_un *D;
struct sockaddr_un C =
  {.sun_family = (sa_family_t)1,
   .sun_path = {(char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0,
                (char)0}};
char v[u];
unsigned int E = (unsigned int)sizeof(B);
unsigned int F = (unsigned int)sizeof(x);
char *I = (char *)"\033[0m\033[2J\033[0;0H";
char *K;
char *L = (char *)(& C.sun_path);
char *M;
char *J = (char *)"\033[0;30;40m \000\033[0m\n\000#!/bin/cat\n\033[1A";
char N;
int O(void)
{
  int __retres;
  struct sockaddr_un *tmp_0;
  n = 0;
  while (1) {
    int tmp;
    n ++;
    if (! (n < 9)) break;
    tmp = rand();
    *(L + n) = (char)(tmp % 13 + 65);
  }
  b = socket(1,2,0);
  t(b);
  ;
  if (b == 4) tmp_0 = & B; else tmp_0 = & C;
  ;
  n = bind(b,(struct sockaddr const *)tmp_0,E);
  /*@ assert missing_return: \false; */ ;
  __retres = 0;
  return __retres;
}

struct timeval y;
struct timeval z;
int H(void)
{
  int __retres;
  recvfrom(b,(void *)(& w),(size_t)F,0,(struct sockaddr *)(& A),& E);
  a = w.A;
  /*@ assert missing_return: \false; */ ;
  __retres = 0;
  return __retres;
}

int Q(void)
{
  int __retres;
  int tmp_1;
  FILE *tmp;
  close(4);
  tmp = fopen((char const *)K,"r");
  if (tmp) {
    int tmp_0;
    read(4,(void *)(v),(size_t)u);
    close(4);
    tmp_0 = unlink((char const *)K);
    if (tmp_0) tmp_1 = 1; else tmp_1 = 0;
  }
  else tmp_1 = 0;
  O();
  b = 3;
  /*@ assert missing_return: \false; */ ;
  __retres = 0;
  return __retres;
}

int P(int P_0)
{
  int __retres;
  strcat(v,(char const *)(J + P_0));
  /*@ assert missing_return: \false; */ ;
  __retres = 0;
  return __retres;
}

int G(int G_0)
{
  int __retres;
  ssize_t tmp_1;
  struct __anonstruct_w_1 *tmp_0;
  x.A = G_0;
  if (G_0 < 5) D = (struct sockaddr_un *)0;
  else {
    struct sockaddr_un *tmp;
    if (G_0 ^ 8) tmp = & B; else tmp = & A;
    D = tmp;
  }
  ;
  ;
  ;
  if (G_0 ^ 3) tmp_0 = & x; else tmp_0 = & w;
  ;
  tmp_1 = sendto(b,(void const *)tmp_0,(size_t)F,0,
                 (struct sockaddr const *)D,(unsigned int)(! (! D)) * E);
  __retres = (int)tmp_1;
  return __retres;
}

struct termios o;
/*@ requires valid_read_string(param0);
    requires valid_read_nstring(param2, param1);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param2 + (0 ..))),
            (indirect: param1), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param2 + (0 ..)), param1, *(param0 + (0 ..));
 */
int printf_va_1(char const * restrict format, char *param0, int param1,
                char *param2);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_2(char const * restrict format);

/*@ requires valid_read_nstring(param2, 11);
    requires valid_read_string(param7);
    requires valid_read_string(param8);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param8 + (0 ..))),
            (indirect: *(param7 + (0 ..))), (indirect: param6),
            (indirect: param5), (indirect: param4), (indirect: param3),
            (indirect: *(param2 + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param8 + (0 ..)), *(param7 + (0 ..)), param6, param5, param4,
            param3, *(param2 + (0 ..)), param1, param0;
 */
int printf_va_3(char const * restrict format, int param0, int param1,
                char *param2, int param3, int param4, int param5, int param6,
                char *param7, char *param8);

int main(int F_0, char **D_0)
{
  int __retres;
  n = 0;
  P(18);
  while (1) {
    int tmp_0;
    tmp_0 = n;
    n ++;
    ;
    if (! (tmp_0 < 24)) break;
    b = 0;
    while (1) {
      int tmp;
      tmp = b;
      b ++;
      ;
      if (! (tmp < 80)) break;
      P(0);
    }
    P(12);
  }
  if (F_0 == 2) {
    pid_t tmp_1;
    K = *(D_0 + 1);
    t(0);
    tmp_1 = getpid();
    srand((unsigned int)tmp_1);
    strcpy(L,(char const *)K);
    B = C;
    *L = (char)0;
    x.J = 44;
    O();
    Q();
    G(6);
    while (1) {
      int tmp_39;
      tmp_39 = F_0;
      F_0 ++;
      ;
      if (! (tmp_39 - 4)) break;
      tcgetattr(1,& o);
      o.c_lflag ^= (unsigned int)11;
      tcsetattr(1,0,& o);
      while (F_0 - 4) {
        int tmp_2;
        int tmp_4;
        int tmp_3;
        int tmp_14;
        int tmp_5;
        int tmp_16;
        int tmp_38;
        gettimeofday(& y,(void *)0);
        n = y.tv_usec;
        if (m) tmp_2 = 1;
        else {
          m = (3 << 19) + n;
          if (m) tmp_2 = 1; else tmp_2 = 0;
        }
        z.tv_usec = (m - n) % 999999;
        b = 3;
        p[0] = q;
        tmp_3 = select(5,p,(fd_set *)0,(fd_set *)0,& z);
        if (tmp_3) tmp_4 = 1;
        else {
          x.E ^= 1;
          G(9);
          m = 0;
          if (m) tmp_4 = 1; else tmp_4 = 0;
        }
        tmp_5 = r(0);
        if (tmp_5) {
          int tmp_6;
          int tmp_7;
          int tmp_10;
          int tmp_11;
          int tmp_13;
          b = 3;
          read(0,(void *)(& N),(size_t)1);
          N = (char)((int)N % 65);
          if (34 ^ (int)N) tmp_6 = 1;
          else {
            x.D = x.D % 6 + 1;
            if (x.D) tmp_6 = 1; else tmp_6 = 0;
          }
          if ((int)N ^ 47) {
            if ((int)N ^ 43) tmp_7 = 1; else goto _LAND;
          }
          else {
            _LAND:
            if ((int)N == x.J) {
              x.E = 0;
              G(10);
              x.J = 44;
            }
            else x.J = (int)N;
            if (x.J) tmp_7 = 1; else tmp_7 = 0;
          }
          if ((int)N < 4) {
            int tmp_8;
            int tmp_9;
            x.E = 0;
            G(9);
            if ((int)N == 3) 
              if (x.F) tmp_8 = 1; else tmp_8 = 0;
            else tmp_8 = 0;
            x.F -= tmp_8;
            x.F += ((int)N == 2) & (x.F != 80 - 3);
            if (! N) 
              if (x.G) tmp_9 = 1; else tmp_9 = 0;
            else tmp_9 = 0;
            x.G -= tmp_9;
            x.G += ((int)N == 1) & (x.G != 24 - 3);
            x.E = 1;
            if (x.E) tmp_10 = 1; else tmp_10 = 0;
          }
          else tmp_10 = 0;
          if (x.J ^ 43) {
            x.H = x.F;
            x.I = x.G;
            if (x.I) tmp_11 = 1; else tmp_11 = 0;
          }
          else tmp_11 = 0;
          G(9);
          if (48 ^ (int)N) tmp_13 = 1;
          else {
            int tmp_12;
            x.E = 0;
            G(9);
            tmp_12 = G(7);
            if (tmp_12) tmp_13 = 1; else tmp_13 = 0;
          }
          if (tmp_13) tmp_14 = 1; else tmp_14 = 0;
        }
        else tmp_14 = 0;
        tmp_16 = r(4);
        if (tmp_16) {
          H();
          if (a ^ 6) 
            if (a ^ 5) 
              while (1) {
                b ++;
                ;
                if (! (b <= c)) break;
                G(3);
              }
            else {
              x.K = (int)v[w.L];
              b = w.B;
              G(4);
            }
          else {
            int tmp_15;
            ;
            O();
            x.C = b;
            connect(x.C,(struct sockaddr const *)(& A),E);
            if (b > c) {
              c = b;
              if (c) tmp_15 = 1; else tmp_15 = 0;
            }
            else tmp_15 = 0;
            G(1);
          }
        }
        tmp_38 = r(3);
        if (tmp_38) {
          H();
          if (a ^ 2) {
            int tmp_18;
            int tmp_22;
            int tmp_27;
            if (a) tmp_18 = 1;
            else {
              int tmp_17;
              tmp_17 = G(6);
              if (tmp_17) tmp_18 = 1; else tmp_18 = 0;
            }
            if (a ^ 1) tmp_22 = 1;
            else {
              int tmp_19;
              int tmp_21;
              x.B = w.C;
              if (x.D) tmp_19 = 1;
              else {
                x.D = x.B % 6 + 1;
                if (x.D) tmp_19 = 1; else tmp_19 = 0;
              }
              if (x.L) tmp_21 = 1;
              else {
                int tmp_20;
                tmp_20 = G(5);
                if (tmp_20) tmp_21 = 1; else tmp_21 = 0;
              }
              if (tmp_21) tmp_22 = 1; else tmp_22 = 0;
            }
            if (a ^ 4) tmp_27 = 1;
            else {
              int tmp_23;
              int tmp_26;
              tmp_23 = x.L;
              (x.L) ++;
              v[tmp_23] = (char)w.K;
              if (x.L < u) tmp_26 = G(5);
              else tmp_26 = printf("%s%.*s\r \033[97mmode:",I,u - 6,v); /* printf_va_1 */
              if (tmp_26) tmp_27 = 1; else tmp_27 = 0;
            }
            if (a == 7) {
              int tmp_31;
              if (x.B ^ 5) tmp_31 = 1;
              else {
                int tmp_30;
                tmp_30 = close(w.B);
                if (tmp_30) tmp_31 = 1; else tmp_31 = 0;
              }
              if (w.B == x.B) {
                if (x.B == 5) {
                  int tmp_28;
                  unlink((char const *)K);
                  tmp_28 = creat((char const *)K,(mode_t)511);
                  write(tmp_28,(void const *)(v),(size_t)u);
                  b = 5;
                  while (1) {
                    int tmp_29;
                    b ++;
                    ;
                    if (! (b <= c)) break;
                    tmp_29 = G(2);
                    if (tmp_29 + 1) {
                      H();
                      while (1) {
                        b ++;
                        ;
                        if (! (b <= c)) break;
                        G(0);
                      }
                    }
                  }
                }
                printf((char const *)I); /* printf_va_2 */
                break;
              }
            }
            if (a > 8) {
              int tmp_32;
              d = w.F;
              e = w.G;
              f = w.H;
              h = w.I;
              a = w.E;
              if (d < f) i = 1; else i = -1;
              j = (f - d) * i;
              if (e < h) k = 1; else k = -1;
              l = (h - e) * k;
              if (j > l) tmp_32 = j; else tmp_32 = - l;
              n = tmp_32 / 2;
              while (1) {
                int tmp_36;
                int tmp_33;
                int tmp_34;
                M = (& v[(e + 1) * (5 + 80 * 11)] + d * 11) + 34;
                if (47 ^ w.J) {
                  if ((43 ^ w.J) | (w.A ^ 10)) tmp_36 = 1; else goto _LAND_0;
                }
                else {
                  char tmp_35;
                  _LAND_0: tmp_35 = (char)(w.D + 48);
                  *M = tmp_35;
                  if (tmp_35) tmp_36 = 1; else tmp_36 = 0;
                }
                *(M - 3) = (char)(w.D * (w.D + 48 != (int)*M) + 48);
                *(M - 6) = (char)(w.E * 7 + 48);
                if (a) *(M + 2) = (char)42; else *(M + 2) = (char)32;
                printf("\033[%d;%dH%.11s\033[%d;%dH\033[0;4%dm%c%s%s",
                       e + 2,d + 2,M - 8,24,8,x.D,x.J + 65,I + 8,J); /* printf_va_3 */
                if (! ((f ^ d) | (e ^ h))) break;
                b = n;
                ;
                if (b > - j) {
                  n -= l;
                  d += i;
                  if (d) tmp_33 = 1; else tmp_33 = 0;
                }
                else tmp_33 = 0;
                if (b < l) {
                  n += j;
                  e += k;
                  if (e) tmp_34 = 1; else tmp_34 = 0;
                }
                else tmp_34 = 0;
                a = 0;
              }
            }
            fflush(__fc_stdout);
          }
          else {
            int tmp_37;
            tmp_37 = Q();
            G(6);
            G(8);
          }
        }
      }
    }
  }
  __retres = 0;
  return __retres;
}


