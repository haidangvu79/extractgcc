/* Generated by Frama-C */
#include "errno.h"
#include "fcntl.h"
#include "inttypes.h"
#include "netdb.h"
#include "netinet/in.h"
#include "signal.h"
#include "stdarg.h"
#include "stddef.h"
#include "stdint.h"
#include "stdio.h"
#include "stdlib.h"
#include "string.h"
#include "strings.h"
#include "sys/select.h"
#include "sys/socket.h"
#include "sys/time.h"
#include "sys/types.h"
#include "sys/uio.h"
#include "time.h"
#include "unistd.h"
struct __anonstruct_aes_context_1 {
   int nr ;
   unsigned long *rk ;
   unsigned long buf[68] ;
};
typedef struct __anonstruct_aes_context_1 aes_context;
typedef long t_sint;
typedef unsigned long t_uint;
struct __anonstruct_mpi_2 {
   int s ;
   size_t n ;
   t_uint *p ;
};
typedef struct __anonstruct_mpi_2 mpi;
struct __anonstruct_dhm_context_3 {
   size_t len ;
   mpi P ;
   mpi G ;
   mpi X ;
   mpi GX ;
   mpi GY ;
   mpi K ;
   mpi RP ;
};
typedef struct __anonstruct_dhm_context_3 dhm_context;
struct __anonstruct_rsa_context_4 {
   int ver ;
   size_t len ;
   mpi N ;
   mpi E ;
   mpi D ;
   mpi P ;
   mpi Q ;
   mpi DP ;
   mpi DQ ;
   mpi QP ;
   mpi RN ;
   mpi RP ;
   mpi RQ ;
   int padding ;
   int hash_id ;
};
typedef struct __anonstruct_rsa_context_4 rsa_context;
struct __anonstruct_md5_context_5 {
   unsigned long total[2] ;
   unsigned long state[4] ;
   unsigned char buffer[64] ;
   unsigned char ipad[64] ;
   unsigned char opad[64] ;
};
typedef struct __anonstruct_md5_context_5 md5_context;
struct __anonstruct_sha1_context_6 {
   unsigned long total[2] ;
   unsigned long state[5] ;
   unsigned char buffer[64] ;
   unsigned char ipad[64] ;
   unsigned char opad[64] ;
};
typedef struct __anonstruct_sha1_context_6 sha1_context;
struct _asn1_buf {
   int tag ;
   size_t len ;
   unsigned char *p ;
};
typedef struct _asn1_buf asn1_buf;
struct _asn1_bitstring {
   size_t len ;
   unsigned char unused_bits ;
   unsigned char *p ;
};
typedef struct _asn1_bitstring asn1_bitstring;
struct _asn1_sequence {
   asn1_buf buf ;
   struct _asn1_sequence *next ;
};
typedef struct _asn1_sequence asn1_sequence;
typedef asn1_buf x509_buf;
typedef asn1_bitstring x509_bitstring;
struct _x509_name {
   x509_buf oid ;
   x509_buf val ;
   struct _x509_name *next ;
};
typedef struct _x509_name x509_name;
typedef asn1_sequence x509_sequence;
struct _x509_time {
   int year ;
   int mon ;
   int day ;
   int hour ;
   int min ;
   int sec ;
};
typedef struct _x509_time x509_time;
struct _x509_cert {
   x509_buf raw ;
   x509_buf tbs ;
   int version ;
   x509_buf serial ;
   x509_buf sig_oid1 ;
   x509_buf issuer_raw ;
   x509_buf subject_raw ;
   x509_name issuer ;
   x509_name subject ;
   x509_time valid_from ;
   x509_time valid_to ;
   x509_buf pk_oid ;
   rsa_context rsa ;
   x509_buf issuer_id ;
   x509_buf subject_id ;
   x509_buf v3_ext ;
   int ext_types ;
   int ca_istrue ;
   int max_pathlen ;
   unsigned char key_usage ;
   x509_sequence ext_key_usage ;
   unsigned char ns_cert_type ;
   x509_buf sig_oid2 ;
   x509_buf sig ;
   int sig_alg ;
   struct _x509_cert *next ;
};
typedef struct _x509_cert x509_cert;
struct _x509_crl_entry {
   x509_buf raw ;
   x509_buf serial ;
   x509_time revocation_date ;
   x509_buf entry_ext ;
   struct _x509_crl_entry *next ;
};
typedef struct _x509_crl_entry x509_crl_entry;
struct _x509_crl {
   x509_buf raw ;
   x509_buf tbs ;
   int version ;
   x509_buf sig_oid1 ;
   x509_buf issuer_raw ;
   x509_name issuer ;
   x509_time this_update ;
   x509_time next_update ;
   x509_crl_entry entry ;
   x509_buf crl_ext ;
   x509_buf sig_oid2 ;
   x509_buf sig ;
   int sig_alg ;
   struct _x509_crl *next ;
};
typedef struct _x509_crl x509_crl;
enum __anonenum_ssl_states_7 {
    SSL_HELLO_REQUEST = 0,
    SSL_CLIENT_HELLO = 1,
    SSL_SERVER_HELLO = 2,
    SSL_SERVER_CERTIFICATE = 3,
    SSL_SERVER_KEY_EXCHANGE = 4,
    SSL_CERTIFICATE_REQUEST = 5,
    SSL_SERVER_HELLO_DONE = 6,
    SSL_CLIENT_CERTIFICATE = 7,
    SSL_CLIENT_KEY_EXCHANGE = 8,
    SSL_CERTIFICATE_VERIFY = 9,
    SSL_CLIENT_CHANGE_CIPHER_SPEC = 10,
    SSL_CLIENT_FINISHED = 11,
    SSL_SERVER_CHANGE_CIPHER_SPEC = 12,
    SSL_SERVER_FINISHED = 13,
    SSL_FLUSH_BUFFERS = 14,
    SSL_HANDSHAKE_OVER = 15
};
struct _ssl_session;
typedef struct _ssl_session ssl_session;
struct _ssl_context;
typedef struct _ssl_context ssl_context;
struct _ssl_session {
   time_t start ;
   int ciphersuite ;
   size_t length ;
   unsigned char id[32] ;
   unsigned char master[48] ;
   ssl_session *next ;
};
struct _ssl_context {
   int state ;
   int major_ver ;
   int minor_ver ;
   int max_major_ver ;
   int max_minor_ver ;
   int (*f_rng)(void *, unsigned char *, size_t ) ;
   void (*f_dbg)(void *, int , char const *) ;
   int (*f_recv)(void *, unsigned char *, size_t ) ;
   int (*f_send)(void *, unsigned char const *, size_t ) ;
   int (*f_vrfy)(void *, x509_cert *, int , int ) ;
   void *p_rng ;
   void *p_dbg ;
   void *p_recv ;
   void *p_send ;
   void *p_vrfy ;
   int resume ;
   int timeout ;
   ssl_session *session ;
   int (*s_get)(ssl_context *) ;
   int (*s_set)(ssl_context *) ;
   unsigned char *in_ctr ;
   unsigned char *in_hdr ;
   unsigned char *in_msg ;
   unsigned char *in_offt ;
   int in_msgtype ;
   size_t in_msglen ;
   size_t in_left ;
   size_t in_hslen ;
   int nb_zero ;
   unsigned char *out_ctr ;
   unsigned char *out_hdr ;
   unsigned char *out_msg ;
   int out_msgtype ;
   size_t out_msglen ;
   size_t out_left ;
   rsa_context *rsa_key ;
   x509_cert *own_cert ;
   x509_cert *ca_chain ;
   x509_crl *ca_crl ;
   x509_cert *peer_cert ;
   char const *peer_cn ;
   int endpoint ;
   int authmode ;
   int client_auth ;
   int verify_result ;
   dhm_context dhm_ctx ;
   md5_context fin_md5 ;
   sha1_context fin_sha1 ;
   int do_crypt ;
   int *ciphersuites ;
   size_t pmslen ;
   unsigned int keylen ;
   size_t minlen ;
   size_t ivlen ;
   size_t maclen ;
   unsigned char randbytes[64] ;
   unsigned char premaster[256] ;
   unsigned char iv_enc[16] ;
   unsigned char iv_dec[16] ;
   unsigned char mac_enc[32] ;
   unsigned char mac_dec[32] ;
   unsigned long ctx_enc[128] ;
   unsigned long ctx_dec[128] ;
   unsigned char *hostname ;
   size_t hostname_len ;
};
struct hr_time {
   unsigned char opaque[32] ;
};
struct __anonstruct_ctr_drbg_context_8 {
   unsigned char counter[16] ;
   int reseed_counter ;
   int prediction_resistance ;
   size_t entropy_len ;
   int reseed_interval ;
   aes_context aes_ctx ;
   int (*f_entropy)(void *, unsigned char *, size_t ) ;
   void *p_entropy ;
};
typedef struct __anonstruct_ctr_drbg_context_8 ctr_drbg_context;
struct __anonstruct_camellia_context_9 {
   int nr ;
   uint32_t rk[68] ;
};
typedef struct __anonstruct_camellia_context_9 camellia_context;
struct __anonstruct_arc4_context_10 {
   int x ;
   int y ;
   unsigned char m[256] ;
};
typedef struct __anonstruct_arc4_context_10 arc4_context;
struct __anonstruct_des_context_11 {
   int mode ;
   unsigned long sk[32] ;
};
typedef struct __anonstruct_des_context_11 des_context;
struct __anonstruct_des3_context_12 {
   int mode ;
   unsigned long sk[96] ;
};
typedef struct __anonstruct_des3_context_12 des3_context;
struct __anonstruct_sha4_context_13 {
   unsigned long long total[2] ;
   unsigned long long state[8] ;
   unsigned char buffer[128] ;
   unsigned char ipad[128] ;
   unsigned char opad[128] ;
   int is384 ;
};
typedef struct __anonstruct_sha4_context_13 sha4_context;
enum __anonenum_cipher_id_t_1 {
    POLARSSL_CIPHER_ID_NONE = 0,
    POLARSSL_CIPHER_ID_AES = 1,
    POLARSSL_CIPHER_ID_DES = 2,
    POLARSSL_CIPHER_ID_3DES = 3,
    POLARSSL_CIPHER_ID_CAMELLIA = 4
};
typedef enum __anonenum_cipher_id_t_1 cipher_id_t;
enum __anonenum_cipher_type_t_2 {
    POLARSSL_CIPHER_NONE = 0,
    POLARSSL_CIPHER_AES_128_CBC = 1,
    POLARSSL_CIPHER_AES_192_CBC = 2,
    POLARSSL_CIPHER_AES_256_CBC = 3,
    POLARSSL_CIPHER_AES_128_CFB128 = 4,
    POLARSSL_CIPHER_AES_192_CFB128 = 5,
    POLARSSL_CIPHER_AES_256_CFB128 = 6,
    POLARSSL_CIPHER_AES_128_CTR = 7,
    POLARSSL_CIPHER_AES_192_CTR = 8,
    POLARSSL_CIPHER_AES_256_CTR = 9,
    POLARSSL_CIPHER_CAMELLIA_128_CBC = 10,
    POLARSSL_CIPHER_CAMELLIA_192_CBC = 11,
    POLARSSL_CIPHER_CAMELLIA_256_CBC = 12,
    POLARSSL_CIPHER_CAMELLIA_128_CFB128 = 13,
    POLARSSL_CIPHER_CAMELLIA_192_CFB128 = 14,
    POLARSSL_CIPHER_CAMELLIA_256_CFB128 = 15,
    POLARSSL_CIPHER_CAMELLIA_128_CTR = 16,
    POLARSSL_CIPHER_CAMELLIA_192_CTR = 17,
    POLARSSL_CIPHER_CAMELLIA_256_CTR = 18,
    POLARSSL_CIPHER_DES_CBC = 19,
    POLARSSL_CIPHER_DES_EDE_CBC = 20,
    POLARSSL_CIPHER_DES_EDE3_CBC = 21
};
typedef enum __anonenum_cipher_type_t_2 cipher_type_t;
enum __anonenum_cipher_mode_t_3 {
    POLARSSL_MODE_NONE = 0,
    POLARSSL_MODE_CBC = 1,
    POLARSSL_MODE_CFB128 = 2,
    POLARSSL_MODE_OFB = 3,
    POLARSSL_MODE_CTR = 4
};
typedef enum __anonenum_cipher_mode_t_3 cipher_mode_t;
enum __anonenum_operation_t_4 {
    POLARSSL_OPERATION_NONE = -1,
    POLARSSL_DECRYPT = 0,
    POLARSSL_ENCRYPT = 1
};
typedef enum __anonenum_operation_t_4 operation_t;
enum __anonenum_5 {
    POLARSSL_KEY_LENGTH_NONE = 0,
    POLARSSL_KEY_LENGTH_DES = 64,
    POLARSSL_KEY_LENGTH_DES_EDE = 128,
    POLARSSL_KEY_LENGTH_DES_EDE3 = 192,
    POLARSSL_MAX_IV_LENGTH = 16
};
struct __anonstruct_cipher_base_t_6 {
   cipher_id_t cipher ;
   int (*cbc_func)(void *ctx, operation_t mode, size_t length,
                   unsigned char *iv, unsigned char const *input,
                   unsigned char *output) ;
   int (*cfb128_func)(void *ctx, operation_t mode, size_t length,
                      size_t *iv_off, unsigned char *iv,
                      unsigned char const *input, unsigned char *output) ;
   int (*ctr_func)(void *ctx, size_t length, size_t *nc_off,
                   unsigned char *nonce_counter, unsigned char *stream_block,
                   unsigned char const *input, unsigned char *output) ;
   int (*setkey_enc_func)(void *ctx, unsigned char const *key,
                          unsigned int key_length) ;
   int (*setkey_dec_func)(void *ctx, unsigned char const *key,
                          unsigned int key_length) ;
   void *(*ctx_alloc_func)(void) ;
   void (*ctx_free_func)(void *ctx) ;
};
typedef struct __anonstruct_cipher_base_t_6 cipher_base_t;
struct __anonstruct_cipher_info_t_7 {
   cipher_type_t type ;
   cipher_mode_t mode ;
   unsigned int key_length ;
   char const *name ;
   unsigned int iv_size ;
   unsigned int block_size ;
   cipher_base_t const *base ;
};
typedef struct __anonstruct_cipher_info_t_7 cipher_info_t;
struct __anonstruct_cipher_context_t_8 {
   cipher_info_t const *cipher_info ;
   int key_length ;
   operation_t operation ;
   unsigned char unprocessed_data[POLARSSL_MAX_IV_LENGTH] ;
   size_t unprocessed_len ;
   unsigned char iv[POLARSSL_MAX_IV_LENGTH] ;
   void *cipher_ctx ;
};
typedef struct __anonstruct_cipher_context_t_8 cipher_context_t;
struct __anonstruct_source_state_2 {
   int (*f_source)(void *, unsigned char *, size_t , size_t *) ;
   void *p_source ;
   size_t size ;
   size_t threshold ;
};
typedef struct __anonstruct_source_state_2 source_state;
struct __anonstruct_entropy_context_3 {
   sha4_context accumulator ;
   int source_count ;
   source_state source[20] ;
};
typedef struct __anonstruct_entropy_context_3 entropy_context;
enum __anonenum_md_type_t_19 {
    POLARSSL_MD_NONE = 0,
    POLARSSL_MD_MD2 = 1,
    POLARSSL_MD_MD4 = 2,
    POLARSSL_MD_MD5 = 3,
    POLARSSL_MD_SHA1 = 4,
    POLARSSL_MD_SHA224 = 5,
    POLARSSL_MD_SHA256 = 6,
    POLARSSL_MD_SHA384 = 7,
    POLARSSL_MD_SHA512 = 8
};
typedef enum __anonenum_md_type_t_19 md_type_t;
struct __anonstruct_md_info_t_20 {
   md_type_t type ;
   char const *name ;
   int size ;
   void (*starts_func)(void *ctx) ;
   void (*update_func)(void *ctx, unsigned char const *input, size_t ilen) ;
   void (*finish_func)(void *ctx, unsigned char *output) ;
   void (*digest_func)(unsigned char const *input, size_t ilen,
                       unsigned char *output) ;
   int (*file_func)(char const *path, unsigned char *output) ;
   void (*hmac_starts_func)(void *ctx, unsigned char const *key,
                            size_t keylen) ;
   void (*hmac_update_func)(void *ctx, unsigned char const *input,
                            size_t ilen) ;
   void (*hmac_finish_func)(void *ctx, unsigned char *output) ;
   void (*hmac_reset_func)(void *ctx) ;
   void (*hmac_func)(unsigned char const *key, size_t keylen,
                     unsigned char const *input, size_t ilen,
                     unsigned char *output) ;
   void *(*ctx_alloc_func)(void) ;
   void (*ctx_free_func)(void *ctx) ;
};
typedef struct __anonstruct_md_info_t_20 md_info_t;
struct __anonstruct_md_context_t_21 {
   md_info_t const *md_info ;
   void *md_ctx ;
};
typedef struct __anonstruct_md_context_t_21 md_context_t;
struct __anonstruct_pem_context_23 {
   unsigned char *buf ;
   size_t buflen ;
   unsigned char *info ;
};
typedef struct __anonstruct_pem_context_23 pem_context;
struct __anonstruct_sha2_context_26 {
   unsigned long total[2] ;
   unsigned long state[8] ;
   unsigned char buffer[64] ;
   unsigned char ipad[64] ;
   unsigned char opad[64] ;
   int is224 ;
};
typedef struct __anonstruct_sha2_context_26 sha2_context;
struct __anonstruct_xtea_context_28 {
   uint32_t k[4] ;
};
typedef struct __anonstruct_xtea_context_28 xtea_context;
struct _hr_time {
   struct timeval start ;
};
int aes_setkey_enc(aes_context *ctx, unsigned char const *key,
                   unsigned int keysize);

int aes_setkey_dec(aes_context *ctx, unsigned char const *key,
                   unsigned int keysize);

int aes_crypt_ecb(aes_context *ctx, int mode, unsigned char const input[16],
                  unsigned char output[16]);

int aes_crypt_cbc(aes_context *ctx, int mode, size_t length,
                  unsigned char iv[16], unsigned char const *input,
                  unsigned char *output);

int aes_crypt_cfb128(aes_context *ctx, int mode, size_t length,
                     size_t *iv_off, unsigned char iv[16],
                     unsigned char const *input, unsigned char *output);

int aes_crypt_ctr(aes_context *ctx, size_t length, size_t *nc_off,
                  unsigned char nonce_counter[16],
                  unsigned char stream_block[16], unsigned char const *input,
                  unsigned char *output);

int aes_self_test(int verbose);

int net_connect(int *fd, char const *host, int port);

int net_bind(int *fd, char const *bind_ip, int port);

int net_accept(int bind_fd, int *client_fd, void *client_ip);

int net_set_block(int fd);

int net_set_nonblock(int fd);

void net_usleep(unsigned long usec);

int net_recv(void *ctx, unsigned char *buf, size_t len);

int net_send(void *ctx, unsigned char const *buf, size_t len);

void net_close(int fd);

void mpi_init(mpi *X);

void mpi_free(mpi *X);

int mpi_grow(mpi *X, size_t nblimbs);

int mpi_copy(mpi *X, mpi const *Y);

void mpi_swap(mpi *X, mpi *Y);

int mpi_lset(mpi *X, t_sint z);

int mpi_get_bit(mpi *X, size_t pos);

int mpi_set_bit(mpi *X, size_t pos, unsigned char val);

size_t mpi_lsb(mpi const *X);

size_t mpi_msb(mpi const *X);

size_t mpi_size(mpi const *X);

int mpi_read_string(mpi *X, int radix, char const *s);

int mpi_write_string(mpi const *X, int radix, char *s, size_t *slen);

int mpi_read_file(mpi *X, int radix, FILE *fin);

int mpi_write_file(char const *p, mpi const *X, int radix, FILE *fout);

int mpi_read_binary(mpi *X, unsigned char const *buf, size_t buflen);

int mpi_write_binary(mpi const *X, unsigned char *buf, size_t buflen);

int mpi_shift_l(mpi *X, size_t count);

int mpi_shift_r(mpi *X, size_t count);

int mpi_cmp_abs(mpi const *X, mpi const *Y);

int mpi_cmp_mpi(mpi const *X, mpi const *Y);

int mpi_cmp_int(mpi const *X, t_sint z);

int mpi_add_abs(mpi *X, mpi const *A, mpi const *B);

int mpi_sub_abs(mpi *X, mpi const *A, mpi const *B);

int mpi_add_mpi(mpi *X, mpi const *A, mpi const *B);

int mpi_sub_mpi(mpi *X, mpi const *A, mpi const *B);

int mpi_add_int(mpi *X, mpi const *A, t_sint b);

int mpi_sub_int(mpi *X, mpi const *A, t_sint b);

int mpi_mul_mpi(mpi *X, mpi const *A, mpi const *B);

int mpi_mul_int(mpi *X, mpi const *A, t_sint b);

int mpi_div_mpi(mpi *Q, mpi *R, mpi const *A, mpi const *B);

int mpi_div_int(mpi *Q, mpi *R, mpi const *A, t_sint b);

int mpi_mod_mpi(mpi *R, mpi const *A, mpi const *B);

int mpi_mod_int(t_uint *r, mpi const *A, t_sint b);

int mpi_exp_mod(mpi *X, mpi const *A, mpi const *E, mpi const *N, mpi *_RR);

int mpi_fill_random(mpi *X, size_t size,
                    int (*f_rng)(void *, unsigned char *, size_t ),
                    void *p_rng);

int mpi_gcd(mpi *G, mpi const *A, mpi const *B);

int mpi_inv_mod(mpi *X, mpi const *A, mpi const *N);

int mpi_is_prime(mpi *X, int (*f_rng)(void *, unsigned char *, size_t ),
                 void *p_rng);

int mpi_gen_prime(mpi *X, size_t nbits, int dh_flag,
                  int (*f_rng)(void *, unsigned char *, size_t ), void *p_rng);

int mpi_self_test(int verbose);

int dhm_read_params(dhm_context *ctx, unsigned char **p,
                    unsigned char const *end);

int dhm_make_params(dhm_context *ctx, int x_size, unsigned char *output,
                    size_t *olen,
                    int (*f_rng)(void *, unsigned char *, size_t ),
                    void *p_rng);

int dhm_read_public(dhm_context *ctx, unsigned char const *input, size_t ilen);

int dhm_make_public(dhm_context *ctx, int x_size, unsigned char *output,
                    size_t olen,
                    int (*f_rng)(void *, unsigned char *, size_t ),
                    void *p_rng);

int dhm_calc_secret(dhm_context *ctx, unsigned char *output, size_t *olen);

void dhm_free(dhm_context *ctx);

int dhm_self_test(int verbose);

void rsa_init(rsa_context *ctx, int padding, int hash_id);

int rsa_gen_key(rsa_context *ctx,
                int (*f_rng)(void *, unsigned char *, size_t ), void *p_rng,
                unsigned int nbits, int exponent);

int rsa_check_pubkey(rsa_context const *ctx);

int rsa_check_privkey(rsa_context const *ctx);

int rsa_public(rsa_context *ctx, unsigned char const *input,
               unsigned char *output);

int rsa_private(rsa_context *ctx, unsigned char const *input,
                unsigned char *output);

int rsa_pkcs1_encrypt(rsa_context *ctx,
                      int (*f_rng)(void *, unsigned char *, size_t ),
                      void *p_rng, int mode, size_t ilen,
                      unsigned char const *input, unsigned char *output);

int rsa_pkcs1_decrypt(rsa_context *ctx, int mode, size_t *olen,
                      unsigned char const *input, unsigned char *output,
                      size_t output_max_len);

int rsa_pkcs1_sign(rsa_context *ctx,
                   int (*f_rng)(void *, unsigned char *, size_t ),
                   void *p_rng, int mode, int hash_id, unsigned int hashlen,
                   unsigned char const *hash, unsigned char *sig);

int rsa_pkcs1_verify(rsa_context *ctx, int mode, int hash_id,
                     unsigned int hashlen, unsigned char const *hash,
                     unsigned char *sig);

void rsa_free(rsa_context *ctx);

int rsa_self_test(int verbose);

void md5_starts(md5_context *ctx);

void md5_update(md5_context *ctx, unsigned char const *input, size_t ilen);

void md5_finish(md5_context *ctx, unsigned char output[16]);

void md5(unsigned char const *input, size_t ilen, unsigned char output[16]);

int md5_file(char const *path, unsigned char output[16]);

void md5_hmac_starts(md5_context *ctx, unsigned char const *key,
                     size_t keylen);

void md5_hmac_update(md5_context *ctx, unsigned char const *input,
                     size_t ilen);

void md5_hmac_finish(md5_context *ctx, unsigned char output[16]);

void md5_hmac_reset(md5_context *ctx);

void md5_hmac(unsigned char const *key, size_t keylen,
              unsigned char const *input, size_t ilen,
              unsigned char output[16]);

int md5_self_test(int verbose);

void md5_process(md5_context *ctx, unsigned char const data[64]);

void sha1_starts(sha1_context *ctx);

void sha1_update(sha1_context *ctx, unsigned char const *input, size_t ilen);

void sha1_finish(sha1_context *ctx, unsigned char output[20]);

void sha1(unsigned char const *input, size_t ilen, unsigned char output[20]);

int sha1_file(char const *path, unsigned char output[20]);

void sha1_hmac_starts(sha1_context *ctx, unsigned char const *key,
                      size_t keylen);

void sha1_hmac_update(sha1_context *ctx, unsigned char const *input,
                      size_t ilen);

void sha1_hmac_finish(sha1_context *ctx, unsigned char output[20]);

void sha1_hmac_reset(sha1_context *ctx);

void sha1_hmac(unsigned char const *key, size_t keylen,
               unsigned char const *input, size_t ilen,
               unsigned char output[20]);

int sha1_self_test(int verbose);

void sha1_process(sha1_context *ctx, unsigned char const data[64]);

int asn1_get_len(unsigned char **p, unsigned char const *end, size_t *len);

int asn1_get_tag(unsigned char **p, unsigned char const *end, size_t *len,
                 int tag);

int asn1_get_bool(unsigned char **p, unsigned char const *end, int *val);

int asn1_get_int(unsigned char **p, unsigned char const *end, int *val);

int asn1_get_bitstring(unsigned char **p, unsigned char const *end,
                       asn1_bitstring *bs);

int asn1_get_sequence_of(unsigned char **p, unsigned char const *end,
                         asn1_sequence *cur_0, int tag);

int asn1_get_mpi(unsigned char **p, unsigned char const *end, mpi *X);

int x509parse_crt_der(x509_cert *chain, unsigned char const *buf,
                      size_t buflen);

int x509parse_crt(x509_cert *chain, unsigned char const *buf, size_t buflen);

int x509parse_crtfile(x509_cert *chain, char const *path);

int x509parse_crl(x509_crl *chain, unsigned char const *buf, size_t buflen);

int x509parse_crlfile(x509_crl *chain, char const *path);

int x509parse_key(rsa_context *rsa, unsigned char const *key, size_t keylen,
                  unsigned char const *pwd, size_t pwdlen);

int x509parse_keyfile(rsa_context *rsa, char const *path, char const *pwd);

int x509parse_public_key(rsa_context *rsa, unsigned char const *key,
                         size_t keylen);

int x509parse_public_keyfile(rsa_context *rsa, char const *path);

int x509parse_dhm(dhm_context *dhm, unsigned char const *dhmin,
                  size_t dhminlen);

int x509parse_dhmfile(dhm_context *dhm, char const *path);

int x509parse_dn_gets(char *buf, size_t size, x509_name const *dn);

int x509parse_serial_gets(char *buf, size_t size, x509_buf const *serial);

int x509parse_cert_info(char *buf, size_t size, char const *prefix,
                        x509_cert const *crt);

int x509parse_crl_info(char *buf, size_t size, char const *prefix,
                       x509_crl const *crl);

char const *x509_oid_get_description(x509_buf *oid);

int x509_oid_get_numeric_string(char *buf, size_t size, x509_buf *oid);

int x509parse_time_expired(x509_time const *to);

int x509parse_verify(x509_cert *crt, x509_cert *trust_ca, x509_crl *ca_crl,
                     char const *cn, int *flags,
                     int (*f_vrfy)(void *, x509_cert *, int , int ),
                     void *p_vrfy);

int x509parse_revoked(x509_cert const *crt, x509_crl const *crl);

void x509_free(x509_cert *crt);

void x509_crl_free(x509_crl *crl);

int x509_self_test(int verbose);

int ssl_default_ciphersuites[13];

__inline static int const *ssl_list_ciphersuites(void)
{
  int const *__retres;
  __retres = (int const *)(ssl_default_ciphersuites);
  return __retres;
}

char const *ssl_get_ciphersuite_name(int const ciphersuite_id);

int ssl_get_ciphersuite_id(char const *ciphersuite_name);

int ssl_init(ssl_context *ssl);

void ssl_session_reset(ssl_context *ssl);

void ssl_set_endpoint(ssl_context *ssl, int endpoint);

void ssl_set_authmode(ssl_context *ssl, int authmode);

void ssl_set_verify(ssl_context *ssl,
                    int (*f_vrfy)(void *, x509_cert *, int , int ),
                    void *p_vrfy);

void ssl_set_rng(ssl_context *ssl,
                 int (*f_rng)(void *, unsigned char *, size_t ), void *p_rng);

void ssl_set_dbg(ssl_context *ssl, void (*f_dbg)(void *, int , char const *),
                 void *p_dbg);

void ssl_set_bio(ssl_context *ssl,
                 int (*f_recv)(void *, unsigned char *, size_t ),
                 void *p_recv,
                 int (*f_send)(void *, unsigned char const *, size_t ),
                 void *p_send);

void ssl_set_scb(ssl_context *ssl, int (*s_get)(ssl_context *),
                 int (*s_set)(ssl_context *));

void ssl_set_session(ssl_context *ssl, int resume, int timeout,
                     ssl_session *session);

void ssl_set_ciphersuites(ssl_context *ssl, int *ciphersuites);

void ssl_set_ca_chain(ssl_context *ssl, x509_cert *ca_chain,
                      x509_crl *ca_crl, char const *peer_cn);

void ssl_set_own_cert(ssl_context *ssl, x509_cert *own_cert,
                      rsa_context *rsa_key);

int ssl_set_dh_param(ssl_context *ssl, char const *dhm_P, char const *dhm_G);

int ssl_set_dh_param_ctx(ssl_context *ssl, dhm_context *dhm_ctx);

int ssl_set_hostname(ssl_context *ssl, char const *hostname);

void ssl_set_max_version(ssl_context *ssl, int major, int minor);

size_t ssl_get_bytes_avail(ssl_context const *ssl);

int ssl_get_verify_result(ssl_context const *ssl);

char const *ssl_get_ciphersuite(ssl_context const *ssl);

char const *ssl_get_version(ssl_context const *ssl);

int ssl_handshake(ssl_context *ssl);

int ssl_read(ssl_context *ssl, unsigned char *buf, size_t len);

int ssl_write(ssl_context *ssl, unsigned char const *buf, size_t len);

int ssl_close_notify(ssl_context *ssl);

void ssl_free(ssl_context *ssl);

int ssl_handshake_client(ssl_context *ssl);

int ssl_handshake_server(ssl_context *ssl);

int ssl_derive_keys(ssl_context *ssl);

void ssl_calc_verify(ssl_context *ssl, unsigned char hash[36]);

int ssl_read_record(ssl_context *ssl);

int ssl_fetch_input(ssl_context *ssl, size_t nb_want);

int ssl_write_record(ssl_context *ssl);

int ssl_flush_output(ssl_context *ssl);

int ssl_parse_certificate(ssl_context *ssl);

int ssl_write_certificate(ssl_context *ssl);

int ssl_parse_change_cipher_spec(ssl_context *ssl);

int ssl_write_change_cipher_spec(ssl_context *ssl);

int ssl_parse_finished(ssl_context *ssl);

int ssl_write_finished(ssl_context *ssl);

int volatile alarmed;

unsigned long hardclock(void);

unsigned long get_timer(struct hr_time *val, int reset);

void set_alarm(int seconds);

void m_sleep(int milliseconds);

int ctr_drbg_init(ctr_drbg_context *ctx,
                  int (*f_entropy)(void *, unsigned char *, size_t ),
                  void *p_entropy, unsigned char const *custom, size_t len);

void ctr_drbg_set_prediction_resistance(ctr_drbg_context *ctx, int resistance);

void ctr_drbg_set_entropy_len(ctr_drbg_context *ctx, size_t len);

void ctr_drbg_set_reseed_interval(ctr_drbg_context *ctx, int interval);

int ctr_drbg_reseed(ctr_drbg_context *ctx, unsigned char const *additional,
                    size_t len);

void ctr_drbg_update(ctr_drbg_context *ctx, unsigned char const *additional,
                     size_t add_len);

int ctr_drbg_random_with_add(void *p_rng, unsigned char *output,
                             size_t output_len,
                             unsigned char const *additional, size_t add_len);

int ctr_drbg_random(void *p_rng, unsigned char *output, size_t output_len);

int ctr_drbg_write_seed_file(ctr_drbg_context *ctx, char const *path);

int ctr_drbg_update_seed_file(ctr_drbg_context *ctx, char const *path);

int ctr_drbg_self_test(int verbose);

int camellia_setkey_enc(camellia_context *ctx, unsigned char const *key,
                        unsigned int keysize);

int camellia_setkey_dec(camellia_context *ctx, unsigned char const *key,
                        unsigned int keysize);

int camellia_crypt_ecb(camellia_context *ctx, int mode,
                       unsigned char const input[16],
                       unsigned char output[16]);

int camellia_crypt_cbc(camellia_context *ctx, int mode, size_t length,
                       unsigned char iv[16], unsigned char const *input,
                       unsigned char *output);

int camellia_crypt_cfb128(camellia_context *ctx, int mode, size_t length,
                          size_t *iv_off, unsigned char iv[16],
                          unsigned char const *input, unsigned char *output);

int camellia_crypt_ctr(camellia_context *ctx, size_t length, size_t *nc_off,
                       unsigned char nonce_counter[16],
                       unsigned char stream_block[16],
                       unsigned char const *input, unsigned char *output);

int camellia_self_test(int verbose);

void arc4_setup(arc4_context *ctx, unsigned char const *key,
                unsigned int keylen);

int arc4_crypt(arc4_context *ctx, size_t length, unsigned char const *input,
               unsigned char *output);

int arc4_self_test(int verbose);

void des_key_set_parity(unsigned char key[8]);

int des_key_check_key_parity(unsigned char const key[8]);

int des_key_check_weak(unsigned char const key[8]);

int des_setkey_enc(des_context *ctx, unsigned char const key[8]);

int des_setkey_dec(des_context *ctx, unsigned char const key[8]);

int des3_set2key_enc(des3_context *ctx, unsigned char const key[16]);

int des3_set2key_dec(des3_context *ctx, unsigned char const key[16]);

int des3_set3key_enc(des3_context *ctx, unsigned char const key[24]);

int des3_set3key_dec(des3_context *ctx, unsigned char const key[24]);

int des_crypt_ecb(des_context *ctx, unsigned char const input[8],
                  unsigned char output[8]);

int des_crypt_cbc(des_context *ctx, int mode, size_t length,
                  unsigned char iv[8], unsigned char const *input,
                  unsigned char *output);

int des3_crypt_ecb(des3_context *ctx, unsigned char const input[8],
                   unsigned char output[8]);

int des3_crypt_cbc(des3_context *ctx, int mode, size_t length,
                   unsigned char iv[8], unsigned char const *input,
                   unsigned char *output);

int des_self_test(int verbose);

/*@ ghost int volatile _state; */
int aes_setkey_enc(aes_context *ctx, unsigned char const *key,
                   unsigned int keysize);

int aes_setkey_dec(aes_context *ctx, unsigned char const *key,
                   unsigned int keysize);

int aes_crypt_ecb(aes_context *ctx, int mode, unsigned char const input[16],
                  unsigned char output[16]);

int aes_crypt_cbc(aes_context *ctx, int mode, size_t length,
                  unsigned char iv[16], unsigned char const *input,
                  unsigned char *output);

void mpi_free(mpi *X);

int mpi_copy(mpi *X, mpi const *Y);

size_t mpi_msb(mpi const *X);

size_t mpi_size(mpi const *X);

int mpi_read_string(mpi *X, int radix, char const *s);

int mpi_read_binary(mpi *X, unsigned char const *buf, size_t buflen);

int mpi_write_binary(mpi const *X, unsigned char *buf, size_t buflen);

int mpi_cmp_abs(mpi const *X, mpi const *Y);

int mpi_cmp_mpi(mpi const *X, mpi const *Y);

int mpi_add_abs(mpi *X, mpi const *A, mpi const *B);

int mpi_sub_abs(mpi *X, mpi const *A, mpi const *B);

int mpi_sub_mpi(mpi *X, mpi const *A, mpi const *B);

int mpi_mul_mpi(mpi *X, mpi const *A, mpi const *B);

int mpi_mod_mpi(mpi *R, mpi const *A, mpi const *B);

int mpi_exp_mod(mpi *X, mpi const *A, mpi const *E, mpi const *N, mpi *_RR);

int mpi_fill_random(mpi *X, size_t size,
                    int (*f_rng)(void *, unsigned char *, size_t ),
                    void *p_rng);

int dhm_make_params(dhm_context *ctx, int x_size, unsigned char *output,
                    size_t *olen,
                    int (*f_rng)(void *, unsigned char *, size_t ),
                    void *p_rng);

void md5_process(md5_context *ctx, unsigned char const data[64]);

void sha1_finish(sha1_context *ctx, unsigned char output[20]);

void sha1_process(sha1_context *ctx, unsigned char const data[64]);

int camellia_crypt_cbc(camellia_context *ctx, int mode, size_t length,
                       unsigned char iv[16], unsigned char const *input,
                       unsigned char *output);

int arc4_crypt(arc4_context *ctx, size_t length, unsigned char const *input,
               unsigned char *output);

int des3_crypt_ecb(des3_context *ctx, unsigned char const input[8],
                   unsigned char output[8]);

/*@ ghost int volatile _rsa_keyfile; */
int x509parse_key(rsa_context *rsa, unsigned char const *key, size_t keylen,
                  unsigned char const *pwd, size_t pwdlen);

/*@ ghost long volatile _hardclock_clock; */
unsigned long hardclock(void);

void sha4(unsigned char const *input, size_t ilen, unsigned char output[64],
          int is384);

/*@ ghost int volatile _ctr_drbg_random_source; */
int ctr_drbg_random(void *p_rng, unsigned char *output, size_t output_len);

/*@ ghost int volatile __fc_recv_status; */
/*@ requires \valid(buf + (0 .. len - 1));
    requires \valid((int *)ctx);
    assigns *(buf + (0 .. len - 1)), \result;
    assigns *(buf + (0 .. len - 1))
      \from *((int *)ctx), len, __fc_recv_status;
    assigns \result \from *((int *)ctx), len, __fc_recv_status;
    
    behavior error:
      assumes __fc_recv_status < 0;
      ensures \result < 0;
      assigns \result;
      assigns \result \from __fc_recv_status;
    
    behavior ok:
      assumes __fc_recv_status ≥ 0;
      ensures 0 ≤ \result ≤ \old(len);
      assigns *(buf + (0 .. len - 1)), \result;
      assigns *(buf + (0 .. len - 1))
        \from *((int *)ctx), len, __fc_recv_status;
      assigns \result \from *((int *)ctx), len, __fc_recv_status;
    
    complete behaviors ok, error;
    disjoint behaviors ok, error;
 */
int fc_recv(void *ctx, unsigned char *buf, size_t len);

void sha4_starts(sha4_context *ctx, int is384);

void sha4_update(sha4_context *ctx, unsigned char const *input, size_t ilen);

void sha4_finish(sha4_context *ctx, unsigned char output[64]);

int sha4_file(char const *path, unsigned char output[64], int is384);

void sha4_hmac_starts(sha4_context *ctx, unsigned char const *key,
                      size_t keylen, int is384);

void sha4_hmac_update(sha4_context *ctx, unsigned char const *input,
                      size_t ilen);

void sha4_hmac_finish(sha4_context *ctx, unsigned char output[64]);

void sha4_hmac_reset(sha4_context *ctx);

void sha4_hmac(unsigned char const *key, size_t keylen,
               unsigned char const *input, size_t ilen,
               unsigned char output[64], int is384);

int sha4_self_test(int verbose);

int padlock_supports(int feature);

int padlock_xcryptecb(aes_context *ctx, int mode,
                      unsigned char const input[16], unsigned char output[16]);

int padlock_xcryptcbc(aes_context *ctx, int mode, size_t length,
                      unsigned char iv[16], unsigned char const *input,
                      unsigned char *output);

static unsigned char FSb[256];
static unsigned long FT0[256];
static unsigned long FT1[256];
static unsigned long FT2[256];
static unsigned long FT3[256];
static unsigned char RSb[256];
static unsigned long RT0[256];
static unsigned long RT1[256];
static unsigned long RT2[256];
static unsigned long RT3[256];
static unsigned long RCON[10];
static int aes_init_done = 0;
static void aes_gen_tables(void)
{
  int i;
  int x;
  int y;
  int z;
  int pow[256];
  int log[256];
  i = 0;
  x = 1;
  while (i < 256) {
    {
      int tmp;
      pow[i] = x;
      log[x] = i;
      if (x & 0x80) tmp = 0x1B; else tmp = 0x00;
      x = (x ^ ((x << 1) ^ tmp)) & 0xFF;
    }
    i ++;
  }
  i = 0;
  x = 1;
  while (i < 10) {
    {
      int tmp_0;
      RCON[i] = (unsigned long)x;
      if (x & 0x80) tmp_0 = 0x1B; else tmp_0 = 0x00;
      x = ((x << 1) ^ tmp_0) & 0xFF;
    }
    i ++;
  }
  FSb[0x00] = (unsigned char)0x63;
  RSb[0x63] = (unsigned char)0x00;
  i = 1;
  while (i < 256) {
    x = pow[255 - log[i]];
    y = x;
    y = ((y << 1) | (y >> 7)) & 0xFF;
    x ^= y;
    y = ((y << 1) | (y >> 7)) & 0xFF;
    x ^= y;
    y = ((y << 1) | (y >> 7)) & 0xFF;
    x ^= y;
    y = ((y << 1) | (y >> 7)) & 0xFF;
    x ^= y ^ 0x63;
    FSb[i] = (unsigned char)x;
    RSb[x] = (unsigned char)i;
    i ++;
  }
  i = 0;
  while (i < 256) {
    {
      int tmp_1;
      int tmp_2;
      int tmp_3;
      int tmp_4;
      int tmp_5;
      x = (int)FSb[i];
      if (x & 0x80) tmp_1 = 0x1B; else tmp_1 = 0x00;
      y = ((x << 1) ^ tmp_1) & 0xFF;
      z = (y ^ x) & 0xFF;
      FT0[i] = (((unsigned long)y ^ ((unsigned long)x << 8)) ^ ((unsigned long)x << 16)) ^ (
               (unsigned long)z << 24);
      FT1[i] = ((FT0[i] << 8) & (unsigned long)0xFFFFFFFF) | (FT0[i] >> 24);
      FT2[i] = ((FT1[i] << 8) & (unsigned long)0xFFFFFFFF) | (FT1[i] >> 24);
      FT3[i] = ((FT2[i] << 8) & (unsigned long)0xFFFFFFFF) | (FT2[i] >> 24);
      x = (int)RSb[i];
      if (x) tmp_2 = pow[(log[0x0E] + log[x]) % 255]; else tmp_2 = 0;
      if (x) tmp_3 = pow[(log[0x09] + log[x]) % 255]; else tmp_3 = 0;
      if (x) tmp_4 = pow[(log[0x0D] + log[x]) % 255]; else tmp_4 = 0;
      if (x) tmp_5 = pow[(log[0x0B] + log[x]) % 255]; else tmp_5 = 0;
      RT0[i] = (((unsigned long)tmp_2 ^ ((unsigned long)tmp_3 << 8)) ^ (
                (unsigned long)tmp_4 << 16)) ^ ((unsigned long)tmp_5 << 24);
      RT1[i] = ((RT0[i] << 8) & (unsigned long)0xFFFFFFFF) | (RT0[i] >> 24);
      RT2[i] = ((RT1[i] << 8) & (unsigned long)0xFFFFFFFF) | (RT1[i] >> 24);
      RT3[i] = ((RT2[i] << 8) & (unsigned long)0xFFFFFFFF) | (RT2[i] >> 24);
    }
    i ++;
  }
  return;
}

/*@ requires \valid(ctx);
    requires \valid_read(key + (0 .. 31));
    requires keysize ≡ 128 ∨ keysize ≡ 192 ∨ keysize ≡ 256;
    ensures \initialized(&\old(ctx)->rk);
    ensures
      \old(ctx)->nr ≡ 10 ∨ \old(ctx)->nr ≡ 12 ∨ \old(ctx)->nr ≡ 14;
    assigns ctx->nr, ctx->rk, _state;
    assigns ctx->nr \from keysize;
    assigns ctx->rk \from _state;
    assigns _state \from _state;
 */
int aes_setkey_enc(aes_context *ctx, unsigned char const *key,
                   unsigned int keysize)
{
  int __retres;
  unsigned int i;
  unsigned long *RK;
  if (aes_init_done == 0) {
    aes_gen_tables();
    aes_init_done = 1;
  }
  switch (keysize) {
    case (unsigned int)128: ctx->nr = 10;
    break;
    case (unsigned int)192: ctx->nr = 12;
    break;
    case (unsigned int)256: ctx->nr = 14;
    break;
    default: __retres = -0x0020;
    goto return_label;
  }
  RK = (unsigned long *)((long)16 + ((long)(ctx->buf) & (long)(~ 15)));
  ctx->rk = RK;
  i = (unsigned int)0;
  while (i < keysize >> 5) {
    *(RK + i) = (((unsigned long)*(key + (i << 2)) | ((unsigned long)*(
                                                      key + ((i << 2) + (unsigned int)1)) << 8)) | (
                 (unsigned long)*(key + ((i << 2) + (unsigned int)2)) << 16)) | (
                (unsigned long)*(key + ((i << 2) + (unsigned int)3)) << 24);
    i ++;
  }
  switch (ctx->nr) {
    case 10: i = (unsigned int)0;
    while (i < (unsigned int)10) {
      *(RK + 4) = ((((*(RK + 0) ^ RCON[i]) ^ (unsigned long)FSb[(*(RK + 3) >> 8) & (unsigned long)0xFF]) ^ (
                    (unsigned long)FSb[(*(RK + 3) >> 16) & (unsigned long)0xFF] << 8)) ^ (
                   (unsigned long)FSb[(*(RK + 3) >> 24) & (unsigned long)0xFF] << 16)) ^ (
                  (unsigned long)FSb[*(RK + 3) & (unsigned long)0xFF] << 24);
      *(RK + 5) = *(RK + 1) ^ *(RK + 4);
      *(RK + 6) = *(RK + 2) ^ *(RK + 5);
      *(RK + 7) = *(RK + 3) ^ *(RK + 6);
      i ++;
      RK += 4;
    }
    break;
    case 12: i = (unsigned int)0;
    while (i < (unsigned int)8) {
      *(RK + 6) = ((((*(RK + 0) ^ RCON[i]) ^ (unsigned long)FSb[(*(RK + 5) >> 8) & (unsigned long)0xFF]) ^ (
                    (unsigned long)FSb[(*(RK + 5) >> 16) & (unsigned long)0xFF] << 8)) ^ (
                   (unsigned long)FSb[(*(RK + 5) >> 24) & (unsigned long)0xFF] << 16)) ^ (
                  (unsigned long)FSb[*(RK + 5) & (unsigned long)0xFF] << 24);
      *(RK + 7) = *(RK + 1) ^ *(RK + 6);
      *(RK + 8) = *(RK + 2) ^ *(RK + 7);
      *(RK + 9) = *(RK + 3) ^ *(RK + 8);
      *(RK + 10) = *(RK + 4) ^ *(RK + 9);
      *(RK + 11) = *(RK + 5) ^ *(RK + 10);
      i ++;
      RK += 6;
    }
    break;
    case 14: i = (unsigned int)0;
    while (i < (unsigned int)7) {
      *(RK + 8) = ((((*(RK + 0) ^ RCON[i]) ^ (unsigned long)FSb[(*(RK + 7) >> 8) & (unsigned long)0xFF]) ^ (
                    (unsigned long)FSb[(*(RK + 7) >> 16) & (unsigned long)0xFF] << 8)) ^ (
                   (unsigned long)FSb[(*(RK + 7) >> 24) & (unsigned long)0xFF] << 16)) ^ (
                  (unsigned long)FSb[*(RK + 7) & (unsigned long)0xFF] << 24);
      *(RK + 9) = *(RK + 1) ^ *(RK + 8);
      *(RK + 10) = *(RK + 2) ^ *(RK + 9);
      *(RK + 11) = *(RK + 3) ^ *(RK + 10);
      *(RK + 12) = (((*(RK + 4) ^ (unsigned long)FSb[*(RK + 11) & (unsigned long)0xFF]) ^ (
                     (unsigned long)FSb[(*(RK + 11) >> 8) & (unsigned long)0xFF] << 8)) ^ (
                    (unsigned long)FSb[(*(RK + 11) >> 16) & (unsigned long)0xFF] << 16)) ^ (
                   (unsigned long)FSb[(*(RK + 11) >> 24) & (unsigned long)0xFF] << 24);
      *(RK + 13) = *(RK + 5) ^ *(RK + 12);
      *(RK + 14) = *(RK + 6) ^ *(RK + 13);
      *(RK + 15) = *(RK + 7) ^ *(RK + 14);
      i ++;
      RK += 8;
    }
    break;
    default: break;
  }
  __retres = 0;
  return_label: return __retres;
}

/*@ requires \valid(ctx);
    requires \valid_read(key + (0 .. 31));
    requires keysize ≡ 128 ∨ keysize ≡ 192 ∨ keysize ≡ 256;
    ensures \initialized(&\old(ctx)->rk);
    ensures
      \old(ctx)->nr ≡ 10 ∨ \old(ctx)->nr ≡ 12 ∨ \old(ctx)->nr ≡ 14;
    assigns ctx->nr, ctx->rk, _state;
    assigns ctx->nr \from keysize;
    assigns ctx->rk \from _state;
    assigns _state \from _state;
 */
int aes_setkey_dec(aes_context *ctx, unsigned char const *key,
                   unsigned int keysize)
{
  int __retres;
  int i;
  int j;
  aes_context cty;
  unsigned long *RK;
  unsigned long *SK;
  int ret;
  unsigned long *tmp;
  unsigned long *tmp_0;
  unsigned long *tmp_1;
  unsigned long *tmp_2;
  unsigned long *tmp_3;
  unsigned long *tmp_4;
  unsigned long *tmp_5;
  unsigned long *tmp_6;
  unsigned long *tmp_8;
  unsigned long *tmp_9;
  unsigned long *tmp_10;
  unsigned long *tmp_11;
  unsigned long *tmp_12;
  unsigned long *tmp_13;
  unsigned long *tmp_14;
  unsigned long *tmp_15;
  switch (keysize) {
    case (unsigned int)128: ctx->nr = 10;
    break;
    case (unsigned int)192: ctx->nr = 12;
    break;
    case (unsigned int)256: ctx->nr = 14;
    break;
    default: __retres = -0x0020;
    goto return_label;
  }
  RK = (unsigned long *)((long)16 + ((long)(ctx->buf) & (long)(~ 15)));
  ctx->rk = RK;
  ret = aes_setkey_enc(& cty,key,keysize);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  SK = cty.rk + cty.nr * 4;
  tmp = RK;
  RK ++;
  tmp_0 = SK;
  SK ++;
  *tmp = *tmp_0;
  tmp_1 = RK;
  RK ++;
  tmp_2 = SK;
  SK ++;
  *tmp_1 = *tmp_2;
  tmp_3 = RK;
  RK ++;
  tmp_4 = SK;
  SK ++;
  *tmp_3 = *tmp_4;
  tmp_5 = RK;
  RK ++;
  tmp_6 = SK;
  SK ++;
  *tmp_5 = *tmp_6;
  i = ctx->nr - 1;
  SK -= 8;
  while (i > 0) {
    j = 0;
    while (j < 4) {
      {
        unsigned long *tmp_7;
        tmp_7 = RK;
        RK ++;
        *tmp_7 = ((RT0[FSb[*SK & (unsigned long)0xFF]] ^ RT1[FSb[(*SK >> 8) & (unsigned long)0xFF]]) ^ RT2[FSb[
                  (*SK >> 16) & (unsigned long)0xFF]]) ^ RT3[FSb[(*SK >> 24) & (unsigned long)0xFF]];
      }
      j ++;
      SK ++;
    }
    i --;
    SK -= 8;
  }
  tmp_8 = RK;
  RK ++;
  tmp_9 = SK;
  SK ++;
  *tmp_8 = *tmp_9;
  tmp_10 = RK;
  RK ++;
  tmp_11 = SK;
  SK ++;
  *tmp_10 = *tmp_11;
  tmp_12 = RK;
  RK ++;
  tmp_13 = SK;
  SK ++;
  *tmp_12 = *tmp_13;
  tmp_14 = RK;
  RK ++;
  tmp_15 = SK;
  SK ++;
  *tmp_14 = *tmp_15;
  memset((void *)(& cty),0,sizeof(aes_context));
  __retres = 0;
  return_label: return __retres;
}

/*@ requires \valid(ctx);
    requires \valid_read(input + (0 .. 15));
    requires \valid(output + (0 .. 15));
    ensures \initialized(\old(output) + (0 .. 15));
    assigns \result, *(output + (0 .. 15));
    assigns \result \from _state;
    assigns *(output + (0 .. 15)) \from _state;
 */
int aes_crypt_ecb(aes_context *ctx, int mode, unsigned char const input[16],
                  unsigned char output[16])
{
  int __retres;
  int i;
  unsigned long *RK;
  unsigned long X0;
  unsigned long X1;
  unsigned long X2;
  unsigned long X3;
  unsigned long Y0;
  unsigned long Y1;
  unsigned long Y2;
  unsigned long Y3;
  int tmp_0;
  unsigned long *tmp_1;
  unsigned long *tmp_2;
  unsigned long *tmp_3;
  unsigned long *tmp_4;
  tmp_0 = padlock_supports(0x00C0);
  if (tmp_0) {
    int tmp;
    tmp = padlock_xcryptecb(ctx,mode,input,output);
    if (tmp == 0) {
      __retres = 0;
      goto return_label;
    }
  }
  RK = ctx->rk;
  X0 = (((unsigned long)*(input + 0) | ((unsigned long)*(input + (0 + 1)) << 8)) | (
        (unsigned long)*(input + (0 + 2)) << 16)) | ((unsigned long)*(
                                                     input + (0 + 3)) << 24);
  tmp_1 = RK;
  RK ++;
  X0 ^= *tmp_1;
  X1 = (((unsigned long)*(input + 4) | ((unsigned long)*(input + (4 + 1)) << 8)) | (
        (unsigned long)*(input + (4 + 2)) << 16)) | ((unsigned long)*(
                                                     input + (4 + 3)) << 24);
  tmp_2 = RK;
  RK ++;
  X1 ^= *tmp_2;
  X2 = (((unsigned long)*(input + 8) | ((unsigned long)*(input + (8 + 1)) << 8)) | (
        (unsigned long)*(input + (8 + 2)) << 16)) | ((unsigned long)*(
                                                     input + (8 + 3)) << 24);
  tmp_3 = RK;
  RK ++;
  X2 ^= *tmp_3;
  X3 = (((unsigned long)*(input + 12) | ((unsigned long)*(input + (12 + 1)) << 8)) | (
        (unsigned long)*(input + (12 + 2)) << 16)) | ((unsigned long)*(
                                                      input + (12 + 3)) << 24);
  tmp_4 = RK;
  RK ++;
  X3 ^= *tmp_4;
  if (mode == 0) {
    unsigned long *tmp_17;
    unsigned long *tmp_18;
    unsigned long *tmp_19;
    unsigned long *tmp_20;
    i = (ctx->nr >> 1) - 1;
    while (i > 0) {
      {
        unsigned long *tmp_5;
        unsigned long *tmp_6;
        unsigned long *tmp_7;
        unsigned long *tmp_8;
        tmp_5 = RK;
        RK ++;
        Y0 = (((*tmp_5 ^ RT0[X0 & (unsigned long)0xFF]) ^ RT1[(X3 >> 8) & (unsigned long)0xFF]) ^ RT2[
              (X2 >> 16) & (unsigned long)0xFF]) ^ RT3[(X1 >> 24) & (unsigned long)0xFF];
        tmp_6 = RK;
        RK ++;
        Y1 = (((*tmp_6 ^ RT0[X1 & (unsigned long)0xFF]) ^ RT1[(X0 >> 8) & (unsigned long)0xFF]) ^ RT2[
              (X3 >> 16) & (unsigned long)0xFF]) ^ RT3[(X2 >> 24) & (unsigned long)0xFF];
        tmp_7 = RK;
        RK ++;
        Y2 = (((*tmp_7 ^ RT0[X2 & (unsigned long)0xFF]) ^ RT1[(X1 >> 8) & (unsigned long)0xFF]) ^ RT2[
              (X0 >> 16) & (unsigned long)0xFF]) ^ RT3[(X3 >> 24) & (unsigned long)0xFF];
        tmp_8 = RK;
        RK ++;
        Y3 = (((*tmp_8 ^ RT0[X3 & (unsigned long)0xFF]) ^ RT1[(X2 >> 8) & (unsigned long)0xFF]) ^ RT2[
              (X1 >> 16) & (unsigned long)0xFF]) ^ RT3[(X0 >> 24) & (unsigned long)0xFF];
      }
      {
        unsigned long *tmp_9;
        unsigned long *tmp_10;
        unsigned long *tmp_11;
        unsigned long *tmp_12;
        tmp_9 = RK;
        RK ++;
        X0 = (((*tmp_9 ^ RT0[Y0 & (unsigned long)0xFF]) ^ RT1[(Y3 >> 8) & (unsigned long)0xFF]) ^ RT2[
              (Y2 >> 16) & (unsigned long)0xFF]) ^ RT3[(Y1 >> 24) & (unsigned long)0xFF];
        tmp_10 = RK;
        RK ++;
        X1 = (((*tmp_10 ^ RT0[Y1 & (unsigned long)0xFF]) ^ RT1[(Y0 >> 8) & (unsigned long)0xFF]) ^ RT2[
              (Y3 >> 16) & (unsigned long)0xFF]) ^ RT3[(Y2 >> 24) & (unsigned long)0xFF];
        tmp_11 = RK;
        RK ++;
        X2 = (((*tmp_11 ^ RT0[Y2 & (unsigned long)0xFF]) ^ RT1[(Y1 >> 8) & (unsigned long)0xFF]) ^ RT2[
              (Y0 >> 16) & (unsigned long)0xFF]) ^ RT3[(Y3 >> 24) & (unsigned long)0xFF];
        tmp_12 = RK;
        RK ++;
        X3 = (((*tmp_12 ^ RT0[Y3 & (unsigned long)0xFF]) ^ RT1[(Y2 >> 8) & (unsigned long)0xFF]) ^ RT2[
              (Y1 >> 16) & (unsigned long)0xFF]) ^ RT3[(Y0 >> 24) & (unsigned long)0xFF];
      }
      i --;
    }
    {
      unsigned long *tmp_13;
      unsigned long *tmp_14;
      unsigned long *tmp_15;
      unsigned long *tmp_16;
      tmp_13 = RK;
      RK ++;
      Y0 = (((*tmp_13 ^ RT0[X0 & (unsigned long)0xFF]) ^ RT1[(X3 >> 8) & (unsigned long)0xFF]) ^ RT2[
            (X2 >> 16) & (unsigned long)0xFF]) ^ RT3[(X1 >> 24) & (unsigned long)0xFF];
      tmp_14 = RK;
      RK ++;
      Y1 = (((*tmp_14 ^ RT0[X1 & (unsigned long)0xFF]) ^ RT1[(X0 >> 8) & (unsigned long)0xFF]) ^ RT2[
            (X3 >> 16) & (unsigned long)0xFF]) ^ RT3[(X2 >> 24) & (unsigned long)0xFF];
      tmp_15 = RK;
      RK ++;
      Y2 = (((*tmp_15 ^ RT0[X2 & (unsigned long)0xFF]) ^ RT1[(X1 >> 8) & (unsigned long)0xFF]) ^ RT2[
            (X0 >> 16) & (unsigned long)0xFF]) ^ RT3[(X3 >> 24) & (unsigned long)0xFF];
      tmp_16 = RK;
      RK ++;
      Y3 = (((*tmp_16 ^ RT0[X3 & (unsigned long)0xFF]) ^ RT1[(X2 >> 8) & (unsigned long)0xFF]) ^ RT2[
            (X1 >> 16) & (unsigned long)0xFF]) ^ RT3[(X0 >> 24) & (unsigned long)0xFF];
    }
    tmp_17 = RK;
    RK ++;
    X0 = (((*tmp_17 ^ (unsigned long)RSb[Y0 & (unsigned long)0xFF]) ^ (
           (unsigned long)RSb[(Y3 >> 8) & (unsigned long)0xFF] << 8)) ^ (
          (unsigned long)RSb[(Y2 >> 16) & (unsigned long)0xFF] << 16)) ^ (
         (unsigned long)RSb[(Y1 >> 24) & (unsigned long)0xFF] << 24);
    tmp_18 = RK;
    RK ++;
    X1 = (((*tmp_18 ^ (unsigned long)RSb[Y1 & (unsigned long)0xFF]) ^ (
           (unsigned long)RSb[(Y0 >> 8) & (unsigned long)0xFF] << 8)) ^ (
          (unsigned long)RSb[(Y3 >> 16) & (unsigned long)0xFF] << 16)) ^ (
         (unsigned long)RSb[(Y2 >> 24) & (unsigned long)0xFF] << 24);
    tmp_19 = RK;
    RK ++;
    X2 = (((*tmp_19 ^ (unsigned long)RSb[Y2 & (unsigned long)0xFF]) ^ (
           (unsigned long)RSb[(Y1 >> 8) & (unsigned long)0xFF] << 8)) ^ (
          (unsigned long)RSb[(Y0 >> 16) & (unsigned long)0xFF] << 16)) ^ (
         (unsigned long)RSb[(Y3 >> 24) & (unsigned long)0xFF] << 24);
    tmp_20 = RK;
    RK ++;
    X3 = (((*tmp_20 ^ (unsigned long)RSb[Y3 & (unsigned long)0xFF]) ^ (
           (unsigned long)RSb[(Y2 >> 8) & (unsigned long)0xFF] << 8)) ^ (
          (unsigned long)RSb[(Y1 >> 16) & (unsigned long)0xFF] << 16)) ^ (
         (unsigned long)RSb[(Y0 >> 24) & (unsigned long)0xFF] << 24);
  }
  else {
    unsigned long *tmp_33;
    unsigned long *tmp_34;
    unsigned long *tmp_35;
    unsigned long *tmp_36;
    i = (ctx->nr >> 1) - 1;
    while (i > 0) {
      {
        unsigned long *tmp_21;
        unsigned long *tmp_22;
        unsigned long *tmp_23;
        unsigned long *tmp_24;
        tmp_21 = RK;
        RK ++;
        Y0 = (((*tmp_21 ^ FT0[X0 & (unsigned long)0xFF]) ^ FT1[(X1 >> 8) & (unsigned long)0xFF]) ^ FT2[
              (X2 >> 16) & (unsigned long)0xFF]) ^ FT3[(X3 >> 24) & (unsigned long)0xFF];
        tmp_22 = RK;
        RK ++;
        Y1 = (((*tmp_22 ^ FT0[X1 & (unsigned long)0xFF]) ^ FT1[(X2 >> 8) & (unsigned long)0xFF]) ^ FT2[
              (X3 >> 16) & (unsigned long)0xFF]) ^ FT3[(X0 >> 24) & (unsigned long)0xFF];
        tmp_23 = RK;
        RK ++;
        Y2 = (((*tmp_23 ^ FT0[X2 & (unsigned long)0xFF]) ^ FT1[(X3 >> 8) & (unsigned long)0xFF]) ^ FT2[
              (X0 >> 16) & (unsigned long)0xFF]) ^ FT3[(X1 >> 24) & (unsigned long)0xFF];
        tmp_24 = RK;
        RK ++;
        Y3 = (((*tmp_24 ^ FT0[X3 & (unsigned long)0xFF]) ^ FT1[(X0 >> 8) & (unsigned long)0xFF]) ^ FT2[
              (X1 >> 16) & (unsigned long)0xFF]) ^ FT3[(X2 >> 24) & (unsigned long)0xFF];
      }
      {
        unsigned long *tmp_25;
        unsigned long *tmp_26;
        unsigned long *tmp_27;
        unsigned long *tmp_28;
        tmp_25 = RK;
        RK ++;
        X0 = (((*tmp_25 ^ FT0[Y0 & (unsigned long)0xFF]) ^ FT1[(Y1 >> 8) & (unsigned long)0xFF]) ^ FT2[
              (Y2 >> 16) & (unsigned long)0xFF]) ^ FT3[(Y3 >> 24) & (unsigned long)0xFF];
        tmp_26 = RK;
        RK ++;
        X1 = (((*tmp_26 ^ FT0[Y1 & (unsigned long)0xFF]) ^ FT1[(Y2 >> 8) & (unsigned long)0xFF]) ^ FT2[
              (Y3 >> 16) & (unsigned long)0xFF]) ^ FT3[(Y0 >> 24) & (unsigned long)0xFF];
        tmp_27 = RK;
        RK ++;
        X2 = (((*tmp_27 ^ FT0[Y2 & (unsigned long)0xFF]) ^ FT1[(Y3 >> 8) & (unsigned long)0xFF]) ^ FT2[
              (Y0 >> 16) & (unsigned long)0xFF]) ^ FT3[(Y1 >> 24) & (unsigned long)0xFF];
        tmp_28 = RK;
        RK ++;
        X3 = (((*tmp_28 ^ FT0[Y3 & (unsigned long)0xFF]) ^ FT1[(Y0 >> 8) & (unsigned long)0xFF]) ^ FT2[
              (Y1 >> 16) & (unsigned long)0xFF]) ^ FT3[(Y2 >> 24) & (unsigned long)0xFF];
      }
      i --;
    }
    {
      unsigned long *tmp_29;
      unsigned long *tmp_30;
      unsigned long *tmp_31;
      unsigned long *tmp_32;
      tmp_29 = RK;
      RK ++;
      Y0 = (((*tmp_29 ^ FT0[X0 & (unsigned long)0xFF]) ^ FT1[(X1 >> 8) & (unsigned long)0xFF]) ^ FT2[
            (X2 >> 16) & (unsigned long)0xFF]) ^ FT3[(X3 >> 24) & (unsigned long)0xFF];
      tmp_30 = RK;
      RK ++;
      Y1 = (((*tmp_30 ^ FT0[X1 & (unsigned long)0xFF]) ^ FT1[(X2 >> 8) & (unsigned long)0xFF]) ^ FT2[
            (X3 >> 16) & (unsigned long)0xFF]) ^ FT3[(X0 >> 24) & (unsigned long)0xFF];
      tmp_31 = RK;
      RK ++;
      Y2 = (((*tmp_31 ^ FT0[X2 & (unsigned long)0xFF]) ^ FT1[(X3 >> 8) & (unsigned long)0xFF]) ^ FT2[
            (X0 >> 16) & (unsigned long)0xFF]) ^ FT3[(X1 >> 24) & (unsigned long)0xFF];
      tmp_32 = RK;
      RK ++;
      Y3 = (((*tmp_32 ^ FT0[X3 & (unsigned long)0xFF]) ^ FT1[(X0 >> 8) & (unsigned long)0xFF]) ^ FT2[
            (X1 >> 16) & (unsigned long)0xFF]) ^ FT3[(X2 >> 24) & (unsigned long)0xFF];
    }
    tmp_33 = RK;
    RK ++;
    X0 = (((*tmp_33 ^ (unsigned long)FSb[Y0 & (unsigned long)0xFF]) ^ (
           (unsigned long)FSb[(Y1 >> 8) & (unsigned long)0xFF] << 8)) ^ (
          (unsigned long)FSb[(Y2 >> 16) & (unsigned long)0xFF] << 16)) ^ (
         (unsigned long)FSb[(Y3 >> 24) & (unsigned long)0xFF] << 24);
    tmp_34 = RK;
    RK ++;
    X1 = (((*tmp_34 ^ (unsigned long)FSb[Y1 & (unsigned long)0xFF]) ^ (
           (unsigned long)FSb[(Y2 >> 8) & (unsigned long)0xFF] << 8)) ^ (
          (unsigned long)FSb[(Y3 >> 16) & (unsigned long)0xFF] << 16)) ^ (
         (unsigned long)FSb[(Y0 >> 24) & (unsigned long)0xFF] << 24);
    tmp_35 = RK;
    RK ++;
    X2 = (((*tmp_35 ^ (unsigned long)FSb[Y2 & (unsigned long)0xFF]) ^ (
           (unsigned long)FSb[(Y3 >> 8) & (unsigned long)0xFF] << 8)) ^ (
          (unsigned long)FSb[(Y0 >> 16) & (unsigned long)0xFF] << 16)) ^ (
         (unsigned long)FSb[(Y1 >> 24) & (unsigned long)0xFF] << 24);
    tmp_36 = RK;
    RK ++;
    X3 = (((*tmp_36 ^ (unsigned long)FSb[Y3 & (unsigned long)0xFF]) ^ (
           (unsigned long)FSb[(Y0 >> 8) & (unsigned long)0xFF] << 8)) ^ (
          (unsigned long)FSb[(Y1 >> 16) & (unsigned long)0xFF] << 16)) ^ (
         (unsigned long)FSb[(Y2 >> 24) & (unsigned long)0xFF] << 24);
  }
  *(output + 0) = (unsigned char)X0;
  *(output + (0 + 1)) = (unsigned char)(X0 >> 8);
  *(output + (0 + 2)) = (unsigned char)(X0 >> 16);
  *(output + (0 + 3)) = (unsigned char)(X0 >> 24);
  *(output + 4) = (unsigned char)X1;
  *(output + (4 + 1)) = (unsigned char)(X1 >> 8);
  *(output + (4 + 2)) = (unsigned char)(X1 >> 16);
  *(output + (4 + 3)) = (unsigned char)(X1 >> 24);
  *(output + 8) = (unsigned char)X2;
  *(output + (8 + 1)) = (unsigned char)(X2 >> 8);
  *(output + (8 + 2)) = (unsigned char)(X2 >> 16);
  *(output + (8 + 3)) = (unsigned char)(X2 >> 24);
  *(output + 12) = (unsigned char)X3;
  *(output + (12 + 1)) = (unsigned char)(X3 >> 8);
  *(output + (12 + 2)) = (unsigned char)(X3 >> 16);
  *(output + (12 + 3)) = (unsigned char)(X3 >> 24);
  __retres = 0;
  return_label: return __retres;
}

/*@ requires length % 16 ≡ 0;
    requires \valid(iv + (0 .. 15));
    requires \valid(output + (0 .. length - 1));
    requires \valid_read(input + (0 .. length - 1));
    assigns *(iv + (0 .. 15)), *(output + (0 .. length - 1)), \result;
    assigns *(iv + (0 .. 15)) \from *(input + (0 .. length - 1));
    assigns *(output + (0 .. length - 1))
      \from *(input + (0 .. length - 1)), *(iv + (0 .. 15));
    assigns \result \from _state;
 */
int aes_crypt_cbc(aes_context *ctx, int mode, size_t length,
                  unsigned char iv[16], unsigned char const *input,
                  unsigned char *output)
{
  int __retres;
  int i;
  unsigned char temp[16];
  int tmp_0;
  if (length % (unsigned int)16) {
    __retres = -0x0022;
    goto return_label;
  }
  tmp_0 = padlock_supports(0x00C0);
  if (tmp_0) {
    int tmp;
    tmp = padlock_xcryptcbc(ctx,mode,length,iv,input,output);
    if (tmp == 0) {
      __retres = 0;
      goto return_label;
    }
  }
  if (mode == 0) 
    while (length > (size_t)0) {
      memcpy((void *)(temp),(void const *)input,(size_t)16);
      aes_crypt_ecb(ctx,mode,input,output);
      i = 0;
      while (i < 16) {
        *(output + i) = (unsigned char)((int)*(output + i) ^ (int)*(iv + i));
        i ++;
      }
      memcpy((void *)iv,(void const *)(temp),(size_t)16);
      input += 16;
      output += 16;
      length -= (size_t)16;
    }
  else 
    while (length > (size_t)0) {
      i = 0;
      while (i < 16) {
        *(output + i) = (unsigned char)((int)*(input + i) ^ (int)*(iv + i));
        i ++;
      }
      aes_crypt_ecb(ctx,mode,(unsigned char const *)output,output);
      memcpy((void *)iv,(void const *)output,(size_t)16);
      input += 16;
      output += 16;
      length -= (size_t)16;
    }
  __retres = 0;
  return_label: return __retres;
}

int aes_crypt_cfb128(aes_context *ctx, int mode, size_t length,
                     size_t *iv_off, unsigned char iv[16],
                     unsigned char const *input, unsigned char *output)
{
  int __retres;
  int c;
  size_t n = *iv_off;
  if (mode == 0) 
    while (1) {
      size_t tmp_1;
      tmp_1 = length;
      length --;
      ;
      if (! tmp_1) break;
      {
        unsigned char const *tmp;
        unsigned char *tmp_0;
        if (n == (size_t)0) aes_crypt_ecb(ctx,1,(unsigned char const *)iv,iv);
        tmp = input;
        input ++;
        c = (int)*tmp;
        tmp_0 = output;
        output ++;
        *tmp_0 = (unsigned char)(c ^ (int)*(iv + n));
        *(iv + n) = (unsigned char)c;
        n = (n + (size_t)1) & (unsigned int)0x0F;
      }
    }
  else 
    while (1) {
      size_t tmp_5;
      tmp_5 = length;
      length --;
      ;
      if (! tmp_5) break;
      {
        unsigned char *tmp_2;
        unsigned char const *tmp_4;
        unsigned char tmp_3;
        if (n == (size_t)0) aes_crypt_ecb(ctx,1,(unsigned char const *)iv,iv);
        tmp_2 = output;
        output ++;
        tmp_4 = input;
        input ++;
        tmp_3 = (unsigned char)((int)*(iv + n) ^ (int)*tmp_4);
        *tmp_2 = tmp_3;
        *(iv + n) = tmp_3;
        n = (n + (size_t)1) & (unsigned int)0x0F;
      }
    }
  *iv_off = n;
  __retres = 0;
  return __retres;
}

int aes_crypt_ctr(aes_context *ctx, size_t length, size_t *nc_off,
                  unsigned char nonce_counter[16],
                  unsigned char stream_block[16], unsigned char const *input,
                  unsigned char *output)
{
  int __retres;
  int c;
  int i;
  int cb;
  size_t n = *nc_off;
  while (1) {
    size_t tmp_2;
    tmp_2 = length;
    length --;
    ;
    if (! tmp_2) break;
    {
      unsigned char const *tmp_0;
      unsigned char *tmp_1;
      if (n == (size_t)0) {
        aes_crypt_ecb(ctx,1,(unsigned char const *)nonce_counter,
                      stream_block);
        i = 15;
        while (1) {
          int tmp;
          *(nonce_counter + i) = (unsigned char)((int)*(nonce_counter + i) + 1);
          cb = (int)*(nonce_counter + i) == 0;
          tmp = i;
          i --;
          ;
          if (tmp) {
            if (! cb) break;
          }
          else break;
        }
      }
      tmp_0 = input;
      input ++;
      c = (int)*tmp_0;
      tmp_1 = output;
      output ++;
      *tmp_1 = (unsigned char)(c ^ (int)*(stream_block + n));
      n = (n + (size_t)1) & (unsigned int)0x0F;
    }
  }
  *nc_off = n;
  __retres = 0;
  return __retres;
}

static unsigned char const aes_test_ecb_dec[3][16] =
  {{(unsigned char)0x44,
    (unsigned char)0x41,
    (unsigned char)0x6A,
    (unsigned char)0xC2,
    (unsigned char)0xD1,
    (unsigned char)0xF5,
    (unsigned char)0x3C,
    (unsigned char)0x58,
    (unsigned char)0x33,
    (unsigned char)0x03,
    (unsigned char)0x91,
    (unsigned char)0x7E,
    (unsigned char)0x6B,
    (unsigned char)0xE9,
    (unsigned char)0xEB,
    (unsigned char)0xE0},
   {(unsigned char)0x48,
    (unsigned char)0xE3,
    (unsigned char)0x1E,
    (unsigned char)0x9E,
    (unsigned char)0x25,
    (unsigned char)0x67,
    (unsigned char)0x18,
    (unsigned char)0xF2,
    (unsigned char)0x92,
    (unsigned char)0x29,
    (unsigned char)0x31,
    (unsigned char)0x9C,
    (unsigned char)0x19,
    (unsigned char)0xF1,
    (unsigned char)0x5B,
    (unsigned char)0xA4},
   {(unsigned char)0x05,
    (unsigned char)0x8C,
    (unsigned char)0xCF,
    (unsigned char)0xFD,
    (unsigned char)0xBB,
    (unsigned char)0xCB,
    (unsigned char)0x38,
    (unsigned char)0x2D,
    (unsigned char)0x1F,
    (unsigned char)0x6F,
    (unsigned char)0x56,
    (unsigned char)0x58,
    (unsigned char)0x5D,
    (unsigned char)0x8A,
    (unsigned char)0x4A,
    (unsigned char)0xDE}};
static unsigned char const aes_test_ecb_enc[3][16] =
  {{(unsigned char)0xC3,
    (unsigned char)0x4C,
    (unsigned char)0x05,
    (unsigned char)0x2C,
    (unsigned char)0xC0,
    (unsigned char)0xDA,
    (unsigned char)0x8D,
    (unsigned char)0x73,
    (unsigned char)0x45,
    (unsigned char)0x1A,
    (unsigned char)0xFE,
    (unsigned char)0x5F,
    (unsigned char)0x03,
    (unsigned char)0xBE,
    (unsigned char)0x29,
    (unsigned char)0x7F},
   {(unsigned char)0xF3,
    (unsigned char)0xF6,
    (unsigned char)0x75,
    (unsigned char)0x2A,
    (unsigned char)0xE8,
    (unsigned char)0xD7,
    (unsigned char)0x83,
    (unsigned char)0x11,
    (unsigned char)0x38,
    (unsigned char)0xF0,
    (unsigned char)0x41,
    (unsigned char)0x56,
    (unsigned char)0x06,
    (unsigned char)0x31,
    (unsigned char)0xB1,
    (unsigned char)0x14},
   {(unsigned char)0x8B,
    (unsigned char)0x79,
    (unsigned char)0xEE,
    (unsigned char)0xCC,
    (unsigned char)0x93,
    (unsigned char)0xA0,
    (unsigned char)0xEE,
    (unsigned char)0x5D,
    (unsigned char)0xFF,
    (unsigned char)0x30,
    (unsigned char)0xB4,
    (unsigned char)0xEA,
    (unsigned char)0x21,
    (unsigned char)0x63,
    (unsigned char)0x6D,
    (unsigned char)0xA4}};
static unsigned char const aes_test_cbc_dec[3][16] =
  {{(unsigned char)0xFA,
    (unsigned char)0xCA,
    (unsigned char)0x37,
    (unsigned char)0xE0,
    (unsigned char)0xB0,
    (unsigned char)0xC8,
    (unsigned char)0x53,
    (unsigned char)0x73,
    (unsigned char)0xDF,
    (unsigned char)0x70,
    (unsigned char)0x6E,
    (unsigned char)0x73,
    (unsigned char)0xF7,
    (unsigned char)0xC9,
    (unsigned char)0xAF,
    (unsigned char)0x86},
   {(unsigned char)0x5D,
    (unsigned char)0xF6,
    (unsigned char)0x78,
    (unsigned char)0xDD,
    (unsigned char)0x17,
    (unsigned char)0xBA,
    (unsigned char)0x4E,
    (unsigned char)0x75,
    (unsigned char)0xB6,
    (unsigned char)0x17,
    (unsigned char)0x68,
    (unsigned char)0xC6,
    (unsigned char)0xAD,
    (unsigned char)0xEF,
    (unsigned char)0x7C,
    (unsigned char)0x7B},
   {(unsigned char)0x48,
    (unsigned char)0x04,
    (unsigned char)0xE1,
    (unsigned char)0x81,
    (unsigned char)0x8F,
    (unsigned char)0xE6,
    (unsigned char)0x29,
    (unsigned char)0x75,
    (unsigned char)0x19,
    (unsigned char)0xA3,
    (unsigned char)0xE8,
    (unsigned char)0x8C,
    (unsigned char)0x57,
    (unsigned char)0x31,
    (unsigned char)0x04,
    (unsigned char)0x13}};
static unsigned char const aes_test_cbc_enc[3][16] =
  {{(unsigned char)0x8A,
    (unsigned char)0x05,
    (unsigned char)0xFC,
    (unsigned char)0x5E,
    (unsigned char)0x09,
    (unsigned char)0x5A,
    (unsigned char)0xF4,
    (unsigned char)0x84,
    (unsigned char)0x8A,
    (unsigned char)0x08,
    (unsigned char)0xD3,
    (unsigned char)0x28,
    (unsigned char)0xD3,
    (unsigned char)0x68,
    (unsigned char)0x8E,
    (unsigned char)0x3D},
   {(unsigned char)0x7B,
    (unsigned char)0xD9,
    (unsigned char)0x66,
    (unsigned char)0xD5,
    (unsigned char)0x3A,
    (unsigned char)0xD8,
    (unsigned char)0xC1,
    (unsigned char)0xBB,
    (unsigned char)0x85,
    (unsigned char)0xD2,
    (unsigned char)0xAD,
    (unsigned char)0xFA,
    (unsigned char)0xE8,
    (unsigned char)0x7B,
    (unsigned char)0xB1,
    (unsigned char)0x04},
   {(unsigned char)0xFE,
    (unsigned char)0x3C,
    (unsigned char)0x53,
    (unsigned char)0x65,
    (unsigned char)0x3E,
    (unsigned char)0x2F,
    (unsigned char)0x45,
    (unsigned char)0xB5,
    (unsigned char)0x6F,
    (unsigned char)0xCD,
    (unsigned char)0x88,
    (unsigned char)0xB2,
    (unsigned char)0xCC,
    (unsigned char)0x89,
    (unsigned char)0x8F,
    (unsigned char)0xF0}};
static unsigned char const aes_test_cfb128_key[3][32] =
  {{(unsigned char)0x2B,
    (unsigned char)0x7E,
    (unsigned char)0x15,
    (unsigned char)0x16,
    (unsigned char)0x28,
    (unsigned char)0xAE,
    (unsigned char)0xD2,
    (unsigned char)0xA6,
    (unsigned char)0xAB,
    (unsigned char)0xF7,
    (unsigned char)0x15,
    (unsigned char)0x88,
    (unsigned char)0x09,
    (unsigned char)0xCF,
    (unsigned char)0x4F,
    (unsigned char)0x3C},
   {(unsigned char)0x8E,
    (unsigned char)0x73,
    (unsigned char)0xB0,
    (unsigned char)0xF7,
    (unsigned char)0xDA,
    (unsigned char)0x0E,
    (unsigned char)0x64,
    (unsigned char)0x52,
    (unsigned char)0xC8,
    (unsigned char)0x10,
    (unsigned char)0xF3,
    (unsigned char)0x2B,
    (unsigned char)0x80,
    (unsigned char)0x90,
    (unsigned char)0x79,
    (unsigned char)0xE5,
    (unsigned char)0x62,
    (unsigned char)0xF8,
    (unsigned char)0xEA,
    (unsigned char)0xD2,
    (unsigned char)0x52,
    (unsigned char)0x2C,
    (unsigned char)0x6B,
    (unsigned char)0x7B},
   {(unsigned char)0x60,
    (unsigned char)0x3D,
    (unsigned char)0xEB,
    (unsigned char)0x10,
    (unsigned char)0x15,
    (unsigned char)0xCA,
    (unsigned char)0x71,
    (unsigned char)0xBE,
    (unsigned char)0x2B,
    (unsigned char)0x73,
    (unsigned char)0xAE,
    (unsigned char)0xF0,
    (unsigned char)0x85,
    (unsigned char)0x7D,
    (unsigned char)0x77,
    (unsigned char)0x81,
    (unsigned char)0x1F,
    (unsigned char)0x35,
    (unsigned char)0x2C,
    (unsigned char)0x07,
    (unsigned char)0x3B,
    (unsigned char)0x61,
    (unsigned char)0x08,
    (unsigned char)0xD7,
    (unsigned char)0x2D,
    (unsigned char)0x98,
    (unsigned char)0x10,
    (unsigned char)0xA3,
    (unsigned char)0x09,
    (unsigned char)0x14,
    (unsigned char)0xDF,
    (unsigned char)0xF4}};
static unsigned char const aes_test_cfb128_iv[16] =
  {(unsigned char)0x00,
   (unsigned char)0x01,
   (unsigned char)0x02,
   (unsigned char)0x03,
   (unsigned char)0x04,
   (unsigned char)0x05,
   (unsigned char)0x06,
   (unsigned char)0x07,
   (unsigned char)0x08,
   (unsigned char)0x09,
   (unsigned char)0x0A,
   (unsigned char)0x0B,
   (unsigned char)0x0C,
   (unsigned char)0x0D,
   (unsigned char)0x0E,
   (unsigned char)0x0F};
static unsigned char const aes_test_cfb128_pt[64] =
  {(unsigned char)0x6B,
   (unsigned char)0xC1,
   (unsigned char)0xBE,
   (unsigned char)0xE2,
   (unsigned char)0x2E,
   (unsigned char)0x40,
   (unsigned char)0x9F,
   (unsigned char)0x96,
   (unsigned char)0xE9,
   (unsigned char)0x3D,
   (unsigned char)0x7E,
   (unsigned char)0x11,
   (unsigned char)0x73,
   (unsigned char)0x93,
   (unsigned char)0x17,
   (unsigned char)0x2A,
   (unsigned char)0xAE,
   (unsigned char)0x2D,
   (unsigned char)0x8A,
   (unsigned char)0x57,
   (unsigned char)0x1E,
   (unsigned char)0x03,
   (unsigned char)0xAC,
   (unsigned char)0x9C,
   (unsigned char)0x9E,
   (unsigned char)0xB7,
   (unsigned char)0x6F,
   (unsigned char)0xAC,
   (unsigned char)0x45,
   (unsigned char)0xAF,
   (unsigned char)0x8E,
   (unsigned char)0x51,
   (unsigned char)0x30,
   (unsigned char)0xC8,
   (unsigned char)0x1C,
   (unsigned char)0x46,
   (unsigned char)0xA3,
   (unsigned char)0x5C,
   (unsigned char)0xE4,
   (unsigned char)0x11,
   (unsigned char)0xE5,
   (unsigned char)0xFB,
   (unsigned char)0xC1,
   (unsigned char)0x19,
   (unsigned char)0x1A,
   (unsigned char)0x0A,
   (unsigned char)0x52,
   (unsigned char)0xEF,
   (unsigned char)0xF6,
   (unsigned char)0x9F,
   (unsigned char)0x24,
   (unsigned char)0x45,
   (unsigned char)0xDF,
   (unsigned char)0x4F,
   (unsigned char)0x9B,
   (unsigned char)0x17,
   (unsigned char)0xAD,
   (unsigned char)0x2B,
   (unsigned char)0x41,
   (unsigned char)0x7B,
   (unsigned char)0xE6,
   (unsigned char)0x6C,
   (unsigned char)0x37,
   (unsigned char)0x10};
static unsigned char const aes_test_cfb128_ct[3][64] =
  {{(unsigned char)0x3B,
    (unsigned char)0x3F,
    (unsigned char)0xD9,
    (unsigned char)0x2E,
    (unsigned char)0xB7,
    (unsigned char)0x2D,
    (unsigned char)0xAD,
    (unsigned char)0x20,
    (unsigned char)0x33,
    (unsigned char)0x34,
    (unsigned char)0x49,
    (unsigned char)0xF8,
    (unsigned char)0xE8,
    (unsigned char)0x3C,
    (unsigned char)0xFB,
    (unsigned char)0x4A,
    (unsigned char)0xC8,
    (unsigned char)0xA6,
    (unsigned char)0x45,
    (unsigned char)0x37,
    (unsigned char)0xA0,
    (unsigned char)0xB3,
    (unsigned char)0xA9,
    (unsigned char)0x3F,
    (unsigned char)0xCD,
    (unsigned char)0xE3,
    (unsigned char)0xCD,
    (unsigned char)0xAD,
    (unsigned char)0x9F,
    (unsigned char)0x1C,
    (unsigned char)0xE5,
    (unsigned char)0x8B,
    (unsigned char)0x26,
    (unsigned char)0x75,
    (unsigned char)0x1F,
    (unsigned char)0x67,
    (unsigned char)0xA3,
    (unsigned char)0xCB,
    (unsigned char)0xB1,
    (unsigned char)0x40,
    (unsigned char)0xB1,
    (unsigned char)0x80,
    (unsigned char)0x8C,
    (unsigned char)0xF1,
    (unsigned char)0x87,
    (unsigned char)0xA4,
    (unsigned char)0xF4,
    (unsigned char)0xDF,
    (unsigned char)0xC0,
    (unsigned char)0x4B,
    (unsigned char)0x05,
    (unsigned char)0x35,
    (unsigned char)0x7C,
    (unsigned char)0x5D,
    (unsigned char)0x1C,
    (unsigned char)0x0E,
    (unsigned char)0xEA,
    (unsigned char)0xC4,
    (unsigned char)0xC6,
    (unsigned char)0x6F,
    (unsigned char)0x9F,
    (unsigned char)0xF7,
    (unsigned char)0xF2,
    (unsigned char)0xE6},
   {(unsigned char)0xCD,
    (unsigned char)0xC8,
    (unsigned char)0x0D,
    (unsigned char)0x6F,
    (unsigned char)0xDD,
    (unsigned char)0xF1,
    (unsigned char)0x8C,
    (unsigned char)0xAB,
    (unsigned char)0x34,
    (unsigned char)0xC2,
    (unsigned char)0x59,
    (unsigned char)0x09,
    (unsigned char)0xC9,
    (unsigned char)0x9A,
    (unsigned char)0x41,
    (unsigned char)0x74,
    (unsigned char)0x67,
    (unsigned char)0xCE,
    (unsigned char)0x7F,
    (unsigned char)0x7F,
    (unsigned char)0x81,
    (unsigned char)0x17,
    (unsigned char)0x36,
    (unsigned char)0x21,
    (unsigned char)0x96,
    (unsigned char)0x1A,
    (unsigned char)0x2B,
    (unsigned char)0x70,
    (unsigned char)0x17,
    (unsigned char)0x1D,
    (unsigned char)0x3D,
    (unsigned char)0x7A,
    (unsigned char)0x2E,
    (unsigned char)0x1E,
    (unsigned char)0x8A,
    (unsigned char)0x1D,
    (unsigned char)0xD5,
    (unsigned char)0x9B,
    (unsigned char)0x88,
    (unsigned char)0xB1,
    (unsigned char)0xC8,
    (unsigned char)0xE6,
    (unsigned char)0x0F,
    (unsigned char)0xED,
    (unsigned char)0x1E,
    (unsigned char)0xFA,
    (unsigned char)0xC4,
    (unsigned char)0xC9,
    (unsigned char)0xC0,
    (unsigned char)0x5F,
    (unsigned char)0x9F,
    (unsigned char)0x9C,
    (unsigned char)0xA9,
    (unsigned char)0x83,
    (unsigned char)0x4F,
    (unsigned char)0xA0,
    (unsigned char)0x42,
    (unsigned char)0xAE,
    (unsigned char)0x8F,
    (unsigned char)0xBA,
    (unsigned char)0x58,
    (unsigned char)0x4B,
    (unsigned char)0x09,
    (unsigned char)0xFF},
   {(unsigned char)0xDC,
    (unsigned char)0x7E,
    (unsigned char)0x84,
    (unsigned char)0xBF,
    (unsigned char)0xDA,
    (unsigned char)0x79,
    (unsigned char)0x16,
    (unsigned char)0x4B,
    (unsigned char)0x7E,
    (unsigned char)0xCD,
    (unsigned char)0x84,
    (unsigned char)0x86,
    (unsigned char)0x98,
    (unsigned char)0x5D,
    (unsigned char)0x38,
    (unsigned char)0x60,
    (unsigned char)0x39,
    (unsigned char)0xFF,
    (unsigned char)0xED,
    (unsigned char)0x14,
    (unsigned char)0x3B,
    (unsigned char)0x28,
    (unsigned char)0xB1,
    (unsigned char)0xC8,
    (unsigned char)0x32,
    (unsigned char)0x11,
    (unsigned char)0x3C,
    (unsigned char)0x63,
    (unsigned char)0x31,
    (unsigned char)0xE5,
    (unsigned char)0x40,
    (unsigned char)0x7B,
    (unsigned char)0xDF,
    (unsigned char)0x10,
    (unsigned char)0x13,
    (unsigned char)0x24,
    (unsigned char)0x15,
    (unsigned char)0xE5,
    (unsigned char)0x4B,
    (unsigned char)0x92,
    (unsigned char)0xA1,
    (unsigned char)0x3E,
    (unsigned char)0xD0,
    (unsigned char)0xA8,
    (unsigned char)0x26,
    (unsigned char)0x7A,
    (unsigned char)0xE2,
    (unsigned char)0xF9,
    (unsigned char)0x75,
    (unsigned char)0xA3,
    (unsigned char)0x85,
    (unsigned char)0x74,
    (unsigned char)0x1A,
    (unsigned char)0xB9,
    (unsigned char)0xCE,
    (unsigned char)0xF8,
    (unsigned char)0x20,
    (unsigned char)0x31,
    (unsigned char)0x62,
    (unsigned char)0x3D,
    (unsigned char)0x55,
    (unsigned char)0xB1,
    (unsigned char)0xE4,
    (unsigned char)0x71}};
static unsigned char const aes_test_ctr_key[3][16] =
  {{(unsigned char)0xAE,
    (unsigned char)0x68,
    (unsigned char)0x52,
    (unsigned char)0xF8,
    (unsigned char)0x12,
    (unsigned char)0x10,
    (unsigned char)0x67,
    (unsigned char)0xCC,
    (unsigned char)0x4B,
    (unsigned char)0xF7,
    (unsigned char)0xA5,
    (unsigned char)0x76,
    (unsigned char)0x55,
    (unsigned char)0x77,
    (unsigned char)0xF3,
    (unsigned char)0x9E},
   {(unsigned char)0x7E,
    (unsigned char)0x24,
    (unsigned char)0x06,
    (unsigned char)0x78,
    (unsigned char)0x17,
    (unsigned char)0xFA,
    (unsigned char)0xE0,
    (unsigned char)0xD7,
    (unsigned char)0x43,
    (unsigned char)0xD6,
    (unsigned char)0xCE,
    (unsigned char)0x1F,
    (unsigned char)0x32,
    (unsigned char)0x53,
    (unsigned char)0x91,
    (unsigned char)0x63},
   {(unsigned char)0x76,
    (unsigned char)0x91,
    (unsigned char)0xBE,
    (unsigned char)0x03,
    (unsigned char)0x5E,
    (unsigned char)0x50,
    (unsigned char)0x20,
    (unsigned char)0xA8,
    (unsigned char)0xAC,
    (unsigned char)0x6E,
    (unsigned char)0x61,
    (unsigned char)0x85,
    (unsigned char)0x29,
    (unsigned char)0xF9,
    (unsigned char)0xA0,
    (unsigned char)0xDC}};
static unsigned char const aes_test_ctr_nonce_counter[3][16] =
  {{(unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x30,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x01},
   {(unsigned char)0x00,
    (unsigned char)0x6C,
    (unsigned char)0xB6,
    (unsigned char)0xDB,
    (unsigned char)0xC0,
    (unsigned char)0x54,
    (unsigned char)0x3B,
    (unsigned char)0x59,
    (unsigned char)0xDA,
    (unsigned char)0x48,
    (unsigned char)0xD9,
    (unsigned char)0x0B,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x01},
   {(unsigned char)0x00,
    (unsigned char)0xE0,
    (unsigned char)0x01,
    (unsigned char)0x7B,
    (unsigned char)0x27,
    (unsigned char)0x77,
    (unsigned char)0x7F,
    (unsigned char)0x3F,
    (unsigned char)0x4A,
    (unsigned char)0x17,
    (unsigned char)0x86,
    (unsigned char)0xF0,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x01}};
static unsigned char const aes_test_ctr_pt[3][48] =
  {{(unsigned char)0x53,
    (unsigned char)0x69,
    (unsigned char)0x6E,
    (unsigned char)0x67,
    (unsigned char)0x6C,
    (unsigned char)0x65,
    (unsigned char)0x20,
    (unsigned char)0x62,
    (unsigned char)0x6C,
    (unsigned char)0x6F,
    (unsigned char)0x63,
    (unsigned char)0x6B,
    (unsigned char)0x20,
    (unsigned char)0x6D,
    (unsigned char)0x73,
    (unsigned char)0x67},
   {(unsigned char)0x00,
    (unsigned char)0x01,
    (unsigned char)0x02,
    (unsigned char)0x03,
    (unsigned char)0x04,
    (unsigned char)0x05,
    (unsigned char)0x06,
    (unsigned char)0x07,
    (unsigned char)0x08,
    (unsigned char)0x09,
    (unsigned char)0x0A,
    (unsigned char)0x0B,
    (unsigned char)0x0C,
    (unsigned char)0x0D,
    (unsigned char)0x0E,
    (unsigned char)0x0F,
    (unsigned char)0x10,
    (unsigned char)0x11,
    (unsigned char)0x12,
    (unsigned char)0x13,
    (unsigned char)0x14,
    (unsigned char)0x15,
    (unsigned char)0x16,
    (unsigned char)0x17,
    (unsigned char)0x18,
    (unsigned char)0x19,
    (unsigned char)0x1A,
    (unsigned char)0x1B,
    (unsigned char)0x1C,
    (unsigned char)0x1D,
    (unsigned char)0x1E,
    (unsigned char)0x1F},
   {(unsigned char)0x00,
    (unsigned char)0x01,
    (unsigned char)0x02,
    (unsigned char)0x03,
    (unsigned char)0x04,
    (unsigned char)0x05,
    (unsigned char)0x06,
    (unsigned char)0x07,
    (unsigned char)0x08,
    (unsigned char)0x09,
    (unsigned char)0x0A,
    (unsigned char)0x0B,
    (unsigned char)0x0C,
    (unsigned char)0x0D,
    (unsigned char)0x0E,
    (unsigned char)0x0F,
    (unsigned char)0x10,
    (unsigned char)0x11,
    (unsigned char)0x12,
    (unsigned char)0x13,
    (unsigned char)0x14,
    (unsigned char)0x15,
    (unsigned char)0x16,
    (unsigned char)0x17,
    (unsigned char)0x18,
    (unsigned char)0x19,
    (unsigned char)0x1A,
    (unsigned char)0x1B,
    (unsigned char)0x1C,
    (unsigned char)0x1D,
    (unsigned char)0x1E,
    (unsigned char)0x1F,
    (unsigned char)0x20,
    (unsigned char)0x21,
    (unsigned char)0x22,
    (unsigned char)0x23}};
static unsigned char const aes_test_ctr_ct[3][48] =
  {{(unsigned char)0xE4,
    (unsigned char)0x09,
    (unsigned char)0x5D,
    (unsigned char)0x4F,
    (unsigned char)0xB7,
    (unsigned char)0xA7,
    (unsigned char)0xB3,
    (unsigned char)0x79,
    (unsigned char)0x2D,
    (unsigned char)0x61,
    (unsigned char)0x75,
    (unsigned char)0xA3,
    (unsigned char)0x26,
    (unsigned char)0x13,
    (unsigned char)0x11,
    (unsigned char)0xB8},
   {(unsigned char)0x51,
    (unsigned char)0x04,
    (unsigned char)0xA1,
    (unsigned char)0x06,
    (unsigned char)0x16,
    (unsigned char)0x8A,
    (unsigned char)0x72,
    (unsigned char)0xD9,
    (unsigned char)0x79,
    (unsigned char)0x0D,
    (unsigned char)0x41,
    (unsigned char)0xEE,
    (unsigned char)0x8E,
    (unsigned char)0xDA,
    (unsigned char)0xD3,
    (unsigned char)0x88,
    (unsigned char)0xEB,
    (unsigned char)0x2E,
    (unsigned char)0x1E,
    (unsigned char)0xFC,
    (unsigned char)0x46,
    (unsigned char)0xDA,
    (unsigned char)0x57,
    (unsigned char)0xC8,
    (unsigned char)0xFC,
    (unsigned char)0xE6,
    (unsigned char)0x30,
    (unsigned char)0xDF,
    (unsigned char)0x91,
    (unsigned char)0x41,
    (unsigned char)0xBE,
    (unsigned char)0x28},
   {(unsigned char)0xC1,
    (unsigned char)0xCF,
    (unsigned char)0x48,
    (unsigned char)0xA8,
    (unsigned char)0x9F,
    (unsigned char)0x2F,
    (unsigned char)0xFD,
    (unsigned char)0xD9,
    (unsigned char)0xCF,
    (unsigned char)0x46,
    (unsigned char)0x52,
    (unsigned char)0xE9,
    (unsigned char)0xEF,
    (unsigned char)0xDB,
    (unsigned char)0x72,
    (unsigned char)0xD7,
    (unsigned char)0x45,
    (unsigned char)0x40,
    (unsigned char)0xA4,
    (unsigned char)0x2B,
    (unsigned char)0xDE,
    (unsigned char)0x6D,
    (unsigned char)0x78,
    (unsigned char)0x36,
    (unsigned char)0xD5,
    (unsigned char)0x9A,
    (unsigned char)0x5C,
    (unsigned char)0xEA,
    (unsigned char)0xAE,
    (unsigned char)0xF3,
    (unsigned char)0x10,
    (unsigned char)0x53,
    (unsigned char)0x25,
    (unsigned char)0xB2,
    (unsigned char)0x07,
    (unsigned char)0x2F}};
static int const aes_test_ctr_len[3] = {16, 32, 36};
/*@ requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param1 + (0 ..)), param0;
 */
int printf_va_1(char const * restrict format, int param0, char *param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_2(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_3(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_4(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_5(char const * restrict format);

/*@ requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param1 + (0 ..)), param0;
 */
int printf_va_6(char const * restrict format, int param0, char *param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_7(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_8(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_9(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_10(char const * restrict format);

/*@ requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param1 + (0 ..)), param0;
 */
int printf_va_11(char const * restrict format, int param0, char *param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_12(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_13(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_14(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_15(char const * restrict format);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_16(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_17(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_18(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_19(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_20(char const * restrict format);

int aes_self_test(int verbose)
{
  int __retres;
  int i;
  int j;
  int u;
  int v;
  unsigned char key[32];
  unsigned char buf[64];
  unsigned char prv_0[16];
  unsigned char iv[16];
  size_t offset;
  int len;
  unsigned char nonce_counter[16];
  unsigned char stream_block[16];
  aes_context ctx;
  memset((void *)(key),0,(size_t)32);
  i = 0;
  while (i < 6) {
    u = i >> 1;
    v = i & 1;
    if (verbose != 0) {
      char const *tmp;
      if (v == 0) tmp = "dec"; else tmp = "enc";
      ;
      printf("  AES-ECB-%3d (%s): ",128 + u * 64,(char *)tmp); /* printf_va_1 */
    }
    memset((void *)(buf),0,(size_t)16);
    if (v == 0) {
      int tmp_0;
      aes_setkey_dec(& ctx,(unsigned char const *)(key),
                     (unsigned int)(128 + u * 64));
      j = 0;
      while (j < 10000) {
        aes_crypt_ecb(& ctx,v,(unsigned char const *)(buf),buf);
        j ++;
      }
      tmp_0 = memcmp((void const *)(buf),(void const *)(aes_test_ecb_dec[u]),
                     (size_t)16);
      if (tmp_0 != 0) {
        if (verbose != 0) printf("failed\n"); /* printf_va_2 */
        __retres = 1;
        goto return_label;
      }
    }
    else {
      int tmp_1;
      aes_setkey_enc(& ctx,(unsigned char const *)(key),
                     (unsigned int)(128 + u * 64));
      j = 0;
      while (j < 10000) {
        aes_crypt_ecb(& ctx,v,(unsigned char const *)(buf),buf);
        j ++;
      }
      tmp_1 = memcmp((void const *)(buf),(void const *)(aes_test_ecb_enc[u]),
                     (size_t)16);
      if (tmp_1 != 0) {
        if (verbose != 0) printf("failed\n"); /* printf_va_3 */
        __retres = 1;
        goto return_label;
      }
    }
    if (verbose != 0) printf("passed\n"); /* printf_va_4 */
    i ++;
  }
  if (verbose != 0) printf("\n"); /* printf_va_5 */
  i = 0;
  while (i < 6) {
    u = i >> 1;
    v = i & 1;
    if (verbose != 0) {
      char const *tmp_2;
      if (v == 0) tmp_2 = "dec"; else tmp_2 = "enc";
      ;
      printf("  AES-CBC-%3d (%s): ",128 + u * 64,(char *)tmp_2); /* printf_va_6 */
    }
    memset((void *)(iv),0,(size_t)16);
    memset((void *)(prv_0),0,(size_t)16);
    memset((void *)(buf),0,(size_t)16);
    if (v == 0) {
      int tmp_3;
      aes_setkey_dec(& ctx,(unsigned char const *)(key),
                     (unsigned int)(128 + u * 64));
      j = 0;
      while (j < 10000) {
        aes_crypt_cbc(& ctx,v,(size_t)16,iv,(unsigned char const *)(buf),buf);
        j ++;
      }
      tmp_3 = memcmp((void const *)(buf),(void const *)(aes_test_cbc_dec[u]),
                     (size_t)16);
      if (tmp_3 != 0) {
        if (verbose != 0) printf("failed\n"); /* printf_va_7 */
        __retres = 1;
        goto return_label;
      }
    }
    else {
      int tmp_5;
      aes_setkey_enc(& ctx,(unsigned char const *)(key),
                     (unsigned int)(128 + u * 64));
      j = 0;
      while (j < 10000) {
        {
          unsigned char tmp_4[16];
          aes_crypt_cbc(& ctx,v,(size_t)16,iv,(unsigned char const *)(buf),
                        buf);
          memcpy((void *)(tmp_4),(void const *)(prv_0),(size_t)16);
          memcpy((void *)(prv_0),(void const *)(buf),(size_t)16);
          memcpy((void *)(buf),(void const *)(tmp_4),(size_t)16);
        }
        j ++;
      }
      tmp_5 = memcmp((void const *)(prv_0),
                     (void const *)(aes_test_cbc_enc[u]),(size_t)16);
      if (tmp_5 != 0) {
        if (verbose != 0) printf("failed\n"); /* printf_va_8 */
        __retres = 1;
        goto return_label;
      }
    }
    if (verbose != 0) printf("passed\n"); /* printf_va_9 */
    i ++;
  }
  if (verbose != 0) printf("\n"); /* printf_va_10 */
  i = 0;
  while (i < 6) {
    u = i >> 1;
    v = i & 1;
    if (verbose != 0) {
      char const *tmp_6;
      if (v == 0) tmp_6 = "dec"; else tmp_6 = "enc";
      ;
      printf("  AES-CFB128-%3d (%s): ",128 + u * 64,(char *)tmp_6); /* printf_va_11 */
    }
    memcpy((void *)(iv),(void const *)(aes_test_cfb128_iv),(size_t)16);
    memcpy((void *)(key),(void const *)(aes_test_cfb128_key[u]),
           (size_t)(16 + u * 8));
    offset = (size_t)0;
    aes_setkey_enc(& ctx,(unsigned char const *)(key),
                   (unsigned int)(128 + u * 64));
    if (v == 0) {
      int tmp_7;
      memcpy((void *)(buf),(void const *)(aes_test_cfb128_ct[u]),(size_t)64);
      aes_crypt_cfb128(& ctx,v,(size_t)64,& offset,iv,
                       (unsigned char const *)(buf),buf);
      tmp_7 = memcmp((void const *)(buf),(void const *)(aes_test_cfb128_pt),
                     (size_t)64);
      if (tmp_7 != 0) {
        if (verbose != 0) printf("failed\n"); /* printf_va_12 */
        __retres = 1;
        goto return_label;
      }
    }
    else {
      int tmp_8;
      memcpy((void *)(buf),(void const *)(aes_test_cfb128_pt),(size_t)64);
      aes_crypt_cfb128(& ctx,v,(size_t)64,& offset,iv,
                       (unsigned char const *)(buf),buf);
      tmp_8 = memcmp((void const *)(buf),
                     (void const *)(aes_test_cfb128_ct[u]),(size_t)64);
      if (tmp_8 != 0) {
        if (verbose != 0) printf("failed\n"); /* printf_va_13 */
        __retres = 1;
        goto return_label;
      }
    }
    if (verbose != 0) printf("passed\n"); /* printf_va_14 */
    i ++;
  }
  if (verbose != 0) printf("\n"); /* printf_va_15 */
  i = 0;
  while (i < 6) {
    u = i >> 1;
    v = i & 1;
    if (verbose != 0) {
      char const *tmp_9;
      if (v == 0) tmp_9 = "dec"; else tmp_9 = "enc";
      printf("  AES-CTR-128 (%s): ",(char *)tmp_9); /* printf_va_16 */
    }
    memcpy((void *)(nonce_counter),
           (void const *)(aes_test_ctr_nonce_counter[u]),(size_t)16);
    memcpy((void *)(key),(void const *)(aes_test_ctr_key[u]),(size_t)16);
    offset = (size_t)0;
    aes_setkey_enc(& ctx,(unsigned char const *)(key),(unsigned int)128);
    if (v == 0) {
      int tmp_10;
      len = aes_test_ctr_len[u];
      memcpy((void *)(buf),(void const *)(aes_test_ctr_ct[u]),(size_t)len);
      aes_crypt_ctr(& ctx,(size_t)len,& offset,nonce_counter,stream_block,
                    (unsigned char const *)(buf),buf);
      tmp_10 = memcmp((void const *)(buf),(void const *)(aes_test_ctr_pt[u]),
                      (size_t)len);
      if (tmp_10 != 0) {
        if (verbose != 0) printf("failed\n"); /* printf_va_17 */
        __retres = 1;
        goto return_label;
      }
    }
    else {
      int tmp_11;
      len = aes_test_ctr_len[u];
      memcpy((void *)(buf),(void const *)(aes_test_ctr_pt[u]),(size_t)len);
      aes_crypt_ctr(& ctx,(size_t)len,& offset,nonce_counter,stream_block,
                    (unsigned char const *)(buf),buf);
      tmp_11 = memcmp((void const *)(buf),(void const *)(aes_test_ctr_ct[u]),
                      (size_t)len);
      if (tmp_11 != 0) {
        if (verbose != 0) printf("failed\n"); /* printf_va_18 */
        __retres = 1;
        goto return_label;
      }
    }
    if (verbose != 0) printf("passed\n"); /* printf_va_19 */
    i ++;
  }
  if (verbose != 0) printf("\n"); /* printf_va_20 */
  __retres = 0;
  return_label: return __retres;
}

void arc4_setup(arc4_context *ctx, unsigned char const *key,
                unsigned int keylen)
{
  int i;
  int j;
  int a;
  unsigned int k;
  unsigned char *m;
  ctx->x = 0;
  ctx->y = 0;
  m = ctx->m;
  i = 0;
  /*@ loop unroll 256; */
  while (i < 256) {
    *(m + i) = (unsigned char)i;
    i ++;
  }
  k = (unsigned int)0;
  j = (int)k;
  i = 0;
  /*@ loop unroll 256; */
  while (i < 256) {
    if (k >= keylen) k = (unsigned int)0;
    a = (int)*(m + i);
    j = ((j + a) + (int)*(key + k)) & 0xFF;
    *(m + i) = *(m + j);
    *(m + j) = (unsigned char)a;
    i ++;
    k ++;
  }
  return;
}

/*@ requires \valid(ctx);
    requires \valid_read(input + (0 .. length - 1));
    requires \valid(output + (0 .. length - 1));
    ensures \initialized(\old(output) + (0 .. \old(length) - 1));
    assigns *(output + (0 .. length - 1)), _state;
    assigns *(output + (0 .. length - 1)) \from _state;
    assigns _state \from _state;
 */
int arc4_crypt(arc4_context *ctx, size_t length, unsigned char const *input,
               unsigned char *output)
{
  int __retres;
  int x;
  int y;
  int a;
  int b;
  size_t i;
  unsigned char *m;
  x = ctx->x;
  y = ctx->y;
  m = ctx->m;
  i = (size_t)0;
  while (i < length) {
    x = (x + 1) & 0xFF;
    a = (int)*(m + x);
    y = (y + a) & 0xFF;
    b = (int)*(m + y);
    *(m + x) = (unsigned char)b;
    *(m + y) = (unsigned char)a;
    *(output + i) = (unsigned char)((int)*(input + i) ^ (int)*(m + (unsigned char)(
                                                               a + b)));
    i ++;
  }
  ctx->x = x;
  ctx->y = y;
  __retres = 0;
  return __retres;
}

static unsigned char const arc4_test_key[3][8] =
  {{(unsigned char)0x01,
    (unsigned char)0x23,
    (unsigned char)0x45,
    (unsigned char)0x67,
    (unsigned char)0x89,
    (unsigned char)0xAB,
    (unsigned char)0xCD,
    (unsigned char)0xEF},
   {(unsigned char)0x01,
    (unsigned char)0x23,
    (unsigned char)0x45,
    (unsigned char)0x67,
    (unsigned char)0x89,
    (unsigned char)0xAB,
    (unsigned char)0xCD,
    (unsigned char)0xEF},
   {(unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00}};
static unsigned char const arc4_test_pt[3][8] =
  {{(unsigned char)0x01,
    (unsigned char)0x23,
    (unsigned char)0x45,
    (unsigned char)0x67,
    (unsigned char)0x89,
    (unsigned char)0xAB,
    (unsigned char)0xCD,
    (unsigned char)0xEF},
   {(unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00},
   {(unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00}};
static unsigned char const arc4_test_ct[3][8] =
  {{(unsigned char)0x75,
    (unsigned char)0xB7,
    (unsigned char)0x87,
    (unsigned char)0x80,
    (unsigned char)0x99,
    (unsigned char)0xE0,
    (unsigned char)0xC5,
    (unsigned char)0x96},
   {(unsigned char)0x74,
    (unsigned char)0x94,
    (unsigned char)0xC2,
    (unsigned char)0xE7,
    (unsigned char)0x10,
    (unsigned char)0x4B,
    (unsigned char)0x08,
    (unsigned char)0x79},
   {(unsigned char)0xDE,
    (unsigned char)0x18,
    (unsigned char)0x89,
    (unsigned char)0x41,
    (unsigned char)0xA3,
    (unsigned char)0x37,
    (unsigned char)0x5D,
    (unsigned char)0x3A}};
/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_21(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_22(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_23(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_24(char const * restrict format);

int arc4_self_test(int verbose)
{
  int __retres;
  int i;
  unsigned char ibuf[8];
  unsigned char obuf[8];
  arc4_context ctx;
  i = 0;
  while (i < 3) {
    {
      int tmp;
      if (verbose != 0) printf("  ARC4 test #%d: ",i + 1); /* printf_va_21 */
      memcpy((void *)(ibuf),(void const *)(arc4_test_pt[i]),(size_t)8);
      arc4_setup(& ctx,arc4_test_key[i],(unsigned int)8);
      arc4_crypt(& ctx,(size_t)8,(unsigned char const *)(ibuf),obuf);
      tmp = memcmp((void const *)(obuf),(void const *)(arc4_test_ct[i]),
                   (size_t)8);
      if (tmp != 0) {
        if (verbose != 0) printf("failed\n"); /* printf_va_22 */
        __retres = 1;
        goto return_label;
      }
      if (verbose != 0) printf("passed\n"); /* printf_va_23 */
    }
    i ++;
  }
  if (verbose != 0) printf("\n"); /* printf_va_24 */
  __retres = 0;
  return_label: return __retres;
}

int asn1_get_len(unsigned char **p, unsigned char const *end, size_t *len)
{
  int __retres;
  if (end - *p < 1) {
    __retres = -0x0014;
    goto return_label;
  }
  if (((int)*(*p) & 0x80) == 0) {
    unsigned char *tmp;
    tmp = *p;
    (*p) ++;
    *len = (size_t)*tmp;
  }
  else 
    switch ((int)*(*p) & 0x7F) {
      case 1: ;
      if (end - *p < 2) {
        __retres = -0x0014;
        goto return_label;
      }
      *len = (size_t)*(*p + 1);
      *p += 2;
      break;
      case 2: ;
      if (end - *p < 3) {
        __retres = -0x0014;
        goto return_label;
      }
      *len = (size_t)(((int)*(*p + 1) << 8) | (int)*(*p + 2));
      *p += 3;
      break;
      case 3: ;
      if (end - *p < 4) {
        __retres = -0x0014;
        goto return_label;
      }
      *len = (size_t)((((int)*(*p + 1) << 16) | ((int)*(*p + 2) << 8)) | (int)*(
                      *p + 3));
      *p += 4;
      break;
      case 4: ;
      if (end - *p < 5) {
        __retres = -0x0014;
        goto return_label;
      }
      *len = (size_t)(((((int)*(*p + 1) << 24) | ((int)*(*p + 2) << 16)) | (
                       (int)*(*p + 3) << 8)) | (int)*(*p + 4));
      *p += 5;
      break;
      default: __retres = -0x0018;
      goto return_label;
    }
  if (*len > (size_t)(end - *p)) {
    __retres = -0x0014;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int asn1_get_tag(unsigned char **p, unsigned char const *end, size_t *len,
                 int tag)
{
  int __retres;
  int tmp;
  if (end - *p < 1) {
    __retres = -0x0014;
    goto return_label;
  }
  if ((int)*(*p) != tag) {
    __retres = -0x0016;
    goto return_label;
  }
  (*p) ++;
  tmp = asn1_get_len(p,end,len);
  __retres = tmp;
  return_label: return __retres;
}

int asn1_get_bool(unsigned char **p, unsigned char const *end, int *val)
{
  int __retres;
  int ret;
  size_t len;
  ret = asn1_get_tag(p,end,& len,0x01);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  if (len != (size_t)1) {
    __retres = -0x0018;
    goto return_label;
  }
  if ((int)*(*p) != 0) *val = 1; else *val = 0;
  (*p) ++;
  __retres = 0;
  return_label: return __retres;
}

int asn1_get_int(unsigned char **p, unsigned char const *end, int *val)
{
  int __retres;
  int ret;
  size_t len;
  ret = asn1_get_tag(p,end,& len,0x02);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  if (len > sizeof(int)) {
    __retres = -0x0018;
    goto return_label;
  }
  else 
    if (((int)*(*p) & 0x80) != 0) {
      __retres = -0x0018;
      goto return_label;
    }
  *val = 0;
  while (1) {
    size_t tmp;
    tmp = len;
    len --;
    ;
    if (! (tmp > (size_t)0)) break;
    *val = (*val << 8) | (int)*(*p);
    (*p) ++;
  }
  __retres = 0;
  return_label: return __retres;
}

int asn1_get_mpi(unsigned char **p, unsigned char const *end, mpi *X)
{
  int __retres;
  int ret;
  size_t len;
  ret = asn1_get_tag(p,end,& len,0x02);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  ret = mpi_read_binary(X,(unsigned char const *)*p,len);
  *p += len;
  __retres = ret;
  return_label: return __retres;
}

int asn1_get_bitstring(unsigned char **p, unsigned char const *end,
                       asn1_bitstring *bs)
{
  int __retres;
  int ret;
  ret = asn1_get_tag(p,end,& bs->len,0x03);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  if (bs->len < (size_t)1) {
    __retres = -0x0014;
    goto return_label;
  }
  bs->len -= (size_t)1;
  bs->unused_bits = *(*p);
  if ((int)bs->unused_bits > 7) {
    __retres = -0x0018;
    goto return_label;
  }
  (*p) ++;
  bs->p = *p;
  *p += bs->len;
  if ((void *)*p != (void *)end) {
    __retres = -0x001A;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int asn1_get_sequence_of(unsigned char **p, unsigned char const *end,
                         asn1_sequence *cur_0, int tag)
{
  int __retres;
  int ret;
  size_t len;
  asn1_buf *buf;
  ret = asn1_get_tag(p,end,& len,0x20 | 0x10);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  if ((void *)(*p + len) != (void *)end) {
    __retres = -0x001A;
    goto return_label;
  }
  while ((void *)*p < (void *)end) {
    buf = & cur_0->buf;
    buf->tag = (int)*(*p);
    ret = asn1_get_tag(p,end,& buf->len,tag);
    if (ret != 0) {
      __retres = ret;
      goto return_label;
    }
    buf->p = *p;
    *p += buf->len;
    if ((void *)*p < (void *)end) {
      cur_0->next = (struct _asn1_sequence *)malloc(sizeof(asn1_sequence));
      if (cur_0->next == (struct _asn1_sequence *)0) {
        __retres = -0x001E;
        goto return_label;
      }
      cur_0 = cur_0->next;
    }
  }
  cur_0->next = (struct _asn1_sequence *)0;
  if ((void *)*p != (void *)end) {
    __retres = -0x001A;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int base64_encode(unsigned char *dst, size_t *dlen, unsigned char const *src,
                  size_t slen);

int base64_decode(unsigned char *dst, size_t *dlen, unsigned char const *src,
                  size_t slen);

int base64_self_test(int verbose);

static unsigned char const base64_enc_map[64] =
  {(unsigned char)'A',
   (unsigned char)'B',
   (unsigned char)'C',
   (unsigned char)'D',
   (unsigned char)'E',
   (unsigned char)'F',
   (unsigned char)'G',
   (unsigned char)'H',
   (unsigned char)'I',
   (unsigned char)'J',
   (unsigned char)'K',
   (unsigned char)'L',
   (unsigned char)'M',
   (unsigned char)'N',
   (unsigned char)'O',
   (unsigned char)'P',
   (unsigned char)'Q',
   (unsigned char)'R',
   (unsigned char)'S',
   (unsigned char)'T',
   (unsigned char)'U',
   (unsigned char)'V',
   (unsigned char)'W',
   (unsigned char)'X',
   (unsigned char)'Y',
   (unsigned char)'Z',
   (unsigned char)'a',
   (unsigned char)'b',
   (unsigned char)'c',
   (unsigned char)'d',
   (unsigned char)'e',
   (unsigned char)'f',
   (unsigned char)'g',
   (unsigned char)'h',
   (unsigned char)'i',
   (unsigned char)'j',
   (unsigned char)'k',
   (unsigned char)'l',
   (unsigned char)'m',
   (unsigned char)'n',
   (unsigned char)'o',
   (unsigned char)'p',
   (unsigned char)'q',
   (unsigned char)'r',
   (unsigned char)'s',
   (unsigned char)'t',
   (unsigned char)'u',
   (unsigned char)'v',
   (unsigned char)'w',
   (unsigned char)'x',
   (unsigned char)'y',
   (unsigned char)'z',
   (unsigned char)'0',
   (unsigned char)'1',
   (unsigned char)'2',
   (unsigned char)'3',
   (unsigned char)'4',
   (unsigned char)'5',
   (unsigned char)'6',
   (unsigned char)'7',
   (unsigned char)'8',
   (unsigned char)'9',
   (unsigned char)'+',
   (unsigned char)'/'};
static unsigned char const base64_dec_map[128] =
  {(unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)62,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)63,
   (unsigned char)52,
   (unsigned char)53,
   (unsigned char)54,
   (unsigned char)55,
   (unsigned char)56,
   (unsigned char)57,
   (unsigned char)58,
   (unsigned char)59,
   (unsigned char)60,
   (unsigned char)61,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)64,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)0,
   (unsigned char)1,
   (unsigned char)2,
   (unsigned char)3,
   (unsigned char)4,
   (unsigned char)5,
   (unsigned char)6,
   (unsigned char)7,
   (unsigned char)8,
   (unsigned char)9,
   (unsigned char)10,
   (unsigned char)11,
   (unsigned char)12,
   (unsigned char)13,
   (unsigned char)14,
   (unsigned char)15,
   (unsigned char)16,
   (unsigned char)17,
   (unsigned char)18,
   (unsigned char)19,
   (unsigned char)20,
   (unsigned char)21,
   (unsigned char)22,
   (unsigned char)23,
   (unsigned char)24,
   (unsigned char)25,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)26,
   (unsigned char)27,
   (unsigned char)28,
   (unsigned char)29,
   (unsigned char)30,
   (unsigned char)31,
   (unsigned char)32,
   (unsigned char)33,
   (unsigned char)34,
   (unsigned char)35,
   (unsigned char)36,
   (unsigned char)37,
   (unsigned char)38,
   (unsigned char)39,
   (unsigned char)40,
   (unsigned char)41,
   (unsigned char)42,
   (unsigned char)43,
   (unsigned char)44,
   (unsigned char)45,
   (unsigned char)46,
   (unsigned char)47,
   (unsigned char)48,
   (unsigned char)49,
   (unsigned char)50,
   (unsigned char)51,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127,
   (unsigned char)127};
int base64_encode(unsigned char *dst, size_t *dlen, unsigned char const *src,
                  size_t slen)
{
  int __retres;
  size_t i;
  size_t n;
  int C1;
  int C2;
  int C3;
  unsigned char *p;
  if (slen == (size_t)0) {
    __retres = 0;
    goto return_label;
  }
  n = (slen << 3) / (size_t)6;
  switch ((slen << 3) - n * (size_t)6) {
    case (size_t)2: n += (size_t)3;
    break;
    case (size_t)4: n += (size_t)2;
    break;
    default: break;
  }
  if (*dlen < n + (size_t)1) {
    *dlen = n + (size_t)1;
    __retres = -0x002A;
    goto return_label;
  }
  n = (slen / (size_t)3) * (size_t)3;
  i = (size_t)0;
  p = dst;
  while (i < n) {
    {
      unsigned char const *tmp;
      unsigned char const *tmp_0;
      unsigned char const *tmp_1;
      unsigned char *tmp_2;
      unsigned char *tmp_3;
      unsigned char *tmp_4;
      unsigned char *tmp_5;
      tmp = src;
      src ++;
      C1 = (int)*tmp;
      tmp_0 = src;
      src ++;
      C2 = (int)*tmp_0;
      tmp_1 = src;
      src ++;
      C3 = (int)*tmp_1;
      tmp_2 = p;
      p ++;
      *tmp_2 = base64_enc_map[(C1 >> 2) & 0x3F];
      tmp_3 = p;
      p ++;
      *tmp_3 = base64_enc_map[(((C1 & 3) << 4) + (C2 >> 4)) & 0x3F];
      tmp_4 = p;
      p ++;
      *tmp_4 = base64_enc_map[(((C2 & 15) << 2) + (C3 >> 6)) & 0x3F];
      tmp_5 = p;
      p ++;
      *tmp_5 = base64_enc_map[C3 & 0x3F];
    }
    i += (size_t)3;
  }
  if (i < slen) {
    unsigned char const *tmp_6;
    unsigned char *tmp_8;
    unsigned char *tmp_9;
    unsigned char *tmp_12;
    tmp_6 = src;
    src ++;
    C1 = (int)*tmp_6;
    if (i + (size_t)1 < slen) {
      unsigned char const *tmp_7;
      tmp_7 = src;
      src ++;
      C2 = (int)*tmp_7;
    }
    else C2 = 0;
    tmp_8 = p;
    p ++;
    *tmp_8 = base64_enc_map[(C1 >> 2) & 0x3F];
    tmp_9 = p;
    p ++;
    *tmp_9 = base64_enc_map[(((C1 & 3) << 4) + (C2 >> 4)) & 0x3F];
    if (i + (size_t)1 < slen) {
      unsigned char *tmp_10;
      tmp_10 = p;
      p ++;
      *tmp_10 = base64_enc_map[((C2 & 15) << 2) & 0x3F];
    }
    else {
      unsigned char *tmp_11;
      tmp_11 = p;
      p ++;
      *tmp_11 = (unsigned char)'=';
    }
    tmp_12 = p;
    p ++;
    *tmp_12 = (unsigned char)'=';
  }
  *dlen = (size_t)(p - dst);
  *p = (unsigned char)0;
  __retres = 0;
  return_label: return __retres;
}

int base64_decode(unsigned char *dst, size_t *dlen, unsigned char const *src,
                  size_t slen)
{
  int __retres;
  size_t i;
  size_t j;
  size_t n;
  unsigned long x;
  unsigned char *p;
  n = (size_t)0;
  j = n;
  i = j;
  while (i < slen) {
    if (slen - i >= (size_t)2) 
      if ((int)*(src + i) == '\r') 
        if ((int)*(src + (i + (size_t)1)) == '\n') goto __Cont;
    if ((int)*(src + i) == '\n') goto __Cont;
    if ((int)*(src + i) == '=') {
      j ++;
      if (j > (size_t)2) {
        __retres = -0x002C;
        goto return_label;
      }
    }
    if ((int)*(src + i) > 127) {
      __retres = -0x002C;
      goto return_label;
    }
    else 
      if ((int)base64_dec_map[*(src + i)] == 127) {
        __retres = -0x002C;
        goto return_label;
      }
    if ((int)base64_dec_map[*(src + i)] < 64) 
      if (j != (size_t)0) {
        __retres = -0x002C;
        goto return_label;
      }
    n ++;
    __Cont: i ++;
  }
  if (n == (size_t)0) {
    __retres = 0;
    goto return_label;
  }
  n = (n * (size_t)6 + (size_t)7) >> 3;
  if (*dlen < n) {
    *dlen = n;
    __retres = -0x002A;
    goto return_label;
  }
  j = (size_t)3;
  x = (unsigned long)0;
  n = (size_t)x;
  p = dst;
  while (i > (size_t)0) {
    if ((int)*src == '\r') goto __Cont_0;
    else 
      if ((int)*src == '\n') goto __Cont_0;
    j -= (size_t)((int)base64_dec_map[*src] == 64);
    x = (x << 6) | (unsigned long)((int)base64_dec_map[*src] & 0x3F);
    n ++;
    if (n == (size_t)4) {
      n = (size_t)0;
      if (j > (size_t)0) {
        unsigned char *tmp;
        tmp = p;
        p ++;
        *tmp = (unsigned char)(x >> 16);
      }
      if (j > (size_t)1) {
        unsigned char *tmp_0;
        tmp_0 = p;
        p ++;
        *tmp_0 = (unsigned char)(x >> 8);
      }
      if (j > (size_t)2) {
        unsigned char *tmp_1;
        tmp_1 = p;
        p ++;
        *tmp_1 = (unsigned char)x;
      }
    }
    __Cont_0: i --;
    src ++;
  }
  *dlen = (size_t)(p - dst);
  __retres = 0;
  return_label: return __retres;
}

static unsigned char const base64_test_dec[64] =
  {(unsigned char)0x24,
   (unsigned char)0x48,
   (unsigned char)0x6E,
   (unsigned char)0x56,
   (unsigned char)0x87,
   (unsigned char)0x62,
   (unsigned char)0x5A,
   (unsigned char)0xBD,
   (unsigned char)0xBF,
   (unsigned char)0x17,
   (unsigned char)0xD9,
   (unsigned char)0xA2,
   (unsigned char)0xC4,
   (unsigned char)0x17,
   (unsigned char)0x1A,
   (unsigned char)0x01,
   (unsigned char)0x94,
   (unsigned char)0xED,
   (unsigned char)0x8F,
   (unsigned char)0x1E,
   (unsigned char)0x11,
   (unsigned char)0xB3,
   (unsigned char)0xD7,
   (unsigned char)0x09,
   (unsigned char)0x0C,
   (unsigned char)0xB6,
   (unsigned char)0xE9,
   (unsigned char)0x10,
   (unsigned char)0x6F,
   (unsigned char)0x22,
   (unsigned char)0xEE,
   (unsigned char)0x13,
   (unsigned char)0xCA,
   (unsigned char)0xB3,
   (unsigned char)0x07,
   (unsigned char)0x05,
   (unsigned char)0x76,
   (unsigned char)0xC9,
   (unsigned char)0xFA,
   (unsigned char)0x31,
   (unsigned char)0x6C,
   (unsigned char)0x08,
   (unsigned char)0x34,
   (unsigned char)0xFF,
   (unsigned char)0x8D,
   (unsigned char)0xC2,
   (unsigned char)0x6C,
   (unsigned char)0x38,
   (unsigned char)0x00,
   (unsigned char)0x43,
   (unsigned char)0xE9,
   (unsigned char)0x54,
   (unsigned char)0x97,
   (unsigned char)0xAF,
   (unsigned char)0x50,
   (unsigned char)0x4B,
   (unsigned char)0xD1,
   (unsigned char)0x41,
   (unsigned char)0xBA,
   (unsigned char)0x95,
   (unsigned char)0x31,
   (unsigned char)0x5A,
   (unsigned char)0x0B,
   (unsigned char)0x97};
static unsigned char const base64_test_enc[89] =
  {(unsigned char)'J',
   (unsigned char)'E',
   (unsigned char)'h',
   (unsigned char)'u',
   (unsigned char)'V',
   (unsigned char)'o',
   (unsigned char)'d',
   (unsigned char)'i',
   (unsigned char)'W',
   (unsigned char)'r',
   (unsigned char)'2',
   (unsigned char)'/',
   (unsigned char)'F',
   (unsigned char)'9',
   (unsigned char)'m',
   (unsigned char)'i',
   (unsigned char)'x',
   (unsigned char)'B',
   (unsigned char)'c',
   (unsigned char)'a',
   (unsigned char)'A',
   (unsigned char)'Z',
   (unsigned char)'T',
   (unsigned char)'t',
   (unsigned char)'j',
   (unsigned char)'x',
   (unsigned char)'4',
   (unsigned char)'R',
   (unsigned char)'s',
   (unsigned char)'9',
   (unsigned char)'c',
   (unsigned char)'J',
   (unsigned char)'D',
   (unsigned char)'L',
   (unsigned char)'b',
   (unsigned char)'p',
   (unsigned char)'E',
   (unsigned char)'G',
   (unsigned char)'8',
   (unsigned char)'i',
   (unsigned char)'7',
   (unsigned char)'h',
   (unsigned char)'P',
   (unsigned char)'K',
   (unsigned char)'s',
   (unsigned char)'w',
   (unsigned char)'c',
   (unsigned char)'F',
   (unsigned char)'d',
   (unsigned char)'s',
   (unsigned char)'n',
   (unsigned char)'6',
   (unsigned char)'M',
   (unsigned char)'W',
   (unsigned char)'w',
   (unsigned char)'I',
   (unsigned char)'N',
   (unsigned char)'P',
   (unsigned char)'+',
   (unsigned char)'N',
   (unsigned char)'w',
   (unsigned char)'m',
   (unsigned char)'w',
   (unsigned char)'4',
   (unsigned char)'A',
   (unsigned char)'E',
   (unsigned char)'P',
   (unsigned char)'p',
   (unsigned char)'V',
   (unsigned char)'J',
   (unsigned char)'e',
   (unsigned char)'v',
   (unsigned char)'U',
   (unsigned char)'E',
   (unsigned char)'v',
   (unsigned char)'R',
   (unsigned char)'Q',
   (unsigned char)'b',
   (unsigned char)'q',
   (unsigned char)'V',
   (unsigned char)'M',
   (unsigned char)'V',
   (unsigned char)'o',
   (unsigned char)'L',
   (unsigned char)'l',
   (unsigned char)'w',
   (unsigned char)'=',
   (unsigned char)'=',
   (unsigned char)'\000'};
/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_25(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_26(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_27(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_28(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_29(char const * restrict format);

int base64_self_test(int verbose)
{
  int __retres;
  size_t len;
  unsigned char *src;
  unsigned char buffer[128];
  int tmp;
  int tmp_1;
  if (verbose != 0) printf("  Base64 encoding test: "); /* printf_va_25 */
  len = sizeof(buffer);
  src = (unsigned char *)(base64_test_dec);
  tmp = base64_encode(buffer,& len,(unsigned char const *)src,(size_t)64);
  if (tmp != 0) goto _LOR;
  else {
    int tmp_0;
    tmp_0 = memcmp((void const *)(base64_test_enc),(void const *)(buffer),
                   (size_t)88);
    if (tmp_0 != 0) {
      _LOR:
      {
        if (verbose != 0) printf("failed\n"); /* printf_va_26 */
        __retres = 1;
        goto return_label;
      }
    }
  }
  if (verbose != 0) printf("passed\n  Base64 decoding test: "); /* printf_va_27 */
  len = sizeof(buffer);
  src = (unsigned char *)(base64_test_enc);
  tmp_1 = base64_decode(buffer,& len,(unsigned char const *)src,(size_t)88);
  if (tmp_1 != 0) goto _LOR_0;
  else {
    int tmp_2;
    tmp_2 = memcmp((void const *)(base64_test_dec),(void const *)(buffer),
                   (size_t)64);
    if (tmp_2 != 0) {
      _LOR_0:
      {
        if (verbose != 0) printf("failed\n"); /* printf_va_28 */
        __retres = 1;
        goto return_label;
      }
    }
  }
  if (verbose != 0) printf("passed\n\n"); /* printf_va_29 */
  __retres = 0;
  return_label: return __retres;
}

void mpi_init(mpi *X)
{
  if (X == (mpi *)0) goto return_label;
  X->s = 1;
  X->n = (size_t)0;
  X->p = (t_uint *)0;
  return_label: return;
}

/*@ assigns *X;
    assigns *X \from _state; */
void mpi_free(mpi *X)
{
  if (X == (mpi *)0) goto return_label;
  if (X->p != (t_uint *)0) {
    memset((void *)X->p,0,X->n * sizeof(t_uint));
    free((void *)X->p);
  }
  X->s = 1;
  X->n = (size_t)0;
  X->p = (t_uint *)0;
  return_label: return;
}

int mpi_grow(mpi *X, size_t nblimbs)
{
  int __retres;
  t_uint *p;
  if (nblimbs > (size_t)10000) {
    __retres = -0x0010;
    goto return_label;
  }
  if (X->n < nblimbs) {
    p = (t_uint *)malloc(nblimbs * sizeof(t_uint));
    if (p == (t_uint *)0) {
      __retres = -0x0010;
      goto return_label;
    }
    memset((void *)p,0,nblimbs * sizeof(t_uint));
    if (X->p != (t_uint *)0) {
      memcpy((void *)p,(void const *)X->p,X->n * sizeof(t_uint));
      memset((void *)X->p,0,X->n * sizeof(t_uint));
      free((void *)X->p);
    }
    X->n = nblimbs;
    X->p = p;
  }
  __retres = 0;
  return_label: return __retres;
}

/*@ requires \valid(X);
    requires \valid_read(Y);
    ensures \old(X)->s ≡ 1 ∨ \old(X)->s ≡ -1;
    assigns *X, \result, _state;
    assigns *X \from _state;
    assigns \result \from _state;
    assigns _state \from _state;
 */
int mpi_copy(mpi *X, mpi const *Y)
{
  int __retres;
  int ret;
  size_t i;
  if ((void *)X == (void *)Y) {
    __retres = 0;
    goto return_label;
  }
  i = Y->n - (size_t)1;
  while (i > (size_t)0) {
    if (*(Y->p + i) != (t_uint)0) break;
    i --;
  }
  i ++;
  X->s = Y->s;
  ret = mpi_grow(X,i);
  if (ret != 0) goto cleanup;
  memset((void *)X->p,0,X->n * sizeof(t_uint));
  memcpy((void *)X->p,(void const *)Y->p,i * sizeof(t_uint));
  cleanup: ;
  __retres = ret;
  return_label: return __retres;
}

void mpi_swap(mpi *X, mpi *Y)
{
  mpi T;
  memcpy((void *)(& T),(void const *)X,sizeof(mpi));
  memcpy((void *)X,(void const *)Y,sizeof(mpi));
  memcpy((void *)Y,(void const *)(& T),sizeof(mpi));
  return;
}

int mpi_lset(mpi *X, t_sint z)
{
  int ret;
  ret = mpi_grow(X,(size_t)1);
  if (ret != 0) goto cleanup;
  memset((void *)X->p,0,X->n * sizeof(t_uint));
  if (z < (t_sint)0) *(X->p + 0) = (t_uint)(- z);
  else *(X->p + 0) = (t_uint)z;
  if (z < (t_sint)0) X->s = -1; else X->s = 1;
  cleanup: ;
  return ret;
}

int mpi_get_bit(mpi *X, size_t pos)
{
  int __retres;
  if (X->n * (sizeof(t_uint) << 3) <= pos) {
    __retres = 0;
    goto return_label;
  }
  __retres = (int)((*(X->p + pos / (sizeof(t_uint) << 3)) >> pos % (sizeof(t_uint) << 3)) & (unsigned long)0x01);
  return_label: return __retres;
}

int mpi_set_bit(mpi *X, size_t pos, unsigned char val)
{
  int __retres;
  int ret = 0;
  size_t off = pos / (sizeof(t_uint) << 3);
  size_t idx = pos % (sizeof(t_uint) << 3);
  if ((int)val != 0) 
    if ((int)val != 1) {
      __retres = -0x0004;
      goto return_label;
    }
  if (X->n * (sizeof(t_uint) << 3) <= pos) {
    if ((int)val == 0) {
      __retres = 0;
      goto return_label;
    }
    ret = mpi_grow(X,off + (size_t)1);
    if (ret != 0) goto cleanup;
  }
  *(X->p + off) = (*(X->p + off) & (unsigned long)(~ (0x01 << idx))) | (unsigned long)(
                  (int)val << idx);
  cleanup: ;
  __retres = ret;
  return_label: return __retres;
}

size_t mpi_lsb(mpi const *X)
{
  size_t __retres;
  size_t i;
  size_t j;
  size_t count = (size_t)0;
  i = (size_t)0;
  while (i < X->n) {
    j = (size_t)0;
    while (j < sizeof(t_uint) << 3) {
      if (((*(X->p + i) >> j) & (unsigned long)1) != (unsigned long)0) {
        __retres = count;
        goto return_label;
      }
      j ++;
      count ++;
    }
    i ++;
  }
  __retres = (size_t)0;
  return_label: return __retres;
}

/*@ requires \valid_read(X);
    assigns \result, _state;
    assigns \result \from _state;
    assigns _state \from _state;
 */
size_t mpi_msb(mpi const *X)
{
  size_t __retres;
  size_t i;
  size_t j;
  i = X->n - (size_t)1;
  while (i > (size_t)0) {
    if (*(X->p + i) != (t_uint)0) break;
    i --;
  }
  j = sizeof(t_uint) << 3;
  while (j > (size_t)0) {
    if (((*(X->p + i) >> (j - (size_t)1)) & (unsigned long)1) != (unsigned long)0) 
      break;
    j --;
  }
  __retres = i * (sizeof(t_uint) << 3) + j;
  return __retres;
}

/*@ requires \valid_read(X);
    assigns \result, _state;
    assigns \result \from _state;
    assigns _state \from _state;
 */
size_t mpi_size(mpi const *X)
{
  size_t __retres;
  size_t tmp;
  tmp = mpi_msb(X);
  __retres = (tmp + (size_t)7) >> 3;
  return __retres;
}

static int mpi_get_digit(t_uint *d, int radix, char c)
{
  int __retres;
  *d = (t_uint)255;
  if ((int)c >= 0x30) 
    if ((int)c <= 0x39) *d = (t_uint)((int)c - 0x30);
  if ((int)c >= 0x41) 
    if ((int)c <= 0x46) *d = (t_uint)((int)c - 0x37);
  if ((int)c >= 0x61) 
    if ((int)c <= 0x66) *d = (t_uint)((int)c - 0x57);
  if (*d >= (t_uint)radix) {
    __retres = -0x0006;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

/*@ requires \valid_read(s);
    requires \valid(X);
    ensures \old(X)->s ≡ 1 ∨ \old(X)->s ≡ -1;
    assigns \result, *X, _state;
    assigns \result \from _state;
    assigns *X \from _state;
    assigns _state \from _state;
 */
int mpi_read_string(mpi *X, int radix, char const *s)
{
  int __retres;
  int ret;
  size_t i;
  size_t j;
  size_t slen;
  size_t n;
  t_uint d;
  mpi T;
  if (radix < 2) {
    __retres = -0x0004;
    goto return_label;
  }
  else 
    if (radix > 16) {
      __retres = -0x0004;
      goto return_label;
    }
  mpi_init(& T);
  slen = strlen(s);
  if (radix == 16) {
    n = (((slen << 2) + (sizeof(t_uint) << 3)) - (size_t)1) / (sizeof(t_uint) << 3);
    ret = mpi_grow(X,n);
    if (ret != 0) goto cleanup;
    ret = mpi_lset(X,(t_sint)0);
    if (ret != 0) goto cleanup;
    i = slen;
    j = (size_t)0;
    while (i > (size_t)0) {
      if (i == (size_t)1) 
        if ((int)*(s + (i - (size_t)1)) == '-') {
          X->s = -1;
          break;
        }
      ret = mpi_get_digit(& d,radix,*(s + (i - (size_t)1)));
      if (ret != 0) goto cleanup;
      *(X->p + j / ((unsigned int)2 * sizeof(t_uint))) |= d << (j % (
                                                                (unsigned int)2 * sizeof(t_uint)) << 2);
      i --;
      j ++;
    }
  }
  else {
    ret = mpi_lset(X,(t_sint)0);
    if (ret != 0) goto cleanup;
    i = (size_t)0;
    while (i < slen) {
      if (i == (size_t)0) 
        if ((int)*(s + i) == '-') {
          X->s = -1;
          goto __Cont;
        }
      ret = mpi_get_digit(& d,radix,*(s + i));
      if (ret != 0) goto cleanup;
      ret = mpi_mul_int(& T,(mpi const *)X,(t_sint)radix);
      if (ret != 0) goto cleanup;
      if (X->s == 1) {
        ret = mpi_add_int(X,(mpi const *)(& T),(t_sint)d);
        if (ret != 0) goto cleanup;
      }
      else {
        ret = mpi_sub_int(X,(mpi const *)(& T),(t_sint)d);
        if (ret != 0) goto cleanup;
      }
      __Cont: i ++;
    }
  }
  cleanup: mpi_free(& T);
  __retres = ret;
  return_label: return __retres;
}

static int mpi_write_hlp(mpi *X, int radix, char **p)
{
  int __retres;
  int ret;
  t_uint r;
  int tmp;
  if (radix < 2) {
    __retres = -0x0004;
    goto return_label;
  }
  else 
    if (radix > 16) {
      __retres = -0x0004;
      goto return_label;
    }
  ret = mpi_mod_int(& r,(mpi const *)X,(t_sint)radix);
  if (ret != 0) goto cleanup;
  ret = mpi_div_int(X,(mpi *)0,(mpi const *)X,(t_sint)radix);
  if (ret != 0) goto cleanup;
  tmp = mpi_cmp_int((mpi const *)X,(t_sint)0);
  if (tmp != 0) {
    ret = mpi_write_hlp(X,radix,p);
    if (ret != 0) goto cleanup;
  }
  if (r < (t_uint)10) {
    char *tmp_0;
    tmp_0 = *p;
    (*p) ++;
    *tmp_0 = (char)(r + (t_uint)0x30);
  }
  else {
    char *tmp_1;
    tmp_1 = *p;
    (*p) ++;
    *tmp_1 = (char)(r + (t_uint)0x37);
  }
  cleanup: ;
  __retres = ret;
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: *(format + (0 ..))), (indirect: param0);
    assigns *(s + (0 ..)) \from (indirect: *(format + (0 ..))), param0;
 */
int sprintf_va_1(char * restrict s, char const * restrict format,
                 unsigned int param0);

int mpi_write_string(mpi const *X, int radix, char *s, size_t *slen)
{
  int __retres;
  size_t n;
  char *p;
  mpi T;
  char *tmp_1;
  int ret = 0;
  if (radix < 2) {
    __retres = -0x0004;
    goto return_label;
  }
  else 
    if (radix > 16) {
      __retres = -0x0004;
      goto return_label;
    }
  n = mpi_msb(X);
  if (radix >= 4) n >>= 1;
  if (radix >= 16) n >>= 1;
  n += (size_t)3;
  if (*slen < n) {
    *slen = n;
    __retres = -0x0008;
    goto return_label;
  }
  p = s;
  mpi_init(& T);
  if (X->s == -1) {
    char *tmp;
    tmp = p;
    p ++;
    *tmp = (char)'-';
  }
  if (radix == 16) {
    int c;
    size_t i;
    size_t j;
    size_t k;
    i = X->n;
    k = (size_t)0;
    while (i > (size_t)0) {
      j = sizeof(t_uint);
      while (j > (size_t)0) {
        {
          int tmp_0;
          c = (int)((*(X->p + (i - (size_t)1)) >> ((j - (size_t)1) << 3)) & (unsigned long)0xFF);
          if (c == 0) 
            if (k == (size_t)0) 
              if ((i + j) + (size_t)3 != (size_t)0) goto __Cont;
          tmp_0 = sprintf(p,"%02X",(unsigned int)c); /* sprintf_va_1 */
          p += tmp_0;
          k = (size_t)1;
        }
        __Cont: j --;
      }
      i --;
    }
  }
  else {
    ret = mpi_copy(& T,X);
    if (ret != 0) goto cleanup;
    if (T.s == -1) T.s = 1;
    ret = mpi_write_hlp(& T,radix,& p);
    if (ret != 0) goto cleanup;
  }
  tmp_1 = p;
  p ++;
  *tmp_1 = (char)'\000';
  *slen = (size_t)(p - s);
  cleanup: mpi_free(& T);
  __retres = ret;
  return_label: return __retres;
}

int mpi_read_file(mpi *X, int radix, FILE *fin)
{
  int __retres;
  t_uint d;
  size_t slen;
  char *p;
  char s[1250];
  char *tmp;
  int tmp_1;
  memset((void *)(s),0,sizeof(s));
  tmp = fgets(s,(int)(sizeof(s) - (unsigned int)1),fin);
  if (tmp == (char *)0) {
    __retres = -0x0002;
    goto return_label;
  }
  slen = strlen((char const *)(s));
  if (slen == sizeof(s) - (unsigned int)2) {
    __retres = -0x0008;
    goto return_label;
  }
  if ((int)s[slen - (size_t)1] == '\n') {
    slen --;
    s[slen] = (char)'\000';
  }
  if ((int)s[slen - (size_t)1] == '\r') {
    slen --;
    s[slen] = (char)'\000';
  }
  p = & s[slen];
  while (1) {
    int tmp_0;
    p --;
    if (! (p >= s)) break;
    tmp_0 = mpi_get_digit(& d,radix,*p);
    if (tmp_0 != 0) break;
  }
  tmp_1 = mpi_read_string(X,radix,(char const *)(p + 1));
  __retres = tmp_1;
  return_label: return __retres;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param1 + (0 ..)), *(param0 + (0 ..));
 */
int printf_va_30(char const * restrict format, char *param0, char *param1);

int mpi_write_file(char const *p, mpi const *X, int radix, FILE *fout)
{
  int __retres;
  int ret;
  size_t n;
  size_t slen;
  size_t plen;
  char s[2 * 512 + 2];
  size_t tmp;
  size_t tmp_0;
  n = sizeof(s);
  memset((void *)(s),0,n);
  n -= (size_t)2;
  ret = mpi_write_string(X,radix,s,& n);
  if (ret != 0) goto cleanup;
  if (p == (char const *)0) p = "";
  plen = strlen(p);
  slen = strlen((char const *)(s));
  tmp = slen;
  slen ++;
  s[tmp] = (char)'\r';
  tmp_0 = slen;
  slen ++;
  s[tmp_0] = (char)'\n';
  if (fout != (FILE *)0) {
    size_t tmp_1;
    tmp_1 = fwrite((void const *)p,(size_t)1,plen,fout);
    ;
    if (tmp_1 != plen) {
      __retres = -0x0002;
      goto return_label;
    }
    else {
      size_t tmp_2;
      tmp_2 = fwrite((void const *)(s),(size_t)1,slen,fout);
      ;
      if (tmp_2 != slen) {
        __retres = -0x0002;
        goto return_label;
      }
    }
  }
  else printf("%s%s",(char *)p,s); /* printf_va_30 */
  cleanup: ;
  __retres = ret;
  return_label: return __retres;
}

/*@ requires \valid_read(buf + (0 .. buflen - 1));
    requires \valid(X);
    ensures \old(X)->s ≡ 1 ∨ \old(X)->s ≡ -1;
    assigns \result, *X, _state;
    assigns \result \from _state;
    assigns *X \from _state;
    assigns _state \from _state;
 */
int mpi_read_binary(mpi *X, unsigned char const *buf, size_t buflen)
{
  int ret;
  size_t i;
  size_t j;
  size_t n;
  n = (size_t)0;
  while (n < buflen) {
    if ((int)*(buf + n) != 0) break;
    n ++;
  }
  ret = mpi_grow(X,
                 (((buflen - n) + sizeof(t_uint)) - (size_t)1) / sizeof(t_uint));
  if (ret != 0) goto cleanup;
  ret = mpi_lset(X,(t_sint)0);
  if (ret != 0) goto cleanup;
  i = buflen;
  j = (size_t)0;
  while (i > n) {
    *(X->p + j / sizeof(t_uint)) |= (t_uint)*(buf + (i - (size_t)1)) << (
                                    j % sizeof(t_uint) << 3);
    i --;
    j ++;
  }
  cleanup: ;
  return ret;
}

/*@ requires \valid_read(X);
    ensures \initialized(\old(buf) + (0 .. \old(buflen) - 1));
    assigns \result, *(buf + (0 .. buflen - 1)), _state;
    assigns \result \from _state;
    assigns *(buf + (0 .. buflen - 1)) \from _state;
    assigns _state \from _state;
 */
int mpi_write_binary(mpi const *X, unsigned char *buf, size_t buflen)
{
  int __retres;
  size_t i;
  size_t j;
  size_t n;
  n = mpi_size(X);
  if (buflen < n) {
    __retres = -0x0008;
    goto return_label;
  }
  memset((void *)buf,0,buflen);
  i = buflen - (size_t)1;
  j = (size_t)0;
  while (n > (size_t)0) {
    *(buf + i) = (unsigned char)(*(X->p + j / sizeof(t_uint)) >> (j % sizeof(t_uint) << 3));
    i --;
    j ++;
    n --;
  }
  __retres = 0;
  return_label: return __retres;
}

int mpi_shift_l(mpi *X, size_t count)
{
  int ret;
  size_t i;
  size_t v0;
  size_t t1;
  t_uint r1;
  size_t tmp;
  t_uint r0 = (t_uint)0;
  v0 = count / (sizeof(t_uint) << 3);
  t1 = count & ((sizeof(t_uint) << 3) - (unsigned int)1);
  tmp = mpi_msb((mpi const *)X);
  i = tmp + count;
  if (X->n * (sizeof(t_uint) << 3) < i) {
    ret = mpi_grow(X,
                   ((i + (sizeof(t_uint) << 3)) - (size_t)1) / (sizeof(t_uint) << 3));
    if (ret != 0) goto cleanup;
  }
  ret = 0;
  if (v0 > (size_t)0) {
    i = X->n;
    while (i > v0) {
      *(X->p + (i - (size_t)1)) = *(X->p + ((i - v0) - (size_t)1));
      i --;
    }
    while (i > (size_t)0) {
      *(X->p + (i - (size_t)1)) = (t_uint)0;
      i --;
    }
  }
  if (t1 > (size_t)0) {
    i = v0;
    while (i < X->n) {
      r1 = *(X->p + i) >> ((sizeof(t_uint) << 3) - t1);
      *(X->p + i) <<= t1;
      *(X->p + i) |= r0;
      r0 = r1;
      i ++;
    }
  }
  cleanup: ;
  return ret;
}

int mpi_shift_r(mpi *X, size_t count)
{
  int __retres;
  size_t i;
  size_t v0;
  size_t v1;
  t_uint r1;
  t_uint r0 = (t_uint)0;
  v0 = count / (sizeof(t_uint) << 3);
  v1 = count & ((sizeof(t_uint) << 3) - (unsigned int)1);
  if (v0 > X->n) goto _LOR;
  else 
    if (v0 == X->n) 
      if (v1 > (size_t)0) {
        int tmp;
        _LOR: tmp = mpi_lset(X,(t_sint)0);
        __retres = tmp;
        goto return_label;
      }
  if (v0 > (size_t)0) {
    i = (size_t)0;
    while (i < X->n - v0) {
      *(X->p + i) = *(X->p + (i + v0));
      i ++;
    }
    while (i < X->n) {
      *(X->p + i) = (t_uint)0;
      i ++;
    }
  }
  if (v1 > (size_t)0) {
    i = X->n;
    while (i > (size_t)0) {
      r1 = *(X->p + (i - (size_t)1)) << ((sizeof(t_uint) << 3) - v1);
      *(X->p + (i - (size_t)1)) >>= v1;
      *(X->p + (i - (size_t)1)) |= r0;
      r0 = r1;
      i --;
    }
  }
  __retres = 0;
  return_label: return __retres;
}

/*@ requires \valid_read(X);
    requires \valid_read(Y);
    assigns \result, _state;
    assigns \result \from _state;
    assigns _state \from _state;
 */
int mpi_cmp_abs(mpi const *X, mpi const *Y)
{
  int __retres;
  size_t i;
  size_t j;
  i = X->n;
  while (i > (size_t)0) {
    if (*(X->p + (i - (size_t)1)) != (t_uint)0) break;
    i --;
  }
  j = Y->n;
  while (j > (size_t)0) {
    if (*(Y->p + (j - (size_t)1)) != (t_uint)0) break;
    j --;
  }
  if (i == (size_t)0) 
    if (j == (size_t)0) {
      __retres = 0;
      goto return_label;
    }
  if (i > j) {
    __retres = 1;
    goto return_label;
  }
  if (j > i) {
    __retres = -1;
    goto return_label;
  }
  while (i > (size_t)0) {
    if (*(X->p + (i - (size_t)1)) > *(Y->p + (i - (size_t)1))) {
      __retres = 1;
      goto return_label;
    }
    if (*(X->p + (i - (size_t)1)) < *(Y->p + (i - (size_t)1))) {
      __retres = -1;
      goto return_label;
    }
    i --;
  }
  __retres = 0;
  return_label: return __retres;
}

/*@ requires \valid_read(X);
    requires \valid_read(Y);
    assigns \result, _state;
    assigns \result \from _state;
    assigns _state \from _state;
 */
int mpi_cmp_mpi(mpi const *X, mpi const *Y)
{
  int __retres;
  size_t i;
  size_t j;
  i = X->n;
  while (i > (size_t)0) {
    if (*(X->p + (i - (size_t)1)) != (t_uint)0) break;
    i --;
  }
  j = Y->n;
  while (j > (size_t)0) {
    if (*(Y->p + (j - (size_t)1)) != (t_uint)0) break;
    j --;
  }
  if (i == (size_t)0) 
    if (j == (size_t)0) {
      __retres = 0;
      goto return_label;
    }
  if (i > j) {
    __retres = X->s;
    goto return_label;
  }
  if (j > i) {
    __retres = - Y->s;
    goto return_label;
  }
  if (X->s > 0) 
    if (Y->s < 0) {
      __retres = 1;
      goto return_label;
    }
  if (Y->s > 0) 
    if (X->s < 0) {
      __retres = -1;
      goto return_label;
    }
  while (i > (size_t)0) {
    if (*(X->p + (i - (size_t)1)) > *(Y->p + (i - (size_t)1))) {
      __retres = X->s;
      goto return_label;
    }
    if (*(X->p + (i - (size_t)1)) < *(Y->p + (i - (size_t)1))) {
      __retres = - X->s;
      goto return_label;
    }
    i --;
  }
  __retres = 0;
  return_label: return __retres;
}

int mpi_cmp_int(mpi const *X, t_sint z)
{
  mpi Y;
  t_uint p[1];
  int tmp;
  if (z < (t_sint)0) p[0] = (t_uint)(- z); else p[0] = (t_uint)z;
  if (z < (t_sint)0) Y.s = -1; else Y.s = 1;
  Y.n = (size_t)1;
  Y.p = p;
  tmp = mpi_cmp_mpi(X,(mpi const *)(& Y));
  return tmp;
}

/*@ requires \valid(X);
    requires \valid_read(A);
    requires \valid_read(B);
    ensures \old(X)->s ≡ 1 ∨ \old(X)->s ≡ -1;
    assigns *X, \result, _state;
    assigns *X \from _state;
    assigns \result \from _state;
    assigns _state \from _state;
 */
int mpi_add_abs(mpi *X, mpi const *A, mpi const *B)
{
  int ret;
  size_t i;
  size_t j;
  t_uint *o;
  t_uint *p;
  t_uint c;
  if ((void *)X == (void *)B) {
    mpi const *T = A;
    A = (mpi const *)X;
    B = T;
  }
  if ((void *)X != (void *)A) {
    ret = mpi_copy(X,A);
    if (ret != 0) goto cleanup;
  }
  X->s = 1;
  j = B->n;
  while (j > (size_t)0) {
    if (*(B->p + (j - (size_t)1)) != (t_uint)0) break;
    j --;
  }
  ret = mpi_grow(X,j);
  if (ret != 0) goto cleanup;
  o = B->p;
  p = X->p;
  c = (t_uint)0;
  i = (size_t)0;
  while (i < j) {
    *p += c;
    c = (t_uint)(*p < c);
    *p += *o;
    c += (t_uint)(*p < *o);
    i ++;
    o ++;
    p ++;
  }
  while (c != (t_uint)0) {
    if (i >= X->n) {
      ret = mpi_grow(X,i + (size_t)1);
      if (ret != 0) goto cleanup;
      p = X->p + i;
    }
    *p += c;
    c = (t_uint)(*p < c);
    i ++;
    p ++;
  }
  cleanup: ;
  return ret;
}

static void mpi_sub_hlp(size_t n, t_uint *s, t_uint *d)
{
  size_t i;
  t_uint c;
  t_uint z;
  c = (t_uint)0;
  i = (size_t)c;
  while (i < n) {
    z = (t_uint)(*d < c);
    *d -= c;
    c = (t_uint)(*d < *s) + z;
    *d -= *s;
    i ++;
    s ++;
    d ++;
  }
  while (c != (t_uint)0) {
    z = (t_uint)(*d < c);
    *d -= c;
    c = z;
    i ++;
    d ++;
  }
  return;
}

/*@ requires \valid(X);
    requires \valid_read(A);
    requires \valid_read(B);
    ensures \old(X)->s ≡ 1 ∨ \old(X)->s ≡ -1;
    assigns *X, \result, _state;
    assigns *X \from _state;
    assigns \result \from _state;
    assigns _state \from _state;
 */
int mpi_sub_abs(mpi *X, mpi const *A, mpi const *B)
{
  int __retres;
  mpi TB;
  int ret;
  size_t n;
  int tmp;
  tmp = mpi_cmp_abs(A,B);
  if (tmp < 0) {
    __retres = -0x000A;
    goto return_label;
  }
  mpi_init(& TB);
  if ((void *)X == (void *)B) {
    ret = mpi_copy(& TB,B);
    if (ret != 0) goto cleanup;
    B = (mpi const *)(& TB);
  }
  if ((void *)X != (void *)A) {
    ret = mpi_copy(X,A);
    if (ret != 0) goto cleanup;
  }
  X->s = 1;
  ret = 0;
  n = B->n;
  while (n > (size_t)0) {
    if (*(B->p + (n - (size_t)1)) != (t_uint)0) break;
    n --;
  }
  mpi_sub_hlp(n,B->p,X->p);
  cleanup: mpi_free(& TB);
  __retres = ret;
  return_label: return __retres;
}

int mpi_add_mpi(mpi *X, mpi const *A, mpi const *B)
{
  int ret;
  int s = A->s;
  if (A->s * B->s < 0) {
    int tmp;
    tmp = mpi_cmp_abs(A,B);
    if (tmp >= 0) {
      ret = mpi_sub_abs(X,A,B);
      if (ret != 0) goto cleanup;
      X->s = s;
    }
    else {
      ret = mpi_sub_abs(X,B,A);
      if (ret != 0) goto cleanup;
      X->s = - s;
    }
  }
  else {
    ret = mpi_add_abs(X,A,B);
    if (ret != 0) goto cleanup;
    X->s = s;
  }
  cleanup: ;
  return ret;
}

/*@ requires \valid(X);
    requires \valid_read(A);
    requires \valid_read(B);
    ensures \old(X)->s ≡ 1 ∨ \old(X)->s ≡ -1;
    assigns *X, \result, _state;
    assigns *X \from _state;
    assigns \result \from _state;
    assigns _state \from _state;
 */
int mpi_sub_mpi(mpi *X, mpi const *A, mpi const *B)
{
  int ret;
  int s = A->s;
  if (A->s * B->s > 0) {
    int tmp;
    tmp = mpi_cmp_abs(A,B);
    if (tmp >= 0) {
      ret = mpi_sub_abs(X,A,B);
      if (ret != 0) goto cleanup;
      X->s = s;
    }
    else {
      ret = mpi_sub_abs(X,B,A);
      if (ret != 0) goto cleanup;
      X->s = - s;
    }
  }
  else {
    ret = mpi_add_abs(X,A,B);
    if (ret != 0) goto cleanup;
    X->s = s;
  }
  cleanup: ;
  return ret;
}

int mpi_add_int(mpi *X, mpi const *A, t_sint b)
{
  mpi _B;
  t_uint p[1];
  int tmp;
  if (b < (t_sint)0) p[0] = (t_uint)(- b); else p[0] = (t_uint)b;
  if (b < (t_sint)0) _B.s = -1; else _B.s = 1;
  _B.n = (size_t)1;
  _B.p = p;
  tmp = mpi_add_mpi(X,A,(mpi const *)(& _B));
  return tmp;
}

int mpi_sub_int(mpi *X, mpi const *A, t_sint b)
{
  mpi _B;
  t_uint p[1];
  int tmp;
  if (b < (t_sint)0) p[0] = (t_uint)(- b); else p[0] = (t_uint)b;
  if (b < (t_sint)0) _B.s = -1; else _B.s = 1;
  _B.n = (size_t)1;
  _B.p = p;
  tmp = mpi_sub_mpi(X,A,(mpi const *)(& _B));
  return tmp;
}

static void mpi_mul_hlp(size_t i, t_uint *s, t_uint *d, t_uint b)
{
  t_uint c = (t_uint)0;
  t_uint t = (t_uint)0;
  while (i >= (size_t)16) {
    /*@ assigns *(s + (..));
        assigns *(s + (..)) \from (indirect: s), *(s + (..));
    */
    __asm__ ("movq   %0, %%rsi      " :  : "m" (s));
    /*@ assigns *(d + (..));
        assigns *(d + (..)) \from (indirect: d), *(d + (..));
    */
    __asm__ ("movq   %0, %%rdi      " :  : "m" (d));
    /*@ assigns \nothing; */
    __asm__ ("movq   %0, %%rcx      " :  : "m" (c));
    /*@ assigns \nothing; */
    __asm__ ("movq   %0, %%rbx      " :  : "m" (b));
    __asm__ ("xorq   %r8, %r8       ");
    __asm__ ("movq  (%rsi),%rax     ");
    __asm__ ("mulq   %rbx           ");
    __asm__ ("addq   $8,   %rsi     ");
    __asm__ ("addq   %rcx, %rax     ");
    __asm__ ("movq   %r8,  %rcx     ");
    __asm__ ("adcq   $0,   %rdx     ");
    __asm__ ("nop                   ");
    __asm__ ("addq   %rax, (%rdi)   ");
    __asm__ ("adcq   %rdx, %rcx     ");
    __asm__ ("addq   $8,   %rdi     ");
    __asm__ ("movq  (%rsi),%rax     ");
    __asm__ ("mulq   %rbx           ");
    __asm__ ("addq   $8,   %rsi     ");
    __asm__ ("addq   %rcx, %rax     ");
    __asm__ ("movq   %r8,  %rcx     ");
    __asm__ ("adcq   $0,   %rdx     ");
    __asm__ ("nop                   ");
    __asm__ ("addq   %rax, (%rdi)   ");
    __asm__ ("adcq   %rdx, %rcx     ");
    __asm__ ("addq   $8,   %rdi     ");
    __asm__ ("movq  (%rsi),%rax     ");
    __asm__ ("mulq   %rbx           ");
    __asm__ ("addq   $8,   %rsi     ");
    __asm__ ("addq   %rcx, %rax     ");
    __asm__ ("movq   %r8,  %rcx     ");
    __asm__ ("adcq   $0,   %rdx     ");
    __asm__ ("nop                   ");
    __asm__ ("addq   %rax, (%rdi)   ");
    __asm__ ("adcq   %rdx, %rcx     ");
    __asm__ ("addq   $8,   %rdi     ");
    __asm__ ("movq  (%rsi),%rax     ");
    __asm__ ("mulq   %rbx           ");
    __asm__ ("addq   $8,   %rsi     ");
    __asm__ ("addq   %rcx, %rax     ");
    __asm__ ("movq   %r8,  %rcx     ");
    __asm__ ("adcq   $0,   %rdx     ");
    __asm__ ("nop                   ");
    __asm__ ("addq   %rax, (%rdi)   ");
    __asm__ ("adcq   %rdx, %rcx     ");
    __asm__ ("addq   $8,   %rdi     ");
    __asm__ ("movq  (%rsi),%rax     ");
    __asm__ ("mulq   %rbx           ");
    __asm__ ("addq   $8,   %rsi     ");
    __asm__ ("addq   %rcx, %rax     ");
    __asm__ ("movq   %r8,  %rcx     ");
    __asm__ ("adcq   $0,   %rdx     ");
    __asm__ ("nop                   ");
    __asm__ ("addq   %rax, (%rdi)   ");
    __asm__ ("adcq   %rdx, %rcx     ");
    __asm__ ("addq   $8,   %rdi     ");
    __asm__ ("movq  (%rsi),%rax     ");
    __asm__ ("mulq   %rbx           ");
    __asm__ ("addq   $8,   %rsi     ");
    __asm__ ("addq   %rcx, %rax     ");
    __asm__ ("movq   %r8,  %rcx     ");
    __asm__ ("adcq   $0,   %rdx     ");
    __asm__ ("nop                   ");
    __asm__ ("addq   %rax, (%rdi)   ");
    __asm__ ("adcq   %rdx, %rcx     ");
    __asm__ ("addq   $8,   %rdi     ");
    __asm__ ("movq  (%rsi),%rax     ");
    __asm__ ("mulq   %rbx           ");
    __asm__ ("addq   $8,   %rsi     ");
    __asm__ ("addq   %rcx, %rax     ");
    __asm__ ("movq   %r8,  %rcx     ");
    __asm__ ("adcq   $0,   %rdx     ");
    __asm__ ("nop                   ");
    __asm__ ("addq   %rax, (%rdi)   ");
    __asm__ ("adcq   %rdx, %rcx     ");
    __asm__ ("addq   $8,   %rdi     ");
    __asm__ ("movq  (%rsi),%rax     ");
    __asm__ ("mulq   %rbx           ");
    __asm__ ("addq   $8,   %rsi     ");
    __asm__ ("addq   %rcx, %rax     ");
    __asm__ ("movq   %r8,  %rcx     ");
    __asm__ ("adcq   $0,   %rdx     ");
    __asm__ ("nop                   ");
    __asm__ ("addq   %rax, (%rdi)   ");
    __asm__ ("adcq   %rdx, %rcx     ");
    __asm__ ("addq   $8,   %rdi     ");
    __asm__ ("movq  (%rsi),%rax     ");
    __asm__ ("mulq   %rbx           ");
    __asm__ ("addq   $8,   %rsi     ");
    __asm__ ("addq   %rcx, %rax     ");
    __asm__ ("movq   %r8,  %rcx     ");
    __asm__ ("adcq   $0,   %rdx     ");
    __asm__ ("nop                   ");
    __asm__ ("addq   %rax, (%rdi)   ");
    __asm__ ("adcq   %rdx, %rcx     ");
    __asm__ ("addq   $8,   %rdi     ");
    __asm__ ("movq  (%rsi),%rax     ");
    __asm__ ("mulq   %rbx           ");
    __asm__ ("addq   $8,   %rsi     ");
    __asm__ ("addq   %rcx, %rax     ");
    __asm__ ("movq   %r8,  %rcx     ");
    __asm__ ("adcq   $0,   %rdx     ");
    __asm__ ("nop                   ");
    __asm__ ("addq   %rax, (%rdi)   ");
    __asm__ ("adcq   %rdx, %rcx     ");
    __asm__ ("addq   $8,   %rdi     ");
    __asm__ ("movq  (%rsi),%rax     ");
    __asm__ ("mulq   %rbx           ");
    __asm__ ("addq   $8,   %rsi     ");
    __asm__ ("addq   %rcx, %rax     ");
    __asm__ ("movq   %r8,  %rcx     ");
    __asm__ ("adcq   $0,   %rdx     ");
    __asm__ ("nop                   ");
    __asm__ ("addq   %rax, (%rdi)   ");
    __asm__ ("adcq   %rdx, %rcx     ");
    __asm__ ("addq   $8,   %rdi     ");
    __asm__ ("movq  (%rsi),%rax     ");
    __asm__ ("mulq   %rbx           ");
    __asm__ ("addq   $8,   %rsi     ");
    __asm__ ("addq   %rcx, %rax     ");
    __asm__ ("movq   %r8,  %rcx     ");
    __asm__ ("adcq   $0,   %rdx     ");
    __asm__ ("nop                   ");
    __asm__ ("addq   %rax, (%rdi)   ");
    __asm__ ("adcq   %rdx, %rcx     ");
    __asm__ ("addq   $8,   %rdi     ");
    __asm__ ("movq  (%rsi),%rax     ");
    __asm__ ("mulq   %rbx           ");
    __asm__ ("addq   $8,   %rsi     ");
    __asm__ ("addq   %rcx, %rax     ");
    __asm__ ("movq   %r8,  %rcx     ");
    __asm__ ("adcq   $0,   %rdx     ");
    __asm__ ("nop                   ");
    __asm__ ("addq   %rax, (%rdi)   ");
    __asm__ ("adcq   %rdx, %rcx     ");
    __asm__ ("addq   $8,   %rdi     ");
    __asm__ ("movq  (%rsi),%rax     ");
    __asm__ ("mulq   %rbx           ");
    __asm__ ("addq   $8,   %rsi     ");
    __asm__ ("addq   %rcx, %rax     ");
    __asm__ ("movq   %r8,  %rcx     ");
    __asm__ ("adcq   $0,   %rdx     ");
    __asm__ ("nop                   ");
    __asm__ ("addq   %rax, (%rdi)   ");
    __asm__ ("adcq   %rdx, %rcx     ");
    __asm__ ("addq   $8,   %rdi     ");
    __asm__ ("movq  (%rsi),%rax     ");
    __asm__ ("mulq   %rbx           ");
    __asm__ ("addq   $8,   %rsi     ");
    __asm__ ("addq   %rcx, %rax     ");
    __asm__ ("movq   %r8,  %rcx     ");
    __asm__ ("adcq   $0,   %rdx     ");
    __asm__ ("nop                   ");
    __asm__ ("addq   %rax, (%rdi)   ");
    __asm__ ("adcq   %rdx, %rcx     ");
    __asm__ ("addq   $8,   %rdi     ");
    __asm__ ("movq  (%rsi),%rax     ");
    __asm__ ("mulq   %rbx           ");
    __asm__ ("addq   $8,   %rsi     ");
    __asm__ ("addq   %rcx, %rax     ");
    __asm__ ("movq   %r8,  %rcx     ");
    __asm__ ("adcq   $0,   %rdx     ");
    __asm__ ("nop                   ");
    __asm__ ("addq   %rax, (%rdi)   ");
    __asm__ ("adcq   %rdx, %rcx     ");
    __asm__ ("addq   $8,   %rdi     ");
    /*@ assigns c;
        assigns c \from \nothing; */
    __asm__ ("movq   %%rcx, %0      " : "=m" (c));
    /*@ assigns d;
        assigns d \from \nothing; */
    __asm__ ("movq   %%rdi, %0      " : "=m" (d));
    /*@ assigns s;
        assigns s \from \nothing; */
    __asm__ (
      "movq   %%rsi, %0      "
      : "=m" (s)
      : 
      : "rax", "rcx", "rdx", "rbx", "rsi", "rdi", "r8"
      );
    i -= (size_t)16;
  }
  while (i >= (size_t)8) {
    /*@ assigns *(s + (..));
        assigns *(s + (..)) \from (indirect: s), *(s + (..));
    */
    __asm__ ("movq   %0, %%rsi      " :  : "m" (s));
    /*@ assigns *(d + (..));
        assigns *(d + (..)) \from (indirect: d), *(d + (..));
    */
    __asm__ ("movq   %0, %%rdi      " :  : "m" (d));
    /*@ assigns \nothing; */
    __asm__ ("movq   %0, %%rcx      " :  : "m" (c));
    /*@ assigns \nothing; */
    __asm__ ("movq   %0, %%rbx      " :  : "m" (b));
    __asm__ ("xorq   %r8, %r8       ");
    __asm__ ("movq  (%rsi),%rax     ");
    __asm__ ("mulq   %rbx           ");
    __asm__ ("addq   $8,   %rsi     ");
    __asm__ ("addq   %rcx, %rax     ");
    __asm__ ("movq   %r8,  %rcx     ");
    __asm__ ("adcq   $0,   %rdx     ");
    __asm__ ("nop                   ");
    __asm__ ("addq   %rax, (%rdi)   ");
    __asm__ ("adcq   %rdx, %rcx     ");
    __asm__ ("addq   $8,   %rdi     ");
    __asm__ ("movq  (%rsi),%rax     ");
    __asm__ ("mulq   %rbx           ");
    __asm__ ("addq   $8,   %rsi     ");
    __asm__ ("addq   %rcx, %rax     ");
    __asm__ ("movq   %r8,  %rcx     ");
    __asm__ ("adcq   $0,   %rdx     ");
    __asm__ ("nop                   ");
    __asm__ ("addq   %rax, (%rdi)   ");
    __asm__ ("adcq   %rdx, %rcx     ");
    __asm__ ("addq   $8,   %rdi     ");
    __asm__ ("movq  (%rsi),%rax     ");
    __asm__ ("mulq   %rbx           ");
    __asm__ ("addq   $8,   %rsi     ");
    __asm__ ("addq   %rcx, %rax     ");
    __asm__ ("movq   %r8,  %rcx     ");
    __asm__ ("adcq   $0,   %rdx     ");
    __asm__ ("nop                   ");
    __asm__ ("addq   %rax, (%rdi)   ");
    __asm__ ("adcq   %rdx, %rcx     ");
    __asm__ ("addq   $8,   %rdi     ");
    __asm__ ("movq  (%rsi),%rax     ");
    __asm__ ("mulq   %rbx           ");
    __asm__ ("addq   $8,   %rsi     ");
    __asm__ ("addq   %rcx, %rax     ");
    __asm__ ("movq   %r8,  %rcx     ");
    __asm__ ("adcq   $0,   %rdx     ");
    __asm__ ("nop                   ");
    __asm__ ("addq   %rax, (%rdi)   ");
    __asm__ ("adcq   %rdx, %rcx     ");
    __asm__ ("addq   $8,   %rdi     ");
    __asm__ ("movq  (%rsi),%rax     ");
    __asm__ ("mulq   %rbx           ");
    __asm__ ("addq   $8,   %rsi     ");
    __asm__ ("addq   %rcx, %rax     ");
    __asm__ ("movq   %r8,  %rcx     ");
    __asm__ ("adcq   $0,   %rdx     ");
    __asm__ ("nop                   ");
    __asm__ ("addq   %rax, (%rdi)   ");
    __asm__ ("adcq   %rdx, %rcx     ");
    __asm__ ("addq   $8,   %rdi     ");
    __asm__ ("movq  (%rsi),%rax     ");
    __asm__ ("mulq   %rbx           ");
    __asm__ ("addq   $8,   %rsi     ");
    __asm__ ("addq   %rcx, %rax     ");
    __asm__ ("movq   %r8,  %rcx     ");
    __asm__ ("adcq   $0,   %rdx     ");
    __asm__ ("nop                   ");
    __asm__ ("addq   %rax, (%rdi)   ");
    __asm__ ("adcq   %rdx, %rcx     ");
    __asm__ ("addq   $8,   %rdi     ");
    __asm__ ("movq  (%rsi),%rax     ");
    __asm__ ("mulq   %rbx           ");
    __asm__ ("addq   $8,   %rsi     ");
    __asm__ ("addq   %rcx, %rax     ");
    __asm__ ("movq   %r8,  %rcx     ");
    __asm__ ("adcq   $0,   %rdx     ");
    __asm__ ("nop                   ");
    __asm__ ("addq   %rax, (%rdi)   ");
    __asm__ ("adcq   %rdx, %rcx     ");
    __asm__ ("addq   $8,   %rdi     ");
    __asm__ ("movq  (%rsi),%rax     ");
    __asm__ ("mulq   %rbx           ");
    __asm__ ("addq   $8,   %rsi     ");
    __asm__ ("addq   %rcx, %rax     ");
    __asm__ ("movq   %r8,  %rcx     ");
    __asm__ ("adcq   $0,   %rdx     ");
    __asm__ ("nop                   ");
    __asm__ ("addq   %rax, (%rdi)   ");
    __asm__ ("adcq   %rdx, %rcx     ");
    __asm__ ("addq   $8,   %rdi     ");
    /*@ assigns c;
        assigns c \from \nothing; */
    __asm__ ("movq   %%rcx, %0      " : "=m" (c));
    /*@ assigns d;
        assigns d \from \nothing; */
    __asm__ ("movq   %%rdi, %0      " : "=m" (d));
    /*@ assigns s;
        assigns s \from \nothing; */
    __asm__ (
      "movq   %%rsi, %0      "
      : "=m" (s)
      : 
      : "rax", "rcx", "rdx", "rbx", "rsi", "rdi", "r8"
      );
    i -= (size_t)8;
  }
  while (i > (size_t)0) {
    /*@ assigns *(s + (..));
        assigns *(s + (..)) \from (indirect: s), *(s + (..));
    */
    __asm__ ("movq   %0, %%rsi      " :  : "m" (s));
    /*@ assigns *(d + (..));
        assigns *(d + (..)) \from (indirect: d), *(d + (..));
    */
    __asm__ ("movq   %0, %%rdi      " :  : "m" (d));
    /*@ assigns \nothing; */
    __asm__ ("movq   %0, %%rcx      " :  : "m" (c));
    /*@ assigns \nothing; */
    __asm__ ("movq   %0, %%rbx      " :  : "m" (b));
    __asm__ ("xorq   %r8, %r8       ");
    __asm__ ("movq  (%rsi),%rax     ");
    __asm__ ("mulq   %rbx           ");
    __asm__ ("addq   $8,   %rsi     ");
    __asm__ ("addq   %rcx, %rax     ");
    __asm__ ("movq   %r8,  %rcx     ");
    __asm__ ("adcq   $0,   %rdx     ");
    __asm__ ("nop                   ");
    __asm__ ("addq   %rax, (%rdi)   ");
    __asm__ ("adcq   %rdx, %rcx     ");
    __asm__ ("addq   $8,   %rdi     ");
    /*@ assigns c;
        assigns c \from \nothing; */
    __asm__ ("movq   %%rcx, %0      " : "=m" (c));
    /*@ assigns d;
        assigns d \from \nothing; */
    __asm__ ("movq   %%rdi, %0      " : "=m" (d));
    /*@ assigns s;
        assigns s \from \nothing; */
    __asm__ (
      "movq   %%rsi, %0      "
      : "=m" (s)
      : 
      : "rax", "rcx", "rdx", "rbx", "rsi", "rdi", "r8"
      );
    i --;
  }
  t ++;
  while (1) {
    *d += c;
    c = (t_uint)(*d < c);
    d ++;
    if (! (c != (t_uint)0)) break;
  }
  return;
}

/*@ requires \valid(X);
    requires \valid_read(A);
    requires \valid_read(B);
    ensures \old(X)->s ≡ 1 ∨ \old(X)->s ≡ -1;
    assigns *X, \result, _state;
    assigns *X \from _state;
    assigns \result \from _state;
    assigns _state \from _state;
 */
int mpi_mul_mpi(mpi *X, mpi const *A, mpi const *B)
{
  int ret;
  size_t i;
  size_t j;
  mpi TA;
  mpi TB;
  mpi_init(& TA);
  mpi_init(& TB);
  if ((void *)X == (void *)A) {
    ret = mpi_copy(& TA,A);
    if (ret != 0) goto cleanup;
    A = (mpi const *)(& TA);
  }
  if ((void *)X == (void *)B) {
    ret = mpi_copy(& TB,B);
    if (ret != 0) goto cleanup;
    B = (mpi const *)(& TB);
  }
  i = A->n;
  while (i > (size_t)0) {
    if (*(A->p + (i - (size_t)1)) != (t_uint)0) break;
    i --;
  }
  j = B->n;
  while (j > (size_t)0) {
    if (*(B->p + (j - (size_t)1)) != (t_uint)0) break;
    j --;
  }
  ret = mpi_grow(X,i + j);
  if (ret != 0) goto cleanup;
  ret = mpi_lset(X,(t_sint)0);
  if (ret != 0) goto cleanup;
  i ++;
  while (j > (size_t)0) {
    mpi_mul_hlp(i - (size_t)1,A->p,(X->p + j) - 1,*(B->p + (j - (size_t)1)));
    j --;
  }
  X->s = A->s * B->s;
  cleanup: mpi_free(& TB);
  mpi_free(& TA);
  return ret;
}

int mpi_mul_int(mpi *X, mpi const *A, t_sint b)
{
  mpi _B;
  t_uint p[1];
  int tmp;
  _B.s = 1;
  _B.n = (size_t)1;
  _B.p = p;
  p[0] = (t_uint)b;
  tmp = mpi_mul_mpi(X,A,(mpi const *)(& _B));
  return tmp;
}

int mpi_div_mpi(mpi *Q, mpi *R, mpi const *A, mpi const *B)
{
  int __retres;
  int ret;
  size_t i;
  size_t n;
  size_t t;
  size_t k;
  mpi X;
  mpi Y;
  mpi Z;
  mpi T1;
  mpi T2;
  int tmp;
  int tmp_0;
  size_t tmp_1;
  tmp = mpi_cmp_int(B,(t_sint)0);
  if (tmp == 0) {
    __retres = -0x000C;
    goto return_label;
  }
  mpi_init(& X);
  mpi_init(& Y);
  mpi_init(& Z);
  mpi_init(& T1);
  mpi_init(& T2);
  tmp_0 = mpi_cmp_abs(A,B);
  if (tmp_0 < 0) {
    if (Q != (mpi *)0) {
      ret = mpi_lset(Q,(t_sint)0);
      if (ret != 0) goto cleanup;
    }
    if (R != (mpi *)0) {
      ret = mpi_copy(R,A);
      if (ret != 0) goto cleanup;
    }
    __retres = 0;
    goto return_label;
  }
  ret = mpi_copy(& X,A);
  if (ret != 0) goto cleanup;
  ret = mpi_copy(& Y,B);
  if (ret != 0) goto cleanup;
  Y.s = 1;
  X.s = Y.s;
  ret = mpi_grow(& Z,A->n + (size_t)2);
  if (ret != 0) goto cleanup;
  ret = mpi_lset(& Z,(t_sint)0);
  if (ret != 0) goto cleanup;
  ret = mpi_grow(& T1,(size_t)2);
  if (ret != 0) goto cleanup;
  ret = mpi_grow(& T2,(size_t)3);
  if (ret != 0) goto cleanup;
  tmp_1 = mpi_msb((mpi const *)(& Y));
  k = tmp_1 % (sizeof(t_uint) << 3);
  if (k < (sizeof(t_uint) << 3) - (unsigned int)1) {
    k = ((sizeof(t_uint) << 3) - (unsigned int)1) - k;
    ret = mpi_shift_l(& X,k);
    if (ret != 0) goto cleanup;
    ret = mpi_shift_l(& Y,k);
    if (ret != 0) goto cleanup;
  }
  else k = (size_t)0;
  n = X.n - (size_t)1;
  t = Y.n - (size_t)1;
  mpi_shift_l(& Y,(sizeof(t_uint) << 3) * (n - t));
  while (1) {
    int tmp_2;
    tmp_2 = mpi_cmp_mpi((mpi const *)(& X),(mpi const *)(& Y));
    if (! (tmp_2 >= 0)) break;
    (*(Z.p + (n - t))) ++;
    mpi_sub_mpi(& X,(mpi const *)(& X),(mpi const *)(& Y));
  }
  mpi_shift_r(& Y,(sizeof(t_uint) << 3) * (n - t));
  i = n;
  while (i > t) {
    {
      int tmp_4;
      if (*(X.p + i) >= *(Y.p + t)) *(Z.p + ((i - t) - (size_t)1)) = (t_uint)(~ 0);
      else {
        t_uint q0;
        t_uint q1;
        t_uint r0;
        t_uint r1;
        t_uint d0;
        t_uint d1;
        t_uint d;
        t_uint m;
        d = *(Y.p + t);
        d0 = (d << (sizeof(t_uint) << 2)) >> (sizeof(t_uint) << 2);
        d1 = d >> (sizeof(t_uint) << 2);
        q1 = *(X.p + i) / d1;
        r1 = *(X.p + i) - d1 * q1;
        r1 <<= sizeof(t_uint) << 2;
        r1 |= *(X.p + (i - (size_t)1)) >> (sizeof(t_uint) << 2);
        m = q1 * d0;
        if (r1 < m) {
          q1 --;
          r1 += d;
          while (1) {
            if (r1 >= d) {
              if (! (r1 < m)) break;
            }
            else break;
            q1 --;
            r1 += d;
          }
        }
        r1 -= m;
        q0 = r1 / d1;
        r0 = r1 - d1 * q0;
        r0 <<= sizeof(t_uint) << 2;
        r0 |= (*(X.p + (i - (size_t)1)) << (sizeof(t_uint) << 2)) >> (
              sizeof(t_uint) << 2);
        m = q0 * d0;
        if (r0 < m) {
          q0 --;
          r0 += d;
          while (1) {
            if (r0 >= d) {
              if (! (r0 < m)) break;
            }
            else break;
            q0 --;
            r0 += d;
          }
        }
        r0 -= m;
        *(Z.p + ((i - t) - (size_t)1)) = (q1 << (sizeof(t_uint) << 2)) | q0;
      }
      (*(Z.p + ((i - t) - (size_t)1))) ++;
      while (1) {
        int tmp_3;
        (*(Z.p + ((i - t) - (size_t)1))) --;
        ret = mpi_lset(& T1,(t_sint)0);
        if (ret != 0) goto cleanup;
        if (t < (size_t)1) *(T1.p + 0) = (t_uint)0;
        else *(T1.p + 0) = *(Y.p + (t - (size_t)1));
        *(T1.p + 1) = *(Y.p + t);
        ret = mpi_mul_int(& T1,(mpi const *)(& T1),
                          (t_sint)*(Z.p + ((i - t) - (size_t)1)));
        if (ret != 0) goto cleanup;
        ret = mpi_lset(& T2,(t_sint)0);
        if (ret != 0) goto cleanup;
        if (i < (size_t)2) *(T2.p + 0) = (t_uint)0;
        else *(T2.p + 0) = *(X.p + (i - (size_t)2));
        if (i < (size_t)1) *(T2.p + 1) = (t_uint)0;
        else *(T2.p + 1) = *(X.p + (i - (size_t)1));
        *(T2.p + 2) = *(X.p + i);
        tmp_3 = mpi_cmp_mpi((mpi const *)(& T1),(mpi const *)(& T2));
        if (! (tmp_3 > 0)) break;
      }
      ret = mpi_mul_int(& T1,(mpi const *)(& Y),
                        (t_sint)*(Z.p + ((i - t) - (size_t)1)));
      if (ret != 0) goto cleanup;
      ret = mpi_shift_l(& T1,(sizeof(t_uint) << 3) * ((i - t) - (size_t)1));
      if (ret != 0) goto cleanup;
      ret = mpi_sub_mpi(& X,(mpi const *)(& X),(mpi const *)(& T1));
      if (ret != 0) goto cleanup;
      tmp_4 = mpi_cmp_int((mpi const *)(& X),(t_sint)0);
      if (tmp_4 < 0) {
        ret = mpi_copy(& T1,(mpi const *)(& Y));
        if (ret != 0) goto cleanup;
        ret = mpi_shift_l(& T1,(sizeof(t_uint) << 3) * ((i - t) - (size_t)1));
        if (ret != 0) goto cleanup;
        ret = mpi_add_mpi(& X,(mpi const *)(& X),(mpi const *)(& T1));
        if (ret != 0) goto cleanup;
        (*(Z.p + ((i - t) - (size_t)1))) --;
      }
    }
    i --;
  }
  if (Q != (mpi *)0) {
    mpi_copy(Q,(mpi const *)(& Z));
    Q->s = A->s * B->s;
  }
  if (R != (mpi *)0) {
    int tmp_5;
    mpi_shift_r(& X,k);
    X.s = A->s;
    mpi_copy(R,(mpi const *)(& X));
    tmp_5 = mpi_cmp_int((mpi const *)R,(t_sint)0);
    if (tmp_5 == 0) R->s = 1;
  }
  cleanup: mpi_free(& X);
  mpi_free(& Y);
  mpi_free(& Z);
  mpi_free(& T1);
  mpi_free(& T2);
  __retres = ret;
  return_label: return __retres;
}

int mpi_div_int(mpi *Q, mpi *R, mpi const *A, t_sint b)
{
  mpi _B;
  t_uint p[1];
  int tmp;
  if (b < (t_sint)0) p[0] = (t_uint)(- b); else p[0] = (t_uint)b;
  if (b < (t_sint)0) _B.s = -1; else _B.s = 1;
  _B.n = (size_t)1;
  _B.p = p;
  tmp = mpi_div_mpi(Q,R,A,(mpi const *)(& _B));
  return tmp;
}

/*@ requires \valid(R);
    requires \valid_read(A);
    requires \valid_read(B);
    ensures \old(R)->s ≡ 1 ∨ \old(R)->s ≡ -1;
    assigns *R, \result, _state;
    assigns *R \from _state;
    assigns \result \from _state;
    assigns _state \from _state;
 */
int mpi_mod_mpi(mpi *R, mpi const *A, mpi const *B)
{
  int __retres;
  int ret;
  int tmp;
  tmp = mpi_cmp_int(B,(t_sint)0);
  if (tmp < 0) {
    __retres = -0x000A;
    goto return_label;
  }
  ret = mpi_div_mpi((mpi *)0,R,A,B);
  if (ret != 0) goto cleanup;
  while (1) {
    int tmp_0;
    tmp_0 = mpi_cmp_int((mpi const *)R,(t_sint)0);
    if (! (tmp_0 < 0)) break;
    ret = mpi_add_mpi(R,(mpi const *)R,B);
    if (ret != 0) goto cleanup;
  }
  while (1) {
    int tmp_1;
    tmp_1 = mpi_cmp_mpi((mpi const *)R,B);
    if (! (tmp_1 >= 0)) break;
    ret = mpi_sub_mpi(R,(mpi const *)R,B);
    if (ret != 0) goto cleanup;
  }
  cleanup: ;
  __retres = ret;
  return_label: return __retres;
}

int mpi_mod_int(t_uint *r, mpi const *A, t_sint b)
{
  int __retres;
  size_t i;
  t_uint x;
  t_uint y;
  t_uint z;
  if (b == (t_sint)0) {
    __retres = -0x000C;
    goto return_label;
  }
  if (b < (t_sint)0) {
    __retres = -0x000A;
    goto return_label;
  }
  if (b == (t_sint)1) {
    *r = (t_uint)0;
    __retres = 0;
    goto return_label;
  }
  if (b == (t_sint)2) {
    *r = *(A->p + 0) & (unsigned long)1;
    __retres = 0;
    goto return_label;
  }
  i = A->n;
  y = (t_uint)0;
  while (i > (size_t)0) {
    x = *(A->p + (i - (size_t)1));
    y = (y << (sizeof(t_uint) << 2)) | (x >> (sizeof(t_uint) << 2));
    z = y / (t_uint)b;
    y -= z * (t_uint)b;
    x <<= sizeof(t_uint) << 2;
    y = (y << (sizeof(t_uint) << 2)) | (x >> (sizeof(t_uint) << 2));
    z = y / (t_uint)b;
    y -= z * (t_uint)b;
    i --;
  }
  if (A->s < 0) 
    if (y != (t_uint)0) y = (t_uint)b - y;
  *r = y;
  __retres = 0;
  return_label: return __retres;
}

static void mpi_montg_init(t_uint *mm, mpi const *N)
{
  t_uint x;
  t_uint m0 = *(N->p + 0);
  x = m0;
  x += ((m0 + (t_uint)2) & (unsigned long)4) << 1;
  x *= (t_uint)2 - m0 * x;
  if (sizeof(t_uint) << 3 >= (unsigned int)16) x *= (t_uint)2 - m0 * x;
  if (sizeof(t_uint) << 3 >= (unsigned int)32) x *= (t_uint)2 - m0 * x;
  if (sizeof(t_uint) << 3 >= (unsigned int)64) x *= (t_uint)2 - m0 * x;
  *mm = ~ x + (t_uint)1;
  return;
}

static void mpi_montmul(mpi *A, mpi const *B, mpi const *N, t_uint mm,
                        mpi const *T)
{
  size_t i;
  size_t n;
  size_t m;
  t_uint u0;
  t_uint u1;
  t_uint *d;
  int tmp_0;
  memset((void *)T->p,0,T->n * sizeof(t_uint));
  d = T->p;
  n = N->n;
  if (B->n < n) m = B->n; else m = n;
  i = (size_t)0;
  while (i < n) {
    {
      t_uint *tmp;
      u0 = *(A->p + i);
      u1 = (*(d + 0) + u0 * *(B->p + 0)) * mm;
      mpi_mul_hlp(m,B->p,d,u0);
      mpi_mul_hlp(n,N->p,d,u1);
      tmp = d;
      d ++;
      *tmp = u0;
      *(d + (n + (size_t)1)) = (t_uint)0;
    }
    i ++;
  }
  memcpy((void *)A->p,(void const *)d,(n + (size_t)1) * sizeof(t_uint));
  tmp_0 = mpi_cmp_abs((mpi const *)A,N);
  if (tmp_0 >= 0) mpi_sub_hlp(n,N->p,A->p); else mpi_sub_hlp(n,A->p,T->p);
  return;
}

static void mpi_montred(mpi *A, mpi const *N, t_uint mm, mpi const *T)
{
  mpi U;
  t_uint z = (t_uint)1;
  U.s = (int)z;
  U.n = (size_t)U.s;
  U.p = & z;
  mpi_montmul(A,(mpi const *)(& U),N,mm,T);
  return;
}

/*@ requires \valid(X);
    requires \valid_read(A);
    requires \valid_read(E);
    requires \valid_read(N);
    ensures \old(X)->s ≡ 1 ∨ \old(X)->s ≡ -1;
    assigns \result, _state, *X;
    assigns \result \from _state;
    assigns _state \from _state;
    assigns *X \from _state;
 */
int mpi_exp_mod(mpi *X, mpi const *A, mpi const *E, mpi const *N, mpi *_RR)
{
  int __retres;
  int ret;
  size_t wbits;
  size_t wsize;
  size_t i;
  size_t j;
  size_t nblimbs;
  size_t bufsize;
  size_t nbits;
  t_uint ei;
  t_uint mm;
  t_uint state;
  mpi RR;
  mpi T;
  mpi W[2 << 6];
  mpi Apos;
  int neg;
  int tmp;
  int tmp_0;
  int tmp_4;
  size_t one = (size_t)1;
  tmp = mpi_cmp_int(N,(t_sint)0);
  if (tmp < 0) {
    __retres = -0x0004;
    goto return_label;
  }
  else 
    if ((*(N->p + 0) & (unsigned long)1) == (unsigned long)0) {
      __retres = -0x0004;
      goto return_label;
    }
  tmp_0 = mpi_cmp_int(E,(t_sint)0);
  if (tmp_0 < 0) {
    __retres = -0x0004;
    goto return_label;
  }
  mpi_montg_init(& mm,N);
  mpi_init(& RR);
  mpi_init(& T);
  memset((void *)(W),0,sizeof(W));
  i = mpi_msb(E);
  if (i > (size_t)671) wsize = (size_t)6;
  else {
    int tmp_3;
    if (i > (size_t)239) tmp_3 = 5;
    else {
      int tmp_2;
      if (i > (size_t)79) tmp_2 = 4;
      else {
        int tmp_1;
        if (i > (size_t)23) tmp_1 = 3; else tmp_1 = 1;
        tmp_2 = tmp_1;
      }
      tmp_3 = tmp_2;
    }
    wsize = (size_t)tmp_3;
  }
  if (wsize > (size_t)6) wsize = (size_t)6;
  j = N->n + (size_t)1;
  ret = mpi_grow(X,j);
  if (ret != 0) goto cleanup;
  ret = mpi_grow(& W[1],j);
  if (ret != 0) goto cleanup;
  ret = mpi_grow(& T,j * (size_t)2);
  if (ret != 0) goto cleanup;
  neg = A->s == -1;
  mpi_init(& Apos);
  if (neg) {
    ret = mpi_copy(& Apos,A);
    if (ret != 0) goto cleanup;
    Apos.s = 1;
    A = (mpi const *)(& Apos);
  }
  if (_RR == (mpi *)0) goto _LOR;
  else 
    if (_RR->p == (t_uint *)0) {
      _LOR:
      {
        ret = mpi_lset(& RR,(t_sint)1);
        if (ret != 0) goto cleanup;
        ret = mpi_shift_l(& RR,(N->n * (size_t)2) * (sizeof(t_uint) << 3));
        if (ret != 0) goto cleanup;
        ret = mpi_mod_mpi(& RR,(mpi const *)(& RR),N);
        if (ret != 0) goto cleanup;
        if (_RR != (mpi *)0) memcpy((void *)_RR,(void const *)(& RR),
                                    sizeof(mpi));
      }
    }
    else memcpy((void *)(& RR),(void const *)_RR,sizeof(mpi));
  tmp_4 = mpi_cmp_mpi(A,N);
  if (tmp_4 >= 0) mpi_mod_mpi(& W[1],A,N); else mpi_copy(& W[1],A);
  mpi_montmul(& W[1],(mpi const *)(& RR),N,mm,(mpi const *)(& T));
  ret = mpi_copy(X,(mpi const *)(& RR));
  if (ret != 0) goto cleanup;
  mpi_montred(X,N,mm,(mpi const *)(& T));
  if (wsize > (size_t)1) {
    j = one << (wsize - (size_t)1);
    ret = mpi_grow(& W[j],N->n + (size_t)1);
    if (ret != 0) goto cleanup;
    ret = mpi_copy(& W[j],(mpi const *)(& W[1]));
    if (ret != 0) goto cleanup;
    i = (size_t)0;
    while (i < wsize - (size_t)1) {
      mpi_montmul(& W[j],(mpi const *)(& W[j]),N,mm,(mpi const *)(& T));
      i ++;
    }
    i = j + (size_t)1;
    while (i < one << wsize) {
      ret = mpi_grow(& W[i],N->n + (size_t)1);
      if (ret != 0) goto cleanup;
      ret = mpi_copy(& W[i],(mpi const *)(& W[i - (size_t)1]));
      if (ret != 0) goto cleanup;
      mpi_montmul(& W[i],(mpi const *)(& W[1]),N,mm,(mpi const *)(& T));
      i ++;
    }
  }
  nblimbs = E->n;
  bufsize = (size_t)0;
  nbits = (size_t)0;
  wbits = (size_t)0;
  state = (t_uint)0;
  while (1) {
    if (bufsize == (size_t)0) {
      size_t tmp_5;
      tmp_5 = nblimbs;
      nblimbs --;
      ;
      if (tmp_5 == (size_t)0) break;
      bufsize = sizeof(t_uint) << 3;
    }
    bufsize --;
    ei = (*(E->p + nblimbs) >> bufsize) & (unsigned long)1;
    if (ei == (t_uint)0) 
      if (state == (t_uint)0) continue;
    if (ei == (t_uint)0) 
      if (state == (t_uint)1) {
        mpi_montmul(X,(mpi const *)X,N,mm,(mpi const *)(& T));
        continue;
      }
    state = (t_uint)2;
    nbits ++;
    wbits = (size_t)((unsigned long)wbits | (ei << (wsize - nbits)));
    if (nbits == wsize) {
      i = (size_t)0;
      while (i < wsize) {
        mpi_montmul(X,(mpi const *)X,N,mm,(mpi const *)(& T));
        i ++;
      }
      mpi_montmul(X,(mpi const *)(& W[wbits]),N,mm,(mpi const *)(& T));
      state --;
      nbits = (size_t)0;
      wbits = (size_t)0;
    }
  }
  i = (size_t)0;
  while (i < nbits) {
    mpi_montmul(X,(mpi const *)X,N,mm,(mpi const *)(& T));
    wbits <<= 1;
    if ((wbits & (one << wsize)) != (unsigned int)0) mpi_montmul(X,
                                                                 (mpi const *)(& W[1]),
                                                                 N,mm,
                                                                 (mpi const *)(& T));
    i ++;
  }
  mpi_montred(X,N,mm,(mpi const *)(& T));
  if (neg) {
    X->s = -1;
    mpi_add_mpi(X,N,(mpi const *)X);
  }
  cleanup: i = one << (wsize - (size_t)1);
  while (i < one << wsize) {
    mpi_free(& W[i]);
    i ++;
  }
  mpi_free(& W[1]);
  mpi_free(& T);
  mpi_free(& Apos);
  if (_RR == (mpi *)0) mpi_free(& RR);
  __retres = ret;
  return_label: return __retres;
}

int mpi_gcd(mpi *G, mpi const *A, mpi const *B)
{
  int ret;
  size_t lz;
  size_t lzt;
  mpi TG;
  mpi TA;
  mpi TB;
  mpi_init(& TG);
  mpi_init(& TA);
  mpi_init(& TB);
  ret = mpi_copy(& TA,A);
  if (ret != 0) goto cleanup;
  ret = mpi_copy(& TB,B);
  if (ret != 0) goto cleanup;
  lz = mpi_lsb((mpi const *)(& TA));
  lzt = mpi_lsb((mpi const *)(& TB));
  if (lzt < lz) lz = lzt;
  ret = mpi_shift_r(& TA,lz);
  if (ret != 0) goto cleanup;
  ret = mpi_shift_r(& TB,lz);
  if (ret != 0) goto cleanup;
  TB.s = 1;
  TA.s = TB.s;
  while (1) {
    int tmp_2;
    tmp_2 = mpi_cmp_int((mpi const *)(& TA),(t_sint)0);
    if (! (tmp_2 != 0)) break;
    {
      size_t tmp;
      size_t tmp_0;
      int tmp_1;
      tmp = mpi_lsb((mpi const *)(& TA));
      ret = mpi_shift_r(& TA,tmp);
      if (ret != 0) goto cleanup;
      tmp_0 = mpi_lsb((mpi const *)(& TB));
      ret = mpi_shift_r(& TB,tmp_0);
      if (ret != 0) goto cleanup;
      tmp_1 = mpi_cmp_mpi((mpi const *)(& TA),(mpi const *)(& TB));
      if (tmp_1 >= 0) {
        ret = mpi_sub_abs(& TA,(mpi const *)(& TA),(mpi const *)(& TB));
        if (ret != 0) goto cleanup;
        ret = mpi_shift_r(& TA,(size_t)1);
        if (ret != 0) goto cleanup;
      }
      else {
        ret = mpi_sub_abs(& TB,(mpi const *)(& TB),(mpi const *)(& TA));
        if (ret != 0) goto cleanup;
        ret = mpi_shift_r(& TB,(size_t)1);
        if (ret != 0) goto cleanup;
      }
    }
  }
  ret = mpi_shift_l(& TB,lz);
  if (ret != 0) goto cleanup;
  ret = mpi_copy(G,(mpi const *)(& TB));
  if (ret != 0) goto cleanup;
  cleanup: mpi_free(& TG);
  mpi_free(& TA);
  mpi_free(& TB);
  return ret;
}

/*@ requires \valid(X);
    ensures \result ≡ 0 ∨ \result ≡ -0x0010;
    ensures \old(X)->s ≡ 1 ∨ \old(X)->s ≡ -1;
    assigns \result, *X, _state;
    assigns \result \from _state;
    assigns *X \from _state;
    assigns _state \from _state;
 */
int mpi_fill_random(mpi *X, size_t size,
                    int (*f_rng)(void *, unsigned char *, size_t ),
                    void *p_rng)
{
  int ret;
  ret = mpi_grow(X,((size + sizeof(t_uint)) - (size_t)1) / sizeof(t_uint));
  if (ret != 0) goto cleanup;
  ret = mpi_lset(X,(t_sint)0);
  if (ret != 0) goto cleanup;
  ret = (*f_rng)(p_rng,(unsigned char *)X->p,size);
  if (ret != 0) goto cleanup;
  cleanup: ;
  return ret;
}

int mpi_inv_mod(mpi *X, mpi const *A, mpi const *N)
{
  int __retres;
  int ret;
  mpi G;
  mpi TA;
  mpi TU;
  mpi U1;
  mpi U2;
  mpi TB;
  mpi TV;
  mpi V1;
  mpi V2;
  int tmp;
  int tmp_0;
  tmp = mpi_cmp_int(N,(t_sint)0);
  if (tmp <= 0) {
    __retres = -0x0004;
    goto return_label;
  }
  mpi_init(& TA);
  mpi_init(& TU);
  mpi_init(& U1);
  mpi_init(& U2);
  mpi_init(& G);
  mpi_init(& TB);
  mpi_init(& TV);
  mpi_init(& V1);
  mpi_init(& V2);
  ret = mpi_gcd(& G,A,N);
  if (ret != 0) goto cleanup;
  tmp_0 = mpi_cmp_int((mpi const *)(& G),(t_sint)1);
  if (tmp_0 != 0) {
    ret = -0x000E;
    goto cleanup;
  }
  ret = mpi_mod_mpi(& TA,A,N);
  if (ret != 0) goto cleanup;
  ret = mpi_copy(& TU,(mpi const *)(& TA));
  if (ret != 0) goto cleanup;
  ret = mpi_copy(& TB,N);
  if (ret != 0) goto cleanup;
  ret = mpi_copy(& TV,N);
  if (ret != 0) goto cleanup;
  ret = mpi_lset(& U1,(t_sint)1);
  if (ret != 0) goto cleanup;
  ret = mpi_lset(& U2,(t_sint)0);
  if (ret != 0) goto cleanup;
  ret = mpi_lset(& V1,(t_sint)0);
  if (ret != 0) goto cleanup;
  ret = mpi_lset(& V2,(t_sint)1);
  if (ret != 0) goto cleanup;
  while (1) {
    int tmp_2;
    {
      int tmp_1;
      while ((*(TU.p + 0) & (unsigned long)1) == (unsigned long)0) {
        ret = mpi_shift_r(& TU,(size_t)1);
        if (ret != 0) goto cleanup;
        if ((*(U1.p + 0) & (unsigned long)1) != (unsigned long)0) goto _LOR;
        else 
          if ((*(U2.p + 0) & (unsigned long)1) != (unsigned long)0) {
            _LOR:
            {
              ret = mpi_add_mpi(& U1,(mpi const *)(& U1),(mpi const *)(& TB));
              if (ret != 0) goto cleanup;
              ret = mpi_sub_mpi(& U2,(mpi const *)(& U2),(mpi const *)(& TA));
              if (ret != 0) goto cleanup;
            }
          }
        ret = mpi_shift_r(& U1,(size_t)1);
        if (ret != 0) goto cleanup;
        ret = mpi_shift_r(& U2,(size_t)1);
        if (ret != 0) goto cleanup;
      }
      while ((*(TV.p + 0) & (unsigned long)1) == (unsigned long)0) {
        ret = mpi_shift_r(& TV,(size_t)1);
        if (ret != 0) goto cleanup;
        if ((*(V1.p + 0) & (unsigned long)1) != (unsigned long)0) goto _LOR_0;
        else 
          if ((*(V2.p + 0) & (unsigned long)1) != (unsigned long)0) {
            _LOR_0:
            {
              ret = mpi_add_mpi(& V1,(mpi const *)(& V1),(mpi const *)(& TB));
              if (ret != 0) goto cleanup;
              ret = mpi_sub_mpi(& V2,(mpi const *)(& V2),(mpi const *)(& TA));
              if (ret != 0) goto cleanup;
            }
          }
        ret = mpi_shift_r(& V1,(size_t)1);
        if (ret != 0) goto cleanup;
        ret = mpi_shift_r(& V2,(size_t)1);
        if (ret != 0) goto cleanup;
      }
      tmp_1 = mpi_cmp_mpi((mpi const *)(& TU),(mpi const *)(& TV));
      if (tmp_1 >= 0) {
        ret = mpi_sub_mpi(& TU,(mpi const *)(& TU),(mpi const *)(& TV));
        if (ret != 0) goto cleanup;
        ret = mpi_sub_mpi(& U1,(mpi const *)(& U1),(mpi const *)(& V1));
        if (ret != 0) goto cleanup;
        ret = mpi_sub_mpi(& U2,(mpi const *)(& U2),(mpi const *)(& V2));
        if (ret != 0) goto cleanup;
      }
      else {
        ret = mpi_sub_mpi(& TV,(mpi const *)(& TV),(mpi const *)(& TU));
        if (ret != 0) goto cleanup;
        ret = mpi_sub_mpi(& V1,(mpi const *)(& V1),(mpi const *)(& U1));
        if (ret != 0) goto cleanup;
        ret = mpi_sub_mpi(& V2,(mpi const *)(& V2),(mpi const *)(& U2));
        if (ret != 0) goto cleanup;
      }
    }
    tmp_2 = mpi_cmp_int((mpi const *)(& TU),(t_sint)0);
    if (! (tmp_2 != 0)) break;
  }
  while (1) {
    int tmp_3;
    tmp_3 = mpi_cmp_int((mpi const *)(& V1),(t_sint)0);
    if (! (tmp_3 < 0)) break;
    ret = mpi_add_mpi(& V1,(mpi const *)(& V1),N);
    if (ret != 0) goto cleanup;
  }
  while (1) {
    int tmp_4;
    tmp_4 = mpi_cmp_mpi((mpi const *)(& V1),N);
    if (! (tmp_4 >= 0)) break;
    ret = mpi_sub_mpi(& V1,(mpi const *)(& V1),N);
    if (ret != 0) goto cleanup;
  }
  ret = mpi_copy(X,(mpi const *)(& V1));
  if (ret != 0) goto cleanup;
  cleanup: mpi_free(& TA);
  mpi_free(& TU);
  mpi_free(& U1);
  mpi_free(& U2);
  mpi_free(& G);
  mpi_free(& TB);
  mpi_free(& TV);
  mpi_free(& V1);
  mpi_free(& V2);
  __retres = ret;
  return_label: return __retres;
}

static int const small_prime[168] =
  {3,
   5,
   7,
   11,
   13,
   17,
   19,
   23,
   29,
   31,
   37,
   41,
   43,
   47,
   53,
   59,
   61,
   67,
   71,
   73,
   79,
   83,
   89,
   97,
   101,
   103,
   107,
   109,
   113,
   127,
   131,
   137,
   139,
   149,
   151,
   157,
   163,
   167,
   173,
   179,
   181,
   191,
   193,
   197,
   199,
   211,
   223,
   227,
   229,
   233,
   239,
   241,
   251,
   257,
   263,
   269,
   271,
   277,
   281,
   283,
   293,
   307,
   311,
   313,
   317,
   331,
   337,
   347,
   349,
   353,
   359,
   367,
   373,
   379,
   383,
   389,
   397,
   401,
   409,
   419,
   421,
   431,
   433,
   439,
   443,
   449,
   457,
   461,
   463,
   467,
   479,
   487,
   491,
   499,
   503,
   509,
   521,
   523,
   541,
   547,
   557,
   563,
   569,
   571,
   577,
   587,
   593,
   599,
   601,
   607,
   613,
   617,
   619,
   631,
   641,
   643,
   647,
   653,
   659,
   661,
   673,
   677,
   683,
   691,
   701,
   709,
   719,
   727,
   733,
   739,
   743,
   751,
   757,
   761,
   769,
   773,
   787,
   797,
   809,
   811,
   821,
   823,
   827,
   829,
   839,
   853,
   857,
   859,
   863,
   877,
   881,
   883,
   887,
   907,
   911,
   919,
   929,
   937,
   941,
   947,
   953,
   967,
   971,
   977,
   983,
   991,
   997,
   -103};
int mpi_is_prime(mpi *X, int (*f_rng)(void *, unsigned char *, size_t ),
                 void *p_rng)
{
  int __retres;
  int ret;
  int xs;
  size_t i;
  size_t j;
  size_t n;
  size_t s;
  mpi W;
  mpi R;
  mpi T;
  mpi A;
  mpi RR;
  int tmp;
  int tmp_1;
  tmp = mpi_cmp_int((mpi const *)X,(t_sint)0);
  if (tmp == 0) {
    __retres = -0x000E;
    goto return_label;
  }
  else {
    int tmp_0;
    tmp_0 = mpi_cmp_int((mpi const *)X,(t_sint)1);
    if (tmp_0 == 0) {
      __retres = -0x000E;
      goto return_label;
    }
  }
  tmp_1 = mpi_cmp_int((mpi const *)X,(t_sint)2);
  if (tmp_1 == 0) {
    __retres = 0;
    goto return_label;
  }
  mpi_init(& W);
  mpi_init(& R);
  mpi_init(& T);
  mpi_init(& A);
  mpi_init(& RR);
  xs = X->s;
  X->s = 1;
  if ((*(X->p + 0) & (unsigned long)1) == (unsigned long)0) {
    __retres = -0x000E;
    goto return_label;
  }
  i = (size_t)0;
  while (small_prime[i] > 0) {
    {
      t_uint r;
      int tmp_2;
      tmp_2 = mpi_cmp_int((mpi const *)X,(t_sint)small_prime[i]);
      if (tmp_2 <= 0) {
        __retres = 0;
        goto return_label;
      }
      ret = mpi_mod_int(& r,(mpi const *)X,(t_sint)small_prime[i]);
      if (ret != 0) goto cleanup;
      if (r == (t_uint)0) {
        __retres = -0x000E;
        goto return_label;
      }
    }
    i ++;
  }
  ret = mpi_sub_int(& W,(mpi const *)X,(t_sint)1);
  if (ret != 0) goto cleanup;
  s = mpi_lsb((mpi const *)(& W));
  ret = mpi_copy(& R,(mpi const *)(& W));
  if (ret != 0) goto cleanup;
  ret = mpi_shift_r(& R,s);
  if (ret != 0) goto cleanup;
  i = mpi_msb((mpi const *)X);
  if (i >= (size_t)1300) n = (size_t)2;
  else {
    int tmp_7;
    if (i >= (size_t)850) tmp_7 = 3;
    else {
      int tmp_6;
      if (i >= (size_t)650) tmp_6 = 4;
      else {
        int tmp_5;
        if (i >= (size_t)350) tmp_5 = 8;
        else {
          int tmp_4;
          if (i >= (size_t)250) tmp_4 = 12;
          else {
            int tmp_3;
            if (i >= (size_t)150) tmp_3 = 18; else tmp_3 = 27;
            tmp_4 = tmp_3;
          }
          tmp_5 = tmp_4;
        }
        tmp_6 = tmp_5;
      }
      tmp_7 = tmp_6;
    }
    n = (size_t)tmp_7;
  }
  i = (size_t)0;
  while (i < n) {
    {
      int tmp_10;
      int tmp_11;
      int tmp_15;
      ret = mpi_fill_random(& A,X->n * sizeof(t_uint),f_rng,p_rng);
      if (ret != 0) goto cleanup;
      tmp_10 = mpi_cmp_mpi((mpi const *)(& A),(mpi const *)(& W));
      if (tmp_10 >= 0) {
        size_t tmp_8;
        size_t tmp_9;
        tmp_8 = mpi_msb((mpi const *)(& A));
        tmp_9 = mpi_msb((mpi const *)(& W));
        j = tmp_8 - tmp_9;
        ret = mpi_shift_r(& A,j + (size_t)1);
        if (ret != 0) goto cleanup;
      }
      *(A.p + 0) |= (unsigned long)3;
      ret = mpi_exp_mod(& A,(mpi const *)(& A),(mpi const *)(& R),
                        (mpi const *)X,& RR);
      if (ret != 0) goto cleanup;
      tmp_11 = mpi_cmp_mpi((mpi const *)(& A),(mpi const *)(& W));
      if (tmp_11 == 0) goto __Cont;
      else {
        int tmp_12;
        tmp_12 = mpi_cmp_int((mpi const *)(& A),(t_sint)1);
        if (tmp_12 == 0) goto __Cont;
      }
      j = (size_t)1;
      while (1) {
        if (j < s) {
          int tmp_14;
          tmp_14 = mpi_cmp_mpi((mpi const *)(& A),(mpi const *)(& W));
          if (! (tmp_14 != 0)) break;
        }
        else break;
        {
          int tmp_13;
          ret = mpi_mul_mpi(& T,(mpi const *)(& A),(mpi const *)(& A));
          if (ret != 0) goto cleanup;
          ret = mpi_mod_mpi(& A,(mpi const *)(& T),(mpi const *)X);
          if (ret != 0) goto cleanup;
          tmp_13 = mpi_cmp_int((mpi const *)(& A),(t_sint)1);
          if (tmp_13 == 0) break;
          j ++;
        }
      }
      tmp_15 = mpi_cmp_mpi((mpi const *)(& A),(mpi const *)(& W));
      if (tmp_15 != 0) goto _LOR;
      else {
        int tmp_16;
        tmp_16 = mpi_cmp_int((mpi const *)(& A),(t_sint)1);
        if (tmp_16 == 0) {
          _LOR: {
                  ret = -0x000E;
                  break;
                }
        }
      }
    }
    __Cont: i ++;
  }
  cleanup: X->s = xs;
  mpi_free(& W);
  mpi_free(& R);
  mpi_free(& T);
  mpi_free(& A);
  mpi_free(& RR);
  __retres = ret;
  return_label: return __retres;
}

int mpi_gen_prime(mpi *X, size_t nbits, int dh_flag,
                  int (*f_rng)(void *, unsigned char *, size_t ), void *p_rng)
{
  int __retres;
  int ret;
  size_t k;
  size_t n;
  mpi Y;
  if (nbits < (size_t)3) {
    __retres = -0x0004;
    goto return_label;
  }
  else 
    if (nbits > (size_t)(8 * 512)) {
      __retres = -0x0004;
      goto return_label;
    }
  mpi_init(& Y);
  n = ((nbits + (sizeof(t_uint) << 3)) - (size_t)1) / (sizeof(t_uint) << 3);
  ret = mpi_fill_random(X,n * sizeof(t_uint),f_rng,p_rng);
  if (ret != 0) goto cleanup;
  k = mpi_msb((mpi const *)X);
  if (k < nbits) {
    ret = mpi_shift_l(X,nbits - k);
    if (ret != 0) goto cleanup;
  }
  if (k > nbits) {
    ret = mpi_shift_r(X,k - nbits);
    if (ret != 0) goto cleanup;
  }
  *(X->p + 0) |= (unsigned long)3;
  if (dh_flag == 0) 
    while (1) {
      ret = mpi_is_prime(X,f_rng,p_rng);
      if (! (ret != 0)) break;
      if (ret != -0x000E) goto cleanup;
      ret = mpi_add_int(X,(mpi const *)X,(t_sint)2);
      if (ret != 0) goto cleanup;
    }
  else {
    ret = mpi_sub_int(& Y,(mpi const *)X,(t_sint)1);
    if (ret != 0) goto cleanup;
    ret = mpi_shift_r(& Y,(size_t)1);
    if (ret != 0) goto cleanup;
    while (1) {
      ret = mpi_is_prime(X,f_rng,p_rng);
      if (ret == 0) {
        ret = mpi_is_prime(& Y,f_rng,p_rng);
        if (ret == 0) break;
        if (ret != -0x000E) goto cleanup;
      }
      if (ret != -0x000E) goto cleanup;
      ret = mpi_add_int(& Y,(mpi const *)X,(t_sint)1);
      if (ret != 0) goto cleanup;
      ret = mpi_add_int(X,(mpi const *)X,(t_sint)2);
      if (ret != 0) goto cleanup;
      ret = mpi_shift_r(& Y,(size_t)1);
      if (ret != 0) goto cleanup;
    }
  }
  cleanup: mpi_free(& Y);
  __retres = ret;
  return_label: return __retres;
}

static int const gcd_pairs[3][3] =
  {{693, 609, 21}, {1764, 868, 28}, {768454923, 542167814, 1}};
/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_31(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_32(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_33(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_34(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_35(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_36(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_37(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_38(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_39(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_40(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_41(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_42(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_43(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_44(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_45(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_46(char const * restrict format, unsigned int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_47(char const * restrict format);

int mpi_self_test(int verbose)
{
  int __retres;
  int ret;
  int i;
  mpi A;
  mpi E;
  mpi N;
  mpi X;
  mpi Y;
  mpi U;
  mpi V;
  int tmp;
  int tmp_0;
  int tmp_2;
  int tmp_3;
  mpi_init(& A);
  mpi_init(& E);
  mpi_init(& N);
  mpi_init(& X);
  mpi_init(& Y);
  mpi_init(& U);
  mpi_init(& V);
  ret = mpi_read_string(& A,16,
                        "EFE021C2645FD1DC586E69184AF4A31ED5F53E93B5F123FA41680867BA110131944FE7952E2517337780CB0DB80E61AAE7C8DDC6C5C6AADEB34EB38A2F40D5E6");
  if (ret != 0) goto cleanup;
  ret = mpi_read_string(& E,16,
                        "B2E7EFD37075B9F03FF989C7C5051C2034D2A323810251127E7BF8625A4F49A5F3E27F4DA8BD59C47D6DAABA4C8127BD5B5C25763222FEFCCFC38B832366C29E");
  if (ret != 0) goto cleanup;
  ret = mpi_read_string(& N,16,
                        "0066A198186C18C10B2F5ED9B522752A9830B69916E535C8F047518A889A43A594B6BED27A168D31D4A52F88925AA8F5");
  if (ret != 0) goto cleanup;
  ret = mpi_mul_mpi(& X,(mpi const *)(& A),(mpi const *)(& N));
  if (ret != 0) goto cleanup;
  ret = mpi_read_string(& U,16,
                        "602AB7ECA597A3D6B56FF9829A5E8B859E857EA95A03512E2BAE7391688D264AA5663B0341DB9CCFD2C4C5F421FEC8148001B72E848A38CAE1C65F78E56ABDEFE12D3C039B8A02D6BE593F0BBBDA56F1ECF677152EF804370C1A305CAF3B5BF130879B56C61DE584A0F53A2447A51E");
  if (ret != 0) goto cleanup;
  if (verbose != 0) printf("  MPI test #1 (mul_mpi): "); /* printf_va_31 */
  tmp = mpi_cmp_mpi((mpi const *)(& X),(mpi const *)(& U));
  if (tmp != 0) {
    if (verbose != 0) printf("failed\n"); /* printf_va_32 */
    __retres = 1;
    goto return_label;
  }
  if (verbose != 0) printf("passed\n"); /* printf_va_33 */
  ret = mpi_div_mpi(& X,& Y,(mpi const *)(& A),(mpi const *)(& N));
  if (ret != 0) goto cleanup;
  ret = mpi_read_string(& U,16,"256567336059E52CAE22925474705F39A94");
  if (ret != 0) goto cleanup;
  ret = mpi_read_string(& V,16,
                        "6613F26162223DF488E9CD48CC132C7A0AC93C701B001B092E4E5B9F73BCD27B9EE50D0657C77F374E903CDFA4C642");
  if (ret != 0) goto cleanup;
  if (verbose != 0) printf("  MPI test #2 (div_mpi): "); /* printf_va_34 */
  tmp_0 = mpi_cmp_mpi((mpi const *)(& X),(mpi const *)(& U));
  if (tmp_0 != 0) goto _LOR;
  else {
    int tmp_1;
    tmp_1 = mpi_cmp_mpi((mpi const *)(& Y),(mpi const *)(& V));
    if (tmp_1 != 0) {
      _LOR:
      {
        if (verbose != 0) printf("failed\n"); /* printf_va_35 */
        __retres = 1;
        goto return_label;
      }
    }
  }
  if (verbose != 0) printf("passed\n"); /* printf_va_36 */
  ret = mpi_exp_mod(& X,(mpi const *)(& A),(mpi const *)(& E),
                    (mpi const *)(& N),(mpi *)0);
  if (ret != 0) goto cleanup;
  ret = mpi_read_string(& U,16,
                        "36E139AEA55215609D2816998ED020BBBD96C37890F65171D948E9BC7CBAA4D9325D24D6A3C12710F10A09FA08AB87");
  if (ret != 0) goto cleanup;
  if (verbose != 0) printf("  MPI test #3 (exp_mod): "); /* printf_va_37 */
  tmp_2 = mpi_cmp_mpi((mpi const *)(& X),(mpi const *)(& U));
  if (tmp_2 != 0) {
    if (verbose != 0) printf("failed\n"); /* printf_va_38 */
    __retres = 1;
    goto return_label;
  }
  if (verbose != 0) printf("passed\n"); /* printf_va_39 */
  ret = mpi_inv_mod(& X,(mpi const *)(& A),(mpi const *)(& N));
  if (ret != 0) goto cleanup;
  ret = mpi_read_string(& U,16,
                        "003A0AAEDD7E784FC07D8F9EC6E3BFD5C3DBA76456363A10869622EAC2DD84ECC5B8A74DAC4D09E03B5E0BE779F2DF61");
  if (ret != 0) goto cleanup;
  if (verbose != 0) printf("  MPI test #4 (inv_mod): "); /* printf_va_40 */
  tmp_3 = mpi_cmp_mpi((mpi const *)(& X),(mpi const *)(& U));
  if (tmp_3 != 0) {
    if (verbose != 0) printf("failed\n"); /* printf_va_41 */
    __retres = 1;
    goto return_label;
  }
  if (verbose != 0) printf("passed\n"); /* printf_va_42 */
  if (verbose != 0) printf("  MPI test #5 (simple gcd): "); /* printf_va_43 */
  i = 0;
  while (i < 3) {
    {
      int tmp_4;
      ret = mpi_lset(& X,(t_sint)gcd_pairs[i][0]);
      if (ret != 0) goto cleanup;
      ret = mpi_lset(& Y,(t_sint)gcd_pairs[i][1]);
      if (ret != 0) goto cleanup;
      ret = mpi_gcd(& A,(mpi const *)(& X),(mpi const *)(& Y));
      if (ret != 0) goto cleanup;
      tmp_4 = mpi_cmp_int((mpi const *)(& A),(t_sint)gcd_pairs[i][2]);
      if (tmp_4 != 0) {
        if (verbose != 0) printf("failed at %d\n",i); /* printf_va_44 */
        __retres = 1;
        goto return_label;
      }
    }
    i ++;
  }
  if (verbose != 0) printf("passed\n"); /* printf_va_45 */
  cleanup: ;
  if (ret != 0) 
    if (verbose != 0) printf("Unexpected error, return code = %08X\n",
                             (unsigned int)ret); /* printf_va_46 */
  mpi_free(& A);
  mpi_free(& E);
  mpi_free(& N);
  mpi_free(& X);
  mpi_free(& Y);
  mpi_free(& U);
  mpi_free(& V);
  if (verbose != 0) printf("\n"); /* printf_va_47 */
  __retres = ret;
  return_label: return __retres;
}

static unsigned char const SIGMA_CHARS[6][8] =
  {{(unsigned char)0xa0,
    (unsigned char)0x9e,
    (unsigned char)0x66,
    (unsigned char)0x7f,
    (unsigned char)0x3b,
    (unsigned char)0xcc,
    (unsigned char)0x90,
    (unsigned char)0x8b},
   {(unsigned char)0xb6,
    (unsigned char)0x7a,
    (unsigned char)0xe8,
    (unsigned char)0x58,
    (unsigned char)0x4c,
    (unsigned char)0xaa,
    (unsigned char)0x73,
    (unsigned char)0xb2},
   {(unsigned char)0xc6,
    (unsigned char)0xef,
    (unsigned char)0x37,
    (unsigned char)0x2f,
    (unsigned char)0xe9,
    (unsigned char)0x4f,
    (unsigned char)0x82,
    (unsigned char)0xbe},
   {(unsigned char)0x54,
    (unsigned char)0xff,
    (unsigned char)0x53,
    (unsigned char)0xa5,
    (unsigned char)0xf1,
    (unsigned char)0xd3,
    (unsigned char)0x6f,
    (unsigned char)0x1c},
   {(unsigned char)0x10,
    (unsigned char)0xe5,
    (unsigned char)0x27,
    (unsigned char)0xfa,
    (unsigned char)0xde,
    (unsigned char)0x68,
    (unsigned char)0x2d,
    (unsigned char)0x1d},
   {(unsigned char)0xb0,
    (unsigned char)0x56,
    (unsigned char)0x88,
    (unsigned char)0xc2,
    (unsigned char)0xb3,
    (unsigned char)0xe6,
    (unsigned char)0xc1,
    (unsigned char)0xfd}};
static unsigned char const FSb_0[256] =
  {(unsigned char)112,
   (unsigned char)130,
   (unsigned char)44,
   (unsigned char)236,
   (unsigned char)179,
   (unsigned char)39,
   (unsigned char)192,
   (unsigned char)229,
   (unsigned char)228,
   (unsigned char)133,
   (unsigned char)87,
   (unsigned char)53,
   (unsigned char)234,
   (unsigned char)12,
   (unsigned char)174,
   (unsigned char)65,
   (unsigned char)35,
   (unsigned char)239,
   (unsigned char)107,
   (unsigned char)147,
   (unsigned char)69,
   (unsigned char)25,
   (unsigned char)165,
   (unsigned char)33,
   (unsigned char)237,
   (unsigned char)14,
   (unsigned char)79,
   (unsigned char)78,
   (unsigned char)29,
   (unsigned char)101,
   (unsigned char)146,
   (unsigned char)189,
   (unsigned char)134,
   (unsigned char)184,
   (unsigned char)175,
   (unsigned char)143,
   (unsigned char)124,
   (unsigned char)235,
   (unsigned char)31,
   (unsigned char)206,
   (unsigned char)62,
   (unsigned char)48,
   (unsigned char)220,
   (unsigned char)95,
   (unsigned char)94,
   (unsigned char)197,
   (unsigned char)11,
   (unsigned char)26,
   (unsigned char)166,
   (unsigned char)225,
   (unsigned char)57,
   (unsigned char)202,
   (unsigned char)213,
   (unsigned char)71,
   (unsigned char)93,
   (unsigned char)61,
   (unsigned char)217,
   (unsigned char)1,
   (unsigned char)90,
   (unsigned char)214,
   (unsigned char)81,
   (unsigned char)86,
   (unsigned char)108,
   (unsigned char)77,
   (unsigned char)139,
   (unsigned char)13,
   (unsigned char)154,
   (unsigned char)102,
   (unsigned char)251,
   (unsigned char)204,
   (unsigned char)176,
   (unsigned char)45,
   (unsigned char)116,
   (unsigned char)18,
   (unsigned char)43,
   (unsigned char)32,
   (unsigned char)240,
   (unsigned char)177,
   (unsigned char)132,
   (unsigned char)153,
   (unsigned char)223,
   (unsigned char)76,
   (unsigned char)203,
   (unsigned char)194,
   (unsigned char)52,
   (unsigned char)126,
   (unsigned char)118,
   (unsigned char)5,
   (unsigned char)109,
   (unsigned char)183,
   (unsigned char)169,
   (unsigned char)49,
   (unsigned char)209,
   (unsigned char)23,
   (unsigned char)4,
   (unsigned char)215,
   (unsigned char)20,
   (unsigned char)88,
   (unsigned char)58,
   (unsigned char)97,
   (unsigned char)222,
   (unsigned char)27,
   (unsigned char)17,
   (unsigned char)28,
   (unsigned char)50,
   (unsigned char)15,
   (unsigned char)156,
   (unsigned char)22,
   (unsigned char)83,
   (unsigned char)24,
   (unsigned char)242,
   (unsigned char)34,
   (unsigned char)254,
   (unsigned char)68,
   (unsigned char)207,
   (unsigned char)178,
   (unsigned char)195,
   (unsigned char)181,
   (unsigned char)122,
   (unsigned char)145,
   (unsigned char)36,
   (unsigned char)8,
   (unsigned char)232,
   (unsigned char)168,
   (unsigned char)96,
   (unsigned char)252,
   (unsigned char)105,
   (unsigned char)80,
   (unsigned char)170,
   (unsigned char)208,
   (unsigned char)160,
   (unsigned char)125,
   (unsigned char)161,
   (unsigned char)137,
   (unsigned char)98,
   (unsigned char)151,
   (unsigned char)84,
   (unsigned char)91,
   (unsigned char)30,
   (unsigned char)149,
   (unsigned char)224,
   (unsigned char)255,
   (unsigned char)100,
   (unsigned char)210,
   (unsigned char)16,
   (unsigned char)196,
   (unsigned char)0,
   (unsigned char)72,
   (unsigned char)163,
   (unsigned char)247,
   (unsigned char)117,
   (unsigned char)219,
   (unsigned char)138,
   (unsigned char)3,
   (unsigned char)230,
   (unsigned char)218,
   (unsigned char)9,
   (unsigned char)63,
   (unsigned char)221,
   (unsigned char)148,
   (unsigned char)135,
   (unsigned char)92,
   (unsigned char)131,
   (unsigned char)2,
   (unsigned char)205,
   (unsigned char)74,
   (unsigned char)144,
   (unsigned char)51,
   (unsigned char)115,
   (unsigned char)103,
   (unsigned char)246,
   (unsigned char)243,
   (unsigned char)157,
   (unsigned char)127,
   (unsigned char)191,
   (unsigned char)226,
   (unsigned char)82,
   (unsigned char)155,
   (unsigned char)216,
   (unsigned char)38,
   (unsigned char)200,
   (unsigned char)55,
   (unsigned char)198,
   (unsigned char)59,
   (unsigned char)129,
   (unsigned char)150,
   (unsigned char)111,
   (unsigned char)75,
   (unsigned char)19,
   (unsigned char)190,
   (unsigned char)99,
   (unsigned char)46,
   (unsigned char)233,
   (unsigned char)121,
   (unsigned char)167,
   (unsigned char)140,
   (unsigned char)159,
   (unsigned char)110,
   (unsigned char)188,
   (unsigned char)142,
   (unsigned char)41,
   (unsigned char)245,
   (unsigned char)249,
   (unsigned char)182,
   (unsigned char)47,
   (unsigned char)253,
   (unsigned char)180,
   (unsigned char)89,
   (unsigned char)120,
   (unsigned char)152,
   (unsigned char)6,
   (unsigned char)106,
   (unsigned char)231,
   (unsigned char)70,
   (unsigned char)113,
   (unsigned char)186,
   (unsigned char)212,
   (unsigned char)37,
   (unsigned char)171,
   (unsigned char)66,
   (unsigned char)136,
   (unsigned char)162,
   (unsigned char)141,
   (unsigned char)250,
   (unsigned char)114,
   (unsigned char)7,
   (unsigned char)185,
   (unsigned char)85,
   (unsigned char)248,
   (unsigned char)238,
   (unsigned char)172,
   (unsigned char)10,
   (unsigned char)54,
   (unsigned char)73,
   (unsigned char)42,
   (unsigned char)104,
   (unsigned char)60,
   (unsigned char)56,
   (unsigned char)241,
   (unsigned char)164,
   (unsigned char)64,
   (unsigned char)40,
   (unsigned char)211,
   (unsigned char)123,
   (unsigned char)187,
   (unsigned char)201,
   (unsigned char)67,
   (unsigned char)193,
   (unsigned char)21,
   (unsigned char)227,
   (unsigned char)173,
   (unsigned char)244,
   (unsigned char)119,
   (unsigned char)199,
   (unsigned char)128,
   (unsigned char)158};
static unsigned char const FSb2[256] =
  {(unsigned char)224,
   (unsigned char)5,
   (unsigned char)88,
   (unsigned char)217,
   (unsigned char)103,
   (unsigned char)78,
   (unsigned char)129,
   (unsigned char)203,
   (unsigned char)201,
   (unsigned char)11,
   (unsigned char)174,
   (unsigned char)106,
   (unsigned char)213,
   (unsigned char)24,
   (unsigned char)93,
   (unsigned char)130,
   (unsigned char)70,
   (unsigned char)223,
   (unsigned char)214,
   (unsigned char)39,
   (unsigned char)138,
   (unsigned char)50,
   (unsigned char)75,
   (unsigned char)66,
   (unsigned char)219,
   (unsigned char)28,
   (unsigned char)158,
   (unsigned char)156,
   (unsigned char)58,
   (unsigned char)202,
   (unsigned char)37,
   (unsigned char)123,
   (unsigned char)13,
   (unsigned char)113,
   (unsigned char)95,
   (unsigned char)31,
   (unsigned char)248,
   (unsigned char)215,
   (unsigned char)62,
   (unsigned char)157,
   (unsigned char)124,
   (unsigned char)96,
   (unsigned char)185,
   (unsigned char)190,
   (unsigned char)188,
   (unsigned char)139,
   (unsigned char)22,
   (unsigned char)52,
   (unsigned char)77,
   (unsigned char)195,
   (unsigned char)114,
   (unsigned char)149,
   (unsigned char)171,
   (unsigned char)142,
   (unsigned char)186,
   (unsigned char)122,
   (unsigned char)179,
   (unsigned char)2,
   (unsigned char)180,
   (unsigned char)173,
   (unsigned char)162,
   (unsigned char)172,
   (unsigned char)216,
   (unsigned char)154,
   (unsigned char)23,
   (unsigned char)26,
   (unsigned char)53,
   (unsigned char)204,
   (unsigned char)247,
   (unsigned char)153,
   (unsigned char)97,
   (unsigned char)90,
   (unsigned char)232,
   (unsigned char)36,
   (unsigned char)86,
   (unsigned char)64,
   (unsigned char)225,
   (unsigned char)99,
   (unsigned char)9,
   (unsigned char)51,
   (unsigned char)191,
   (unsigned char)152,
   (unsigned char)151,
   (unsigned char)133,
   (unsigned char)104,
   (unsigned char)252,
   (unsigned char)236,
   (unsigned char)10,
   (unsigned char)218,
   (unsigned char)111,
   (unsigned char)83,
   (unsigned char)98,
   (unsigned char)163,
   (unsigned char)46,
   (unsigned char)8,
   (unsigned char)175,
   (unsigned char)40,
   (unsigned char)176,
   (unsigned char)116,
   (unsigned char)194,
   (unsigned char)189,
   (unsigned char)54,
   (unsigned char)34,
   (unsigned char)56,
   (unsigned char)100,
   (unsigned char)30,
   (unsigned char)57,
   (unsigned char)44,
   (unsigned char)166,
   (unsigned char)48,
   (unsigned char)229,
   (unsigned char)68,
   (unsigned char)253,
   (unsigned char)136,
   (unsigned char)159,
   (unsigned char)101,
   (unsigned char)135,
   (unsigned char)107,
   (unsigned char)244,
   (unsigned char)35,
   (unsigned char)72,
   (unsigned char)16,
   (unsigned char)209,
   (unsigned char)81,
   (unsigned char)192,
   (unsigned char)249,
   (unsigned char)210,
   (unsigned char)160,
   (unsigned char)85,
   (unsigned char)161,
   (unsigned char)65,
   (unsigned char)250,
   (unsigned char)67,
   (unsigned char)19,
   (unsigned char)196,
   (unsigned char)47,
   (unsigned char)168,
   (unsigned char)182,
   (unsigned char)60,
   (unsigned char)43,
   (unsigned char)193,
   (unsigned char)255,
   (unsigned char)200,
   (unsigned char)165,
   (unsigned char)32,
   (unsigned char)137,
   (unsigned char)0,
   (unsigned char)144,
   (unsigned char)71,
   (unsigned char)239,
   (unsigned char)234,
   (unsigned char)183,
   (unsigned char)21,
   (unsigned char)6,
   (unsigned char)205,
   (unsigned char)181,
   (unsigned char)18,
   (unsigned char)126,
   (unsigned char)187,
   (unsigned char)41,
   (unsigned char)15,
   (unsigned char)184,
   (unsigned char)7,
   (unsigned char)4,
   (unsigned char)155,
   (unsigned char)148,
   (unsigned char)33,
   (unsigned char)102,
   (unsigned char)230,
   (unsigned char)206,
   (unsigned char)237,
   (unsigned char)231,
   (unsigned char)59,
   (unsigned char)254,
   (unsigned char)127,
   (unsigned char)197,
   (unsigned char)164,
   (unsigned char)55,
   (unsigned char)177,
   (unsigned char)76,
   (unsigned char)145,
   (unsigned char)110,
   (unsigned char)141,
   (unsigned char)118,
   (unsigned char)3,
   (unsigned char)45,
   (unsigned char)222,
   (unsigned char)150,
   (unsigned char)38,
   (unsigned char)125,
   (unsigned char)198,
   (unsigned char)92,
   (unsigned char)211,
   (unsigned char)242,
   (unsigned char)79,
   (unsigned char)25,
   (unsigned char)63,
   (unsigned char)220,
   (unsigned char)121,
   (unsigned char)29,
   (unsigned char)82,
   (unsigned char)235,
   (unsigned char)243,
   (unsigned char)109,
   (unsigned char)94,
   (unsigned char)251,
   (unsigned char)105,
   (unsigned char)178,
   (unsigned char)240,
   (unsigned char)49,
   (unsigned char)12,
   (unsigned char)212,
   (unsigned char)207,
   (unsigned char)140,
   (unsigned char)226,
   (unsigned char)117,
   (unsigned char)169,
   (unsigned char)74,
   (unsigned char)87,
   (unsigned char)132,
   (unsigned char)17,
   (unsigned char)69,
   (unsigned char)27,
   (unsigned char)245,
   (unsigned char)228,
   (unsigned char)14,
   (unsigned char)115,
   (unsigned char)170,
   (unsigned char)241,
   (unsigned char)221,
   (unsigned char)89,
   (unsigned char)20,
   (unsigned char)108,
   (unsigned char)146,
   (unsigned char)84,
   (unsigned char)208,
   (unsigned char)120,
   (unsigned char)112,
   (unsigned char)227,
   (unsigned char)73,
   (unsigned char)128,
   (unsigned char)80,
   (unsigned char)167,
   (unsigned char)246,
   (unsigned char)119,
   (unsigned char)147,
   (unsigned char)134,
   (unsigned char)131,
   (unsigned char)42,
   (unsigned char)199,
   (unsigned char)91,
   (unsigned char)233,
   (unsigned char)238,
   (unsigned char)143,
   (unsigned char)1,
   (unsigned char)61};
static unsigned char const FSb3[256] =
  {(unsigned char)56,
   (unsigned char)65,
   (unsigned char)22,
   (unsigned char)118,
   (unsigned char)217,
   (unsigned char)147,
   (unsigned char)96,
   (unsigned char)242,
   (unsigned char)114,
   (unsigned char)194,
   (unsigned char)171,
   (unsigned char)154,
   (unsigned char)117,
   (unsigned char)6,
   (unsigned char)87,
   (unsigned char)160,
   (unsigned char)145,
   (unsigned char)247,
   (unsigned char)181,
   (unsigned char)201,
   (unsigned char)162,
   (unsigned char)140,
   (unsigned char)210,
   (unsigned char)144,
   (unsigned char)246,
   (unsigned char)7,
   (unsigned char)167,
   (unsigned char)39,
   (unsigned char)142,
   (unsigned char)178,
   (unsigned char)73,
   (unsigned char)222,
   (unsigned char)67,
   (unsigned char)92,
   (unsigned char)215,
   (unsigned char)199,
   (unsigned char)62,
   (unsigned char)245,
   (unsigned char)143,
   (unsigned char)103,
   (unsigned char)31,
   (unsigned char)24,
   (unsigned char)110,
   (unsigned char)175,
   (unsigned char)47,
   (unsigned char)226,
   (unsigned char)133,
   (unsigned char)13,
   (unsigned char)83,
   (unsigned char)240,
   (unsigned char)156,
   (unsigned char)101,
   (unsigned char)234,
   (unsigned char)163,
   (unsigned char)174,
   (unsigned char)158,
   (unsigned char)236,
   (unsigned char)128,
   (unsigned char)45,
   (unsigned char)107,
   (unsigned char)168,
   (unsigned char)43,
   (unsigned char)54,
   (unsigned char)166,
   (unsigned char)197,
   (unsigned char)134,
   (unsigned char)77,
   (unsigned char)51,
   (unsigned char)253,
   (unsigned char)102,
   (unsigned char)88,
   (unsigned char)150,
   (unsigned char)58,
   (unsigned char)9,
   (unsigned char)149,
   (unsigned char)16,
   (unsigned char)120,
   (unsigned char)216,
   (unsigned char)66,
   (unsigned char)204,
   (unsigned char)239,
   (unsigned char)38,
   (unsigned char)229,
   (unsigned char)97,
   (unsigned char)26,
   (unsigned char)63,
   (unsigned char)59,
   (unsigned char)130,
   (unsigned char)182,
   (unsigned char)219,
   (unsigned char)212,
   (unsigned char)152,
   (unsigned char)232,
   (unsigned char)139,
   (unsigned char)2,
   (unsigned char)235,
   (unsigned char)10,
   (unsigned char)44,
   (unsigned char)29,
   (unsigned char)176,
   (unsigned char)111,
   (unsigned char)141,
   (unsigned char)136,
   (unsigned char)14,
   (unsigned char)25,
   (unsigned char)135,
   (unsigned char)78,
   (unsigned char)11,
   (unsigned char)169,
   (unsigned char)12,
   (unsigned char)121,
   (unsigned char)17,
   (unsigned char)127,
   (unsigned char)34,
   (unsigned char)231,
   (unsigned char)89,
   (unsigned char)225,
   (unsigned char)218,
   (unsigned char)61,
   (unsigned char)200,
   (unsigned char)18,
   (unsigned char)4,
   (unsigned char)116,
   (unsigned char)84,
   (unsigned char)48,
   (unsigned char)126,
   (unsigned char)180,
   (unsigned char)40,
   (unsigned char)85,
   (unsigned char)104,
   (unsigned char)80,
   (unsigned char)190,
   (unsigned char)208,
   (unsigned char)196,
   (unsigned char)49,
   (unsigned char)203,
   (unsigned char)42,
   (unsigned char)173,
   (unsigned char)15,
   (unsigned char)202,
   (unsigned char)112,
   (unsigned char)255,
   (unsigned char)50,
   (unsigned char)105,
   (unsigned char)8,
   (unsigned char)98,
   (unsigned char)0,
   (unsigned char)36,
   (unsigned char)209,
   (unsigned char)251,
   (unsigned char)186,
   (unsigned char)237,
   (unsigned char)69,
   (unsigned char)129,
   (unsigned char)115,
   (unsigned char)109,
   (unsigned char)132,
   (unsigned char)159,
   (unsigned char)238,
   (unsigned char)74,
   (unsigned char)195,
   (unsigned char)46,
   (unsigned char)193,
   (unsigned char)1,
   (unsigned char)230,
   (unsigned char)37,
   (unsigned char)72,
   (unsigned char)153,
   (unsigned char)185,
   (unsigned char)179,
   (unsigned char)123,
   (unsigned char)249,
   (unsigned char)206,
   (unsigned char)191,
   (unsigned char)223,
   (unsigned char)113,
   (unsigned char)41,
   (unsigned char)205,
   (unsigned char)108,
   (unsigned char)19,
   (unsigned char)100,
   (unsigned char)155,
   (unsigned char)99,
   (unsigned char)157,
   (unsigned char)192,
   (unsigned char)75,
   (unsigned char)183,
   (unsigned char)165,
   (unsigned char)137,
   (unsigned char)95,
   (unsigned char)177,
   (unsigned char)23,
   (unsigned char)244,
   (unsigned char)188,
   (unsigned char)211,
   (unsigned char)70,
   (unsigned char)207,
   (unsigned char)55,
   (unsigned char)94,
   (unsigned char)71,
   (unsigned char)148,
   (unsigned char)250,
   (unsigned char)252,
   (unsigned char)91,
   (unsigned char)151,
   (unsigned char)254,
   (unsigned char)90,
   (unsigned char)172,
   (unsigned char)60,
   (unsigned char)76,
   (unsigned char)3,
   (unsigned char)53,
   (unsigned char)243,
   (unsigned char)35,
   (unsigned char)184,
   (unsigned char)93,
   (unsigned char)106,
   (unsigned char)146,
   (unsigned char)213,
   (unsigned char)33,
   (unsigned char)68,
   (unsigned char)81,
   (unsigned char)198,
   (unsigned char)125,
   (unsigned char)57,
   (unsigned char)131,
   (unsigned char)220,
   (unsigned char)170,
   (unsigned char)124,
   (unsigned char)119,
   (unsigned char)86,
   (unsigned char)5,
   (unsigned char)27,
   (unsigned char)164,
   (unsigned char)21,
   (unsigned char)52,
   (unsigned char)30,
   (unsigned char)28,
   (unsigned char)248,
   (unsigned char)82,
   (unsigned char)32,
   (unsigned char)20,
   (unsigned char)233,
   (unsigned char)189,
   (unsigned char)221,
   (unsigned char)228,
   (unsigned char)161,
   (unsigned char)224,
   (unsigned char)138,
   (unsigned char)241,
   (unsigned char)214,
   (unsigned char)122,
   (unsigned char)187,
   (unsigned char)227,
   (unsigned char)64,
   (unsigned char)79};
static unsigned char const FSb4[256] =
  {(unsigned char)112,
   (unsigned char)44,
   (unsigned char)179,
   (unsigned char)192,
   (unsigned char)228,
   (unsigned char)87,
   (unsigned char)234,
   (unsigned char)174,
   (unsigned char)35,
   (unsigned char)107,
   (unsigned char)69,
   (unsigned char)165,
   (unsigned char)237,
   (unsigned char)79,
   (unsigned char)29,
   (unsigned char)146,
   (unsigned char)134,
   (unsigned char)175,
   (unsigned char)124,
   (unsigned char)31,
   (unsigned char)62,
   (unsigned char)220,
   (unsigned char)94,
   (unsigned char)11,
   (unsigned char)166,
   (unsigned char)57,
   (unsigned char)213,
   (unsigned char)93,
   (unsigned char)217,
   (unsigned char)90,
   (unsigned char)81,
   (unsigned char)108,
   (unsigned char)139,
   (unsigned char)154,
   (unsigned char)251,
   (unsigned char)176,
   (unsigned char)116,
   (unsigned char)43,
   (unsigned char)240,
   (unsigned char)132,
   (unsigned char)223,
   (unsigned char)203,
   (unsigned char)52,
   (unsigned char)118,
   (unsigned char)109,
   (unsigned char)169,
   (unsigned char)209,
   (unsigned char)4,
   (unsigned char)20,
   (unsigned char)58,
   (unsigned char)222,
   (unsigned char)17,
   (unsigned char)50,
   (unsigned char)156,
   (unsigned char)83,
   (unsigned char)242,
   (unsigned char)254,
   (unsigned char)207,
   (unsigned char)195,
   (unsigned char)122,
   (unsigned char)36,
   (unsigned char)232,
   (unsigned char)96,
   (unsigned char)105,
   (unsigned char)170,
   (unsigned char)160,
   (unsigned char)161,
   (unsigned char)98,
   (unsigned char)84,
   (unsigned char)30,
   (unsigned char)224,
   (unsigned char)100,
   (unsigned char)16,
   (unsigned char)0,
   (unsigned char)163,
   (unsigned char)117,
   (unsigned char)138,
   (unsigned char)230,
   (unsigned char)9,
   (unsigned char)221,
   (unsigned char)135,
   (unsigned char)131,
   (unsigned char)205,
   (unsigned char)144,
   (unsigned char)115,
   (unsigned char)246,
   (unsigned char)157,
   (unsigned char)191,
   (unsigned char)82,
   (unsigned char)216,
   (unsigned char)200,
   (unsigned char)198,
   (unsigned char)129,
   (unsigned char)111,
   (unsigned char)19,
   (unsigned char)99,
   (unsigned char)233,
   (unsigned char)167,
   (unsigned char)159,
   (unsigned char)188,
   (unsigned char)41,
   (unsigned char)249,
   (unsigned char)47,
   (unsigned char)180,
   (unsigned char)120,
   (unsigned char)6,
   (unsigned char)231,
   (unsigned char)113,
   (unsigned char)212,
   (unsigned char)171,
   (unsigned char)136,
   (unsigned char)141,
   (unsigned char)114,
   (unsigned char)185,
   (unsigned char)248,
   (unsigned char)172,
   (unsigned char)54,
   (unsigned char)42,
   (unsigned char)60,
   (unsigned char)241,
   (unsigned char)64,
   (unsigned char)211,
   (unsigned char)187,
   (unsigned char)67,
   (unsigned char)21,
   (unsigned char)173,
   (unsigned char)119,
   (unsigned char)128,
   (unsigned char)130,
   (unsigned char)236,
   (unsigned char)39,
   (unsigned char)229,
   (unsigned char)133,
   (unsigned char)53,
   (unsigned char)12,
   (unsigned char)65,
   (unsigned char)239,
   (unsigned char)147,
   (unsigned char)25,
   (unsigned char)33,
   (unsigned char)14,
   (unsigned char)78,
   (unsigned char)101,
   (unsigned char)189,
   (unsigned char)184,
   (unsigned char)143,
   (unsigned char)235,
   (unsigned char)206,
   (unsigned char)48,
   (unsigned char)95,
   (unsigned char)197,
   (unsigned char)26,
   (unsigned char)225,
   (unsigned char)202,
   (unsigned char)71,
   (unsigned char)61,
   (unsigned char)1,
   (unsigned char)214,
   (unsigned char)86,
   (unsigned char)77,
   (unsigned char)13,
   (unsigned char)102,
   (unsigned char)204,
   (unsigned char)45,
   (unsigned char)18,
   (unsigned char)32,
   (unsigned char)177,
   (unsigned char)153,
   (unsigned char)76,
   (unsigned char)194,
   (unsigned char)126,
   (unsigned char)5,
   (unsigned char)183,
   (unsigned char)49,
   (unsigned char)23,
   (unsigned char)215,
   (unsigned char)88,
   (unsigned char)97,
   (unsigned char)27,
   (unsigned char)28,
   (unsigned char)15,
   (unsigned char)22,
   (unsigned char)24,
   (unsigned char)34,
   (unsigned char)68,
   (unsigned char)178,
   (unsigned char)181,
   (unsigned char)145,
   (unsigned char)8,
   (unsigned char)168,
   (unsigned char)252,
   (unsigned char)80,
   (unsigned char)208,
   (unsigned char)125,
   (unsigned char)137,
   (unsigned char)151,
   (unsigned char)91,
   (unsigned char)149,
   (unsigned char)255,
   (unsigned char)210,
   (unsigned char)196,
   (unsigned char)72,
   (unsigned char)247,
   (unsigned char)219,
   (unsigned char)3,
   (unsigned char)218,
   (unsigned char)63,
   (unsigned char)148,
   (unsigned char)92,
   (unsigned char)2,
   (unsigned char)74,
   (unsigned char)51,
   (unsigned char)103,
   (unsigned char)243,
   (unsigned char)127,
   (unsigned char)226,
   (unsigned char)155,
   (unsigned char)38,
   (unsigned char)55,
   (unsigned char)59,
   (unsigned char)150,
   (unsigned char)75,
   (unsigned char)190,
   (unsigned char)46,
   (unsigned char)121,
   (unsigned char)140,
   (unsigned char)110,
   (unsigned char)142,
   (unsigned char)245,
   (unsigned char)182,
   (unsigned char)253,
   (unsigned char)89,
   (unsigned char)152,
   (unsigned char)106,
   (unsigned char)70,
   (unsigned char)186,
   (unsigned char)37,
   (unsigned char)66,
   (unsigned char)162,
   (unsigned char)250,
   (unsigned char)7,
   (unsigned char)85,
   (unsigned char)238,
   (unsigned char)10,
   (unsigned char)73,
   (unsigned char)104,
   (unsigned char)56,
   (unsigned char)164,
   (unsigned char)40,
   (unsigned char)123,
   (unsigned char)201,
   (unsigned char)193,
   (unsigned char)227,
   (unsigned char)244,
   (unsigned char)199,
   (unsigned char)158};
static unsigned char const shifts[2][4][4] =
  {{{(unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1},
    {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0},
    {(unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)1},
    {(unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0}},
   {{(unsigned char)1, (unsigned char)0, (unsigned char)1, (unsigned char)1},
    {(unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)1},
    {(unsigned char)1, (unsigned char)1, (unsigned char)1, (unsigned char)0},
    {(unsigned char)1, (unsigned char)1, (unsigned char)0, (unsigned char)1}}};
static signed char const indexes[2][4][20] =
  {{{(signed char)0,
     (signed char)1,
     (signed char)2,
     (signed char)3,
     (signed char)8,
     (signed char)9,
     (signed char)10,
     (signed char)11,
     (signed char)38,
     (signed char)39,
     (signed char)36,
     (signed char)37,
     (signed char)23,
     (signed char)20,
     (signed char)21,
     (signed char)22,
     (signed char)27,
     (signed char)(-1),
     (signed char)(-1),
     (signed char)26},
    {(signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1)},
    {(signed char)4,
     (signed char)5,
     (signed char)6,
     (signed char)7,
     (signed char)12,
     (signed char)13,
     (signed char)14,
     (signed char)15,
     (signed char)16,
     (signed char)17,
     (signed char)18,
     (signed char)19,
     (signed char)(-1),
     (signed char)24,
     (signed char)25,
     (signed char)(-1),
     (signed char)31,
     (signed char)28,
     (signed char)29,
     (signed char)30},
    {(signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1)}},
   {{(signed char)0,
     (signed char)1,
     (signed char)2,
     (signed char)3,
     (signed char)61,
     (signed char)62,
     (signed char)63,
     (signed char)60,
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)27,
     (signed char)24,
     (signed char)25,
     (signed char)26,
     (signed char)35,
     (signed char)32,
     (signed char)33,
     (signed char)34},
    {(signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)8,
     (signed char)9,
     (signed char)10,
     (signed char)11,
     (signed char)16,
     (signed char)17,
     (signed char)18,
     (signed char)19,
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)39,
     (signed char)36,
     (signed char)37,
     (signed char)38},
    {(signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)12,
     (signed char)13,
     (signed char)14,
     (signed char)15,
     (signed char)58,
     (signed char)59,
     (signed char)56,
     (signed char)57,
     (signed char)31,
     (signed char)28,
     (signed char)29,
     (signed char)30,
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1)},
    {(signed char)4,
     (signed char)5,
     (signed char)6,
     (signed char)7,
     (signed char)65,
     (signed char)66,
     (signed char)67,
     (signed char)64,
     (signed char)20,
     (signed char)21,
     (signed char)22,
     (signed char)23,
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)(-1),
     (signed char)43,
     (signed char)40,
     (signed char)41,
     (signed char)42}}};
static signed char const transposes[2][20] =
  {{(signed char)21,
    (signed char)22,
    (signed char)23,
    (signed char)20,
    (signed char)(-1),
    (signed char)(-1),
    (signed char)(-1),
    (signed char)(-1),
    (signed char)18,
    (signed char)19,
    (signed char)16,
    (signed char)17,
    (signed char)11,
    (signed char)8,
    (signed char)9,
    (signed char)10,
    (signed char)15,
    (signed char)12,
    (signed char)13,
    (signed char)14},
   {(signed char)25,
    (signed char)26,
    (signed char)27,
    (signed char)24,
    (signed char)29,
    (signed char)30,
    (signed char)31,
    (signed char)28,
    (signed char)18,
    (signed char)19,
    (signed char)16,
    (signed char)17,
    (signed char)(-1),
    (signed char)(-1),
    (signed char)(-1),
    (signed char)(-1),
    (signed char)(-1),
    (signed char)(-1),
    (signed char)(-1),
    (signed char)(-1)}};
/*@ requires \valid_read(k + (0 .. 1));
    requires \valid_read(x + (0 .. 1));
    ensures \initialized(\old(z) + (0 .. 1));
    assigns *(z + (0 .. 1));
    assigns *(z + (0 .. 1)) \from *(k + (0 .. 1)), *(x + (0 .. 1));
 */
static void camellia_feistel(uint32_t const x[2], uint32_t const k[2],
                             uint32_t z[2])
{
  uint32_t I0;
  uint32_t I1;
  I0 = *(x + 0) ^ *(k + 0);
  I1 = *(x + 1) ^ *(k + 1);
  I0 = (uint32_t)(((((int)FSb_0[(I0 >> 24) & (unsigned int)0xFF] << 24) | (
                    (int)FSb2[(I0 >> 16) & (unsigned int)0xFF] << 16)) | (
                   (int)FSb3[(I0 >> 8) & (unsigned int)0xFF] << 8)) | (int)FSb4[
                  I0 & (unsigned int)0xFF]);
  I1 = (uint32_t)(((((int)FSb2[(I1 >> 24) & (unsigned int)0xFF] << 24) | (
                    (int)FSb3[(I1 >> 16) & (unsigned int)0xFF] << 16)) | (
                   (int)FSb4[(I1 >> 8) & (unsigned int)0xFF] << 8)) | (int)FSb_0[
                  I1 & (unsigned int)0xFF]);
  I0 ^= (I1 << 8) | (I1 >> 24);
  I1 ^= (I0 << 16) | (I0 >> 16);
  I0 ^= (I1 >> 8) | (I1 << 24);
  I1 ^= (I0 >> 8) | (I0 << 24);
  *(z + 0) ^= I1;
  *(z + 1) ^= I0;
  return;
}

int camellia_setkey_enc(camellia_context *ctx, unsigned char const *key,
                        unsigned int keysize)
{
  int __retres;
  int idx;
  size_t i;
  uint32_t *RK;
  unsigned char t[64];
  uint32_t SIGMA[6][2];
  uint32_t KC[16];
  uint32_t TK[20];
  RK = ctx->rk;
  memset((void *)(t),0,(size_t)64);
  memset((void *)RK,0,sizeof(ctx->rk));
  switch (keysize) {
    case (unsigned int)128: ctx->nr = 3;
    idx = 0;
    break;
    case (unsigned int)192: case (unsigned int)256: ctx->nr = 4;
    idx = 1;
    break;
    default: __retres = -0x0024;
    goto return_label;
  }
  i = (size_t)0;
  /*@ loop unroll 32; */
  while (i < keysize / (unsigned int)8) {
    t[i] = *(key + i);
    i ++;
  }
  if (keysize == (unsigned int)192) {
    i = (size_t)0;
    /*@ loop unroll 8; */
    while (i < (size_t)8) {
      t[(size_t)24 + i] = (unsigned char)(~ ((int)t[(size_t)16 + i]));
      i ++;
    }
  }
  i = (size_t)0;
  /*@ loop unroll 6; */
  while (i < (size_t)6) {
    SIGMA[i][0] = (uint32_t)(((((unsigned long)SIGMA_CHARS[i][0] << 24) | (
                               (unsigned long)SIGMA_CHARS[i][0 + 1] << 16)) | (
                              (unsigned long)SIGMA_CHARS[i][0 + 2] << 8)) | (unsigned long)SIGMA_CHARS[i][
                             0 + 3]);
    SIGMA[i][1] = (uint32_t)(((((unsigned long)SIGMA_CHARS[i][4] << 24) | (
                               (unsigned long)SIGMA_CHARS[i][4 + 1] << 16)) | (
                              (unsigned long)SIGMA_CHARS[i][4 + 2] << 8)) | (unsigned long)SIGMA_CHARS[i][
                             4 + 3]);
    i ++;
  }
  memset((void *)(KC),0,sizeof(KC));
  i = (size_t)0;
  /*@ loop unroll 8; */
  while (i < (size_t)8) {
    KC[i] = (uint32_t)(((((unsigned long)t[i * (size_t)4] << 24) | ((unsigned long)t[
                                                                    i * (size_t)4 + (size_t)1] << 16)) | (
                        (unsigned long)t[i * (size_t)4 + (size_t)2] << 8)) | (unsigned long)t[
                       i * (size_t)4 + (size_t)3]);
    i ++;
  }
  i = (size_t)0;
  /*@ loop unroll 4; */
  while (i < (size_t)4) {
    KC[(size_t)8 + i] = KC[i] ^ KC[(size_t)4 + i];
    i ++;
  }
  camellia_feistel((uint32_t const *)(& KC[8]),(uint32_t const *)(SIGMA[0]),
                   & KC[10]);
  camellia_feistel((uint32_t const *)(& KC[10]),(uint32_t const *)(SIGMA[1]),
                   & KC[8]);
  i = (size_t)0;
  /*@ loop unroll 4; */
  while (i < (size_t)4) {
    KC[(size_t)8 + i] ^= KC[i];
    i ++;
  }
  camellia_feistel((uint32_t const *)(& KC[8]),(uint32_t const *)(SIGMA[2]),
                   & KC[10]);
  camellia_feistel((uint32_t const *)(& KC[10]),(uint32_t const *)(SIGMA[3]),
                   & KC[8]);
  if (keysize > (unsigned int)128) {
    i = (size_t)0;
    /*@ loop unroll 4; */
    while (i < (size_t)4) {
      KC[(size_t)12 + i] = KC[(size_t)4 + i] ^ KC[(size_t)8 + i];
      i ++;
    }
    camellia_feistel((uint32_t const *)(& KC[12]),
                     (uint32_t const *)(SIGMA[4]),& KC[14]);
    camellia_feistel((uint32_t const *)(& KC[14]),
                     (uint32_t const *)(SIGMA[5]),& KC[12]);
  }
  TK[0] = KC[0 * 4 + 0];
  TK[1] = KC[0 * 4 + 1];
  TK[2] = KC[0 * 4 + 2];
  TK[3] = KC[0 * 4 + 3];
  i = (size_t)1;
  /*@ loop unroll 4; */
  while (i <= (size_t)4) {
    if (shifts[idx][0][i - (size_t)1]) {
      *(& TK[i * (size_t)4] + 0) = (TK[0] << ((size_t)15 * i) % (unsigned int)32) ^ (
                                   TK[1] >> ((unsigned int)32 - ((size_t)15 * i) % (unsigned int)32));
      *(& TK[i * (size_t)4] + 1) = (TK[1] << ((size_t)15 * i) % (unsigned int)32) ^ (
                                   TK[2] >> ((unsigned int)32 - ((size_t)15 * i) % (unsigned int)32));
      *(& TK[i * (size_t)4] + 2) = (TK[2] << ((size_t)15 * i) % (unsigned int)32) ^ (
                                   TK[3] >> ((unsigned int)32 - ((size_t)15 * i) % (unsigned int)32));
      *(& TK[i * (size_t)4] + 3) = (TK[3] << ((size_t)15 * i) % (unsigned int)32) ^ (
                                   TK[0] >> ((unsigned int)32 - ((size_t)15 * i) % (unsigned int)32));
    }
    i ++;
  }
  i = (size_t)0;
  /*@ loop unroll 20; */
  while (i < (size_t)20) {
    if ((int)indexes[idx][0][i] != -1) *(RK + indexes[idx][0][i]) = TK[i];
    i ++;
  }
  if (keysize > (unsigned int)128) {
    TK[0] = KC[1 * 4 + 0];
    TK[1] = KC[1 * 4 + 1];
    TK[2] = KC[1 * 4 + 2];
    TK[3] = KC[1 * 4 + 3];
    i = (size_t)1;
    /*@ loop unroll 4; */
    while (i <= (size_t)4) {
      if (shifts[idx][1][i - (size_t)1]) {
        *(& TK[i * (size_t)4] + 0) = (TK[0] << ((size_t)15 * i) % (unsigned int)32) ^ (
                                     TK[1] >> ((unsigned int)32 - ((size_t)15 * i) % (unsigned int)32));
        *(& TK[i * (size_t)4] + 1) = (TK[1] << ((size_t)15 * i) % (unsigned int)32) ^ (
                                     TK[2] >> ((unsigned int)32 - ((size_t)15 * i) % (unsigned int)32));
        *(& TK[i * (size_t)4] + 2) = (TK[2] << ((size_t)15 * i) % (unsigned int)32) ^ (
                                     TK[3] >> ((unsigned int)32 - ((size_t)15 * i) % (unsigned int)32));
        *(& TK[i * (size_t)4] + 3) = (TK[3] << ((size_t)15 * i) % (unsigned int)32) ^ (
                                     TK[0] >> ((unsigned int)32 - ((size_t)15 * i) % (unsigned int)32));
      }
      i ++;
    }
    i = (size_t)0;
    /*@ loop unroll 20; */
    while (i < (size_t)20) {
      if ((int)indexes[idx][1][i] != -1) *(RK + indexes[idx][1][i]) = TK[i];
      i ++;
    }
  }
  TK[0] = KC[2 * 4 + 0];
  TK[1] = KC[2 * 4 + 1];
  TK[2] = KC[2 * 4 + 2];
  TK[3] = KC[2 * 4 + 3];
  i = (size_t)1;
  /*@ loop unroll 4; */
  while (i <= (size_t)4) {
    if (shifts[idx][2][i - (size_t)1]) {
      *(& TK[i * (size_t)4] + 0) = (TK[0] << ((size_t)15 * i) % (unsigned int)32) ^ (
                                   TK[1] >> ((unsigned int)32 - ((size_t)15 * i) % (unsigned int)32));
      *(& TK[i * (size_t)4] + 1) = (TK[1] << ((size_t)15 * i) % (unsigned int)32) ^ (
                                   TK[2] >> ((unsigned int)32 - ((size_t)15 * i) % (unsigned int)32));
      *(& TK[i * (size_t)4] + 2) = (TK[2] << ((size_t)15 * i) % (unsigned int)32) ^ (
                                   TK[3] >> ((unsigned int)32 - ((size_t)15 * i) % (unsigned int)32));
      *(& TK[i * (size_t)4] + 3) = (TK[3] << ((size_t)15 * i) % (unsigned int)32) ^ (
                                   TK[0] >> ((unsigned int)32 - ((size_t)15 * i) % (unsigned int)32));
    }
    i ++;
  }
  i = (size_t)0;
  /*@ loop unroll 20; */
  while (i < (size_t)20) {
    if ((int)indexes[idx][2][i] != -1) *(RK + indexes[idx][2][i]) = TK[i];
    i ++;
  }
  if (keysize > (unsigned int)128) {
    TK[0] = KC[3 * 4 + 0];
    TK[1] = KC[3 * 4 + 1];
    TK[2] = KC[3 * 4 + 2];
    TK[3] = KC[3 * 4 + 3];
    i = (size_t)1;
    /*@ loop unroll 4; */
    while (i <= (size_t)4) {
      if (shifts[idx][3][i - (size_t)1]) {
        *(& TK[i * (size_t)4] + 0) = (TK[0] << ((size_t)15 * i) % (unsigned int)32) ^ (
                                     TK[1] >> ((unsigned int)32 - ((size_t)15 * i) % (unsigned int)32));
        *(& TK[i * (size_t)4] + 1) = (TK[1] << ((size_t)15 * i) % (unsigned int)32) ^ (
                                     TK[2] >> ((unsigned int)32 - ((size_t)15 * i) % (unsigned int)32));
        *(& TK[i * (size_t)4] + 2) = (TK[2] << ((size_t)15 * i) % (unsigned int)32) ^ (
                                     TK[3] >> ((unsigned int)32 - ((size_t)15 * i) % (unsigned int)32));
        *(& TK[i * (size_t)4] + 3) = (TK[3] << ((size_t)15 * i) % (unsigned int)32) ^ (
                                     TK[0] >> ((unsigned int)32 - ((size_t)15 * i) % (unsigned int)32));
      }
      i ++;
    }
    i = (size_t)0;
    /*@ loop unroll 20; */
    while (i < (size_t)20) {
      if ((int)indexes[idx][3][i] != -1) *(RK + indexes[idx][3][i]) = TK[i];
      i ++;
    }
  }
  i = (size_t)0;
  /*@ loop unroll 20; */
  while (i < (size_t)20) {
    if ((int)transposes[idx][i] != -1) *(RK + ((size_t)(32 + 12 * idx) + i)) = *(
                                       RK + transposes[idx][i]);
    i ++;
  }
  __retres = 0;
  return_label: return __retres;
}

int camellia_setkey_dec(camellia_context *ctx, unsigned char const *key,
                        unsigned int keysize)
{
  int __retres;
  int idx;
  size_t i;
  camellia_context cty;
  uint32_t *RK;
  uint32_t *SK;
  int ret;
  uint32_t *tmp;
  uint32_t *tmp_0;
  uint32_t *tmp_1;
  uint32_t *tmp_2;
  uint32_t *tmp_3;
  uint32_t *tmp_4;
  uint32_t *tmp_5;
  uint32_t *tmp_6;
  uint32_t *tmp_11;
  uint32_t *tmp_12;
  uint32_t *tmp_13;
  uint32_t *tmp_14;
  uint32_t *tmp_15;
  uint32_t *tmp_16;
  uint32_t *tmp_17;
  uint32_t *tmp_18;
  switch (keysize) {
    case (unsigned int)128: ctx->nr = 3;
    idx = 0;
    break;
    case (unsigned int)192: case (unsigned int)256: ctx->nr = 4;
    idx = 1;
    break;
    default: __retres = -0x0024;
    goto return_label;
  }
  RK = ctx->rk;
  ret = camellia_setkey_enc(& cty,key,keysize);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  SK = & cty.rk[24 * 2] + (8 * idx) * 2;
  tmp = RK;
  RK ++;
  tmp_0 = SK;
  SK ++;
  *tmp = *tmp_0;
  tmp_1 = RK;
  RK ++;
  tmp_2 = SK;
  SK ++;
  *tmp_1 = *tmp_2;
  tmp_3 = RK;
  RK ++;
  tmp_4 = SK;
  SK ++;
  *tmp_3 = *tmp_4;
  tmp_5 = RK;
  RK ++;
  tmp_6 = SK;
  SK ++;
  *tmp_5 = *tmp_6;
  i = (size_t)(22 + 8 * idx);
  SK -= 6;
  /*@ loop unroll 30; */
  while (i > (size_t)0) {
    {
      uint32_t *tmp_7;
      uint32_t *tmp_8;
      uint32_t *tmp_9;
      uint32_t *tmp_10;
      tmp_7 = RK;
      RK ++;
      tmp_8 = SK;
      SK ++;
      *tmp_7 = *tmp_8;
      tmp_9 = RK;
      RK ++;
      tmp_10 = SK;
      SK ++;
      *tmp_9 = *tmp_10;
    }
    i --;
    SK -= 4;
  }
  SK -= 2;
  tmp_11 = RK;
  RK ++;
  tmp_12 = SK;
  SK ++;
  *tmp_11 = *tmp_12;
  tmp_13 = RK;
  RK ++;
  tmp_14 = SK;
  SK ++;
  *tmp_13 = *tmp_14;
  tmp_15 = RK;
  RK ++;
  tmp_16 = SK;
  SK ++;
  *tmp_15 = *tmp_16;
  tmp_17 = RK;
  RK ++;
  tmp_18 = SK;
  SK ++;
  *tmp_17 = *tmp_18;
  memset((void *)(& cty),0,sizeof(camellia_context));
  __retres = 0;
  return_label: return __retres;
}

int camellia_crypt_ecb(camellia_context *ctx, int mode,
                       unsigned char const input[16],
                       unsigned char output[16])
{
  int __retres;
  int NR;
  uint32_t *RK;
  uint32_t X[4];
  uint32_t *tmp;
  uint32_t *tmp_0;
  uint32_t *tmp_1;
  uint32_t *tmp_2;
  uint32_t *tmp_3;
  uint32_t *tmp_4;
  uint32_t *tmp_5;
  uint32_t *tmp_6;
  NR = ctx->nr;
  RK = ctx->rk;
  X[0] = (uint32_t)(((((unsigned long)*(input + 0) << 24) | ((unsigned long)*(
                                                             input + (
                                                             0 + 1)) << 16)) | (
                     (unsigned long)*(input + (0 + 2)) << 8)) | (unsigned long)*(
                    input + (0 + 3)));
  X[1] = (uint32_t)(((((unsigned long)*(input + 4) << 24) | ((unsigned long)*(
                                                             input + (
                                                             4 + 1)) << 16)) | (
                     (unsigned long)*(input + (4 + 2)) << 8)) | (unsigned long)*(
                    input + (4 + 3)));
  X[2] = (uint32_t)(((((unsigned long)*(input + 8) << 24) | ((unsigned long)*(
                                                             input + (
                                                             8 + 1)) << 16)) | (
                     (unsigned long)*(input + (8 + 2)) << 8)) | (unsigned long)*(
                    input + (8 + 3)));
  X[3] = (uint32_t)(((((unsigned long)*(input + 12) << 24) | ((unsigned long)*(
                                                              input + (
                                                              12 + 1)) << 16)) | (
                     (unsigned long)*(input + (12 + 2)) << 8)) | (unsigned long)*(
                    input + (12 + 3)));
  tmp = RK;
  RK ++;
  X[0] ^= *tmp;
  tmp_0 = RK;
  RK ++;
  X[1] ^= *tmp_0;
  tmp_1 = RK;
  RK ++;
  X[2] ^= *tmp_1;
  tmp_2 = RK;
  RK ++;
  X[3] ^= *tmp_2;
  while (NR) {
    NR --;
    camellia_feistel((uint32_t const *)(X),(uint32_t const *)RK,& X[2]);
    RK += 2;
    camellia_feistel((uint32_t const *)(& X[2]),(uint32_t const *)RK,X);
    RK += 2;
    camellia_feistel((uint32_t const *)(X),(uint32_t const *)RK,& X[2]);
    RK += 2;
    camellia_feistel((uint32_t const *)(& X[2]),(uint32_t const *)RK,X);
    RK += 2;
    camellia_feistel((uint32_t const *)(X),(uint32_t const *)RK,& X[2]);
    RK += 2;
    camellia_feistel((uint32_t const *)(& X[2]),(uint32_t const *)RK,X);
    RK += 2;
    if (NR) {
      X[1] = (((X[0] & *(RK + 0)) << 1) | ((X[0] & *(RK + 0)) >> 31)) ^ X[1];
      X[0] = (X[1] | *(RK + 1)) ^ X[0];
      RK += 2;
      X[2] = (X[3] | *(RK + 1)) ^ X[2];
      X[3] = (((X[2] & *(RK + 0)) << 1) | ((X[2] & *(RK + 0)) >> 31)) ^ X[3];
      RK += 2;
    }
  }
  tmp_3 = RK;
  RK ++;
  X[2] ^= *tmp_3;
  tmp_4 = RK;
  RK ++;
  X[3] ^= *tmp_4;
  tmp_5 = RK;
  RK ++;
  X[0] ^= *tmp_5;
  tmp_6 = RK;
  RK ++;
  X[1] ^= *tmp_6;
  *(output + 0) = (unsigned char)(X[2] >> 24);
  *(output + (0 + 1)) = (unsigned char)(X[2] >> 16);
  *(output + (0 + 2)) = (unsigned char)(X[2] >> 8);
  *(output + (0 + 3)) = (unsigned char)X[2];
  *(output + 4) = (unsigned char)(X[3] >> 24);
  *(output + (4 + 1)) = (unsigned char)(X[3] >> 16);
  *(output + (4 + 2)) = (unsigned char)(X[3] >> 8);
  *(output + (4 + 3)) = (unsigned char)X[3];
  *(output + 8) = (unsigned char)(X[0] >> 24);
  *(output + (8 + 1)) = (unsigned char)(X[0] >> 16);
  *(output + (8 + 2)) = (unsigned char)(X[0] >> 8);
  *(output + (8 + 3)) = (unsigned char)X[0];
  *(output + 12) = (unsigned char)(X[1] >> 24);
  *(output + (12 + 1)) = (unsigned char)(X[1] >> 16);
  *(output + (12 + 2)) = (unsigned char)(X[1] >> 8);
  *(output + (12 + 3)) = (unsigned char)X[1];
  __retres = 0;
  return __retres;
}

/*@ requires length % 16 ≡ 0;
    requires \valid(iv + (0 .. 15));
    requires \valid(output + (0 .. length - 1));
    requires \valid_read(input + (0 .. length - 1));
    assigns *(iv + (0 .. 15)), *(output + (0 .. length - 1)), \result;
    assigns *(iv + (0 .. 15)) \from *(input + (0 .. length - 1));
    assigns *(output + (0 .. length - 1))
      \from *(input + (0 .. length - 1)), *(iv + (0 .. 15));
    assigns \result \from _state;
 */
int camellia_crypt_cbc(camellia_context *ctx, int mode, size_t length,
                       unsigned char iv[16], unsigned char const *input,
                       unsigned char *output)
{
  int __retres;
  int i;
  unsigned char temp[16];
  if (length % (unsigned int)16) {
    __retres = -0x0026;
    goto return_label;
  }
  if (mode == 0) 
    while (length > (size_t)0) {
      memcpy((void *)(temp),(void const *)input,(size_t)16);
      camellia_crypt_ecb(ctx,mode,input,output);
      i = 0;
      while (i < 16) {
        *(output + i) = (unsigned char)((int)*(output + i) ^ (int)*(iv + i));
        i ++;
      }
      memcpy((void *)iv,(void const *)(temp),(size_t)16);
      input += 16;
      output += 16;
      length -= (size_t)16;
    }
  else 
    while (length > (size_t)0) {
      i = 0;
      while (i < 16) {
        *(output + i) = (unsigned char)((int)*(input + i) ^ (int)*(iv + i));
        i ++;
      }
      camellia_crypt_ecb(ctx,mode,(unsigned char const *)output,output);
      memcpy((void *)iv,(void const *)output,(size_t)16);
      input += 16;
      output += 16;
      length -= (size_t)16;
    }
  __retres = 0;
  return_label: return __retres;
}

int camellia_crypt_cfb128(camellia_context *ctx, int mode, size_t length,
                          size_t *iv_off, unsigned char iv[16],
                          unsigned char const *input, unsigned char *output)
{
  int __retres;
  int c;
  size_t n = *iv_off;
  if (mode == 0) 
    while (1) {
      size_t tmp_1;
      tmp_1 = length;
      length --;
      ;
      if (! tmp_1) break;
      {
        unsigned char const *tmp;
        unsigned char *tmp_0;
        if (n == (size_t)0) camellia_crypt_ecb(ctx,1,
                                               (unsigned char const *)iv,iv);
        tmp = input;
        input ++;
        c = (int)*tmp;
        tmp_0 = output;
        output ++;
        *tmp_0 = (unsigned char)(c ^ (int)*(iv + n));
        *(iv + n) = (unsigned char)c;
        n = (n + (size_t)1) & (unsigned int)0x0F;
      }
    }
  else 
    while (1) {
      size_t tmp_5;
      tmp_5 = length;
      length --;
      ;
      if (! tmp_5) break;
      {
        unsigned char *tmp_2;
        unsigned char const *tmp_4;
        unsigned char tmp_3;
        if (n == (size_t)0) camellia_crypt_ecb(ctx,1,
                                               (unsigned char const *)iv,iv);
        tmp_2 = output;
        output ++;
        tmp_4 = input;
        input ++;
        tmp_3 = (unsigned char)((int)*(iv + n) ^ (int)*tmp_4);
        *tmp_2 = tmp_3;
        *(iv + n) = tmp_3;
        n = (n + (size_t)1) & (unsigned int)0x0F;
      }
    }
  *iv_off = n;
  __retres = 0;
  return __retres;
}

int camellia_crypt_ctr(camellia_context *ctx, size_t length, size_t *nc_off,
                       unsigned char nonce_counter[16],
                       unsigned char stream_block[16],
                       unsigned char const *input, unsigned char *output)
{
  int __retres;
  int c;
  int i;
  int cb;
  size_t n = *nc_off;
  while (1) {
    size_t tmp_2;
    tmp_2 = length;
    length --;
    ;
    if (! tmp_2) break;
    {
      unsigned char const *tmp_0;
      unsigned char *tmp_1;
      if (n == (size_t)0) {
        camellia_crypt_ecb(ctx,1,(unsigned char const *)nonce_counter,
                           stream_block);
        i = 15;
        while (1) {
          int tmp;
          *(nonce_counter + i) = (unsigned char)((int)*(nonce_counter + i) + 1);
          cb = (int)*(nonce_counter + i) == 0;
          tmp = i;
          i --;
          ;
          if (tmp) {
            if (! cb) break;
          }
          else break;
        }
      }
      tmp_0 = input;
      input ++;
      c = (int)*tmp_0;
      tmp_1 = output;
      output ++;
      *tmp_1 = (unsigned char)(c ^ (int)*(stream_block + n));
      n = (n + (size_t)1) & (unsigned int)0x0F;
    }
  }
  *nc_off = n;
  __retres = 0;
  return __retres;
}

static unsigned char const camellia_test_ecb_key[3][2][32] =
  {{{(unsigned char)0x01,
     (unsigned char)0x23,
     (unsigned char)0x45,
     (unsigned char)0x67,
     (unsigned char)0x89,
     (unsigned char)0xab,
     (unsigned char)0xcd,
     (unsigned char)0xef,
     (unsigned char)0xfe,
     (unsigned char)0xdc,
     (unsigned char)0xba,
     (unsigned char)0x98,
     (unsigned char)0x76,
     (unsigned char)0x54,
     (unsigned char)0x32,
     (unsigned char)0x10},
    {(unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00}},
   {{(unsigned char)0x01,
     (unsigned char)0x23,
     (unsigned char)0x45,
     (unsigned char)0x67,
     (unsigned char)0x89,
     (unsigned char)0xab,
     (unsigned char)0xcd,
     (unsigned char)0xef,
     (unsigned char)0xfe,
     (unsigned char)0xdc,
     (unsigned char)0xba,
     (unsigned char)0x98,
     (unsigned char)0x76,
     (unsigned char)0x54,
     (unsigned char)0x32,
     (unsigned char)0x10,
     (unsigned char)0x00,
     (unsigned char)0x11,
     (unsigned char)0x22,
     (unsigned char)0x33,
     (unsigned char)0x44,
     (unsigned char)0x55,
     (unsigned char)0x66,
     (unsigned char)0x77},
    {(unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00}},
   {{(unsigned char)0x01,
     (unsigned char)0x23,
     (unsigned char)0x45,
     (unsigned char)0x67,
     (unsigned char)0x89,
     (unsigned char)0xab,
     (unsigned char)0xcd,
     (unsigned char)0xef,
     (unsigned char)0xfe,
     (unsigned char)0xdc,
     (unsigned char)0xba,
     (unsigned char)0x98,
     (unsigned char)0x76,
     (unsigned char)0x54,
     (unsigned char)0x32,
     (unsigned char)0x10,
     (unsigned char)0x00,
     (unsigned char)0x11,
     (unsigned char)0x22,
     (unsigned char)0x33,
     (unsigned char)0x44,
     (unsigned char)0x55,
     (unsigned char)0x66,
     (unsigned char)0x77,
     (unsigned char)0x88,
     (unsigned char)0x99,
     (unsigned char)0xaa,
     (unsigned char)0xbb,
     (unsigned char)0xcc,
     (unsigned char)0xdd,
     (unsigned char)0xee,
     (unsigned char)0xff},
    {(unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00,
     (unsigned char)0x00}}};
static unsigned char const camellia_test_ecb_plain[2][16] =
  {{(unsigned char)0x01,
    (unsigned char)0x23,
    (unsigned char)0x45,
    (unsigned char)0x67,
    (unsigned char)0x89,
    (unsigned char)0xab,
    (unsigned char)0xcd,
    (unsigned char)0xef,
    (unsigned char)0xfe,
    (unsigned char)0xdc,
    (unsigned char)0xba,
    (unsigned char)0x98,
    (unsigned char)0x76,
    (unsigned char)0x54,
    (unsigned char)0x32,
    (unsigned char)0x10},
   {(unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x02,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00}};
static unsigned char const camellia_test_ecb_cipher[3][2][16] =
  {{{(unsigned char)0x67,
     (unsigned char)0x67,
     (unsigned char)0x31,
     (unsigned char)0x38,
     (unsigned char)0x54,
     (unsigned char)0x96,
     (unsigned char)0x69,
     (unsigned char)0x73,
     (unsigned char)0x08,
     (unsigned char)0x57,
     (unsigned char)0x06,
     (unsigned char)0x56,
     (unsigned char)0x48,
     (unsigned char)0xea,
     (unsigned char)0xbe,
     (unsigned char)0x43},
    {(unsigned char)0x38,
     (unsigned char)0x3C,
     (unsigned char)0x6C,
     (unsigned char)0x2A,
     (unsigned char)0xAB,
     (unsigned char)0xEF,
     (unsigned char)0x7F,
     (unsigned char)0xDE,
     (unsigned char)0x25,
     (unsigned char)0xCD,
     (unsigned char)0x47,
     (unsigned char)0x0B,
     (unsigned char)0xF7,
     (unsigned char)0x74,
     (unsigned char)0xA3,
     (unsigned char)0x31}},
   {{(unsigned char)0xb4,
     (unsigned char)0x99,
     (unsigned char)0x34,
     (unsigned char)0x01,
     (unsigned char)0xb3,
     (unsigned char)0xe9,
     (unsigned char)0x96,
     (unsigned char)0xf8,
     (unsigned char)0x4e,
     (unsigned char)0xe5,
     (unsigned char)0xce,
     (unsigned char)0xe7,
     (unsigned char)0xd7,
     (unsigned char)0x9b,
     (unsigned char)0x09,
     (unsigned char)0xb9},
    {(unsigned char)0xD1,
     (unsigned char)0x76,
     (unsigned char)0x3F,
     (unsigned char)0xC0,
     (unsigned char)0x19,
     (unsigned char)0xD7,
     (unsigned char)0x7C,
     (unsigned char)0xC9,
     (unsigned char)0x30,
     (unsigned char)0xBF,
     (unsigned char)0xF2,
     (unsigned char)0xA5,
     (unsigned char)0x6F,
     (unsigned char)0x7C,
     (unsigned char)0x93,
     (unsigned char)0x64}},
   {{(unsigned char)0x9a,
     (unsigned char)0xcc,
     (unsigned char)0x23,
     (unsigned char)0x7d,
     (unsigned char)0xff,
     (unsigned char)0x16,
     (unsigned char)0xd7,
     (unsigned char)0x6c,
     (unsigned char)0x20,
     (unsigned char)0xef,
     (unsigned char)0x7c,
     (unsigned char)0x91,
     (unsigned char)0x9e,
     (unsigned char)0x3a,
     (unsigned char)0x75,
     (unsigned char)0x09},
    {(unsigned char)0x05,
     (unsigned char)0x03,
     (unsigned char)0xFB,
     (unsigned char)0x10,
     (unsigned char)0xAB,
     (unsigned char)0x24,
     (unsigned char)0x1E,
     (unsigned char)0x7C,
     (unsigned char)0xF4,
     (unsigned char)0x5D,
     (unsigned char)0x8C,
     (unsigned char)0xDE,
     (unsigned char)0xEE,
     (unsigned char)0x47,
     (unsigned char)0x43,
     (unsigned char)0x35}}};
static unsigned char const camellia_test_cbc_key[3][32] =
  {{(unsigned char)0x2B,
    (unsigned char)0x7E,
    (unsigned char)0x15,
    (unsigned char)0x16,
    (unsigned char)0x28,
    (unsigned char)0xAE,
    (unsigned char)0xD2,
    (unsigned char)0xA6,
    (unsigned char)0xAB,
    (unsigned char)0xF7,
    (unsigned char)0x15,
    (unsigned char)0x88,
    (unsigned char)0x09,
    (unsigned char)0xCF,
    (unsigned char)0x4F,
    (unsigned char)0x3C},
   {(unsigned char)0x8E,
    (unsigned char)0x73,
    (unsigned char)0xB0,
    (unsigned char)0xF7,
    (unsigned char)0xDA,
    (unsigned char)0x0E,
    (unsigned char)0x64,
    (unsigned char)0x52,
    (unsigned char)0xC8,
    (unsigned char)0x10,
    (unsigned char)0xF3,
    (unsigned char)0x2B,
    (unsigned char)0x80,
    (unsigned char)0x90,
    (unsigned char)0x79,
    (unsigned char)0xE5,
    (unsigned char)0x62,
    (unsigned char)0xF8,
    (unsigned char)0xEA,
    (unsigned char)0xD2,
    (unsigned char)0x52,
    (unsigned char)0x2C,
    (unsigned char)0x6B,
    (unsigned char)0x7B},
   {(unsigned char)0x60,
    (unsigned char)0x3D,
    (unsigned char)0xEB,
    (unsigned char)0x10,
    (unsigned char)0x15,
    (unsigned char)0xCA,
    (unsigned char)0x71,
    (unsigned char)0xBE,
    (unsigned char)0x2B,
    (unsigned char)0x73,
    (unsigned char)0xAE,
    (unsigned char)0xF0,
    (unsigned char)0x85,
    (unsigned char)0x7D,
    (unsigned char)0x77,
    (unsigned char)0x81,
    (unsigned char)0x1F,
    (unsigned char)0x35,
    (unsigned char)0x2C,
    (unsigned char)0x07,
    (unsigned char)0x3B,
    (unsigned char)0x61,
    (unsigned char)0x08,
    (unsigned char)0xD7,
    (unsigned char)0x2D,
    (unsigned char)0x98,
    (unsigned char)0x10,
    (unsigned char)0xA3,
    (unsigned char)0x09,
    (unsigned char)0x14,
    (unsigned char)0xDF,
    (unsigned char)0xF4}};
static unsigned char const camellia_test_cbc_iv[16] =
  {(unsigned char)0x00,
   (unsigned char)0x01,
   (unsigned char)0x02,
   (unsigned char)0x03,
   (unsigned char)0x04,
   (unsigned char)0x05,
   (unsigned char)0x06,
   (unsigned char)0x07,
   (unsigned char)0x08,
   (unsigned char)0x09,
   (unsigned char)0x0A,
   (unsigned char)0x0B,
   (unsigned char)0x0C,
   (unsigned char)0x0D,
   (unsigned char)0x0E,
   (unsigned char)0x0F};
static unsigned char const camellia_test_cbc_plain[3][16] =
  {{(unsigned char)0x6B,
    (unsigned char)0xC1,
    (unsigned char)0xBE,
    (unsigned char)0xE2,
    (unsigned char)0x2E,
    (unsigned char)0x40,
    (unsigned char)0x9F,
    (unsigned char)0x96,
    (unsigned char)0xE9,
    (unsigned char)0x3D,
    (unsigned char)0x7E,
    (unsigned char)0x11,
    (unsigned char)0x73,
    (unsigned char)0x93,
    (unsigned char)0x17,
    (unsigned char)0x2A},
   {(unsigned char)0xAE,
    (unsigned char)0x2D,
    (unsigned char)0x8A,
    (unsigned char)0x57,
    (unsigned char)0x1E,
    (unsigned char)0x03,
    (unsigned char)0xAC,
    (unsigned char)0x9C,
    (unsigned char)0x9E,
    (unsigned char)0xB7,
    (unsigned char)0x6F,
    (unsigned char)0xAC,
    (unsigned char)0x45,
    (unsigned char)0xAF,
    (unsigned char)0x8E,
    (unsigned char)0x51},
   {(unsigned char)0x30,
    (unsigned char)0xC8,
    (unsigned char)0x1C,
    (unsigned char)0x46,
    (unsigned char)0xA3,
    (unsigned char)0x5C,
    (unsigned char)0xE4,
    (unsigned char)0x11,
    (unsigned char)0xE5,
    (unsigned char)0xFB,
    (unsigned char)0xC1,
    (unsigned char)0x19,
    (unsigned char)0x1A,
    (unsigned char)0x0A,
    (unsigned char)0x52,
    (unsigned char)0xEF}};
static unsigned char const camellia_test_cbc_cipher[3][3][16] =
  {{{(unsigned char)0x16,
     (unsigned char)0x07,
     (unsigned char)0xCF,
     (unsigned char)0x49,
     (unsigned char)0x4B,
     (unsigned char)0x36,
     (unsigned char)0xBB,
     (unsigned char)0xF0,
     (unsigned char)0x0D,
     (unsigned char)0xAE,
     (unsigned char)0xB0,
     (unsigned char)0xB5,
     (unsigned char)0x03,
     (unsigned char)0xC8,
     (unsigned char)0x31,
     (unsigned char)0xAB},
    {(unsigned char)0xA2,
     (unsigned char)0xF2,
     (unsigned char)0xCF,
     (unsigned char)0x67,
     (unsigned char)0x16,
     (unsigned char)0x29,
     (unsigned char)0xEF,
     (unsigned char)0x78,
     (unsigned char)0x40,
     (unsigned char)0xC5,
     (unsigned char)0xA5,
     (unsigned char)0xDF,
     (unsigned char)0xB5,
     (unsigned char)0x07,
     (unsigned char)0x48,
     (unsigned char)0x87},
    {(unsigned char)0x0F,
     (unsigned char)0x06,
     (unsigned char)0x16,
     (unsigned char)0x50,
     (unsigned char)0x08,
     (unsigned char)0xCF,
     (unsigned char)0x8B,
     (unsigned char)0x8B,
     (unsigned char)0x5A,
     (unsigned char)0x63,
     (unsigned char)0x58,
     (unsigned char)0x63,
     (unsigned char)0x62,
     (unsigned char)0x54,
     (unsigned char)0x3E,
     (unsigned char)0x54}},
   {{(unsigned char)0x2A,
     (unsigned char)0x48,
     (unsigned char)0x30,
     (unsigned char)0xAB,
     (unsigned char)0x5A,
     (unsigned char)0xC4,
     (unsigned char)0xA1,
     (unsigned char)0xA2,
     (unsigned char)0x40,
     (unsigned char)0x59,
     (unsigned char)0x55,
     (unsigned char)0xFD,
     (unsigned char)0x21,
     (unsigned char)0x95,
     (unsigned char)0xCF,
     (unsigned char)0x93},
    {(unsigned char)0x5D,
     (unsigned char)0x5A,
     (unsigned char)0x86,
     (unsigned char)0x9B,
     (unsigned char)0xD1,
     (unsigned char)0x4C,
     (unsigned char)0xE5,
     (unsigned char)0x42,
     (unsigned char)0x64,
     (unsigned char)0xF8,
     (unsigned char)0x92,
     (unsigned char)0xA6,
     (unsigned char)0xDD,
     (unsigned char)0x2E,
     (unsigned char)0xC3,
     (unsigned char)0xD5},
    {(unsigned char)0x37,
     (unsigned char)0xD3,
     (unsigned char)0x59,
     (unsigned char)0xC3,
     (unsigned char)0x34,
     (unsigned char)0x98,
     (unsigned char)0x36,
     (unsigned char)0xD8,
     (unsigned char)0x84,
     (unsigned char)0xE3,
     (unsigned char)0x10,
     (unsigned char)0xAD,
     (unsigned char)0xDF,
     (unsigned char)0x68,
     (unsigned char)0xC4,
     (unsigned char)0x49}},
   {{(unsigned char)0xE6,
     (unsigned char)0xCF,
     (unsigned char)0xA3,
     (unsigned char)0x5F,
     (unsigned char)0xC0,
     (unsigned char)0x2B,
     (unsigned char)0x13,
     (unsigned char)0x4A,
     (unsigned char)0x4D,
     (unsigned char)0x2C,
     (unsigned char)0x0B,
     (unsigned char)0x67,
     (unsigned char)0x37,
     (unsigned char)0xAC,
     (unsigned char)0x3E,
     (unsigned char)0xDA},
    {(unsigned char)0x36,
     (unsigned char)0xCB,
     (unsigned char)0xEB,
     (unsigned char)0x73,
     (unsigned char)0xBD,
     (unsigned char)0x50,
     (unsigned char)0x4B,
     (unsigned char)0x40,
     (unsigned char)0x70,
     (unsigned char)0xB1,
     (unsigned char)0xB7,
     (unsigned char)0xDE,
     (unsigned char)0x2B,
     (unsigned char)0x21,
     (unsigned char)0xEB,
     (unsigned char)0x50},
    {(unsigned char)0xE3,
     (unsigned char)0x1A,
     (unsigned char)0x60,
     (unsigned char)0x55,
     (unsigned char)0x29,
     (unsigned char)0x7D,
     (unsigned char)0x96,
     (unsigned char)0xCA,
     (unsigned char)0x33,
     (unsigned char)0x30,
     (unsigned char)0xCD,
     (unsigned char)0xF1,
     (unsigned char)0xB1,
     (unsigned char)0x86,
     (unsigned char)0x0A,
     (unsigned char)0x83}}};
static unsigned char const camellia_test_ctr_key[3][16] =
  {{(unsigned char)0xAE,
    (unsigned char)0x68,
    (unsigned char)0x52,
    (unsigned char)0xF8,
    (unsigned char)0x12,
    (unsigned char)0x10,
    (unsigned char)0x67,
    (unsigned char)0xCC,
    (unsigned char)0x4B,
    (unsigned char)0xF7,
    (unsigned char)0xA5,
    (unsigned char)0x76,
    (unsigned char)0x55,
    (unsigned char)0x77,
    (unsigned char)0xF3,
    (unsigned char)0x9E},
   {(unsigned char)0x7E,
    (unsigned char)0x24,
    (unsigned char)0x06,
    (unsigned char)0x78,
    (unsigned char)0x17,
    (unsigned char)0xFA,
    (unsigned char)0xE0,
    (unsigned char)0xD7,
    (unsigned char)0x43,
    (unsigned char)0xD6,
    (unsigned char)0xCE,
    (unsigned char)0x1F,
    (unsigned char)0x32,
    (unsigned char)0x53,
    (unsigned char)0x91,
    (unsigned char)0x63},
   {(unsigned char)0x76,
    (unsigned char)0x91,
    (unsigned char)0xBE,
    (unsigned char)0x03,
    (unsigned char)0x5E,
    (unsigned char)0x50,
    (unsigned char)0x20,
    (unsigned char)0xA8,
    (unsigned char)0xAC,
    (unsigned char)0x6E,
    (unsigned char)0x61,
    (unsigned char)0x85,
    (unsigned char)0x29,
    (unsigned char)0xF9,
    (unsigned char)0xA0,
    (unsigned char)0xDC}};
static unsigned char const camellia_test_ctr_nonce_counter[3][16] =
  {{(unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x30,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x01},
   {(unsigned char)0x00,
    (unsigned char)0x6C,
    (unsigned char)0xB6,
    (unsigned char)0xDB,
    (unsigned char)0xC0,
    (unsigned char)0x54,
    (unsigned char)0x3B,
    (unsigned char)0x59,
    (unsigned char)0xDA,
    (unsigned char)0x48,
    (unsigned char)0xD9,
    (unsigned char)0x0B,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x01},
   {(unsigned char)0x00,
    (unsigned char)0xE0,
    (unsigned char)0x01,
    (unsigned char)0x7B,
    (unsigned char)0x27,
    (unsigned char)0x77,
    (unsigned char)0x7F,
    (unsigned char)0x3F,
    (unsigned char)0x4A,
    (unsigned char)0x17,
    (unsigned char)0x86,
    (unsigned char)0xF0,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x01}};
static unsigned char const camellia_test_ctr_pt[3][48] =
  {{(unsigned char)0x53,
    (unsigned char)0x69,
    (unsigned char)0x6E,
    (unsigned char)0x67,
    (unsigned char)0x6C,
    (unsigned char)0x65,
    (unsigned char)0x20,
    (unsigned char)0x62,
    (unsigned char)0x6C,
    (unsigned char)0x6F,
    (unsigned char)0x63,
    (unsigned char)0x6B,
    (unsigned char)0x20,
    (unsigned char)0x6D,
    (unsigned char)0x73,
    (unsigned char)0x67},
   {(unsigned char)0x00,
    (unsigned char)0x01,
    (unsigned char)0x02,
    (unsigned char)0x03,
    (unsigned char)0x04,
    (unsigned char)0x05,
    (unsigned char)0x06,
    (unsigned char)0x07,
    (unsigned char)0x08,
    (unsigned char)0x09,
    (unsigned char)0x0A,
    (unsigned char)0x0B,
    (unsigned char)0x0C,
    (unsigned char)0x0D,
    (unsigned char)0x0E,
    (unsigned char)0x0F,
    (unsigned char)0x10,
    (unsigned char)0x11,
    (unsigned char)0x12,
    (unsigned char)0x13,
    (unsigned char)0x14,
    (unsigned char)0x15,
    (unsigned char)0x16,
    (unsigned char)0x17,
    (unsigned char)0x18,
    (unsigned char)0x19,
    (unsigned char)0x1A,
    (unsigned char)0x1B,
    (unsigned char)0x1C,
    (unsigned char)0x1D,
    (unsigned char)0x1E,
    (unsigned char)0x1F},
   {(unsigned char)0x00,
    (unsigned char)0x01,
    (unsigned char)0x02,
    (unsigned char)0x03,
    (unsigned char)0x04,
    (unsigned char)0x05,
    (unsigned char)0x06,
    (unsigned char)0x07,
    (unsigned char)0x08,
    (unsigned char)0x09,
    (unsigned char)0x0A,
    (unsigned char)0x0B,
    (unsigned char)0x0C,
    (unsigned char)0x0D,
    (unsigned char)0x0E,
    (unsigned char)0x0F,
    (unsigned char)0x10,
    (unsigned char)0x11,
    (unsigned char)0x12,
    (unsigned char)0x13,
    (unsigned char)0x14,
    (unsigned char)0x15,
    (unsigned char)0x16,
    (unsigned char)0x17,
    (unsigned char)0x18,
    (unsigned char)0x19,
    (unsigned char)0x1A,
    (unsigned char)0x1B,
    (unsigned char)0x1C,
    (unsigned char)0x1D,
    (unsigned char)0x1E,
    (unsigned char)0x1F,
    (unsigned char)0x20,
    (unsigned char)0x21,
    (unsigned char)0x22,
    (unsigned char)0x23}};
static unsigned char const camellia_test_ctr_ct[3][48] =
  {{(unsigned char)0xD0,
    (unsigned char)0x9D,
    (unsigned char)0xC2,
    (unsigned char)0x9A,
    (unsigned char)0x82,
    (unsigned char)0x14,
    (unsigned char)0x61,
    (unsigned char)0x9A,
    (unsigned char)0x20,
    (unsigned char)0x87,
    (unsigned char)0x7C,
    (unsigned char)0x76,
    (unsigned char)0xDB,
    (unsigned char)0x1F,
    (unsigned char)0x0B,
    (unsigned char)0x3F},
   {(unsigned char)0xDB,
    (unsigned char)0xF3,
    (unsigned char)0xC7,
    (unsigned char)0x8D,
    (unsigned char)0xC0,
    (unsigned char)0x83,
    (unsigned char)0x96,
    (unsigned char)0xD4,
    (unsigned char)0xDA,
    (unsigned char)0x7C,
    (unsigned char)0x90,
    (unsigned char)0x77,
    (unsigned char)0x65,
    (unsigned char)0xBB,
    (unsigned char)0xCB,
    (unsigned char)0x44,
    (unsigned char)0x2B,
    (unsigned char)0x8E,
    (unsigned char)0x8E,
    (unsigned char)0x0F,
    (unsigned char)0x31,
    (unsigned char)0xF0,
    (unsigned char)0xDC,
    (unsigned char)0xA7,
    (unsigned char)0x2C,
    (unsigned char)0x74,
    (unsigned char)0x17,
    (unsigned char)0xE3,
    (unsigned char)0x53,
    (unsigned char)0x60,
    (unsigned char)0xE0,
    (unsigned char)0x48},
   {(unsigned char)0xB1,
    (unsigned char)0x9D,
    (unsigned char)0x1F,
    (unsigned char)0xCD,
    (unsigned char)0xCB,
    (unsigned char)0x75,
    (unsigned char)0xEB,
    (unsigned char)0x88,
    (unsigned char)0x2F,
    (unsigned char)0x84,
    (unsigned char)0x9C,
    (unsigned char)0xE2,
    (unsigned char)0x4D,
    (unsigned char)0x85,
    (unsigned char)0xCF,
    (unsigned char)0x73,
    (unsigned char)0x9C,
    (unsigned char)0xE6,
    (unsigned char)0x4B,
    (unsigned char)0x2B,
    (unsigned char)0x5C,
    (unsigned char)0x9D,
    (unsigned char)0x73,
    (unsigned char)0xF1,
    (unsigned char)0x4F,
    (unsigned char)0x2D,
    (unsigned char)0x5D,
    (unsigned char)0x9D,
    (unsigned char)0xCE,
    (unsigned char)0x98,
    (unsigned char)0x89,
    (unsigned char)0xCD,
    (unsigned char)0xDF,
    (unsigned char)0x50,
    (unsigned char)0x86,
    (unsigned char)0x96}};
static int const camellia_test_ctr_len[3] = {16, 32, 36};
/*@ requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param1 + (0 ..)), param0;
 */
int printf_va_48(char const * restrict format, int param0, char *param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_49(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_50(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_51(char const * restrict format);

/*@ requires valid_read_string(param1);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param1 + (0 ..))),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param1 + (0 ..)), param0;
 */
int printf_va_52(char const * restrict format, int param0, char *param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_53(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_54(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_55(char const * restrict format);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param0 + (0 ..));
 */
int printf_va_56(char const * restrict format, char *param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_57(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_58(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_59(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_60(char const * restrict format);

int camellia_self_test(int verbose)
{
  int __retres;
  int i;
  int j;
  int u;
  int v;
  unsigned char key[32];
  unsigned char buf[64];
  unsigned char src[16];
  unsigned char dst[16];
  unsigned char iv[16];
  size_t offset;
  size_t len;
  unsigned char nonce_counter[16];
  unsigned char stream_block[16];
  camellia_context ctx;
  memset((void *)(key),0,(size_t)32);
  j = 0;
  while (j < 6) {
    u = j >> 1;
    v = j & 1;
    if (verbose != 0) {
      char const *tmp;
      if (v == 0) tmp = "dec"; else tmp = "enc";
      ;
      printf("  CAMELLIA-ECB-%3d (%s): ",128 + u * 64,(char *)tmp); /* printf_va_48 */
    }
    i = 0;
    while (i < 2) {
      {
        int tmp_0;
        memcpy((void *)(key),(void const *)(camellia_test_ecb_key[u][i]),
               (size_t)(16 + 8 * u));
        if (v == 0) {
          camellia_setkey_dec(& ctx,(unsigned char const *)(key),
                              (unsigned int)(128 + u * 64));
          memcpy((void *)(src),
                 (void const *)(camellia_test_ecb_cipher[u][i]),(size_t)16);
          memcpy((void *)(dst),(void const *)(camellia_test_ecb_plain[i]),
                 (size_t)16);
        }
        else {
          camellia_setkey_enc(& ctx,(unsigned char const *)(key),
                              (unsigned int)(128 + u * 64));
          memcpy((void *)(src),(void const *)(camellia_test_ecb_plain[i]),
                 (size_t)16);
          memcpy((void *)(dst),
                 (void const *)(camellia_test_ecb_cipher[u][i]),(size_t)16);
        }
        camellia_crypt_ecb(& ctx,v,(unsigned char const *)(src),buf);
        tmp_0 = memcmp((void const *)(buf),(void const *)(dst),(size_t)16);
        if (tmp_0 != 0) {
          if (verbose != 0) printf("failed\n"); /* printf_va_49 */
          __retres = 1;
          goto return_label;
        }
      }
      i ++;
    }
    if (verbose != 0) printf("passed\n"); /* printf_va_50 */
    j ++;
  }
  if (verbose != 0) printf("\n"); /* printf_va_51 */
  j = 0;
  while (j < 6) {
    u = j >> 1;
    v = j & 1;
    if (verbose != 0) {
      char const *tmp_1;
      if (v == 0) tmp_1 = "dec"; else tmp_1 = "enc";
      ;
      printf("  CAMELLIA-CBC-%3d (%s): ",128 + u * 64,(char *)tmp_1); /* printf_va_52 */
    }
    memcpy((void *)(src),(void const *)(camellia_test_cbc_iv),(size_t)16);
    memcpy((void *)(dst),(void const *)(camellia_test_cbc_iv),(size_t)16);
    memcpy((void *)(key),(void const *)(camellia_test_cbc_key[u]),
           (size_t)(16 + 8 * u));
    if (v == 0) camellia_setkey_dec(& ctx,(unsigned char const *)(key),
                                    (unsigned int)(128 + u * 64));
    else camellia_setkey_enc(& ctx,(unsigned char const *)(key),
                             (unsigned int)(128 + u * 64));
    i = 0;
    while (i < 3) {
      {
        int tmp_2;
        if (v == 0) {
          memcpy((void *)(iv),(void const *)(src),(size_t)16);
          memcpy((void *)(src),
                 (void const *)(camellia_test_cbc_cipher[u][i]),(size_t)16);
          memcpy((void *)(dst),(void const *)(camellia_test_cbc_plain[i]),
                 (size_t)16);
        }
        else {
          memcpy((void *)(iv),(void const *)(dst),(size_t)16);
          memcpy((void *)(src),(void const *)(camellia_test_cbc_plain[i]),
                 (size_t)16);
          memcpy((void *)(dst),
                 (void const *)(camellia_test_cbc_cipher[u][i]),(size_t)16);
        }
        camellia_crypt_cbc(& ctx,v,(size_t)16,iv,
                           (unsigned char const *)(src),buf);
        tmp_2 = memcmp((void const *)(buf),(void const *)(dst),(size_t)16);
        if (tmp_2 != 0) {
          if (verbose != 0) printf("failed\n"); /* printf_va_53 */
          __retres = 1;
          goto return_label;
        }
      }
      i ++;
    }
    if (verbose != 0) printf("passed\n"); /* printf_va_54 */
    j ++;
  }
  if (verbose != 0) printf("\n"); /* printf_va_55 */
  i = 0;
  while (i < 6) {
    u = i >> 1;
    v = i & 1;
    if (verbose != 0) {
      char const *tmp_3;
      if (v == 0) tmp_3 = "dec"; else tmp_3 = "enc";
      printf("  CAMELLIA-CTR-128 (%s): ",(char *)tmp_3); /* printf_va_56 */
    }
    memcpy((void *)(nonce_counter),
           (void const *)(camellia_test_ctr_nonce_counter[u]),(size_t)16);
    memcpy((void *)(key),(void const *)(camellia_test_ctr_key[u]),(size_t)16);
    offset = (size_t)0;
    camellia_setkey_enc(& ctx,(unsigned char const *)(key),(unsigned int)128);
    if (v == 0) {
      int tmp_4;
      len = (size_t)camellia_test_ctr_len[u];
      memcpy((void *)(buf),(void const *)(camellia_test_ctr_ct[u]),len);
      camellia_crypt_ctr(& ctx,len,& offset,nonce_counter,stream_block,
                         (unsigned char const *)(buf),buf);
      tmp_4 = memcmp((void const *)(buf),
                     (void const *)(camellia_test_ctr_pt[u]),len);
      if (tmp_4 != 0) {
        if (verbose != 0) printf("failed\n"); /* printf_va_57 */
        __retres = 1;
        goto return_label;
      }
    }
    else {
      int tmp_5;
      len = (size_t)camellia_test_ctr_len[u];
      memcpy((void *)(buf),(void const *)(camellia_test_ctr_pt[u]),len);
      camellia_crypt_ctr(& ctx,len,& offset,nonce_counter,stream_block,
                         (unsigned char const *)(buf),buf);
      tmp_5 = memcmp((void const *)(buf),
                     (void const *)(camellia_test_ctr_ct[u]),len);
      if (tmp_5 != 0) {
        if (verbose != 0) printf("failed\n"); /* printf_va_58 */
        __retres = 1;
        goto return_label;
      }
    }
    if (verbose != 0) printf("passed\n"); /* printf_va_59 */
    i ++;
  }
  if (verbose != 0) printf("\n"); /* printf_va_60 */
  __retres = 0;
  return_label: return __retres;
}

char const test_ca_crt[1307] =
  {(char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'B',
   (char)'E',
   (char)'G',
   (char)'I',
   (char)'N',
   (char)' ',
   (char)'C',
   (char)'E',
   (char)'R',
   (char)'T',
   (char)'I',
   (char)'F',
   (char)'I',
   (char)'C',
   (char)'A',
   (char)'T',
   (char)'E',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'\r',
   (char)'\n',
   (char)'M',
   (char)'I',
   (char)'I',
   (char)'D',
   (char)'h',
   (char)'z',
   (char)'C',
   (char)'C',
   (char)'A',
   (char)'m',
   (char)'+',
   (char)'g',
   (char)'A',
   (char)'w',
   (char)'I',
   (char)'B',
   (char)'A',
   (char)'g',
   (char)'I',
   (char)'B',
   (char)'A',
   (char)'D',
   (char)'A',
   (char)'N',
   (char)'B',
   (char)'g',
   (char)'k',
   (char)'q',
   (char)'h',
   (char)'k',
   (char)'i',
   (char)'G',
   (char)'9',
   (char)'w',
   (char)'0',
   (char)'B',
   (char)'A',
   (char)'Q',
   (char)'U',
   (char)'F',
   (char)'A',
   (char)'D',
   (char)'A',
   (char)'7',
   (char)'M',
   (char)'Q',
   (char)'s',
   (char)'w',
   (char)'C',
   (char)'Q',
   (char)'Y',
   (char)'D',
   (char)'V',
   (char)'Q',
   (char)'Q',
   (char)'G',
   (char)'E',
   (char)'w',
   (char)'J',
   (char)'O',
   (char)'T',
   (char)'D',
   (char)'E',
   (char)'R',
   (char)'\r',
   (char)'\n',
   (char)'M',
   (char)'A',
   (char)'8',
   (char)'G',
   (char)'A',
   (char)'1',
   (char)'U',
   (char)'E',
   (char)'C',
   (char)'h',
   (char)'M',
   (char)'I',
   (char)'U',
   (char)'G',
   (char)'9',
   (char)'s',
   (char)'Y',
   (char)'X',
   (char)'J',
   (char)'T',
   (char)'U',
   (char)'0',
   (char)'w',
   (char)'x',
   (char)'G',
   (char)'T',
   (char)'A',
   (char)'X',
   (char)'B',
   (char)'g',
   (char)'N',
   (char)'V',
   (char)'B',
   (char)'A',
   (char)'M',
   (char)'T',
   (char)'E',
   (char)'F',
   (char)'B',
   (char)'v',
   (char)'b',
   (char)'G',
   (char)'F',
   (char)'y',
   (char)'U',
   (char)'1',
   (char)'N',
   (char)'M',
   (char)'I',
   (char)'F',
   (char)'R',
   (char)'l',
   (char)'c',
   (char)'3',
   (char)'Q',
   (char)'g',
   (char)'Q',
   (char)'0',
   (char)'E',
   (char)'w',
   (char)'H',
   (char)'h',
   (char)'c',
   (char)'N',
   (char)'\r',
   (char)'\n',
   (char)'M',
   (char)'T',
   (char)'E',
   (char)'w',
   (char)'M',
   (char)'j',
   (char)'E',
   (char)'y',
   (char)'M',
   (char)'T',
   (char)'Q',
   (char)'0',
   (char)'N',
   (char)'D',
   (char)'A',
   (char)'w',
   (char)'W',
   (char)'h',
   (char)'c',
   (char)'N',
   (char)'M',
   (char)'j',
   (char)'E',
   (char)'w',
   (char)'M',
   (char)'j',
   (char)'E',
   (char)'y',
   (char)'M',
   (char)'T',
   (char)'Q',
   (char)'0',
   (char)'N',
   (char)'D',
   (char)'A',
   (char)'w',
   (char)'W',
   (char)'j',
   (char)'A',
   (char)'7',
   (char)'M',
   (char)'Q',
   (char)'s',
   (char)'w',
   (char)'C',
   (char)'Q',
   (char)'Y',
   (char)'D',
   (char)'V',
   (char)'Q',
   (char)'Q',
   (char)'G',
   (char)'E',
   (char)'w',
   (char)'J',
   (char)'O',
   (char)'T',
   (char)'D',
   (char)'E',
   (char)'R',
   (char)'M',
   (char)'A',
   (char)'8',
   (char)'G',
   (char)'\r',
   (char)'\n',
   (char)'A',
   (char)'1',
   (char)'U',
   (char)'E',
   (char)'C',
   (char)'h',
   (char)'M',
   (char)'I',
   (char)'U',
   (char)'G',
   (char)'9',
   (char)'s',
   (char)'Y',
   (char)'X',
   (char)'J',
   (char)'T',
   (char)'U',
   (char)'0',
   (char)'w',
   (char)'x',
   (char)'G',
   (char)'T',
   (char)'A',
   (char)'X',
   (char)'B',
   (char)'g',
   (char)'N',
   (char)'V',
   (char)'B',
   (char)'A',
   (char)'M',
   (char)'T',
   (char)'E',
   (char)'F',
   (char)'B',
   (char)'v',
   (char)'b',
   (char)'G',
   (char)'F',
   (char)'y',
   (char)'U',
   (char)'1',
   (char)'N',
   (char)'M',
   (char)'I',
   (char)'F',
   (char)'R',
   (char)'l',
   (char)'c',
   (char)'3',
   (char)'Q',
   (char)'g',
   (char)'Q',
   (char)'0',
   (char)'E',
   (char)'w',
   (char)'g',
   (char)'g',
   (char)'E',
   (char)'i',
   (char)'M',
   (char)'A',
   (char)'0',
   (char)'G',
   (char)'\r',
   (char)'\n',
   (char)'C',
   (char)'S',
   (char)'q',
   (char)'G',
   (char)'S',
   (char)'I',
   (char)'b',
   (char)'3',
   (char)'D',
   (char)'Q',
   (char)'E',
   (char)'B',
   (char)'A',
   (char)'Q',
   (char)'U',
   (char)'A',
   (char)'A',
   (char)'4',
   (char)'I',
   (char)'B',
   (char)'D',
   (char)'w',
   (char)'A',
   (char)'w',
   (char)'g',
   (char)'g',
   (char)'E',
   (char)'K',
   (char)'A',
   (char)'o',
   (char)'I',
   (char)'B',
   (char)'A',
   (char)'Q',
   (char)'D',
   (char)'A',
   (char)'3',
   (char)'z',
   (char)'f',
   (char)'8',
   (char)'F',
   (char)'7',
   (char)'v',
   (char)'g',
   (char)'l',
   (char)'p',
   (char)'0',
   (char)'/',
   (char)'h',
   (char)'t',
   (char)'6',
   (char)'W',
   (char)'M',
   (char)'n',
   (char)'1',
   (char)'E',
   (char)'p',
   (char)'R',
   (char)'a',
   (char)'g',
   (char)'z',
   (char)'S',
   (char)'H',
   (char)'x',
   (char)'\r',
   (char)'\n',
   (char)'m',
   (char)'d',
   (char)'T',
   (char)'s',
   (char)'6',
   (char)'s',
   (char)'t',
   (char)'8',
   (char)'G',
   (char)'F',
   (char)'g',
   (char)'I',
   (char)'l',
   (char)'K',
   (char)'X',
   (char)'s',
   (char)'m',
   (char)'8',
   (char)'W',
   (char)'L',
   (char)'3',
   (char)'x',
   (char)'o',
   (char)'e',
   (char)'m',
   (char)'T',
   (char)'i',
   (char)'Z',
   (char)'h',
   (char)'x',
   (char)'5',
   (char)'7',
   (char)'w',
   (char)'I',
   (char)'0',
   (char)'5',
   (char)'3',
   (char)'z',
   (char)'h',
   (char)'d',
   (char)'c',
   (char)'H',
   (char)'g',
   (char)'H',
   (char)'0',
   (char)'5',
   (char)'7',
   (char)'Z',
   (char)'k',
   (char)'+',
   (char)'i',
   (char)'5',
   (char)'c',
   (char)'l',
   (char)'H',
   (char)'F',
   (char)'z',
   (char)'q',
   (char)'M',
   (char)'w',
   (char)'U',
   (char)'q',
   (char)'n',
   (char)'y',
   (char)'\r',
   (char)'\n',
   (char)'5',
   (char)'0',
   (char)'B',
   (char)'w',
   (char)'F',
   (char)'M',
   (char)'t',
   (char)'E',
   (char)'o',
   (char)'n',
   (char)'I',
   (char)'L',
   (char)'w',
   (char)'u',
   (char)'V',
   (char)'A',
   (char)'+',
   (char)'T',
   (char)'7',
   (char)'l',
   (char)'p',
   (char)'g',
   (char)'6',
   (char)'z',
   (char)'+',
   (char)'e',
   (char)'x',
   (char)'K',
   (char)'Y',
   (char)'8',
   (char)'C',
   (char)'4',
   (char)'K',
   (char)'Q',
   (char)'B',
   (char)'0',
   (char)'n',
   (char)'F',
   (char)'c',
   (char)'7',
   (char)'q',
   (char)'K',
   (char)'U',
   (char)'E',
   (char)'k',
   (char)'H',
   (char)'H',
   (char)'x',
   (char)'v',
   (char)'Y',
   (char)'P',
   (char)'Z',
   (char)'P',
   (char)'9',
   (char)'a',
   (char)'l',
   (char)'4',
   (char)'j',
   (char)'w',
   (char)'q',
   (char)'j',
   (char)'+',
   (char)'8',
   (char)'n',
   (char)'\r',
   (char)'\n',
   (char)'Y',
   (char)'M',
   (char)'P',
   (char)'G',
   (char)'n',
   (char)'8',
   (char)'u',
   (char)'6',
   (char)'7',
   (char)'G',
   (char)'B',
   (char)'9',
   (char)'t',
   (char)'+',
   (char)'a',
   (char)'E',
   (char)'M',
   (char)'r',
   (char)'5',
   (char)'P',
   (char)'+',
   (char)'1',
   (char)'g',
   (char)'m',
   (char)'I',
   (char)'g',
   (char)'N',
   (char)'b',
   (char)'1',
   (char)'L',
   (char)'T',
   (char)'V',
   (char)'+',
   (char)'/',
   (char)'X',
   (char)'j',
   (char)'l',
   (char)'i',
   (char)'5',
   (char)'w',
   (char)'w',
   (char)'O',
   (char)'Q',
   (char)'u',
   (char)'v',
   (char)'f',
   (char)'w',
   (char)'u',
   (char)'7',
   (char)'u',
   (char)'J',
   (char)'B',
   (char)'V',
   (char)'c',
   (char)'A',
   (char)'0',
   (char)'L',
   (char)'n',
   (char)'0',
   (char)'k',
   (char)'c',
   (char)'m',
   (char)'n',
   (char)'L',
   (char)'\r',
   (char)'\n',
   (char)'R',
   (char)'7',
   (char)'E',
   (char)'U',
   (char)'Q',
   (char)'I',
   (char)'N',
   (char)'9',
   (char)'Z',
   (char)'/',
   (char)'S',
   (char)'G',
   (char)'9',
   (char)'j',
   (char)'G',
   (char)'r',
   (char)'8',
   (char)'X',
   (char)'m',
   (char)'k',
   (char)'s',
   (char)'r',
   (char)'U',
   (char)'u',
   (char)'E',
   (char)'v',
   (char)'m',
   (char)'E',
   (char)'F',
   (char)'/',
   (char)'B',
   (char)'i',
   (char)'b',
   (char)'y',
   (char)'c',
   (char)'+',
   (char)'E',
   (char)'1',
   (char)'i',
   (char)'x',
   (char)'V',
   (char)'A',
   (char)'0',
   (char)'h',
   (char)'m',
   (char)'n',
   (char)'M',
   (char)'3',
   (char)'o',
   (char)'T',
   (char)'D',
   (char)'P',
   (char)'b',
   (char)'5',
   (char)'L',
   (char)'c',
   (char)'9',
   (char)'u',
   (char)'n',
   (char)'8',
   (char)'r',
   (char)'N',
   (char)'s',
   (char)'u',
   (char)'\r',
   (char)'\n',
   (char)'K',
   (char)'N',
   (char)'F',
   (char)'+',
   (char)'A',
   (char)'k',
   (char)'s',
   (char)'j',
   (char)'o',
   (char)'B',
   (char)'X',
   (char)'y',
   (char)'O',
   (char)'G',
   (char)'V',
   (char)'k',
   (char)'C',
   (char)'e',
   (char)'o',
   (char)'M',
   (char)'b',
   (char)'o',
   (char)'4',
   (char)'b',
   (char)'F',
   (char)'6',
   (char)'B',
   (char)'x',
   (char)'y',
   (char)'L',
   (char)'O',
   (char)'b',
   (char)'y',
   (char)'a',
   (char)'v',
   (char)'p',
   (char)'w',
   (char)'/',
   (char)'L',
   (char)'P',
   (char)'h',
   (char)'5',
   (char)'a',
   (char)'P',
   (char)'g',
   (char)'A',
   (char)'I',
   (char)'y',
   (char)'n',
   (char)'p',
   (char)'l',
   (char)'Y',
   (char)'b',
   (char)'6',
   (char)'L',
   (char)'V',
   (char)'A',
   (char)'g',
   (char)'M',
   (char)'B',
   (char)'A',
   (char)'A',
   (char)'G',
   (char)'j',
   (char)'\r',
   (char)'\n',
   (char)'g',
   (char)'Z',
   (char)'U',
   (char)'w',
   (char)'g',
   (char)'Z',
   (char)'I',
   (char)'w',
   (char)'D',
   (char)'A',
   (char)'Y',
   (char)'D',
   (char)'V',
   (char)'R',
   (char)'0',
   (char)'T',
   (char)'B',
   (char)'A',
   (char)'U',
   (char)'w',
   (char)'A',
   (char)'w',
   (char)'E',
   (char)'B',
   (char)'/',
   (char)'z',
   (char)'A',
   (char)'d',
   (char)'B',
   (char)'g',
   (char)'N',
   (char)'V',
   (char)'H',
   (char)'Q',
   (char)'4',
   (char)'E',
   (char)'F',
   (char)'g',
   (char)'Q',
   (char)'U',
   (char)'t',
   (char)'F',
   (char)'r',
   (char)'k',
   (char)'p',
   (char)'b',
   (char)'P',
   (char)'e',
   (char)'0',
   (char)'l',
   (char)'L',
   (char)'2',
   (char)'u',
   (char)'d',
   (char)'W',
   (char)'m',
   (char)'l',
   (char)'Q',
   (char)'/',
   (char)'r',
   (char)'P',
   (char)'r',
   (char)'z',
   (char)'H',
   (char)'\r',
   (char)'\n',
   (char)'/',
   (char)'f',
   (char)'8',
   (char)'w',
   (char)'Y',
   (char)'w',
   (char)'Y',
   (char)'D',
   (char)'V',
   (char)'R',
   (char)'0',
   (char)'j',
   (char)'B',
   (char)'F',
   (char)'w',
   (char)'w',
   (char)'W',
   (char)'o',
   (char)'A',
   (char)'U',
   (char)'t',
   (char)'F',
   (char)'r',
   (char)'k',
   (char)'p',
   (char)'b',
   (char)'P',
   (char)'e',
   (char)'0',
   (char)'l',
   (char)'L',
   (char)'2',
   (char)'u',
   (char)'d',
   (char)'W',
   (char)'m',
   (char)'l',
   (char)'Q',
   (char)'/',
   (char)'r',
   (char)'P',
   (char)'r',
   (char)'z',
   (char)'H',
   (char)'/',
   (char)'f',
   (char)'+',
   (char)'h',
   (char)'P',
   (char)'6',
   (char)'Q',
   (char)'9',
   (char)'M',
   (char)'D',
   (char)'s',
   (char)'x',
   (char)'C',
   (char)'z',
   (char)'A',
   (char)'J',
   (char)'B',
   (char)'g',
   (char)'N',
   (char)'V',
   (char)'\r',
   (char)'\n',
   (char)'B',
   (char)'A',
   (char)'Y',
   (char)'T',
   (char)'A',
   (char)'k',
   (char)'5',
   (char)'M',
   (char)'M',
   (char)'R',
   (char)'E',
   (char)'w',
   (char)'D',
   (char)'w',
   (char)'Y',
   (char)'D',
   (char)'V',
   (char)'Q',
   (char)'Q',
   (char)'K',
   (char)'E',
   (char)'w',
   (char)'h',
   (char)'Q',
   (char)'b',
   (char)'2',
   (char)'x',
   (char)'h',
   (char)'c',
   (char)'l',
   (char)'N',
   (char)'T',
   (char)'T',
   (char)'D',
   (char)'E',
   (char)'Z',
   (char)'M',
   (char)'B',
   (char)'c',
   (char)'G',
   (char)'A',
   (char)'1',
   (char)'U',
   (char)'E',
   (char)'A',
   (char)'x',
   (char)'M',
   (char)'Q',
   (char)'U',
   (char)'G',
   (char)'9',
   (char)'s',
   (char)'Y',
   (char)'X',
   (char)'J',
   (char)'T',
   (char)'U',
   (char)'0',
   (char)'w',
   (char)'g',
   (char)'V',
   (char)'G',
   (char)'V',
   (char)'z',
   (char)'\r',
   (char)'\n',
   (char)'d',
   (char)'C',
   (char)'B',
   (char)'D',
   (char)'Q',
   (char)'Y',
   (char)'I',
   (char)'B',
   (char)'A',
   (char)'D',
   (char)'A',
   (char)'N',
   (char)'B',
   (char)'g',
   (char)'k',
   (char)'q',
   (char)'h',
   (char)'k',
   (char)'i',
   (char)'G',
   (char)'9',
   (char)'w',
   (char)'0',
   (char)'B',
   (char)'A',
   (char)'Q',
   (char)'U',
   (char)'F',
   (char)'A',
   (char)'A',
   (char)'O',
   (char)'C',
   (char)'A',
   (char)'Q',
   (char)'E',
   (char)'A',
   (char)'u',
   (char)'P',
   (char)'1',
   (char)'U',
   (char)'2',
   (char)'A',
   (char)'B',
   (char)'U',
   (char)'k',
   (char)'I',
   (char)'s',
   (char)'l',
   (char)'s',
   (char)'C',
   (char)'f',
   (char)'d',
   (char)'l',
   (char)'c',
   (char)'2',
   (char)'i',
   (char)'9',
   (char)'4',
   (char)'Q',
   (char)'H',
   (char)'H',
   (char)'Y',
   (char)'e',
   (char)'J',
   (char)'\r',
   (char)'\n',
   (char)'S',
   (char)'s',
   (char)'R',
   (char)'4',
   (char)'E',
   (char)'d',
   (char)'g',
   (char)'H',
   (char)'t',
   (char)'d',
   (char)'c',
   (char)'i',
   (char)'U',
   (char)'I',
   (char)'5',
   (char)'I',
   (char)'6',
   (char)'2',
   (char)'J',
   (char)'6',
   (char)'M',
   (char)'o',
   (char)'m',
   (char)'+',
   (char)'Y',
   (char)'0',
   (char)'d',
   (char)'T',
   (char)'/',
   (char)'7',
   (char)'a',
   (char)'+',
   (char)'8',
   (char)'S',
   (char)'6',
   (char)'M',
   (char)'V',
   (char)'M',
   (char)'C',
   (char)'Z',
   (char)'P',
   (char)'6',
   (char)'C',
   (char)'5',
   (char)'N',
   (char)'y',
   (char)'N',
   (char)'y',
   (char)'X',
   (char)'w',
   (char)'1',
   (char)'G',
   (char)'W',
   (char)'Y',
   (char)'/',
   (char)'Y',
   (char)'R',
   (char)'8',
   (char)'2',
   (char)'X',
   (char)'T',
   (char)'J',
   (char)'8',
   (char)'H',
   (char)'\r',
   (char)'\n',
   (char)'D',
   (char)'B',
   (char)'J',
   (char)'i',
   (char)'C',
   (char)'T',
   (char)'o',
   (char)'k',
   (char)'5',
   (char)'D',
   (char)'b',
   (char)'Z',
   (char)'6',
   (char)'S',
   (char)'z',
   (char)'a',
   (char)'O',
   (char)'N',
   (char)'B',
   (char)'z',
   (char)'d',
   (char)'W',
   (char)'H',
   (char)'X',
   (char)'w',
   (char)'W',
   (char)'w',
   (char)'m',
   (char)'i',
   (char)'5',
   (char)'v',
   (char)'g',
   (char)'1',
   (char)'d',
   (char)'x',
   (char)'n',
   (char)'7',
   (char)'Y',
   (char)'x',
   (char)'r',
   (char)'M',
   (char)'9',
   (char)'d',
   (char)'0',
   (char)'I',
   (char)'j',
   (char)'x',
   (char)'M',
   (char)'2',
   (char)'7',
   (char)'W',
   (char)'N',
   (char)'K',
   (char)'s',
   (char)'4',
   (char)'s',
   (char)'D',
   (char)'Q',
   (char)'h',
   (char)'Z',
   (char)'B',
   (char)'Q',
   (char)'k',
   (char)'F',
   (char)'\r',
   (char)'\n',
   (char)'p',
   (char)'j',
   (char)'m',
   (char)'f',
   (char)'s',
   (char)'2',
   (char)'c',
   (char)'b',
   (char)'4',
   (char)'o',
   (char)'P',
   (char)'l',
   (char)'4',
   (char)'Y',
   (char)'9',
   (char)'T',
   (char)'9',
   (char)'m',
   (char)'e',
   (char)'T',
   (char)'x',
   (char)'/',
   (char)'l',
   (char)'v',
   (char)'d',
   (char)'k',
   (char)'R',
   (char)'Y',
   (char)'E',
   (char)'u',
   (char)'g',
   (char)'6',
   (char)'1',
   (char)'J',
   (char)'f',
   (char)'n',
   (char)'6',
   (char)'c',
   (char)'A',
   (char)'+',
   (char)'q',
   (char)'H',
   (char)'p',
   (char)'y',
   (char)'P',
   (char)'Y',
   (char)'d',
   (char)'T',
   (char)'H',
   (char)'+',
   (char)'U',
   (char)'s',
   (char)'h',
   (char)'I',
   (char)'T',
   (char)'n',
   (char)'m',
   (char)'p',
   (char)'5',
   (char)'/',
   (char)'Z',
   (char)'t',
   (char)'k',
   (char)'f',
   (char)'\r',
   (char)'\n',
   (char)'m',
   (char)'/',
   (char)'U',
   (char)'T',
   (char)'S',
   (char)'L',
   (char)'B',
   (char)'N',
   (char)'F',
   (char)'N',
   (char)'H',
   (char)'e',
   (char)'s',
   (char)'i',
   (char)'T',
   (char)'Z',
   (char)'e',
   (char)'H',
   (char)'3',
   (char)'1',
   (char)'N',
   (char)'c',
   (char)'x',
   (char)'Y',
   (char)'G',
   (char)'d',
   (char)'H',
   (char)'S',
   (char)'m',
   (char)'e',
   (char)'9',
   (char)'N',
   (char)'c',
   (char)'/',
   (char)'g',
   (char)'f',
   (char)'i',
   (char)'d',
   (char)'R',
   (char)'a',
   (char)'0',
   (char)'F',
   (char)'L',
   (char)'O',
   (char)'C',
   (char)'f',
   (char)'W',
   (char)'x',
   (char)'R',
   (char)'l',
   (char)'F',
   (char)'q',
   (char)'A',
   (char)'I',
   (char)'4',
   (char)'7',
   (char)'z',
   (char)'G',
   (char)'9',
   (char)'j',
   (char)'A',
   (char)'Q',
   (char)'C',
   (char)'Z',
   (char)'\r',
   (char)'\n',
   (char)'7',
   (char)'Z',
   (char)'2',
   (char)'m',
   (char)'C',
   (char)'G',
   (char)'D',
   (char)'N',
   (char)'M',
   (char)'h',
   (char)'j',
   (char)'Q',
   (char)'c',
   (char)'+',
   (char)'B',
   (char)'Y',
   (char)'c',
   (char)'d',
   (char)'n',
   (char)'l',
   (char)'0',
   (char)'l',
   (char)'P',
   (char)'X',
   (char)'j',
   (char)'d',
   (char)'D',
   (char)'K',
   (char)'6',
   (char)'V',
   (char)'0',
   (char)'q',
   (char)'C',
   (char)'g',
   (char)'1',
   (char)'d',
   (char)'V',
   (char)'e',
   (char)'w',
   (char)'h',
   (char)'U',
   (char)'B',
   (char)'c',
   (char)'W',
   (char)'5',
   (char)'g',
   (char)'Z',
   (char)'K',
   (char)'z',
   (char)'V',
   (char)'7',
   (char)'e',
   (char)'9',
   (char)'+',
   (char)'D',
   (char)'p',
   (char)'V',
   (char)'A',
   (char)'=',
   (char)'=',
   (char)'\r',
   (char)'\n',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'E',
   (char)'N',
   (char)'D',
   (char)' ',
   (char)'C',
   (char)'E',
   (char)'R',
   (char)'T',
   (char)'I',
   (char)'F',
   (char)'I',
   (char)'C',
   (char)'A',
   (char)'T',
   (char)'E',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'\r',
   (char)'\n',
   (char)'\000'};
char const test_ca_key[1782] =
  {(char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'B',
   (char)'E',
   (char)'G',
   (char)'I',
   (char)'N',
   (char)' ',
   (char)'R',
   (char)'S',
   (char)'A',
   (char)' ',
   (char)'P',
   (char)'R',
   (char)'I',
   (char)'V',
   (char)'A',
   (char)'T',
   (char)'E',
   (char)' ',
   (char)'K',
   (char)'E',
   (char)'Y',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'\r',
   (char)'\n',
   (char)'P',
   (char)'r',
   (char)'o',
   (char)'c',
   (char)'-',
   (char)'T',
   (char)'y',
   (char)'p',
   (char)'e',
   (char)':',
   (char)' ',
   (char)'4',
   (char)',',
   (char)'E',
   (char)'N',
   (char)'C',
   (char)'R',
   (char)'Y',
   (char)'P',
   (char)'T',
   (char)'E',
   (char)'D',
   (char)'\r',
   (char)'\n',
   (char)'D',
   (char)'E',
   (char)'K',
   (char)'-',
   (char)'I',
   (char)'n',
   (char)'f',
   (char)'o',
   (char)':',
   (char)' ',
   (char)'D',
   (char)'E',
   (char)'S',
   (char)'-',
   (char)'E',
   (char)'D',
   (char)'E',
   (char)'3',
   (char)'-',
   (char)'C',
   (char)'B',
   (char)'C',
   (char)',',
   (char)'A',
   (char)'8',
   (char)'A',
   (char)'9',
   (char)'5',
   (char)'B',
   (char)'0',
   (char)'5',
   (char)'D',
   (char)'5',
   (char)'B',
   (char)'7',
   (char)'2',
   (char)'0',
   (char)'6',
   (char)'B',
   (char)'\r',
   (char)'\n',
   (char)'\r',
   (char)'\n',
   (char)'9',
   (char)'Q',
   (char)'d',
   (char)'9',
   (char)'G',
   (char)'e',
   (char)'A',
   (char)'r',
   (char)'e',
   (char)'j',
   (char)'l',
   (char)'1',
   (char)'G',
   (char)'D',
   (char)'V',
   (char)'h',
   (char)'2',
   (char)'l',
   (char)'L',
   (char)'V',
   (char)'1',
   (char)'b',
   (char)'H',
   (char)'t',
   (char)'0',
   (char)'c',
   (char)'P',
   (char)'t',
   (char)'f',
   (char)'b',
   (char)'h',
   (char)'5',
   (char)'h',
   (char)'/',
   (char)'5',
   (char)'z',
   (char)'V',
   (char)'p',
   (char)'A',
   (char)'V',
   (char)'a',
   (char)'F',
   (char)'p',
   (char)'q',
   (char)'t',
   (char)'S',
   (char)'P',
   (char)'M',
   (char)'r',
   (char)'E',
   (char)'l',
   (char)'p',
   (char)'5',
   (char)'0',
   (char)'R',
   (char)'n',
   (char)'t',
   (char)'n',
   (char)'9',
   (char)'e',
   (char)'t',
   (char)'+',
   (char)'J',
   (char)'A',
   (char)'\r',
   (char)'\n',
   (char)'7',
   (char)'V',
   (char)'O',
   (char)'y',
   (char)'b',
   (char)'o',
   (char)'R',
   (char)'+',
   (char)'I',
   (char)'y',
   (char)'2',
   (char)'t',
   (char)'/',
   (char)'H',
   (char)'U',
   (char)'4',
   (char)'W',
   (char)'v',
   (char)'A',
   (char)'6',
   (char)'8',
   (char)'7',
   (char)'k',
   (char)'3',
   (char)'B',
   (char)'p',
   (char)'p',
   (char)'e',
   (char)'9',
   (char)'G',
   (char)'w',
   (char)'K',
   (char)'H',
   (char)'j',
   (char)'H',
   (char)'h',
   (char)'t',
   (char)'l',
   (char)'/',
   (char)'/',
   (char)'8',
   (char)'x',
   (char)'F',
   (char)'K',
   (char)'w',
   (char)'Z',
   (char)'r',
   (char)'3',
   (char)'X',
   (char)'b',
   (char)'5',
   (char)'y',
   (char)'O',
   (char)'5',
   (char)'J',
   (char)'U',
   (char)'P',
   (char)'8',
   (char)'A',
   (char)'U',
   (char)'c',
   (char)'t',
   (char)'Q',
   (char)'q',
   (char)'\r',
   (char)'\n',
   (char)'N',
   (char)'b',
   (char)'8',
   (char)'C',
   (char)'L',
   (char)'l',
   (char)'Z',
   (char)'y',
   (char)'u',
   (char)'U',
   (char)'C',
   (char)'+',
   (char)'5',
   (char)'2',
   (char)'R',
   (char)'E',
   (char)'A',
   (char)'A',
   (char)'t',
   (char)'h',
   (char)'d',
   (char)'W',
   (char)'g',
   (char)'s',
   (char)'X',
   (char)'+',
   (char)'7',
   (char)'d',
   (char)'J',
   (char)'O',
   (char)'4',
   (char)'y',
   (char)'a',
   (char)'b',
   (char)'z',
   (char)'U',
   (char)'c',
   (char)'Q',
   (char)'2',
   (char)'2',
   (char)'T',
   (char)'p',
   (char)'9',
   (char)'J',
   (char)'S',
   (char)'D',
   (char)'0',
   (char)'h',
   (char)'i',
   (char)'L',
   (char)'4',
   (char)'3',
   (char)'B',
   (char)'l',
   (char)'k',
   (char)'W',
   (char)'Y',
   (char)'U',
   (char)'N',
   (char)'K',
   (char)'3',
   (char)'d',
   (char)'A',
   (char)'o',
   (char)'\r',
   (char)'\n',
   (char)'P',
   (char)'Z',
   (char)'l',
   (char)'m',
   (char)'i',
   (char)'p',
   (char)'t',
   (char)'j',
   (char)'n',
   (char)'z',
   (char)'V',
   (char)'T',
   (char)'j',
   (char)'g',
   (char)'1',
   (char)'M',
   (char)'x',
   (char)'s',
   (char)'B',
   (char)'S',
   (char)'y',
   (char)'d',
   (char)'Z',
   (char)'i',
   (char)'n',
   (char)'W',
   (char)'O',
   (char)'L',
   (char)'B',
   (char)'V',
   (char)'8',
   (char)'/',
   (char)'J',
   (char)'Q',
   (char)'g',
   (char)'x',
   (char)'S',
   (char)'P',
   (char)'o',
   (char)'2',
   (char)'y',
   (char)'D',
   (char)'4',
   (char)'u',
   (char)'E',
   (char)'f',
   (char)'i',
   (char)'g',
   (char)'2',
   (char)'8',
   (char)'q',
   (char)'b',
   (char)'v',
   (char)'Q',
   (char)'2',
   (char)'w',
   (char)'N',
   (char)'I',
   (char)'n',
   (char)'0',
   (char)'p',
   (char)'n',
   (char)'A',
   (char)'b',
   (char)'\r',
   (char)'\n',
   (char)'G',
   (char)'x',
   (char)'n',
   (char)'S',
   (char)'A',
   (char)'O',
   (char)'a',
   (char)'z',
   (char)'k',
   (char)'o',
   (char)'n',
   (char)'g',
   (char)'E',
   (char)'G',
   (char)'f',
   (char)'v',
   (char)'c',
   (char)'j',
   (char)'I',
   (char)'I',
   (char)'s',
   (char)'+',
   (char)'L',
   (char)'Z',
   (char)'N',
   (char)'9',
   (char)'g',
   (char)'X',
   (char)'F',
   (char)'h',
   (char)'x',
   (char)'c',
   (char)'O',
   (char)'h',
   (char)'6',
   (char)'k',
   (char)'c',
   (char)'4',
   (char)'Q',
   (char)'/',
   (char)'c',
   (char)'9',
   (char)'9',
   (char)'B',
   (char)'7',
   (char)'Q',
   (char)'W',
   (char)'E',
   (char)'T',
   (char)'w',
   (char)'L',
   (char)'L',
   (char)'k',
   (char)'Y',
   (char)'g',
   (char)'Z',
   (char)'+',
   (char)'z',
   (char)'1',
   (char)'a',
   (char)'9',
   (char)'V',
   (char)'Y',
   (char)'9',
   (char)'\r',
   (char)'\n',
   (char)'g',
   (char)'E',
   (char)'U',
   (char)'7',
   (char)'C',
   (char)'w',
   (char)'C',
   (char)'x',
   (char)'Y',
   (char)'C',
   (char)'D',
   (char)'+',
   (char)'h',
   (char)'9',
   (char)'h',
   (char)'Y',
   (char)'6',
   (char)'F',
   (char)'P',
   (char)'m',
   (char)'s',
   (char)'K',
   (char)'0',
   (char)'/',
   (char)'l',
   (char)'C',
   (char)'4',
   (char)'O',
   (char)'7',
   (char)'a',
   (char)'e',
   (char)'R',
   (char)'K',
   (char)'p',
   (char)'Y',
   (char)'q',
   (char)'0',
   (char)'0',
   (char)'r',
   (char)'P',
   (char)'P',
   (char)'x',
   (char)'s',
   (char)'6',
   (char)'i',
   (char)'7',
   (char)'p',
   (char)'h',
   (char)'i',
   (char)'e',
   (char)'x',
   (char)'g',
   (char)'6',
   (char)'a',
   (char)'x',
   (char)'6',
   (char)'y',
   (char)'T',
   (char)'M',
   (char)'m',
   (char)'A',
   (char)'r',
   (char)'Q',
   (char)'q',
   (char)'\r',
   (char)'\n',
   (char)'Q',
   (char)'m',
   (char)'K',
   (char)'3',
   (char)'T',
   (char)'A',
   (char)'s',
   (char)'J',
   (char)'m',
   (char)'8',
   (char)'V',
   (char)'/',
   (char)'J',
   (char)'5',
   (char)'A',
   (char)'W',
   (char)'p',
   (char)'L',
   (char)'E',
   (char)'V',
   (char)'6',
   (char)'j',
   (char)'A',
   (char)'F',
   (char)'g',
   (char)'R',
   (char)'G',
   (char)'y',
   (char)'m',
   (char)'G',
   (char)'G',
   (char)'H',
   (char)'n',
   (char)'o',
   (char)'f',
   (char)'0',
   (char)'D',
   (char)'X',
   (char)'z',
   (char)'V',
   (char)'W',
   (char)'Z',
   (char)'i',
   (char)'d',
   (char)'r',
   (char)'c',
   (char)'Z',
   (char)'J',
   (char)'W',
   (char)'T',
   (char)'N',
   (char)'u',
   (char)'G',
   (char)'E',
   (char)'X',
   (char)'9',
   (char)'0',
   (char)'n',
   (char)'B',
   (char)'3',
   (char)'e',
   (char)'e',
   (char)'2',
   (char)'w',
   (char)'\r',
   (char)'\n',
   (char)'P',
   (char)'X',
   (char)'J',
   (char)'E',
   (char)'F',
   (char)'W',
   (char)'K',
   (char)'o',
   (char)'D',
   (char)'3',
   (char)'K',
   (char)'3',
   (char)'a',
   (char)'F',
   (char)'c',
   (char)'S',
   (char)'L',
   (char)'d',
   (char)'H',
   (char)'Y',
   (char)'r',
   (char)'3',
   (char)'m',
   (char)'L',
   (char)'G',
   (char)'x',
   (char)'P',
   (char)'7',
   (char)'H',
   (char)'9',
   (char)'T',
   (char)'h',
   (char)'Q',
   (char)'a',
   (char)'i',
   (char)'9',
   (char)'V',
   (char)'s',
   (char)'y',
   (char)'c',
   (char)'x',
   (char)'Z',
   (char)'K',
   (char)'S',
   (char)'5',
   (char)'k',
   (char)'w',
   (char)'v',
   (char)'B',
   (char)'K',
   (char)'Q',
   (char)'/',
   (char)'/',
   (char)'Y',
   (char)'M',
   (char)'r',
   (char)'m',
   (char)'F',
   (char)'f',
   (char)'w',
   (char)'P',
   (char)'k',
   (char)'8',
   (char)'x',
   (char)'\r',
   (char)'\n',
   (char)'v',
   (char)'T',
   (char)'e',
   (char)'Y',
   (char)'4',
   (char)'K',
   (char)'Z',
   (char)'M',
   (char)'a',
   (char)'U',
   (char)'r',
   (char)'v',
   (char)'e',
   (char)'E',
   (char)'e',
   (char)'l',
   (char)'5',
   (char)'t',
   (char)'W',
   (char)'Z',
   (char)'C',
   (char)'9',
   (char)'4',
   (char)'R',
   (char)'S',
   (char)'M',
   (char)'K',
   (char)'g',
   (char)'x',
   (char)'R',
   (char)'6',
   (char)'c',
   (char)'y',
   (char)'E',
   (char)'1',
   (char)'n',
   (char)'B',
   (char)'X',
   (char)'y',
   (char)'T',
   (char)'Q',
   (char)'n',
   (char)'D',
   (char)'O',
   (char)'G',
   (char)'b',
   (char)'f',
   (char)'p',
   (char)'N',
   (char)'N',
   (char)'g',
   (char)'B',
   (char)'K',
   (char)'x',
   (char)'y',
   (char)'K',
   (char)'b',
   (char)'I',
   (char)'N',
   (char)'W',
   (char)'o',
   (char)'O',
   (char)'J',
   (char)'U',
   (char)'\r',
   (char)'\n',
   (char)'W',
   (char)'J',
   (char)'Z',
   (char)'A',
   (char)'w',
   (char)'l',
   (char)'s',
   (char)'Q',
   (char)'n',
   (char)'+',
   (char)'Q',
   (char)'z',
   (char)'C',
   (char)'D',
   (char)'w',
   (char)'p',
   (char)'r',
   (char)'i',
   (char)'7',
   (char)'+',
   (char)'s',
   (char)'V',
   (char)'1',
   (char)'m',
   (char)'S',
   (char)'3',
   (char)'g',
   (char)'B',
   (char)'E',
   (char)'6',
   (char)'U',
   (char)'Y',
   (char)'7',
   (char)'a',
   (char)'Q',
   (char)'m',
   (char)'n',
   (char)'m',
   (char)'i',
   (char)'i',
   (char)'a',
   (char)'C',
   (char)'2',
   (char)'V',
   (char)'3',
   (char)'H',
   (char)'b',
   (char)'p',
   (char)'h',
   (char)'x',
   (char)'c',
   (char)'t',
   (char)'/',
   (char)'e',
   (char)'n',
   (char)'5',
   (char)'Q',
   (char)'s',
   (char)'f',
   (char)'D',
   (char)'O',
   (char)'t',
   (char)'1',
   (char)'X',
   (char)'\r',
   (char)'\n',
   (char)'J',
   (char)'c',
   (char)'z',
   (char)'S',
   (char)'f',
   (char)'p',
   (char)'R',
   (char)'W',
   (char)'L',
   (char)'l',
   (char)'b',
   (char)'P',
   (char)'z',
   (char)'n',
   (char)'Z',
   (char)'g',
   (char)'8',
   (char)'O',
   (char)'Q',
   (char)'h',
   (char)'/',
   (char)'V',
   (char)'g',
   (char)'C',
   (char)'M',
   (char)'A',
   (char)'5',
   (char)'8',
   (char)'N',
   (char)'5',
   (char)'D',
   (char)'j',
   (char)'O',
   (char)'z',
   (char)'T',
   (char)'I',
   (char)'K',
   (char)'7',
   (char)'s',
   (char)'J',
   (char)'J',
   (char)'5',
   (char)'r',
   (char)'+',
   (char)'9',
   (char)'4',
   (char)'Z',
   (char)'B',
   (char)'T',
   (char)'C',
   (char)'p',
   (char)'g',
   (char)'A',
   (char)'M',
   (char)'b',
   (char)'F',
   (char)'5',
   (char)'8',
   (char)'8',
   (char)'f',
   (char)'0',
   (char)'N',
   (char)'T',
   (char)'R',
   (char)'\r',
   (char)'\n',
   (char)'K',
   (char)'C',
   (char)'e',
   (char)'4',
   (char)'y',
   (char)'r',
   (char)'x',
   (char)'G',
   (char)'J',
   (char)'R',
   (char)'7',
   (char)'X',
   (char)'0',
   (char)'2',
   (char)'M',
   (char)'4',
   (char)'n',
   (char)'v',
   (char)'D',
   (char)'4',
   (char)'I',
   (char)'w',
   (char)'O',
   (char)'l',
   (char)'p',
   (char)'s',
   (char)'Q',
   (char)'8',
   (char)'x',
   (char)'Q',
   (char)'x',
   (char)'Z',
   (char)'t',
   (char)'O',
   (char)'S',
   (char)'g',
   (char)'X',
   (char)'v',
   (char)'4',
   (char)'L',
   (char)'k',
   (char)'x',
   (char)'v',
   (char)'d',
   (char)'U',
   (char)'9',
   (char)'X',
   (char)'J',
   (char)'J',
   (char)'K',
   (char)'W',
   (char)'Z',
   (char)'/',
   (char)'X',
   (char)'N',
   (char)'K',
   (char)'J',
   (char)'e',
   (char)'W',
   (char)'z',
   (char)'t',
   (char)'x',
   (char)'S',
   (char)'e',
   (char)'\r',
   (char)'\n',
   (char)'Z',
   (char)'1',
   (char)'v',
   (char)'d',
   (char)'T',
   (char)'c',
   (char)'2',
   (char)'Y',
   (char)'f',
   (char)'s',
   (char)'D',
   (char)'B',
   (char)'A',
   (char)'2',
   (char)'S',
   (char)'E',
   (char)'v',
   (char)'3',
   (char)'3',
   (char)'v',
   (char)'x',
   (char)'H',
   (char)'x',
   (char)'2',
   (char)'g',
   (char)'1',
   (char)'v',
   (char)'q',
   (char)'t',
   (char)'w',
   (char)'8',
   (char)'S',
   (char)'j',
   (char)'D',
   (char)'R',
   (char)'T',
   (char)'2',
   (char)'R',
   (char)'a',
   (char)'Q',
   (char)'S',
   (char)'S',
   (char)'0',
   (char)'Q',
   (char)'u',
   (char)'S',
   (char)'a',
   (char)'M',
   (char)'J',
   (char)'i',
   (char)'m',
   (char)'d',
   (char)'O',
   (char)'X',
   (char)'6',
   (char)'m',
   (char)'T',
   (char)'O',
   (char)'C',
   (char)'B',
   (char)'K',
   (char)'k',
   (char)'1',
   (char)'J',
   (char)'\r',
   (char)'\n',
   (char)'9',
   (char)'Q',
   (char)'5',
   (char)'m',
   (char)'X',
   (char)'T',
   (char)'r',
   (char)'E',
   (char)'R',
   (char)'+',
   (char)'/',
   (char)'L',
   (char)'n',
   (char)'K',
   (char)'0',
   (char)'j',
   (char)'E',
   (char)'m',
   (char)'X',
   (char)'s',
   (char)'B',
   (char)'X',
   (char)'W',
   (char)'A',
   (char)'5',
   (char)'b',
   (char)'q',
   (char)'q',
   (char)'V',
   (char)'Z',
   (char)'I',
   (char)'y',
   (char)'a',
   (char)'h',
   (char)'X',
   (char)'S',
   (char)'x',
   (char)'4',
   (char)'V',
   (char)'Y',
   (char)'Z',
   (char)'7',
   (char)'l',
   (char)'7',
   (char)'w',
   (char)'/',
   (char)'P',
   (char)'H',
   (char)'i',
   (char)'U',
   (char)'D',
   (char)'t',
   (char)'D',
   (char)'g',
   (char)'y',
   (char)'R',
   (char)'h',
   (char)'M',
   (char)'M',
   (char)'K',
   (char)'i',
   (char)'4',
   (char)'n',
   (char)'2',
   (char)'\r',
   (char)'\n',
   (char)'i',
   (char)'Q',
   (char)'v',
   (char)'Q',
   (char)'c',
   (char)'W',
   (char)'S',
   (char)'Q',
   (char)'T',
   (char)'j',
   (char)'r',
   (char)'p',
   (char)'n',
   (char)'l',
   (char)'J',
   (char)'b',
   (char)'c',
   (char)'a',
   (char)'1',
   (char)'/',
   (char)'D',
   (char)'k',
   (char)'p',
   (char)'R',
   (char)'t',
   (char)'3',
   (char)'Y',
   (char)'w',
   (char)'r',
   (char)'v',
   (char)'J',
   (char)'w',
   (char)'d',
   (char)'q',
   (char)'b',
   (char)'8',
   (char)'a',
   (char)'s',
   (char)'Z',
   (char)'U',
   (char)'2',
   (char)'V',
   (char)'r',
   (char)'N',
   (char)'E',
   (char)'T',
   (char)'h',
   (char)'5',
   (char)'x',
   (char)'0',
   (char)'Q',
   (char)'V',
   (char)'e',
   (char)'f',
   (char)'D',
   (char)'R',
   (char)'L',
   (char)'F',
   (char)'i',
   (char)'V',
   (char)'p',
   (char)'i',
   (char)'f',
   (char)'/',
   (char)'\r',
   (char)'\n',
   (char)'t',
   (char)'U',
   (char)'a',
   (char)'e',
   (char)'A',
   (char)'e',
   (char)'/',
   (char)'P',
   (char)'1',
   (char)'F',
   (char)'8',
   (char)'O',
   (char)'k',
   (char)'S',
   (char)'7',
   (char)'O',
   (char)'I',
   (char)'Z',
   (char)'D',
   (char)'s',
   (char)'1',
   (char)'S',
   (char)'U',
   (char)'b',
   (char)'v',
   (char)'/',
   (char)'s',
   (char)'D',
   (char)'2',
   (char)'v',
   (char)'M',
   (char)'b',
   (char)'h',
   (char)'N',
   (char)'k',
   (char)'U',
   (char)'o',
   (char)'C',
   (char)'m',
   (char)'s',
   (char)'3',
   (char)'/',
   (char)'P',
   (char)'v',
   (char)'N',
   (char)'t',
   (char)'d',
   (char)'n',
   (char)'v',
   (char)'g',
   (char)'L',
   (char)'4',
   (char)'F',
   (char)'0',
   (char)'z',
   (char)'h',
   (char)'a',
   (char)'D',
   (char)'p',
   (char)'K',
   (char)'C',
   (char)'m',
   (char)'l',
   (char)'T',
   (char)'\r',
   (char)'\n',
   (char)'P',
   (char)'8',
   (char)'v',
   (char)'x',
   (char)'4',
   (char)'9',
   (char)'E',
   (char)'7',
   (char)'v',
   (char)'5',
   (char)'C',
   (char)'y',
   (char)'R',
   (char)'N',
   (char)'m',
   (char)'E',
   (char)'D',
   (char)'9',
   (char)'z',
   (char)'Z',
   (char)'g',
   (char)'4',
   (char)'o',
   (char)'3',
   (char)'w',
   (char)'m',
   (char)'M',
   (char)'q',
   (char)'r',
   (char)'Q',
   (char)'O',
   (char)'9',
   (char)'3',
   (char)'P',
   (char)'t',
   (char)'T',
   (char)'u',
   (char)'g',
   (char)'3',
   (char)'E',
   (char)'u',
   (char)'9',
   (char)'o',
   (char)'V',
   (char)'x',
   (char)'1',
   (char)'z',
   (char)'P',
   (char)'Q',
   (char)'M',
   (char)'1',
   (char)'N',
   (char)'V',
   (char)'M',
   (char)'y',
   (char)'B',
   (char)'a',
   (char)'2',
   (char)'+',
   (char)'f',
   (char)'2',
   (char)'9',
   (char)'D',
   (char)'L',
   (char)'\r',
   (char)'\n',
   (char)'1',
   (char)'n',
   (char)'u',
   (char)'T',
   (char)'C',
   (char)'e',
   (char)'X',
   (char)'d',
   (char)'o',
   (char)'9',
   (char)'+',
   (char)'n',
   (char)'i',
   (char)'4',
   (char)'5',
   (char)'x',
   (char)'x',
   (char)'+',
   (char)'j',
   (char)'A',
   (char)'I',
   (char)'4',
   (char)'D',
   (char)'C',
   (char)'w',
   (char)'r',
   (char)'R',
   (char)'d',
   (char)'h',
   (char)'J',
   (char)'9',
   (char)'u',
   (char)'z',
   (char)'Z',
   (char)'y',
   (char)'C',
   (char)'6',
   (char)'9',
   (char)'6',
   (char)'2',
   (char)'H',
   (char)'3',
   (char)'7',
   (char)'H',
   (char)'6',
   (char)'D',
   (char)'+',
   (char)'5',
   (char)'n',
   (char)'a',
   (char)'N',
   (char)'v',
   (char)'C',
   (char)'l',
   (char)'F',
   (char)'R',
   (char)'1',
   (char)'s',
   (char)'6',
   (char)'l',
   (char)'i',
   (char)'1',
   (char)'G',
   (char)'b',
   (char)'\r',
   (char)'\n',
   (char)'n',
   (char)'q',
   (char)'P',
   (char)'o',
   (char)'i',
   (char)'y',
   (char)'/',
   (char)'O',
   (char)'B',
   (char)'s',
   (char)'E',
   (char)'x',
   (char)'9',
   (char)'C',
   (char)'a',
   (char)'D',
   (char)'G',
   (char)'c',
   (char)'q',
   (char)'Q',
   (char)'B',
   (char)'p',
   (char)'5',
   (char)'W',
   (char)'m',
   (char)'e',
   (char)'/',
   (char)'3',
   (char)'X',
   (char)'W',
   (char)'+',
   (char)'6',
   (char)'z',
   (char)'1',
   (char)'I',
   (char)'S',
   (char)'O',
   (char)'x',
   (char)'+',
   (char)'i',
   (char)'g',
   (char)'w',
   (char)'N',
   (char)'T',
   (char)'V',
   (char)'C',
   (char)'T',
   (char)'1',
   (char)'4',
   (char)'m',
   (char)'H',
   (char)'d',
   (char)'B',
   (char)'M',
   (char)'b',
   (char)'y',
   (char)'a',
   (char)'0',
   (char)'e',
   (char)'I',
   (char)'K',
   (char)'f',
   (char)'t',
   (char)'5',
   (char)'\r',
   (char)'\n',
   (char)'X',
   (char)'+',
   (char)'G',
   (char)'n',
   (char)'w',
   (char)'t',
   (char)'g',
   (char)'E',
   (char)'M',
   (char)'y',
   (char)'C',
   (char)'Y',
   (char)'y',
   (char)'y',
   (char)'W',
   (char)'u',
   (char)'U',
   (char)'c',
   (char)'t',
   (char)'8',
   (char)'g',
   (char)'4',
   (char)'R',
   (char)'z',
   (char)'E',
   (char)'r',
   (char)'c',
   (char)'Y',
   (char)'9',
   (char)'+',
   (char)'y',
   (char)'W',
   (char)'9',
   (char)'O',
   (char)'m',
   (char)'5',
   (char)'H',
   (char)'z',
   (char)'p',
   (char)'x',
   (char)'4',
   (char)'z',
   (char)'O',
   (char)'u',
   (char)'W',
   (char)'4',
   (char)'N',
   (char)'P',
   (char)'Z',
   (char)'g',
   (char)'P',
   (char)'D',
   (char)'T',
   (char)'g',
   (char)'K',
   (char)'+',
   (char)'t',
   (char)'2',
   (char)'R',
   (char)'S',
   (char)'L',
   (char)'/',
   (char)'Y',
   (char)'q',
   (char)'\r',
   (char)'\n',
   (char)'r',
   (char)'E',
   (char)'1',
   (char)'n',
   (char)'j',
   (char)'r',
   (char)'g',
   (char)'e',
   (char)'G',
   (char)'Y',
   (char)'c',
   (char)'V',
   (char)'e',
   (char)'G',
   (char)'3',
   (char)'f',
   (char)'+',
   (char)'O',
   (char)'f',
   (char)'t',
   (char)'H',
   (char)'4',
   (char)'s',
   (char)'6',
   (char)'f',
   (char)'P',
   (char)'b',
   (char)'q',
   (char)'7',
   (char)'t',
   (char)'1',
   (char)'A',
   (char)'5',
   (char)'Z',
   (char)'g',
   (char)'U',
   (char)'s',
   (char)'c',
   (char)'b',
   (char)'L',
   (char)'M',
   (char)'B',
   (char)'q',
   (char)'r',
   (char)'9',
   (char)'t',
   (char)'K',
   (char)'+',
   (char)'O',
   (char)'q',
   (char)'y',
   (char)'g',
   (char)'R',
   (char)'4',
   (char)'E',
   (char)'g',
   (char)'K',
   (char)'B',
   (char)'P',
   (char)'s',
   (char)'H',
   (char)'6',
   (char)'C',
   (char)'z',
   (char)'\r',
   (char)'\n',
   (char)'L',
   (char)'6',
   (char)'z',
   (char)'l',
   (char)'v',
   (char)'/',
   (char)'2',
   (char)'R',
   (char)'V',
   (char)'0',
   (char)'q',
   (char)'A',
   (char)'H',
   (char)'v',
   (char)'V',
   (char)'u',
   (char)'D',
   (char)'J',
   (char)'c',
   (char)'I',
   (char)'D',
   (char)'I',
   (char)'g',
   (char)'w',
   (char)'Y',
   (char)'5',
   (char)'r',
   (char)'J',
   (char)'t',
   (char)'I',
   (char)'N',
   (char)'E',
   (char)'m',
   (char)'3',
   (char)'2',
   (char)'r',
   (char)'h',
   (char)'O',
   (char)'e',
   (char)'F',
   (char)'N',
   (char)'J',
   (char)'w',
   (char)'Z',
   (char)'S',
   (char)'5',
   (char)'M',
   (char)'N',
   (char)'I',
   (char)'C',
   (char)'1',
   (char)'c',
   (char)'z',
   (char)'X',
   (char)'Z',
   (char)'x',
   (char)'5',
   (char)'/',
   (char)'/',
   (char)'u',
   (char)'g',
   (char)'X',
   (char)'7',
   (char)'l',
   (char)'\r',
   (char)'\n',
   (char)'I',
   (char)'4',
   (char)'s',
   (char)'y',
   (char)'5',
   (char)'n',
   (char)'b',
   (char)'V',
   (char)'h',
   (char)'w',
   (char)'S',
   (char)'j',
   (char)'t',
   (char)'A',
   (char)'k',
   (char)'8',
   (char)'X',
   (char)'g',
   (char)'5',
   (char)'d',
   (char)'Z',
   (char)'b',
   (char)'d',
   (char)'T',
   (char)'Z',
   (char)'6',
   (char)'m',
   (char)'I',
   (char)'r',
   (char)'b',
   (char)'7',
   (char)'x',
   (char)'q',
   (char)'H',
   (char)'+',
   (char)'f',
   (char)'d',
   (char)'a',
   (char)'k',
   (char)'Z',
   (char)'o',
   (char)'r',
   (char)'1',
   (char)'k',
   (char)'h',
   (char)'G',
   (char)'7',
   (char)'b',
   (char)'C',
   (char)'2',
   (char)'u',
   (char)'I',
   (char)'w',
   (char)'i',
   (char)'b',
   (char)'D',
   (char)'3',
   (char)'c',
   (char)'S',
   (char)'l',
   (char)'2',
   (char)'X',
   (char)'k',
   (char)'R',
   (char)'\r',
   (char)'\n',
   (char)'w',
   (char)'N',
   (char)'4',
   (char)'8',
   (char)'l',
   (char)'s',
   (char)'l',
   (char)'b',
   (char)'H',
   (char)'n',
   (char)'q',
   (char)'q',
   (char)'a',
   (char)'g',
   (char)'r',
   (char)'6',
   (char)'X',
   (char)'m',
   (char)'1',
   (char)'n',
   (char)'N',
   (char)'O',
   (char)'S',
   (char)'V',
   (char)'l',
   (char)'8',
   (char)'C',
   (char)'/',
   (char)'6',
   (char)'k',
   (char)'b',
   (char)'J',
   (char)'E',
   (char)'s',
   (char)'M',
   (char)'p',
   (char)'L',
   (char)'h',
   (char)'A',
   (char)'e',
   (char)'z',
   (char)'f',
   (char)'R',
   (char)'t',
   (char)'G',
   (char)'w',
   (char)'v',
   (char)'O',
   (char)'u',
   (char)'c',
   (char)'o',
   (char)'a',
   (char)'E',
   (char)'+',
   (char)'W',
   (char)'b',
   (char)'e',
   (char)'U',
   (char)'N',
   (char)'o',
   (char)'l',
   (char)'G',
   (char)'d',
   (char)'e',
   (char)'\r',
   (char)'\n',
   (char)'P',
   (char)'/',
   (char)'e',
   (char)'Q',
   (char)'i',
   (char)'d',
   (char)'d',
   (char)'S',
   (char)'f',
   (char)'0',
   (char)'b',
   (char)'r',
   (char)'n',
   (char)'p',
   (char)'i',
   (char)'L',
   (char)'J',
   (char)'R',
   (char)'h',
   (char)'7',
   (char)'q',
   (char)'Z',
   (char)'r',
   (char)'l',
   (char)'9',
   (char)'X',
   (char)'u',
   (char)'q',
   (char)'Y',
   (char)'d',
   (char)'p',
   (char)'U',
   (char)'q',
   (char)'n',
   (char)'o',
   (char)'E',
   (char)'d',
   (char)'M',
   (char)'A',
   (char)'f',
   (char)'o',
   (char)'t',
   (char)'D',
   (char)'O',
   (char)'I',
   (char)'D',
   (char)'8',
   (char)'O',
   (char)'t',
   (char)'V',
   (char)'7',
   (char)'g',
   (char)'t',
   (char)'8',
   (char)'a',
   (char)'4',
   (char)'8',
   (char)'a',
   (char)'d',
   (char)'8',
   (char)'V',
   (char)'P',
   (char)'W',
   (char)'2',
   (char)'\r',
   (char)'\n',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'E',
   (char)'N',
   (char)'D',
   (char)' ',
   (char)'R',
   (char)'S',
   (char)'A',
   (char)' ',
   (char)'P',
   (char)'R',
   (char)'I',
   (char)'V',
   (char)'A',
   (char)'T',
   (char)'E',
   (char)' ',
   (char)'K',
   (char)'E',
   (char)'Y',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'\r',
   (char)'\n',
   (char)'\000'};
char const test_ca_pwd[13] =
  {(char)'P',
   (char)'o',
   (char)'l',
   (char)'a',
   (char)'r',
   (char)'S',
   (char)'S',
   (char)'L',
   (char)'T',
   (char)'e',
   (char)'s',
   (char)'t',
   (char)'\000'};
char const test_srv_crt[1209] =
  {(char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'B',
   (char)'E',
   (char)'G',
   (char)'I',
   (char)'N',
   (char)' ',
   (char)'C',
   (char)'E',
   (char)'R',
   (char)'T',
   (char)'I',
   (char)'F',
   (char)'I',
   (char)'C',
   (char)'A',
   (char)'T',
   (char)'E',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'\r',
   (char)'\n',
   (char)'M',
   (char)'I',
   (char)'I',
   (char)'D',
   (char)'P',
   (char)'z',
   (char)'C',
   (char)'C',
   (char)'A',
   (char)'i',
   (char)'e',
   (char)'g',
   (char)'A',
   (char)'w',
   (char)'I',
   (char)'B',
   (char)'A',
   (char)'g',
   (char)'I',
   (char)'B',
   (char)'A',
   (char)'T',
   (char)'A',
   (char)'N',
   (char)'B',
   (char)'g',
   (char)'k',
   (char)'q',
   (char)'h',
   (char)'k',
   (char)'i',
   (char)'G',
   (char)'9',
   (char)'w',
   (char)'0',
   (char)'B',
   (char)'A',
   (char)'Q',
   (char)'U',
   (char)'F',
   (char)'A',
   (char)'D',
   (char)'A',
   (char)'7',
   (char)'M',
   (char)'Q',
   (char)'s',
   (char)'w',
   (char)'C',
   (char)'Q',
   (char)'Y',
   (char)'D',
   (char)'V',
   (char)'Q',
   (char)'Q',
   (char)'G',
   (char)'E',
   (char)'w',
   (char)'J',
   (char)'O',
   (char)'T',
   (char)'D',
   (char)'E',
   (char)'R',
   (char)'\r',
   (char)'\n',
   (char)'M',
   (char)'A',
   (char)'8',
   (char)'G',
   (char)'A',
   (char)'1',
   (char)'U',
   (char)'E',
   (char)'C',
   (char)'h',
   (char)'M',
   (char)'I',
   (char)'U',
   (char)'G',
   (char)'9',
   (char)'s',
   (char)'Y',
   (char)'X',
   (char)'J',
   (char)'T',
   (char)'U',
   (char)'0',
   (char)'w',
   (char)'x',
   (char)'G',
   (char)'T',
   (char)'A',
   (char)'X',
   (char)'B',
   (char)'g',
   (char)'N',
   (char)'V',
   (char)'B',
   (char)'A',
   (char)'M',
   (char)'T',
   (char)'E',
   (char)'F',
   (char)'B',
   (char)'v',
   (char)'b',
   (char)'G',
   (char)'F',
   (char)'y',
   (char)'U',
   (char)'1',
   (char)'N',
   (char)'M',
   (char)'I',
   (char)'F',
   (char)'R',
   (char)'l',
   (char)'c',
   (char)'3',
   (char)'Q',
   (char)'g',
   (char)'Q',
   (char)'0',
   (char)'E',
   (char)'w',
   (char)'H',
   (char)'h',
   (char)'c',
   (char)'N',
   (char)'\r',
   (char)'\n',
   (char)'M',
   (char)'T',
   (char)'E',
   (char)'w',
   (char)'M',
   (char)'j',
   (char)'E',
   (char)'y',
   (char)'M',
   (char)'T',
   (char)'Q',
   (char)'0',
   (char)'N',
   (char)'D',
   (char)'A',
   (char)'2',
   (char)'W',
   (char)'h',
   (char)'c',
   (char)'N',
   (char)'M',
   (char)'j',
   (char)'E',
   (char)'w',
   (char)'M',
   (char)'j',
   (char)'E',
   (char)'y',
   (char)'M',
   (char)'T',
   (char)'Q',
   (char)'0',
   (char)'N',
   (char)'D',
   (char)'A',
   (char)'2',
   (char)'W',
   (char)'j',
   (char)'A',
   (char)'8',
   (char)'M',
   (char)'Q',
   (char)'s',
   (char)'w',
   (char)'C',
   (char)'Q',
   (char)'Y',
   (char)'D',
   (char)'V',
   (char)'Q',
   (char)'Q',
   (char)'G',
   (char)'E',
   (char)'w',
   (char)'J',
   (char)'O',
   (char)'T',
   (char)'D',
   (char)'E',
   (char)'R',
   (char)'M',
   (char)'A',
   (char)'8',
   (char)'G',
   (char)'\r',
   (char)'\n',
   (char)'A',
   (char)'1',
   (char)'U',
   (char)'E',
   (char)'C',
   (char)'h',
   (char)'M',
   (char)'I',
   (char)'U',
   (char)'G',
   (char)'9',
   (char)'s',
   (char)'Y',
   (char)'X',
   (char)'J',
   (char)'T',
   (char)'U',
   (char)'0',
   (char)'w',
   (char)'x',
   (char)'G',
   (char)'j',
   (char)'A',
   (char)'Y',
   (char)'B',
   (char)'g',
   (char)'N',
   (char)'V',
   (char)'B',
   (char)'A',
   (char)'M',
   (char)'T',
   (char)'E',
   (char)'V',
   (char)'B',
   (char)'v',
   (char)'b',
   (char)'G',
   (char)'F',
   (char)'y',
   (char)'U',
   (char)'1',
   (char)'N',
   (char)'M',
   (char)'I',
   (char)'F',
   (char)'N',
   (char)'l',
   (char)'c',
   (char)'n',
   (char)'Z',
   (char)'l',
   (char)'c',
   (char)'i',
   (char)'A',
   (char)'x',
   (char)'M',
   (char)'I',
   (char)'I',
   (char)'B',
   (char)'I',
   (char)'j',
   (char)'A',
   (char)'N',
   (char)'\r',
   (char)'\n',
   (char)'B',
   (char)'g',
   (char)'k',
   (char)'q',
   (char)'h',
   (char)'k',
   (char)'i',
   (char)'G',
   (char)'9',
   (char)'w',
   (char)'0',
   (char)'B',
   (char)'A',
   (char)'Q',
   (char)'E',
   (char)'F',
   (char)'A',
   (char)'A',
   (char)'O',
   (char)'C',
   (char)'A',
   (char)'Q',
   (char)'8',
   (char)'A',
   (char)'M',
   (char)'I',
   (char)'I',
   (char)'B',
   (char)'C',
   (char)'g',
   (char)'K',
   (char)'C',
   (char)'A',
   (char)'Q',
   (char)'E',
   (char)'A',
   (char)'q',
   (char)'Q',
   (char)'I',
   (char)'f',
   (char)'P',
   (char)'U',
   (char)'B',
   (char)'q',
   (char)'1',
   (char)'V',
   (char)'V',
   (char)'T',
   (char)'i',
   (char)'/',
   (char)'0',
   (char)'2',
   (char)'7',
   (char)'o',
   (char)'J',
   (char)'l',
   (char)'L',
   (char)'h',
   (char)'V',
   (char)'h',
   (char)'X',
   (char)'o',
   (char)'m',
   (char)'/',
   (char)'\r',
   (char)'\n',
   (char)'u',
   (char)'O',
   (char)'h',
   (char)'F',
   (char)'k',
   (char)'N',
   (char)'v',
   (char)'u',
   (char)'i',
   (char)'B',
   (char)'Z',
   (char)'S',
   (char)'0',
   (char)'/',
   (char)'F',
   (char)'D',
   (char)'U',
   (char)'E',
   (char)'e',
   (char)'W',
   (char)'E',
   (char)'l',
   (char)'l',
   (char)'k',
   (char)'h',
   (char)'2',
   (char)'v',
   (char)'9',
   (char)'K',
   (char)'+',
   (char)'B',
   (char)'G',
   (char)'+',
   (char)'X',
   (char)'O',
   (char)'+',
   (char)'3',
   (char)'c',
   (char)'+',
   (char)'S',
   (char)'4',
   (char)'Z',
   (char)'F',
   (char)'b',
   (char)'7',
   (char)'W',
   (char)'a',
   (char)'g',
   (char)'b',
   (char)'4',
   (char)'k',
   (char)'p',
   (char)'e',
   (char)'U',
   (char)'W',
   (char)'A',
   (char)'0',
   (char)'I',
   (char)'N',
   (char)'q',
   (char)'1',
   (char)'U',
   (char)'F',
   (char)'D',
   (char)'\r',
   (char)'\n',
   (char)'d',
   (char)'1',
   (char)'8',
   (char)'5',
   (char)'f',
   (char)'A',
   (char)'k',
   (char)'E',
   (char)'R',
   (char)'4',
   (char)'K',
   (char)'w',
   (char)'V',
   (char)'z',
   (char)'l',
   (char)'w',
   (char)'7',
   (char)'a',
   (char)'P',
   (char)'s',
   (char)'F',
   (char)'R',
   (char)'k',
   (char)'e',
   (char)'q',
   (char)'D',
   (char)'M',
   (char)'I',
   (char)'R',
   (char)'8',
   (char)'E',
   (char)'F',
   (char)'Q',
   (char)'q',
   (char)'n',
   (char)'9',
   (char)'T',
   (char)'M',
   (char)'O',
   (char)'0',
   (char)'3',
   (char)'9',
   (char)'0',
   (char)'G',
   (char)'H',
   (char)'0',
   (char)'0',
   (char)'Q',
   (char)'U',
   (char)'U',
   (char)'B',
   (char)'n',
   (char)'c',
   (char)'x',
   (char)'M',
   (char)'P',
   (char)'Q',
   (char)'P',
   (char)'h',
   (char)'t',
   (char)'g',
   (char)'S',
   (char)'V',
   (char)'f',
   (char)'\r',
   (char)'\n',
   (char)'C',
   (char)'r',
   (char)'F',
   (char)'T',
   (char)'x',
   (char)'j',
   (char)'B',
   (char)'+',
   (char)'F',
   (char)'T',
   (char)'m',
   (char)'s',
   (char)'+',
   (char)'V',
   (char)'r',
   (char)'u',
   (char)'f',
   (char)'5',
   (char)'K',
   (char)'e',
   (char)'p',
   (char)'g',
   (char)'V',
   (char)'b',
   (char)'5',
   (char)'x',
   (char)'O',
   (char)'X',
   (char)'h',
   (char)'b',
   (char)'U',
   (char)'j',
   (char)'k',
   (char)'t',
   (char)'n',
   (char)'U',
   (char)'J',
   (char)'A',
   (char)'b',
   (char)'V',
   (char)'C',
   (char)'S',
   (char)'W',
   (char)'J',
   (char)'d',
   (char)'Q',
   (char)'f',
   (char)'d',
   (char)'p',
   (char)'h',
   (char)'q',
   (char)'P',
   (char)'P',
   (char)'w',
   (char)'k',
   (char)'Z',
   (char)'v',
   (char)'q',
   (char)'1',
   (char)'l',
   (char)'L',
   (char)'G',
   (char)'T',
   (char)'r',
   (char)'\r',
   (char)'\n',
   (char)'l',
   (char)'Z',
   (char)'v',
   (char)'c',
   (char)'/',
   (char)'k',
   (char)'F',
   (char)'e',
   (char)'F',
   (char)'6',
   (char)'b',
   (char)'a',
   (char)'b',
   (char)'F',
   (char)'t',
   (char)'p',
   (char)'z',
   (char)'A',
   (char)'K',
   (char)'6',
   (char)'F',
   (char)'C',
   (char)'w',
   (char)'W',
   (char)'J',
   (char)'J',
   (char)'x',
   (char)'K',
   (char)'3',
   (char)'M',
   (char)'3',
   (char)'Q',
   (char)'9',
   (char)'1',
   (char)'J',
   (char)'n',
   (char)'c',
   (char)'/',
   (char)'E',
   (char)'t',
   (char)'o',
   (char)'C',
   (char)'P',
   (char)'9',
   (char)'f',
   (char)'v',
   (char)'Q',
   (char)'x',
   (char)'y',
   (char)'i',
   (char)'1',
   (char)'w',
   (char)'y',
   (char)'o',
   (char)'k',
   (char)'L',
   (char)'B',
   (char)'N',
   (char)'s',
   (char)'u',
   (char)'p',
   (char)'k',
   (char)'9',
   (char)'w',
   (char)'\r',
   (char)'\n',
   (char)'b',
   (char)'p',
   (char)'7',
   (char)'O',
   (char)'v',
   (char)'V',
   (char)'i',
   (char)'J',
   (char)'4',
   (char)'l',
   (char)'N',
   (char)'Z',
   (char)'n',
   (char)'m',
   (char)'5',
   (char)'a',
   (char)'k',
   (char)'m',
   (char)'X',
   (char)'i',
   (char)'i',
   (char)'D',
   (char)'8',
   (char)'M',
   (char)'l',
   (char)'B',
   (char)'m',
   (char)'j',
   (char)'3',
   (char)'e',
   (char)'X',
   (char)'o',
   (char)'n',
   (char)'Z',
   (char)'U',
   (char)'T',
   (char)'7',
   (char)'S',
   (char)'n',
   (char)'b',
   (char)'q',
   (char)'3',
   (char)'A',
   (char)'S',
   (char)'3',
   (char)'F',
   (char)'r',
   (char)'K',
   (char)'a',
   (char)'x',
   (char)'e',
   (char)'r',
   (char)'U',
   (char)'o',
   (char)'J',
   (char)'U',
   (char)'s',
   (char)'Q',
   (char)'I',
   (char)'D',
   (char)'A',
   (char)'Q',
   (char)'A',
   (char)'B',
   (char)'\r',
   (char)'\n',
   (char)'o',
   (char)'0',
   (char)'0',
   (char)'w',
   (char)'S',
   (char)'z',
   (char)'A',
   (char)'J',
   (char)'B',
   (char)'g',
   (char)'N',
   (char)'V',
   (char)'H',
   (char)'R',
   (char)'M',
   (char)'E',
   (char)'A',
   (char)'j',
   (char)'A',
   (char)'A',
   (char)'M',
   (char)'B',
   (char)'0',
   (char)'G',
   (char)'A',
   (char)'1',
   (char)'U',
   (char)'d',
   (char)'D',
   (char)'g',
   (char)'Q',
   (char)'W',
   (char)'B',
   (char)'B',
   (char)'Q',
   (char)'f',
   (char)'d',
   (char)'N',
   (char)'Y',
   (char)'/',
   (char)'K',
   (char)'c',
   (char)'F',
   (char)'0',
   (char)'d',
   (char)'E',
   (char)'U',
   (char)'7',
   (char)'B',
   (char)'R',
   (char)'I',
   (char)'s',
   (char)'P',
   (char)'a',
   (char)'i',
   (char)'9',
   (char)'Q',
   (char)'1',
   (char)'k',
   (char)'C',
   (char)'p',
   (char)'j',
   (char)'A',
   (char)'f',
   (char)'\r',
   (char)'\n',
   (char)'B',
   (char)'g',
   (char)'N',
   (char)'V',
   (char)'H',
   (char)'S',
   (char)'M',
   (char)'E',
   (char)'G',
   (char)'D',
   (char)'A',
   (char)'W',
   (char)'g',
   (char)'B',
   (char)'S',
   (char)'0',
   (char)'W',
   (char)'u',
   (char)'S',
   (char)'l',
   (char)'s',
   (char)'9',
   (char)'7',
   (char)'S',
   (char)'U',
   (char)'v',
   (char)'a',
   (char)'5',
   (char)'1',
   (char)'a',
   (char)'a',
   (char)'V',
   (char)'D',
   (char)'+',
   (char)'s',
   (char)'+',
   (char)'v',
   (char)'M',
   (char)'f',
   (char)'9',
   (char)'/',
   (char)'z',
   (char)'A',
   (char)'N',
   (char)'B',
   (char)'g',
   (char)'k',
   (char)'q',
   (char)'h',
   (char)'k',
   (char)'i',
   (char)'G',
   (char)'9',
   (char)'w',
   (char)'0',
   (char)'B',
   (char)'A',
   (char)'Q',
   (char)'U',
   (char)'F',
   (char)'A',
   (char)'A',
   (char)'O',
   (char)'C',
   (char)'\r',
   (char)'\n',
   (char)'A',
   (char)'Q',
   (char)'E',
   (char)'A',
   (char)'v',
   (char)'c',
   (char)'+',
   (char)'W',
   (char)'w',
   (char)'Z',
   (char)'U',
   (char)'e',
   (char)'m',
   (char)'s',
   (char)'J',
   (char)'u',
   (char)'2',
   (char)'I',
   (char)'i',
   (char)'I',
   (char)'2',
   (char)'C',
   (char)'p',
   (char)'6',
   (char)'l',
   (char)'i',
   (char)'A',
   (char)'+',
   (char)'U',
   (char)'A',
   (char)'v',
   (char)'I',
   (char)'x',
   (char)'9',
   (char)'8',
   (char)'d',
   (char)'Q',
   (char)'e',
   (char)'3',
   (char)'k',
   (char)'Z',
   (char)'s',
   (char)'2',
   (char)'z',
   (char)'A',
   (char)'o',
   (char)'F',
   (char)'9',
   (char)'V',
   (char)'w',
   (char)'Q',
   (char)'b',
   (char)'X',
   (char)'c',
   (char)'Y',
   (char)'z',
   (char)'W',
   (char)'Q',
   (char)'/',
   (char)'B',
   (char)'I',
   (char)'L',
   (char)'k',
   (char)'j',
   (char)'\r',
   (char)'\n',
   (char)'N',
   (char)'I',
   (char)'m',
   (char)'K',
   (char)'b',
   (char)'P',
   (char)'L',
   (char)'9',
   (char)'x',
   (char)'0',
   (char)'g',
   (char)'2',
   (char)'j',
   (char)'I',
   (char)'D',
   (char)'n',
   (char)'4',
   (char)'Z',
   (char)'v',
   (char)'G',
   (char)'Y',
   (char)'F',
   (char)'y',
   (char)'w',
   (char)'M',
   (char)'w',
   (char)'I',
   (char)'O',
   (char)'/',
   (char)'d',
   (char)'+',
   (char)'+',
   (char)'Y',
   (char)'b',
   (char)'w',
   (char)'Y',
   (char)'i',
   (char)'Q',
   (char)'w',
   (char)'4',
   (char)'2',
   (char)'/',
   (char)'v',
   (char)'7',
   (char)'R',
   (char)'i',
   (char)'M',
   (char)'y',
   (char)'9',
   (char)'4',
   (char)'z',
   (char)'B',
   (char)'P',
   (char)'n',
   (char)'z',
   (char)'e',
   (char)'H',
   (char)'i',
   (char)'8',
   (char)'6',
   (char)'d',
   (char)'y',
   (char)'/',
   (char)'0',
   (char)'\r',
   (char)'\n',
   (char)'j',
   (char)'p',
   (char)'O',
   (char)'O',
   (char)'J',
   (char)'U',
   (char)'x',
   (char)'3',
   (char)'I',
   (char)'X',
   (char)'R',
   (char)'s',
   (char)'G',
   (char)'L',
   (char)'d',
   (char)'y',
   (char)'j',
   (char)'b',
   (char)'/',
   (char)'1',
   (char)'T',
   (char)'1',
   (char)'1',
   (char)'k',
   (char)'l',
   (char)'c',
   (char)'F',
   (char)'q',
   (char)'G',
   (char)'n',
   (char)'A',
   (char)'R',
   (char)'i',
   (char)'K',
   (char)'+',
   (char)'8',
   (char)'V',
   (char)'Y',
   (char)'o',
   (char)'l',
   (char)'M',
   (char)'P',
   (char)'P',
   (char)'6',
   (char)'a',
   (char)'f',
   (char)'K',
   (char)'v',
   (char)'L',
   (char)'X',
   (char)'X',
   (char)'7',
   (char)'K',
   (char)'4',
   (char)'k',
   (char)'i',
   (char)'U',
   (char)'p',
   (char)'s',
   (char)'F',
   (char)'Q',
   (char)'h',
   (char)'U',
   (char)'p',
   (char)'\r',
   (char)'\n',
   (char)'E',
   (char)'5',
   (char)'V',
   (char)'e',
   (char)'M',
   (char)'5',
   (char)'p',
   (char)'V',
   (char)'1',
   (char)'M',
   (char)'c',
   (char)'i',
   (char)'2',
   (char)'E',
   (char)'T',
   (char)'O',
   (char)'J',
   (char)'a',
   (char)'u',
   (char)'2',
   (char)'c',
   (char)'O',
   (char)'4',
   (char)'0',
   (char)'F',
   (char)'J',
   (char)'v',
   (char)'I',
   (char)'/',
   (char)'C',
   (char)'9',
   (char)'W',
   (char)'/',
   (char)'w',
   (char)'R',
   (char)'+',
   (char)'G',
   (char)'A',
   (char)'A',
   (char)'r',
   (char)'M',
   (char)'a',
   (char)'w',
   (char)'2',
   (char)'f',
   (char)'x',
   (char)'G',
   (char)'7',
   (char)'7',
   (char)'E',
   (char)'3',
   (char)'l',
   (char)'a',
   (char)'a',
   (char)'a',
   (char)'0',
   (char)'L',
   (char)'A',
   (char)'O',
   (char)'l',
   (char)'e',
   (char)'x',
   (char)'M',
   (char)'6',
   (char)'\r',
   (char)'\n',
   (char)'A',
   (char)'4',
   (char)'K',
   (char)'O',
   (char)'b',
   (char)'5',
   (char)'f',
   (char)'5',
   (char)'c',
   (char)'G',
   (char)'T',
   (char)'M',
   (char)'5',
   (char)'I',
   (char)'h',
   (char)'6',
   (char)'t',
   (char)'E',
   (char)'F',
   (char)'5',
   (char)'F',
   (char)'V',
   (char)'q',
   (char)'3',
   (char)'/',
   (char)'9',
   (char)'v',
   (char)'z',
   (char)'N',
   (char)'I',
   (char)'Y',
   (char)'M',
   (char)'a',
   (char)'1',
   (char)'F',
   (char)'q',
   (char)'z',
   (char)'a',
   (char)'c',
   (char)'B',
   (char)'L',
   (char)'Z',
   (char)'F',
   (char)'8',
   (char)'z',
   (char)'S',
   (char)'H',
   (char)'Y',
   (char)'L',
   (char)'E',
   (char)'i',
   (char)'m',
   (char)'X',
   (char)'B',
   (char)'d',
   (char)'z',
   (char)'j',
   (char)'B',
   (char)'o',
   (char)'N',
   (char)'4',
   (char)'q',
   (char)'D',
   (char)'U',
   (char)'\r',
   (char)'\n',
   (char)'/',
   (char)'W',
   (char)'z',
   (char)'R',
   (char)'y',
   (char)'Y',
   (char)'R',
   (char)'B',
   (char)'R',
   (char)'j',
   (char)'A',
   (char)'I',
   (char)'4',
   (char)'9',
   (char)'m',
   (char)'z',
   (char)'H',
   (char)'X',
   (char)'6',
   (char)'r',
   (char)'a',
   (char)'l',
   (char)'e',
   (char)'q',
   (char)'n',
   (char)'w',
   (char)'=',
   (char)'=',
   (char)'\r',
   (char)'\n',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'E',
   (char)'N',
   (char)'D',
   (char)' ',
   (char)'C',
   (char)'E',
   (char)'R',
   (char)'T',
   (char)'I',
   (char)'F',
   (char)'I',
   (char)'C',
   (char)'A',
   (char)'T',
   (char)'E',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'\r',
   (char)'\n',
   (char)'\000'};
char const test_srv_key[1703] =
  {(char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'B',
   (char)'E',
   (char)'G',
   (char)'I',
   (char)'N',
   (char)' ',
   (char)'R',
   (char)'S',
   (char)'A',
   (char)' ',
   (char)'P',
   (char)'R',
   (char)'I',
   (char)'V',
   (char)'A',
   (char)'T',
   (char)'E',
   (char)' ',
   (char)'K',
   (char)'E',
   (char)'Y',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'\r',
   (char)'\n',
   (char)'M',
   (char)'I',
   (char)'I',
   (char)'E',
   (char)'o',
   (char)'g',
   (char)'I',
   (char)'B',
   (char)'A',
   (char)'A',
   (char)'K',
   (char)'C',
   (char)'A',
   (char)'Q',
   (char)'E',
   (char)'A',
   (char)'q',
   (char)'Q',
   (char)'I',
   (char)'f',
   (char)'P',
   (char)'U',
   (char)'B',
   (char)'q',
   (char)'1',
   (char)'V',
   (char)'V',
   (char)'T',
   (char)'i',
   (char)'/',
   (char)'0',
   (char)'2',
   (char)'7',
   (char)'o',
   (char)'J',
   (char)'l',
   (char)'L',
   (char)'h',
   (char)'V',
   (char)'h',
   (char)'X',
   (char)'o',
   (char)'m',
   (char)'/',
   (char)'u',
   (char)'O',
   (char)'h',
   (char)'F',
   (char)'k',
   (char)'N',
   (char)'v',
   (char)'u',
   (char)'i',
   (char)'B',
   (char)'Z',
   (char)'S',
   (char)'0',
   (char)'/',
   (char)'F',
   (char)'D',
   (char)'U',
   (char)'E',
   (char)'e',
   (char)'W',
   (char)'\r',
   (char)'\n',
   (char)'E',
   (char)'l',
   (char)'l',
   (char)'k',
   (char)'h',
   (char)'2',
   (char)'v',
   (char)'9',
   (char)'K',
   (char)'+',
   (char)'B',
   (char)'G',
   (char)'+',
   (char)'X',
   (char)'O',
   (char)'+',
   (char)'3',
   (char)'c',
   (char)'+',
   (char)'S',
   (char)'4',
   (char)'Z',
   (char)'F',
   (char)'b',
   (char)'7',
   (char)'W',
   (char)'a',
   (char)'g',
   (char)'b',
   (char)'4',
   (char)'k',
   (char)'p',
   (char)'e',
   (char)'U',
   (char)'W',
   (char)'A',
   (char)'0',
   (char)'I',
   (char)'N',
   (char)'q',
   (char)'1',
   (char)'U',
   (char)'F',
   (char)'D',
   (char)'d',
   (char)'1',
   (char)'8',
   (char)'5',
   (char)'f',
   (char)'A',
   (char)'k',
   (char)'E',
   (char)'R',
   (char)'4',
   (char)'K',
   (char)'w',
   (char)'V',
   (char)'z',
   (char)'l',
   (char)'w',
   (char)'7',
   (char)'a',
   (char)'P',
   (char)'s',
   (char)'\r',
   (char)'\n',
   (char)'F',
   (char)'R',
   (char)'k',
   (char)'e',
   (char)'q',
   (char)'D',
   (char)'M',
   (char)'I',
   (char)'R',
   (char)'8',
   (char)'E',
   (char)'F',
   (char)'Q',
   (char)'q',
   (char)'n',
   (char)'9',
   (char)'T',
   (char)'M',
   (char)'O',
   (char)'0',
   (char)'3',
   (char)'9',
   (char)'0',
   (char)'G',
   (char)'H',
   (char)'0',
   (char)'0',
   (char)'Q',
   (char)'U',
   (char)'U',
   (char)'B',
   (char)'n',
   (char)'c',
   (char)'x',
   (char)'M',
   (char)'P',
   (char)'Q',
   (char)'P',
   (char)'h',
   (char)'t',
   (char)'g',
   (char)'S',
   (char)'V',
   (char)'f',
   (char)'C',
   (char)'r',
   (char)'F',
   (char)'T',
   (char)'x',
   (char)'j',
   (char)'B',
   (char)'+',
   (char)'F',
   (char)'T',
   (char)'m',
   (char)'s',
   (char)'+',
   (char)'V',
   (char)'r',
   (char)'u',
   (char)'f',
   (char)'5',
   (char)'K',
   (char)'e',
   (char)'\r',
   (char)'\n',
   (char)'p',
   (char)'g',
   (char)'V',
   (char)'b',
   (char)'5',
   (char)'x',
   (char)'O',
   (char)'X',
   (char)'h',
   (char)'b',
   (char)'U',
   (char)'j',
   (char)'k',
   (char)'t',
   (char)'n',
   (char)'U',
   (char)'J',
   (char)'A',
   (char)'b',
   (char)'V',
   (char)'C',
   (char)'S',
   (char)'W',
   (char)'J',
   (char)'d',
   (char)'Q',
   (char)'f',
   (char)'d',
   (char)'p',
   (char)'h',
   (char)'q',
   (char)'P',
   (char)'P',
   (char)'w',
   (char)'k',
   (char)'Z',
   (char)'v',
   (char)'q',
   (char)'1',
   (char)'l',
   (char)'L',
   (char)'G',
   (char)'T',
   (char)'r',
   (char)'l',
   (char)'Z',
   (char)'v',
   (char)'c',
   (char)'/',
   (char)'k',
   (char)'F',
   (char)'e',
   (char)'F',
   (char)'6',
   (char)'b',
   (char)'a',
   (char)'b',
   (char)'F',
   (char)'t',
   (char)'p',
   (char)'z',
   (char)'A',
   (char)'K',
   (char)'6',
   (char)'\r',
   (char)'\n',
   (char)'F',
   (char)'C',
   (char)'w',
   (char)'W',
   (char)'J',
   (char)'J',
   (char)'x',
   (char)'K',
   (char)'3',
   (char)'M',
   (char)'3',
   (char)'Q',
   (char)'9',
   (char)'1',
   (char)'J',
   (char)'n',
   (char)'c',
   (char)'/',
   (char)'E',
   (char)'t',
   (char)'o',
   (char)'C',
   (char)'P',
   (char)'9',
   (char)'f',
   (char)'v',
   (char)'Q',
   (char)'x',
   (char)'y',
   (char)'i',
   (char)'1',
   (char)'w',
   (char)'y',
   (char)'o',
   (char)'k',
   (char)'L',
   (char)'B',
   (char)'N',
   (char)'s',
   (char)'u',
   (char)'p',
   (char)'k',
   (char)'9',
   (char)'w',
   (char)'b',
   (char)'p',
   (char)'7',
   (char)'O',
   (char)'v',
   (char)'V',
   (char)'i',
   (char)'J',
   (char)'4',
   (char)'l',
   (char)'N',
   (char)'Z',
   (char)'n',
   (char)'m',
   (char)'5',
   (char)'a',
   (char)'k',
   (char)'m',
   (char)'X',
   (char)'i',
   (char)'\r',
   (char)'\n',
   (char)'i',
   (char)'D',
   (char)'8',
   (char)'M',
   (char)'l',
   (char)'B',
   (char)'m',
   (char)'j',
   (char)'3',
   (char)'e',
   (char)'X',
   (char)'o',
   (char)'n',
   (char)'Z',
   (char)'U',
   (char)'T',
   (char)'7',
   (char)'S',
   (char)'n',
   (char)'b',
   (char)'q',
   (char)'3',
   (char)'A',
   (char)'S',
   (char)'3',
   (char)'F',
   (char)'r',
   (char)'K',
   (char)'a',
   (char)'x',
   (char)'e',
   (char)'r',
   (char)'U',
   (char)'o',
   (char)'J',
   (char)'U',
   (char)'s',
   (char)'Q',
   (char)'I',
   (char)'D',
   (char)'A',
   (char)'Q',
   (char)'A',
   (char)'B',
   (char)'A',
   (char)'o',
   (char)'I',
   (char)'B',
   (char)'A',
   (char)'B',
   (char)'a',
   (char)'J',
   (char)'9',
   (char)'e',
   (char)'i',
   (char)'R',
   (char)'Q',
   (char)'q',
   (char)'4',
   (char)'Y',
   (char)'p',
   (char)'v',
   (char)'+',
   (char)'w',
   (char)'\r',
   (char)'\n',
   (char)'U',
   (char)'T',
   (char)'c',
   (char)'V',
   (char)'p',
   (char)'L',
   (char)'C',
   (char)'0',
   (char)'o',
   (char)'T',
   (char)'u',
   (char)'e',
   (char)'W',
   (char)'z',
   (char)'c',
   (char)'p',
   (char)'o',
   (char)'r',
   (char)'1',
   (char)'i',
   (char)'1',
   (char)'z',
   (char)'j',
   (char)'G',
   (char)'4',
   (char)'V',
   (char)'z',
   (char)'q',
   (char)'e',
   (char)'/',
   (char)'O',
   (char)'k',
   (char)'2',
   (char)'F',
   (char)'q',
   (char)'y',
   (char)'G',
   (char)'T',
   (char)'o',
   (char)'G',
   (char)'K',
   (char)'M',
   (char)'l',
   (char)'F',
   (char)'K',
   (char)'7',
   (char)'H',
   (char)'w',
   (char)'w',
   (char)'a',
   (char)'+',
   (char)'L',
   (char)'E',
   (char)'y',
   (char)'e',
   (char)'J',
   (char)'3',
   (char)'x',
   (char)'y',
   (char)'V',
   (char)'5',
   (char)'y',
   (char)'d',
   (char)'4',
   (char)'\r',
   (char)'\n',
   (char)'v',
   (char)'1',
   (char)'M',
   (char)'w',
   (char)'9',
   (char)'b',
   (char)'D',
   (char)'Z',
   (char)'F',
   (char)'d',
   (char)'J',
   (char)'C',
   (char)'1',
   (char)'e',
   (char)'C',
   (char)'B',
   (char)'j',
   (char)'o',
   (char)'U',
   (char)'A',
   (char)'H',
   (char)'t',
   (char)'X',
   (char)'6',
   (char)'k',
   (char)'9',
   (char)'H',
   (char)'O',
   (char)'E',
   (char)'0',
   (char)'V',
   (char)'d',
   (char)'6',
   (char)'w',
   (char)'o',
   (char)'V',
   (char)'Q',
   (char)'4',
   (char)'V',
   (char)'i',
   (char)'6',
   (char)'O',
   (char)'P',
   (char)'I',
   (char)'1',
   (char)'g',
   (char)'7',
   (char)'B',
   (char)'5',
   (char)'M',
   (char)'n',
   (char)'r',
   (char)'/',
   (char)'5',
   (char)'8',
   (char)'r',
   (char)'N',
   (char)'r',
   (char)'n',
   (char)'N',
   (char)'6',
   (char)'T',
   (char)'M',
   (char)'s',
   (char)'\r',
   (char)'\n',
   (char)'x',
   (char)'5',
   (char)'8',
   (char)'N',
   (char)'F',
   (char)'6',
   (char)'e',
   (char)'u',
   (char)'e',
   (char)'c',
   (char)'w',
   (char)'T',
   (char)'U',
   (char)'8',
   (char)'1',
   (char)'1',
   (char)'Q',
   (char)'J',
   (char)'r',
   (char)'Z',
   (char)'t',
   (char)'L',
   (char)'b',
   (char)'X',
   (char)'7',
   (char)'j',
   (char)'2',
   (char)'C',
   (char)'r',
   (char)'2',
   (char)'8',
   (char)'y',
   (char)'B',
   (char)'2',
   (char)'V',
   (char)'s',
   (char)'8',
   (char)'q',
   (char)'y',
   (char)'Y',
   (char)'l',
   (char)'H',
   (char)'w',
   (char)'V',
   (char)'w',
   (char)'5',
   (char)'j',
   (char)'b',
   (char)'D',
   (char)'O',
   (char)'v',
   (char)'4',
   (char)'3',
   (char)'D',
   (char)'7',
   (char)'v',
   (char)'U',
   (char)'5',
   (char)'g',
   (char)'m',
   (char)'l',
   (char)'I',
   (char)'D',
   (char)'N',
   (char)'\r',
   (char)'\n',
   (char)'0',
   (char)'J',
   (char)'Q',
   (char)'R',
   (char)'u',
   (char)'W',
   (char)'A',
   (char)'n',
   (char)'O',
   (char)'u',
   (char)'P',
   (char)'z',
   (char)'Z',
   (char)'N',
   (char)'o',
   (char)'J',
   (char)'r',
   (char)'4',
   (char)'S',
   (char)'f',
   (char)'J',
   (char)'K',
   (char)'q',
   (char)'H',
   (char)'N',
   (char)'G',
   (char)'x',
   (char)'Y',
   (char)'Y',
   (char)'Y',
   (char)'6',
   (char)'p',
   (char)'H',
   (char)'Z',
   (char)'1',
   (char)'s',
   (char)'0',
   (char)'d',
   (char)'O',
   (char)'T',
   (char)'L',
   (char)'I',
   (char)'D',
   (char)'b',
   (char)'/',
   (char)'B',
   (char)'8',
   (char)'K',
   (char)'Q',
   (char)'W',
   (char)'a',
   (char)'p',
   (char)'A',
   (char)'2',
   (char)'k',
   (char)'R',
   (char)'m',
   (char)'Z',
   (char)'y',
   (char)'i',
   (char)'d',
   (char)'2',
   (char)'E',
   (char)'H',
   (char)'\r',
   (char)'\n',
   (char)'n',
   (char)'w',
   (char)'z',
   (char)'g',
   (char)'L',
   (char)'b',
   (char)'A',
   (char)'s',
   (char)'H',
   (char)'J',
   (char)'C',
   (char)'f',
   (char)'+',
   (char)'b',
   (char)'Q',
   (char)'n',
   (char)'h',
   (char)'X',
   (char)'j',
   (char)'X',
   (char)'u',
   (char)'x',
   (char)'t',
   (char)'U',
   (char)'s',
   (char)'r',
   (char)'c',
   (char)'I',
   (char)'L',
   (char)'8',
   (char)'n',
   (char)'o',
   (char)'Z',
   (char)'L',
   (char)'a',
   (char)'z',
   (char)'l',
   (char)'O',
   (char)'M',
   (char)'x',
   (char)'w',
   (char)'N',
   (char)'E',
   (char)'a',
   (char)'m',
   (char)'m',
   (char)'g',
   (char)'l',
   (char)'V',
   (char)'W',
   (char)'W',
   (char)'2',
   (char)'3',
   (char)'U',
   (char)'d',
   (char)'/',
   (char)'Q',
   (char)'R',
   (char)'n',
   (char)'F',
   (char)'g',
   (char)'J',
   (char)'g',
   (char)'5',
   (char)'\r',
   (char)'\n',
   (char)'U',
   (char)'g',
   (char)'c',
   (char)'A',
   (char)'c',
   (char)'R',
   (char)'E',
   (char)'C',
   (char)'g',
   (char)'Y',
   (char)'E',
   (char)'A',
   (char)'1',
   (char)'9',
   (char)'u',
   (char)'Y',
   (char)'e',
   (char)'t',
   (char)'h',
   (char)'t',
   (char)'5',
   (char)'q',
   (char)'m',
   (char)'w',
   (char)'d',
   (char)'J',
   (char)'+',
   (char)'1',
   (char)'2',
   (char)'o',
   (char)'C',
   (char)'6',
   (char)'z',
   (char)'e',
   (char)'O',
   (char)'+',
   (char)'v',
   (char)'X',
   (char)'L',
   (char)'c',
   (char)'y',
   (char)'D',
   (char)'9',
   (char)'g',
   (char)'o',
   (char)'n',
   (char)'2',
   (char)'3',
   (char)'T',
   (char)'5',
   (char)'J',
   (char)'6',
   (char)'w',
   (char)'2',
   (char)'Y',
   (char)'T',
   (char)'h',
   (char)'l',
   (char)'d',
   (char)'7',
   (char)'/',
   (char)'O',
   (char)'W',
   (char)'0',
   (char)'\r',
   (char)'\n',
   (char)'o',
   (char)'A',
   (char)'r',
   (char)'Q',
   (char)'J',
   (char)'G',
   (char)'g',
   (char)'k',
   (char)'A',
   (char)'d',
   (char)'a',
   (char)'q',
   (char)'0',
   (char)'p',
   (char)'c',
   (char)'T',
   (char)'y',
   (char)'O',
   (char)'I',
   (char)'j',
   (char)'t',
   (char)'T',
   (char)'Q',
   (char)'V',
   (char)'M',
   (char)'F',
   (char)'y',
   (char)'g',
   (char)'d',
   (char)'V',
   (char)'m',
   (char)'C',
   (char)'E',
   (char)'J',
   (char)'m',
   (char)'x',
   (char)'h',
   (char)'/',
   (char)'3',
   (char)'R',
   (char)'u',
   (char)'t',
   (char)'P',
   (char)'c',
   (char)'T',
   (char)'e',
   (char)'y',
   (char)'d',
   (char)'q',
   (char)'W',
   (char)'9',
   (char)'f',
   (char)'p',
   (char)'h',
   (char)'K',
   (char)'D',
   (char)'M',
   (char)'e',
   (char)'j',
   (char)'3',
   (char)'2',
   (char)'J',
   (char)'8',
   (char)'e',
   (char)'\r',
   (char)'\n',
   (char)'G',
   (char)'n',
   (char)'i',
   (char)'G',
   (char)'m',
   (char)'N',
   (char)'G',
   (char)'i',
   (char)'c',
   (char)'l',
   (char)'b',
   (char)'c',
   (char)'f',
   (char)'N',
   (char)'O',
   (char)'S',
   (char)'8',
   (char)'E',
   (char)'5',
   (char)'T',
   (char)'G',
   (char)'p',
   (char)'4',
   (char)'4',
   (char)'5',
   (char)'y',
   (char)'Z',
   (char)'b',
   (char)'9',
   (char)'P',
   (char)'1',
   (char)'+',
   (char)'7',
   (char)'A',
   (char)'H',
   (char)'n',
   (char)'g',
   (char)'1',
   (char)'6',
   (char)'b',
   (char)'G',
   (char)'g',
   (char)'3',
   (char)'Y',
   (char)'k',
   (char)'j',
   (char)'5',
   (char)'E',
   (char)'A',
   (char)'4',
   (char)'G',
   (char)'+',
   (char)'H',
   (char)'C',
   (char)'c',
   (char)'C',
   (char)'g',
   (char)'Y',
   (char)'E',
   (char)'A',
   (char)'y',
   (char)'H',
   (char)'A',
   (char)'l',
   (char)'\r',
   (char)'\n',
   (char)'/',
   (char)'/',
   (char)'e',
   (char)'k',
   (char)'k',
   (char)'8',
   (char)'Y',
   (char)'j',
   (char)'Q',
   (char)'E',
   (char)'l',
   (char)'m',
   (char)'+',
   (char)'8',
   (char)'i',
   (char)'z',
   (char)'L',
   (char)'t',
   (char)'F',
   (char)'k',
   (char)'y',
   (char)'m',
   (char)'I',
   (char)'K',
   (char)'0',
   (char)'a',
   (char)'C',
   (char)'t',
   (char)'E',
   (char)'e',
   (char)'9',
   (char)'C',
   (char)'/',
   (char)'R',
   (char)'I',
   (char)'R',
   (char)'h',
   (char)'F',
   (char)'Y',
   (char)'B',
   (char)'e',
   (char)'F',
   (char)'a',
   (char)'o',
   (char)'t',
   (char)'C',
   (char)'5',
   (char)'d',
   (char)'S',
   (char)'t',
   (char)'N',
   (char)'h',
   (char)'B',
   (char)'O',
   (char)'n',
   (char)'c',
   (char)'n',
   (char)'4',
   (char)'o',
   (char)'v',
   (char)'M',
   (char)'A',
   (char)'P',
   (char)'D',
   (char)'\r',
   (char)'\n',
   (char)'l',
   (char)'X',
   (char)'/',
   (char)'9',
   (char)'2',
   (char)'y',
   (char)'D',
   (char)'i',
   (char)'9',
   (char)'O',
   (char)'P',
   (char)'8',
   (char)'P',
   (char)'P',
   (char)'L',
   (char)'N',
   (char)'3',
   (char)'a',
   (char)'4',
   (char)'B',
   (char)'9',
   (char)'X',
   (char)'p',
   (char)'W',
   (char)'3',
   (char)'k',
   (char)'/',
   (char)'S',
   (char)'S',
   (char)'5',
   (char)'G',
   (char)'r',
   (char)'b',
   (char)'T',
   (char)'5',
   (char)'c',
   (char)'w',
   (char)'O',
   (char)'i',
   (char)'v',
   (char)'B',
   (char)'H',
   (char)'N',
   (char)'l',
   (char)'l',
   (char)'Z',
   (char)'S',
   (char)'m',
   (char)'u',
   (char)'/',
   (char)'2',
   (char)'q',
   (char)'z',
   (char)'5',
   (char)'W',
   (char)'P',
   (char)'G',
   (char)'c',
   (char)'j',
   (char)'V',
   (char)'C',
   (char)'O',
   (char)'r',
   (char)'B',
   (char)'\r',
   (char)'\n',
   (char)'L',
   (char)'Y',
   (char)'l',
   (char)'3',
   (char)'Y',
   (char)'W',
   (char)'r',
   (char)'2',
   (char)'h',
   (char)'3',
   (char)'E',
   (char)'G',
   (char)'K',
   (char)'I',
   (char)'C',
   (char)'T',
   (char)'0',
   (char)'3',
   (char)'k',
   (char)'E',
   (char)'o',
   (char)'T',
   (char)'k',
   (char)'i',
   (char)'D',
   (char)'B',
   (char)'v',
   (char)'C',
   (char)'e',
   (char)'O',
   (char)'p',
   (char)'W',
   (char)'7',
   (char)'c',
   (char)'C',
   (char)'G',
   (char)'l',
   (char)'2',
   (char)'c',
   (char)'C',
   (char)'g',
   (char)'Y',
   (char)'B',
   (char)'D',
   (char)'5',
   (char)'w',
   (char)'h',
   (char)'o',
   (char)'X',
   (char)'H',
   (char)'z',
   (char)'1',
   (char)'+',
   (char)'p',
   (char)'t',
   (char)'P',
   (char)'l',
   (char)'I',
   (char)'4',
   (char)'Y',
   (char)'V',
   (char)'j',
   (char)'Z',
   (char)'t',
   (char)'\r',
   (char)'\n',
   (char)'X',
   (char)'h',
   (char)'8',
   (char)'6',
   (char)'a',
   (char)'U',
   (char)'+',
   (char)'a',
   (char)'j',
   (char)'p',
   (char)'V',
   (char)'P',
   (char)'i',
   (char)'E',
   (char)'y',
   (char)'J',
   (char)'8',
   (char)'4',
   (char)'I',
   (char)'6',
   (char)'x',
   (char)'X',
   (char)'m',
   (char)'O',
   (char)'4',
   (char)'S',
   (char)'Z',
   (char)'X',
   (char)'v',
   (char)'8',
   (char)'q',
   (char)'6',
   (char)'L',
   (char)'a',
   (char)'y',
   (char)'c',
   (char)'R',
   (char)'0',
   (char)'Z',
   (char)'M',
   (char)'b',
   (char)'c',
   (char)'L',
   (char)'+',
   (char)'z',
   (char)'B',
   (char)'e',
   (char)'l',
   (char)'M',
   (char)'b',
   (char)'4',
   (char)'Z',
   (char)'2',
   (char)'n',
   (char)'B',
   (char)'v',
   (char)'7',
   (char)'j',
   (char)'N',
   (char)'r',
   (char)'t',
   (char)'u',
   (char)'R',
   (char)'7',
   (char)'\r',
   (char)'\n',
   (char)'Z',
   (char)'F',
   (char)'2',
   (char)'8',
   (char)'c',
   (char)'d',
   (char)'P',
   (char)'v',
   (char)'+',
   (char)'Y',
   (char)'V',
   (char)'r',
   (char)'3',
   (char)'e',
   (char)'s',
   (char)'a',
   (char)'y',
   (char)'b',
   (char)'Z',
   (char)'E',
   (char)'/',
   (char)'7',
   (char)'3',
   (char)'V',
   (char)'j',
   (char)'X',
   (char)'u',
   (char)'p',
   (char)'4',
   (char)'S',
   (char)'Q',
   (char)'P',
   (char)'H',
   (char)'6',
   (char)'r',
   (char)'3',
   (char)'l',
   (char)'7',
   (char)'q',
   (char)'K',
   (char)'T',
   (char)'V',
   (char)'i',
   (char)'+',
   (char)'y',
   (char)'6',
   (char)'+',
   (char)'F',
   (char)'e',
   (char)'J',
   (char)'4',
   (char)'b',
   (char)'2',
   (char)'X',
   (char)'n',
   (char)'8',
   (char)'/',
   (char)'M',
   (char)'w',
   (char)'g',
   (char)'n',
   (char)'T',
   (char)'2',
   (char)'3',
   (char)'\r',
   (char)'\n',
   (char)'8',
   (char)'E',
   (char)'F',
   (char)'r',
   (char)'y',
   (char)'e',
   (char)'7',
   (char)'w',
   (char)'m',
   (char)'z',
   (char)'p',
   (char)'t',
   (char)'h',
   (char)'r',
   (char)'j',
   (char)'O',
   (char)'g',
   (char)'Z',
   (char)'n',
   (char)'U',
   (char)'M',
   (char)'Q',
   (char)'K',
   (char)'B',
   (char)'g',
   (char)'E',
   (char)'9',
   (char)'L',
   (char)'h',
   (char)'s',
   (char)'z',
   (char)'/',
   (char)'5',
   (char)'J',
   (char)'0',
   (char)'N',
   (char)'i',
   (char)'s',
   (char)'6',
   (char)'Y',
   (char)'+',
   (char)'2',
   (char)'P',
   (char)'q',
   (char)'n',
   (char)'3',
   (char)'C',
   (char)'L',
   (char)'K',
   (char)'E',
   (char)'u',
   (char)'k',
   (char)'g',
   (char)'9',
   (char)'E',
   (char)'w',
   (char)'t',
   (char)'q',
   (char)'d',
   (char)'c',
   (char)'t',
   (char)'2',
   (char)'y',
   (char)'0',
   (char)'\r',
   (char)'\n',
   (char)'5',
   (char)'D',
   (char)'c',
   (char)'t',
   (char)'a',
   (char)'0',
   (char)'F',
   (char)'3',
   (char)'T',
   (char)'y',
   (char)'C',
   (char)'R',
   (char)'I',
   (char)'x',
   (char)'l',
   (char)'C',
   (char)'D',
   (char)'K',
   (char)'T',
   (char)'L',
   (char)'/',
   (char)'B',
   (char)'s',
   (char)'l',
   (char)'q',
   (char)'M',
   (char)'t',
   (char)'f',
   (char)'A',
   (char)'d',
   (char)'Y',
   (char)'4',
   (char)'H',
   (char)'2',
   (char)'6',
   (char)'8',
   (char)'U',
   (char)'O',
   (char)'0',
   (char)'+',
   (char)'8',
   (char)'I',
   (char)'A',
   (char)'Q',
   (char)'M',
   (char)'n',
   (char)'9',
   (char)'b',
   (char)'o',
   (char)'q',
   (char)'z',
   (char)'B',
   (char)'r',
   (char)'H',
   (char)'I',
   (char)'g',
   (char)'s',
   (char)'/',
   (char)'p',
   (char)'v',
   (char)'c',
   (char)'5',
   (char)'k',
   (char)'x',
   (char)'\r',
   (char)'\n',
   (char)'T',
   (char)'b',
   (char)'K',
   (char)'H',
   (char)'m',
   (char)'w',
   (char)'2',
   (char)'w',
   (char)'t',
   (char)'W',
   (char)'R',
   (char)'6',
   (char)'v',
   (char)'Y',
   (char)'e',
   (char)'r',
   (char)'s',
   (char)'B',
   (char)'K',
   (char)'V',
   (char)'g',
   (char)'V',
   (char)'p',
   (char)'b',
   (char)'C',
   (char)'G',
   (char)'S',
   (char)'R',
   (char)'s',
   (char)'s',
   (char)'D',
   (char)'Y',
   (char)'H',
   (char)'G',
   (char)'F',
   (char)'u',
   (char)'1',
   (char)'n',
   (char)'7',
   (char)'4',
   (char)'q',
   (char)'M',
   (char)'4',
   (char)'H',
   (char)'J',
   (char)'/',
   (char)'R',
   (char)'G',
   (char)'c',
   (char)'R',
   (char)'1',
   (char)'z',
   (char)'I',
   (char)'9',
   (char)'Q',
   (char)'U',
   (char)'e',
   (char)'1',
   (char)'g',
   (char)'o',
   (char)'p',
   (char)'S',
   (char)'F',
   (char)'D',
   (char)'\r',
   (char)'\n',
   (char)'x',
   (char)'D',
   (char)'t',
   (char)'L',
   (char)'A',
   (char)'o',
   (char)'G',
   (char)'A',
   (char)'V',
   (char)'A',
   (char)'d',
   (char)'W',
   (char)'v',
   (char)'r',
   (char)'q',
   (char)'D',
   (char)'w',
   (char)'g',
   (char)'o',
   (char)'L',
   (char)'2',
   (char)'h',
   (char)'H',
   (char)'W',
   (char)'3',
   (char)'s',
   (char)'c',
   (char)'G',
   (char)'p',
   (char)'x',
   (char)'d',
   (char)'E',
   (char)'/',
   (char)'y',
   (char)'g',
   (char)'J',
   (char)'D',
   (char)'O',
   (char)'w',
   (char)'H',
   (char)'n',
   (char)'f',
   (char)'+',
   (char)'1',
   (char)'B',
   (char)'9',
   (char)'g',
   (char)'o',
   (char)'K',
   (char)'A',
   (char)'O',
   (char)'P',
   (char)'5',
   (char)'l',
   (char)'f',
   (char)'2',
   (char)'F',
   (char)'J',
   (char)'a',
   (char)'i',
   (char)'A',
   (char)'x',
   (char)'f',
   (char)'3',
   (char)'\r',
   (char)'\n',
   (char)'e',
   (char)'c',
   (char)'t',
   (char)'o',
   (char)'P',
   (char)'O',
   (char)'g',
   (char)'Z',
   (char)'b',
   (char)'C',
   (char)'m',
   (char)'m',
   (char)'/',
   (char)'i',
   (char)'i',
   (char)'D',
   (char)'m',
   (char)'i',
   (char)'g',
   (char)'u',
   (char)'7',
   (char)'0',
   (char)'3',
   (char)'l',
   (char)'d',
   (char)'3',
   (char)'O',
   (char)'+',
   (char)'V',
   (char)'o',
   (char)'C',
   (char)'L',
   (char)'D',
   (char)'D',
   (char)'4',
   (char)'q',
   (char)'x',
   (char)'3',
   (char)'R',
   (char)'+',
   (char)'K',
   (char)'y',
   (char)'A',
   (char)'L',
   (char)'L',
   (char)'7',
   (char)'8',
   (char)'g',
   (char)'t',
   (char)'V',
   (char)'J',
   (char)'Y',
   (char)'z',
   (char)'S',
   (char)'R',
   (char)'i',
   (char)'K',
   (char)'h',
   (char)'z',
   (char)'g',
   (char)'C',
   (char)'Z',
   (char)'3',
   (char)'g',
   (char)'\r',
   (char)'\n',
   (char)'m',
   (char)'K',
   (char)'s',
   (char)'I',
   (char)'V',
   (char)'R',
   (char)'B',
   (char)'q',
   (char)'4',
   (char)'I',
   (char)'f',
   (char)'w',
   (char)'i',
   (char)'w',
   (char)'y',
   (char)'M',
   (char)'N',
   (char)'G',
   (char)'2',
   (char)'B',
   (char)'Y',
   (char)'Z',
   (char)'Q',
   (char)'A',
   (char)'w',
   (char)'b',
   (char)'S',
   (char)'D',
   (char)'j',
   (char)'j',
   (char)'P',
   (char)'t',
   (char)'n',
   (char)'/',
   (char)'k',
   (char)'P',
   (char)'B',
   (char)'d',
   (char)'u',
   (char)'P',
   (char)'z',
   (char)'P',
   (char)'j',
   (char)'7',
   (char)'e',
   (char)'r',
   (char)'i',
   (char)'B',
   (char)'y',
   (char)'h',
   (char)'I',
   (char)'=',
   (char)'\r',
   (char)'\n',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'E',
   (char)'N',
   (char)'D',
   (char)' ',
   (char)'R',
   (char)'S',
   (char)'A',
   (char)' ',
   (char)'P',
   (char)'R',
   (char)'I',
   (char)'V',
   (char)'A',
   (char)'T',
   (char)'E',
   (char)' ',
   (char)'K',
   (char)'E',
   (char)'Y',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'\r',
   (char)'\n',
   (char)'\000'};
char const test_cli_crt[1209] =
  {(char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'B',
   (char)'E',
   (char)'G',
   (char)'I',
   (char)'N',
   (char)' ',
   (char)'C',
   (char)'E',
   (char)'R',
   (char)'T',
   (char)'I',
   (char)'F',
   (char)'I',
   (char)'C',
   (char)'A',
   (char)'T',
   (char)'E',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'\r',
   (char)'\n',
   (char)'M',
   (char)'I',
   (char)'I',
   (char)'D',
   (char)'P',
   (char)'z',
   (char)'C',
   (char)'C',
   (char)'A',
   (char)'i',
   (char)'e',
   (char)'g',
   (char)'A',
   (char)'w',
   (char)'I',
   (char)'B',
   (char)'A',
   (char)'g',
   (char)'I',
   (char)'B',
   (char)'B',
   (char)'D',
   (char)'A',
   (char)'N',
   (char)'B',
   (char)'g',
   (char)'k',
   (char)'q',
   (char)'h',
   (char)'k',
   (char)'i',
   (char)'G',
   (char)'9',
   (char)'w',
   (char)'0',
   (char)'B',
   (char)'A',
   (char)'Q',
   (char)'U',
   (char)'F',
   (char)'A',
   (char)'D',
   (char)'A',
   (char)'7',
   (char)'M',
   (char)'Q',
   (char)'s',
   (char)'w',
   (char)'C',
   (char)'Q',
   (char)'Y',
   (char)'D',
   (char)'V',
   (char)'Q',
   (char)'Q',
   (char)'G',
   (char)'E',
   (char)'w',
   (char)'J',
   (char)'O',
   (char)'T',
   (char)'D',
   (char)'E',
   (char)'R',
   (char)'\r',
   (char)'\n',
   (char)'M',
   (char)'A',
   (char)'8',
   (char)'G',
   (char)'A',
   (char)'1',
   (char)'U',
   (char)'E',
   (char)'C',
   (char)'h',
   (char)'M',
   (char)'I',
   (char)'U',
   (char)'G',
   (char)'9',
   (char)'s',
   (char)'Y',
   (char)'X',
   (char)'J',
   (char)'T',
   (char)'U',
   (char)'0',
   (char)'w',
   (char)'x',
   (char)'G',
   (char)'T',
   (char)'A',
   (char)'X',
   (char)'B',
   (char)'g',
   (char)'N',
   (char)'V',
   (char)'B',
   (char)'A',
   (char)'M',
   (char)'T',
   (char)'E',
   (char)'F',
   (char)'B',
   (char)'v',
   (char)'b',
   (char)'G',
   (char)'F',
   (char)'y',
   (char)'U',
   (char)'1',
   (char)'N',
   (char)'M',
   (char)'I',
   (char)'F',
   (char)'R',
   (char)'l',
   (char)'c',
   (char)'3',
   (char)'Q',
   (char)'g',
   (char)'Q',
   (char)'0',
   (char)'E',
   (char)'w',
   (char)'H',
   (char)'h',
   (char)'c',
   (char)'N',
   (char)'\r',
   (char)'\n',
   (char)'M',
   (char)'T',
   (char)'E',
   (char)'w',
   (char)'M',
   (char)'j',
   (char)'E',
   (char)'y',
   (char)'M',
   (char)'T',
   (char)'Q',
   (char)'0',
   (char)'N',
   (char)'D',
   (char)'A',
   (char)'3',
   (char)'W',
   (char)'h',
   (char)'c',
   (char)'N',
   (char)'M',
   (char)'j',
   (char)'E',
   (char)'w',
   (char)'M',
   (char)'j',
   (char)'E',
   (char)'y',
   (char)'M',
   (char)'T',
   (char)'Q',
   (char)'0',
   (char)'N',
   (char)'D',
   (char)'A',
   (char)'3',
   (char)'W',
   (char)'j',
   (char)'A',
   (char)'8',
   (char)'M',
   (char)'Q',
   (char)'s',
   (char)'w',
   (char)'C',
   (char)'Q',
   (char)'Y',
   (char)'D',
   (char)'V',
   (char)'Q',
   (char)'Q',
   (char)'G',
   (char)'E',
   (char)'w',
   (char)'J',
   (char)'O',
   (char)'T',
   (char)'D',
   (char)'E',
   (char)'R',
   (char)'M',
   (char)'A',
   (char)'8',
   (char)'G',
   (char)'\r',
   (char)'\n',
   (char)'A',
   (char)'1',
   (char)'U',
   (char)'E',
   (char)'C',
   (char)'h',
   (char)'M',
   (char)'I',
   (char)'U',
   (char)'G',
   (char)'9',
   (char)'s',
   (char)'Y',
   (char)'X',
   (char)'J',
   (char)'T',
   (char)'U',
   (char)'0',
   (char)'w',
   (char)'x',
   (char)'G',
   (char)'j',
   (char)'A',
   (char)'Y',
   (char)'B',
   (char)'g',
   (char)'N',
   (char)'V',
   (char)'B',
   (char)'A',
   (char)'M',
   (char)'T',
   (char)'E',
   (char)'V',
   (char)'B',
   (char)'v',
   (char)'b',
   (char)'G',
   (char)'F',
   (char)'y',
   (char)'U',
   (char)'1',
   (char)'N',
   (char)'M',
   (char)'I',
   (char)'E',
   (char)'N',
   (char)'s',
   (char)'a',
   (char)'W',
   (char)'V',
   (char)'u',
   (char)'d',
   (char)'C',
   (char)'A',
   (char)'y',
   (char)'M',
   (char)'I',
   (char)'I',
   (char)'B',
   (char)'I',
   (char)'j',
   (char)'A',
   (char)'N',
   (char)'\r',
   (char)'\n',
   (char)'B',
   (char)'g',
   (char)'k',
   (char)'q',
   (char)'h',
   (char)'k',
   (char)'i',
   (char)'G',
   (char)'9',
   (char)'w',
   (char)'0',
   (char)'B',
   (char)'A',
   (char)'Q',
   (char)'E',
   (char)'F',
   (char)'A',
   (char)'A',
   (char)'O',
   (char)'C',
   (char)'A',
   (char)'Q',
   (char)'8',
   (char)'A',
   (char)'M',
   (char)'I',
   (char)'I',
   (char)'B',
   (char)'C',
   (char)'g',
   (char)'K',
   (char)'C',
   (char)'A',
   (char)'Q',
   (char)'E',
   (char)'A',
   (char)'y',
   (char)'H',
   (char)'T',
   (char)'E',
   (char)'z',
   (char)'L',
   (char)'n',
   (char)'5',
   (char)'t',
   (char)'X',
   (char)'n',
   (char)'p',
   (char)'R',
   (char)'d',
   (char)'k',
   (char)'U',
   (char)'Y',
   (char)'L',
   (char)'B',
   (char)'9',
   (char)'u',
   (char)'5',
   (char)'P',
   (char)'y',
   (char)'a',
   (char)'x',
   (char)'6',
   (char)'f',
   (char)'\r',
   (char)'\n',
   (char)'M',
   (char)'6',
   (char)'0',
   (char)'N',
   (char)'j',
   (char)'4',
   (char)'o',
   (char)'8',
   (char)'V',
   (char)'m',
   (char)'X',
   (char)'l',
   (char)'3',
   (char)'E',
   (char)'T',
   (char)'Z',
   (char)'z',
   (char)'G',
   (char)'a',
   (char)'F',
   (char)'B',
   (char)'9',
   (char)'X',
   (char)'4',
   (char)'J',
   (char)'7',
   (char)'B',
   (char)'K',
   (char)'N',
   (char)'d',
   (char)'B',
   (char)'j',
   (char)'n',
   (char)'g',
   (char)'p',
   (char)'u',
   (char)'G',
   (char)'7',
   (char)'f',
   (char)'a',
   (char)'8',
   (char)'H',
   (char)'6',
   (char)'r',
   (char)'7',
   (char)'g',
   (char)'w',
   (char)'Q',
   (char)'k',
   (char)'4',
   (char)'Z',
   (char)'J',
   (char)'G',
   (char)'D',
   (char)'T',
   (char)'z',
   (char)'q',
   (char)'C',
   (char)'r',
   (char)'S',
   (char)'V',
   (char)'/',
   (char)'U',
   (char)'u',
   (char)'\r',
   (char)'\n',
   (char)'1',
   (char)'C',
   (char)'9',
   (char)'3',
   (char)'K',
   (char)'Y',
   (char)'R',
   (char)'h',
   (char)'T',
   (char)'Y',
   (char)'J',
   (char)'Q',
   (char)'j',
   (char)'6',
   (char)'e',
   (char)'V',
   (char)'S',
   (char)'H',
   (char)'D',
   (char)'1',
   (char)'b',
   (char)'k',
   (char)'2',
   (char)'y',
   (char)'1',
   (char)'R',
   (char)'P',
   (char)'D',
   (char)'0',
   (char)'h',
   (char)'r',
   (char)'t',
   (char)'5',
   (char)'k',
   (char)'P',
   (char)'q',
   (char)'Q',
   (char)'h',
   (char)'T',
   (char)'r',
   (char)'d',
   (char)'O',
   (char)'r',
   (char)'A',
   (char)'7',
   (char)'R',
   (char)'/',
   (char)'U',
   (char)'V',
   (char)'0',
   (char)'6',
   (char)'p',
   (char)'8',
   (char)'6',
   (char)'j',
   (char)'t',
   (char)'0',
   (char)'u',
   (char)'D',
   (char)'B',
   (char)'M',
   (char)'H',
   (char)'E',
   (char)'w',
   (char)'\r',
   (char)'\n',
   (char)'M',
   (char)'j',
   (char)'D',
   (char)'V',
   (char)'0',
   (char)'/',
   (char)'Y',
   (char)'I',
   (char)'0',
   (char)'F',
   (char)'Z',
   (char)'P',
   (char)'R',
   (char)'o',
   (char)'7',
   (char)'y',
   (char)'X',
   (char)'/',
   (char)'k',
   (char)'9',
   (char)'Z',
   (char)'5',
   (char)'G',
   (char)'I',
   (char)'M',
   (char)'C',
   (char)'5',
   (char)'C',
   (char)'s',
   (char)'t',
   (char)'9',
   (char)'9',
   (char)'+',
   (char)'+',
   (char)'U',
   (char)'M',
   (char)'d',
   (char)'/',
   (char)'/',
   (char)'s',
   (char)'M',
   (char)'c',
   (char)'B',
   (char)'4',
   (char)'j',
   (char)'7',
   (char)'/',
   (char)'C',
   (char)'f',
   (char)'8',
   (char)'q',
   (char)'t',
   (char)'b',
   (char)'C',
   (char)'H',
   (char)'W',
   (char)'j',
   (char)'d',
   (char)'m',
   (char)'L',
   (char)'a',
   (char)'o',
   (char)'5',
   (char)'v',
   (char)'\r',
   (char)'\n',
   (char)'4',
   (char)'J',
   (char)'v',
   (char)'4',
   (char)'E',
   (char)'F',
   (char)'b',
   (char)'M',
   (char)'s',
   (char)'4',
   (char)'4',
   (char)'T',
   (char)'F',
   (char)'e',
   (char)'Y',
   (char)'0',
   (char)'B',
   (char)'G',
   (char)'b',
   (char)'H',
   (char)'7',
   (char)'v',
   (char)'k',
   (char)'2',
   (char)'D',
   (char)'m',
   (char)'q',
   (char)'V',
   (char)'9',
   (char)'g',
   (char)'m',
   (char)'a',
   (char)'B',
   (char)'m',
   (char)'f',
   (char)'0',
   (char)'Z',
   (char)'X',
   (char)'H',
   (char)'4',
   (char)'y',
   (char)'q',
   (char)'S',
   (char)'x',
   (char)'J',
   (char)'e',
   (char)'D',
   (char)'+',
   (char)'P',
   (char)'I',
   (char)'s',
   (char)'1',
   (char)'B',
   (char)'G',
   (char)'e',
   (char)'6',
   (char)'4',
   (char)'E',
   (char)'9',
   (char)'2',
   (char)'h',
   (char)'f',
   (char)'x',
   (char)'/',
   (char)'\r',
   (char)'\n',
   (char)'/',
   (char)'D',
   (char)'Z',
   (char)'r',
   (char)'t',
   (char)'e',
   (char)'n',
   (char)'N',
   (char)'L',
   (char)'Q',
   (char)'N',
   (char)'i',
   (char)'T',
   (char)'r',
   (char)'M',
   (char)'9',
   (char)'A',
   (char)'M',
   (char)'+',
   (char)'v',
   (char)'d',
   (char)'q',
   (char)'B',
   (char)'p',
   (char)'V',
   (char)'o',
   (char)'N',
   (char)'q',
   (char)'0',
   (char)'q',
   (char)'j',
   (char)'U',
   (char)'5',
   (char)'1',
   (char)'B',
   (char)'x',
   (char)'5',
   (char)'r',
   (char)'U',
   (char)'2',
   (char)'B',
   (char)'X',
   (char)'c',
   (char)'F',
   (char)'b',
   (char)'X',
   (char)'v',
   (char)'I',
   (char)'5',
   (char)'M',
   (char)'T',
   (char)'9',
   (char)'T',
   (char)'N',
   (char)'U',
   (char)'h',
   (char)'X',
   (char)'w',
   (char)'I',
   (char)'D',
   (char)'A',
   (char)'Q',
   (char)'A',
   (char)'B',
   (char)'\r',
   (char)'\n',
   (char)'o',
   (char)'0',
   (char)'0',
   (char)'w',
   (char)'S',
   (char)'z',
   (char)'A',
   (char)'J',
   (char)'B',
   (char)'g',
   (char)'N',
   (char)'V',
   (char)'H',
   (char)'R',
   (char)'M',
   (char)'E',
   (char)'A',
   (char)'j',
   (char)'A',
   (char)'A',
   (char)'M',
   (char)'B',
   (char)'0',
   (char)'G',
   (char)'A',
   (char)'1',
   (char)'U',
   (char)'d',
   (char)'D',
   (char)'g',
   (char)'Q',
   (char)'W',
   (char)'B',
   (char)'B',
   (char)'R',
   (char)'x',
   (char)'o',
   (char)'Q',
   (char)'B',
   (char)'z',
   (char)'c',
   (char)'k',
   (char)'A',
   (char)'v',
   (char)'V',
   (char)'H',
   (char)'Z',
   (char)'e',
   (char)'M',
   (char)'/',
   (char)'x',
   (char)'S',
   (char)'j',
   (char)'7',
   (char)'z',
   (char)'x',
   (char)'3',
   (char)'W',
   (char)'t',
   (char)'G',
   (char)'I',
   (char)'T',
   (char)'A',
   (char)'f',
   (char)'\r',
   (char)'\n',
   (char)'B',
   (char)'g',
   (char)'N',
   (char)'V',
   (char)'H',
   (char)'S',
   (char)'M',
   (char)'E',
   (char)'G',
   (char)'D',
   (char)'A',
   (char)'W',
   (char)'g',
   (char)'B',
   (char)'S',
   (char)'0',
   (char)'W',
   (char)'u',
   (char)'S',
   (char)'l',
   (char)'s',
   (char)'9',
   (char)'7',
   (char)'S',
   (char)'U',
   (char)'v',
   (char)'a',
   (char)'5',
   (char)'1',
   (char)'a',
   (char)'a',
   (char)'V',
   (char)'D',
   (char)'+',
   (char)'s',
   (char)'+',
   (char)'v',
   (char)'M',
   (char)'f',
   (char)'9',
   (char)'/',
   (char)'z',
   (char)'A',
   (char)'N',
   (char)'B',
   (char)'g',
   (char)'k',
   (char)'q',
   (char)'h',
   (char)'k',
   (char)'i',
   (char)'G',
   (char)'9',
   (char)'w',
   (char)'0',
   (char)'B',
   (char)'A',
   (char)'Q',
   (char)'U',
   (char)'F',
   (char)'A',
   (char)'A',
   (char)'O',
   (char)'C',
   (char)'\r',
   (char)'\n',
   (char)'A',
   (char)'Q',
   (char)'E',
   (char)'A',
   (char)'A',
   (char)'n',
   (char)'8',
   (char)'6',
   (char)'i',
   (char)'s',
   (char)'A',
   (char)'M',
   (char)'8',
   (char)'X',
   (char)'+',
   (char)'m',
   (char)'V',
   (char)'w',
   (char)'J',
   (char)'q',
   (char)'e',
   (char)'I',
   (char)'t',
   (char)'t',
   (char)'6',
   (char)'E',
   (char)'9',
   (char)'s',
   (char)'l',
   (char)'h',
   (char)'E',
   (char)'Q',
   (char)'b',
   (char)'A',
   (char)'o',
   (char)'f',
   (char)'y',
   (char)'k',
   (char)'+',
   (char)'d',
   (char)'i',
   (char)'H',
   (char)'1',
   (char)'L',
   (char)'h',
   (char)'8',
   (char)'Y',
   (char)'9',
   (char)'i',
   (char)'L',
   (char)'l',
   (char)'W',
   (char)'Q',
   (char)'S',
   (char)'K',
   (char)'b',
   (char)'w',
   (char)'/',
   (char)'U',
   (char)'X',
   (char)'Y',
   (char)'j',
   (char)'x',
   (char)'5',
   (char)'\r',
   (char)'\n',
   (char)'L',
   (char)'L',
   (char)'P',
   (char)'Z',
   (char)'c',
   (char)'n',
   (char)'i',
   (char)'o',
   (char)'v',
   (char)'x',
   (char)'I',
   (char)'c',
   (char)'A',
   (char)'R',
   (char)'C',
   (char)'/',
   (char)'B',
   (char)'j',
   (char)'y',
   (char)'Z',
   (char)'R',
   (char)'9',
   (char)'g',
   (char)'3',
   (char)'U',
   (char)'w',
   (char)'T',
   (char)'H',
   (char)'N',
   (char)'G',
   (char)'N',
   (char)'m',
   (char)'+',
   (char)'r',
   (char)'w',
   (char)'r',
   (char)'q',
   (char)'a',
   (char)'1',
   (char)'5',
   (char)'v',
   (char)'i',
   (char)'u',
   (char)'N',
   (char)'O',
   (char)'F',
   (char)'B',
   (char)'c',
   (char)'h',
   (char)'y',
   (char)'k',
   (char)'X',
   (char)'/',
   (char)'O',
   (char)'r',
   (char)'s',
   (char)'k',
   (char)'0',
   (char)'2',
   (char)'E',
   (char)'H',
   (char)'7',
   (char)'N',
   (char)'R',
   (char)'\r',
   (char)'\n',
   (char)'A',
   (char)'l',
   (char)'w',
   (char)'5',
   (char)'W',
   (char)'L',
   (char)'P',
   (char)'o',
   (char)'r',
   (char)'Y',
   (char)'j',
   (char)'E',
   (char)'D',
   (char)'6',
   (char)'c',
   (char)'d',
   (char)'V',
   (char)'Q',
   (char)'g',
   (char)'B',
   (char)'l',
   (char)'9',
   (char)'o',
   (char)'t',
   (char)'9',
   (char)'3',
   (char)'H',
   (char)'d',
   (char)'J',
   (char)'o',
   (char)'g',
   (char)'R',
   (char)'i',
   (char)'X',
   (char)'C',
   (char)'x',
   (char)'E',
   (char)'r',
   (char)'M',
   (char)'7',
   (char)'N',
   (char)'C',
   (char)'8',
   (char)'/',
   (char)'e',
   (char)'P',
   (char)'5',
   (char)'1',
   (char)'1',
   (char)'m',
   (char)'j',
   (char)'q',
   (char)'+',
   (char)'u',
   (char)'L',
   (char)'D',
   (char)'j',
   (char)'L',
   (char)'K',
   (char)'H',
   (char)'8',
   (char)'Z',
   (char)'P',
   (char)'Q',
   (char)'\r',
   (char)'\n',
   (char)'8',
   (char)'I',
   (char)'4',
   (char)'e',
   (char)'k',
   (char)'H',
   (char)'J',
   (char)'n',
   (char)'r',
   (char)'o',
   (char)'L',
   (char)'s',
   (char)'D',
   (char)'k',
   (char)'I',
   (char)'w',
   (char)'X',
   (char)'K',
   (char)'G',
   (char)'I',
   (char)'s',
   (char)'v',
   (char)'I',
   (char)'B',
   (char)'H',
   (char)'Q',
   (char)'y',
   (char)'2',
   (char)'a',
   (char)'c',
   (char)'/',
   (char)'N',
   (char)'w',
   (char)'H',
   (char)'L',
   (char)'C',
   (char)'Q',
   (char)'O',
   (char)'K',
   (char)'6',
   (char)'m',
   (char)'f',
   (char)'u',
   (char)'m',
   (char)'1',
   (char)'p',
   (char)'R',
   (char)'x',
   (char)'5',
   (char)'2',
   (char)'V',
   (char)'4',
   (char)'U',
   (char)'t',
   (char)'u',
   (char)'5',
   (char)'d',
   (char)'L',
   (char)'L',
   (char)'j',
   (char)'D',
   (char)'5',
   (char)'b',
   (char)'M',
   (char)'\r',
   (char)'\n',
   (char)'x',
   (char)'O',
   (char)'B',
   (char)'C',
   (char)'7',
   (char)'K',
   (char)'U',
   (char)'4',
   (char)'x',
   (char)'Z',
   (char)'K',
   (char)'u',
   (char)'M',
   (char)'X',
   (char)'X',
   (char)'Z',
   (char)'M',
   (char)'6',
   (char)'/',
   (char)'9',
   (char)'3',
   (char)'Y',
   (char)'b',
   (char)'5',
   (char)'1',
   (char)'K',
   (char)'/',
   (char)'J',
   (char)'4',
   (char)'a',
   (char)'h',
   (char)'f',
   (char)'1',
   (char)'T',
   (char)'x',
   (char)'J',
   (char)'l',
   (char)'T',
   (char)'W',
   (char)'X',
   (char)'t',
   (char)'n',
   (char)'z',
   (char)'D',
   (char)'r',
   (char)'9',
   (char)'s',
   (char)'a',
   (char)'E',
   (char)'Y',
   (char)'d',
   (char)'N',
   (char)'y',
   (char)'2',
   (char)'S',
   (char)'K',
   (char)'Y',
   (char)'/',
   (char)'6',
   (char)'Z',
   (char)'i',
   (char)'D',
   (char)'N',
   (char)'H',
   (char)'\r',
   (char)'\n',
   (char)'D',
   (char)'+',
   (char)'s',
   (char)'t',
   (char)'p',
   (char)'A',
   (char)'K',
   (char)'i',
   (char)'Q',
   (char)'L',
   (char)'A',
   (char)'W',
   (char)'a',
   (char)'A',
   (char)'u',
   (char)'s',
   (char)'I',
   (char)'W',
   (char)'K',
   (char)'Y',
   (char)'E',
   (char)'y',
   (char)'w',
   (char)'9',
   (char)'M',
   (char)'Q',
   (char)'=',
   (char)'=',
   (char)'\r',
   (char)'\n',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'E',
   (char)'N',
   (char)'D',
   (char)' ',
   (char)'C',
   (char)'E',
   (char)'R',
   (char)'T',
   (char)'I',
   (char)'F',
   (char)'I',
   (char)'C',
   (char)'A',
   (char)'T',
   (char)'E',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'\r',
   (char)'\n',
   (char)'\000'};
char const test_cli_key[1707] =
  {(char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'B',
   (char)'E',
   (char)'G',
   (char)'I',
   (char)'N',
   (char)' ',
   (char)'R',
   (char)'S',
   (char)'A',
   (char)' ',
   (char)'P',
   (char)'R',
   (char)'I',
   (char)'V',
   (char)'A',
   (char)'T',
   (char)'E',
   (char)' ',
   (char)'K',
   (char)'E',
   (char)'Y',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'\r',
   (char)'\n',
   (char)'M',
   (char)'I',
   (char)'I',
   (char)'E',
   (char)'p',
   (char)'A',
   (char)'I',
   (char)'B',
   (char)'A',
   (char)'A',
   (char)'K',
   (char)'C',
   (char)'A',
   (char)'Q',
   (char)'E',
   (char)'A',
   (char)'y',
   (char)'H',
   (char)'T',
   (char)'E',
   (char)'z',
   (char)'L',
   (char)'n',
   (char)'5',
   (char)'t',
   (char)'X',
   (char)'n',
   (char)'p',
   (char)'R',
   (char)'d',
   (char)'k',
   (char)'U',
   (char)'Y',
   (char)'L',
   (char)'B',
   (char)'9',
   (char)'u',
   (char)'5',
   (char)'P',
   (char)'y',
   (char)'a',
   (char)'x',
   (char)'6',
   (char)'f',
   (char)'M',
   (char)'6',
   (char)'0',
   (char)'N',
   (char)'j',
   (char)'4',
   (char)'o',
   (char)'8',
   (char)'V',
   (char)'m',
   (char)'X',
   (char)'l',
   (char)'3',
   (char)'E',
   (char)'T',
   (char)'Z',
   (char)'z',
   (char)'G',
   (char)'a',
   (char)'F',
   (char)'\r',
   (char)'\n',
   (char)'B',
   (char)'9',
   (char)'X',
   (char)'4',
   (char)'J',
   (char)'7',
   (char)'B',
   (char)'K',
   (char)'N',
   (char)'d',
   (char)'B',
   (char)'j',
   (char)'n',
   (char)'g',
   (char)'p',
   (char)'u',
   (char)'G',
   (char)'7',
   (char)'f',
   (char)'a',
   (char)'8',
   (char)'H',
   (char)'6',
   (char)'r',
   (char)'7',
   (char)'g',
   (char)'w',
   (char)'Q',
   (char)'k',
   (char)'4',
   (char)'Z',
   (char)'J',
   (char)'G',
   (char)'D',
   (char)'T',
   (char)'z',
   (char)'q',
   (char)'C',
   (char)'r',
   (char)'S',
   (char)'V',
   (char)'/',
   (char)'U',
   (char)'u',
   (char)'1',
   (char)'C',
   (char)'9',
   (char)'3',
   (char)'K',
   (char)'Y',
   (char)'R',
   (char)'h',
   (char)'T',
   (char)'Y',
   (char)'J',
   (char)'Q',
   (char)'j',
   (char)'6',
   (char)'e',
   (char)'V',
   (char)'S',
   (char)'H',
   (char)'D',
   (char)'1',
   (char)'\r',
   (char)'\n',
   (char)'b',
   (char)'k',
   (char)'2',
   (char)'y',
   (char)'1',
   (char)'R',
   (char)'P',
   (char)'D',
   (char)'0',
   (char)'h',
   (char)'r',
   (char)'t',
   (char)'5',
   (char)'k',
   (char)'P',
   (char)'q',
   (char)'Q',
   (char)'h',
   (char)'T',
   (char)'r',
   (char)'d',
   (char)'O',
   (char)'r',
   (char)'A',
   (char)'7',
   (char)'R',
   (char)'/',
   (char)'U',
   (char)'V',
   (char)'0',
   (char)'6',
   (char)'p',
   (char)'8',
   (char)'6',
   (char)'j',
   (char)'t',
   (char)'0',
   (char)'u',
   (char)'D',
   (char)'B',
   (char)'M',
   (char)'H',
   (char)'E',
   (char)'w',
   (char)'M',
   (char)'j',
   (char)'D',
   (char)'V',
   (char)'0',
   (char)'/',
   (char)'Y',
   (char)'I',
   (char)'0',
   (char)'F',
   (char)'Z',
   (char)'P',
   (char)'R',
   (char)'o',
   (char)'7',
   (char)'y',
   (char)'X',
   (char)'/',
   (char)'k',
   (char)'9',
   (char)'\r',
   (char)'\n',
   (char)'Z',
   (char)'5',
   (char)'G',
   (char)'I',
   (char)'M',
   (char)'C',
   (char)'5',
   (char)'C',
   (char)'s',
   (char)'t',
   (char)'9',
   (char)'9',
   (char)'+',
   (char)'+',
   (char)'U',
   (char)'M',
   (char)'d',
   (char)'/',
   (char)'/',
   (char)'s',
   (char)'M',
   (char)'c',
   (char)'B',
   (char)'4',
   (char)'j',
   (char)'7',
   (char)'/',
   (char)'C',
   (char)'f',
   (char)'8',
   (char)'q',
   (char)'t',
   (char)'b',
   (char)'C',
   (char)'H',
   (char)'W',
   (char)'j',
   (char)'d',
   (char)'m',
   (char)'L',
   (char)'a',
   (char)'o',
   (char)'5',
   (char)'v',
   (char)'4',
   (char)'J',
   (char)'v',
   (char)'4',
   (char)'E',
   (char)'F',
   (char)'b',
   (char)'M',
   (char)'s',
   (char)'4',
   (char)'4',
   (char)'T',
   (char)'F',
   (char)'e',
   (char)'Y',
   (char)'0',
   (char)'B',
   (char)'G',
   (char)'b',
   (char)'H',
   (char)'\r',
   (char)'\n',
   (char)'7',
   (char)'v',
   (char)'k',
   (char)'2',
   (char)'D',
   (char)'m',
   (char)'q',
   (char)'V',
   (char)'9',
   (char)'g',
   (char)'m',
   (char)'a',
   (char)'B',
   (char)'m',
   (char)'f',
   (char)'0',
   (char)'Z',
   (char)'X',
   (char)'H',
   (char)'4',
   (char)'y',
   (char)'q',
   (char)'S',
   (char)'x',
   (char)'J',
   (char)'e',
   (char)'D',
   (char)'+',
   (char)'P',
   (char)'I',
   (char)'s',
   (char)'1',
   (char)'B',
   (char)'G',
   (char)'e',
   (char)'6',
   (char)'4',
   (char)'E',
   (char)'9',
   (char)'2',
   (char)'h',
   (char)'f',
   (char)'x',
   (char)'/',
   (char)'/',
   (char)'D',
   (char)'Z',
   (char)'r',
   (char)'t',
   (char)'e',
   (char)'n',
   (char)'N',
   (char)'L',
   (char)'Q',
   (char)'N',
   (char)'i',
   (char)'T',
   (char)'r',
   (char)'M',
   (char)'9',
   (char)'A',
   (char)'M',
   (char)'+',
   (char)'v',
   (char)'\r',
   (char)'\n',
   (char)'d',
   (char)'q',
   (char)'B',
   (char)'p',
   (char)'V',
   (char)'o',
   (char)'N',
   (char)'q',
   (char)'0',
   (char)'q',
   (char)'j',
   (char)'U',
   (char)'5',
   (char)'1',
   (char)'B',
   (char)'x',
   (char)'5',
   (char)'r',
   (char)'U',
   (char)'2',
   (char)'B',
   (char)'X',
   (char)'c',
   (char)'F',
   (char)'b',
   (char)'X',
   (char)'v',
   (char)'I',
   (char)'5',
   (char)'M',
   (char)'T',
   (char)'9',
   (char)'T',
   (char)'N',
   (char)'U',
   (char)'h',
   (char)'X',
   (char)'w',
   (char)'I',
   (char)'D',
   (char)'A',
   (char)'Q',
   (char)'A',
   (char)'B',
   (char)'A',
   (char)'o',
   (char)'I',
   (char)'B',
   (char)'A',
   (char)'G',
   (char)'d',
   (char)'N',
   (char)'t',
   (char)'f',
   (char)'Y',
   (char)'D',
   (char)'i',
   (char)'a',
   (char)'p',
   (char)'6',
   (char)'b',
   (char)'z',
   (char)'s',
   (char)'t',
   (char)'\r',
   (char)'\n',
   (char)'y',
   (char)'h',
   (char)'C',
   (char)'i',
   (char)'I',
   (char)'8',
   (char)'m',
   (char)'9',
   (char)'T',
   (char)'t',
   (char)'r',
   (char)'h',
   (char)'Z',
   (char)'w',
   (char)'4',
   (char)'M',
   (char)'i',
   (char)'s',
   (char)'a',
   (char)'E',
   (char)'a',
   (char)'N',
   (char)'/',
   (char)'l',
   (char)'l',
   (char)'3',
   (char)'X',
   (char)'S',
   (char)'j',
   (char)'a',
   (char)'O',
   (char)'G',
   (char)'2',
   (char)'d',
   (char)'v',
   (char)'V',
   (char)'6',
   (char)'x',
   (char)'M',
   (char)'Z',
   (char)'C',
   (char)'M',
   (char)'V',
   (char)'+',
   (char)'5',
   (char)'T',
   (char)'e',
   (char)'X',
   (char)'D',
   (char)'H',
   (char)'O',
   (char)'A',
   (char)'Z',
   (char)'n',
   (char)'Y',
   (char)'1',
   (char)'8',
   (char)'Y',
   (char)'i',
   (char)'1',
   (char)'8',
   (char)'v',
   (char)'z',
   (char)'z',
   (char)'\r',
   (char)'\n',
   (char)'4',
   (char)'U',
   (char)'t',
   (char)'2',
   (char)'T',
   (char)'n',
   (char)'N',
   (char)'F',
   (char)'z',
   (char)'i',
   (char)'z',
   (char)'C',
   (char)'E',
   (char)'C',
   (char)'Y',
   (char)'N',
   (char)'a',
   (char)'A',
   (char)'2',
   (char)'f',
   (char)'S',
   (char)'T',
   (char)'3',
   (char)'W',
   (char)'g',
   (char)'I',
   (char)'n',
   (char)'n',
   (char)'x',
   (char)'U',
   (char)'k',
   (char)'V',
   (char)'3',
   (char)'Y',
   (char)'X',
   (char)'A',
   (char)'y',
   (char)'P',
   (char)'6',
   (char)'C',
   (char)'N',
   (char)'x',
   (char)'J',
   (char)'a',
   (char)'C',
   (char)'m',
   (char)'v',
   (char)'2',
   (char)'a',
   (char)'A',
   (char)'0',
   (char)'y',
   (char)'F',
   (char)'r',
   (char)'2',
   (char)'k',
   (char)'F',
   (char)'V',
   (char)'S',
   (char)'e',
   (char)'a',
   (char)'K',
   (char)'G',
   (char)'t',
   (char)'\r',
   (char)'\n',
   (char)'y',
   (char)'m',
   (char)'v',
   (char)'l',
   (char)'j',
   (char)'N',
   (char)'p',
   (char)'2',
   (char)'N',
   (char)'V',
   (char)'k',
   (char)'v',
   (char)'m',
   (char)'7',
   (char)'T',
   (char)'h',
   (char)'8',
   (char)'f',
   (char)'B',
   (char)'Q',
   (char)'B',
   (char)'O',
   (char)'7',
   (char)'I',
   (char)'7',
   (char)'A',
   (char)'X',
   (char)'h',
   (char)'z',
   (char)'4',
   (char)'3',
   (char)'k',
   (char)'0',
   (char)'m',
   (char)'R',
   (char)'7',
   (char)'X',
   (char)'m',
   (char)'P',
   (char)'g',
   (char)'e',
   (char)'w',
   (char)'e',
   (char)'8',
   (char)'A',
   (char)'p',
   (char)'Z',
   (char)'O',
   (char)'G',
   (char)'3',
   (char)'h',
   (char)'s',
   (char)'t',
   (char)'k',
   (char)'O',
   (char)'a',
   (char)'M',
   (char)'v',
   (char)'b',
   (char)'W',
   (char)'A',
   (char)'v',
   (char)'W',
   (char)'A',
   (char)'\r',
   (char)'\n',
   (char)'z',
   (char)'C',
   (char)'Z',
   (char)'u',
   (char)'p',
   (char)'d',
   (char)'D',
   (char)'j',
   (char)'Z',
   (char)'Y',
   (char)'j',
   (char)'O',
   (char)'J',
   (char)'q',
   (char)'l',
   (char)'A',
   (char)'4',
   (char)'e',
   (char)'E',
   (char)'A',
   (char)'4',
   (char)'H',
   (char)'8',
   (char)'/',
   (char)'w',
   (char)'7',
   (char)'F',
   (char)'8',
   (char)'3',
   (char)'r',
   (char)'5',
   (char)'C',
   (char)'u',
   (char)'g',
   (char)'e',
   (char)'B',
   (char)'E',
   (char)'8',
   (char)'L',
   (char)'g',
   (char)'E',
   (char)'R',
   (char)'E',
   (char)'j',
   (char)'L',
   (char)'P',
   (char)'i',
   (char)'y',
   (char)'e',
   (char)'j',
   (char)'r',
   (char)'U',
   (char)'5',
   (char)'H',
   (char)'1',
   (char)'f',
   (char)'u',
   (char)'b',
   (char)'E',
   (char)'Y',
   (char)'+',
   (char)'h',
   (char)'0',
   (char)'d',
   (char)'\r',
   (char)'\n',
   (char)'l',
   (char)'5',
   (char)'H',
   (char)'Z',
   (char)'B',
   (char)'J',
   (char)'6',
   (char)'8',
   (char)'y',
   (char)'b',
   (char)'T',
   (char)'X',
   (char)'f',
   (char)'Q',
   (char)'5',
   (char)'U',
   (char)'9',
   (char)'o',
   (char)'/',
   (char)'Q',
   (char)'K',
   (char)'A',
   (char)'3',
   (char)'d',
   (char)'d',
   (char)'0',
   (char)'t',
   (char)'o',
   (char)'B',
   (char)'E',
   (char)'h',
   (char)'h',
   (char)'d',
   (char)'R',
   (char)'U',
   (char)'D',
   (char)'G',
   (char)'z',
   (char)'W',
   (char)'t',
   (char)'j',
   (char)'v',
   (char)'w',
   (char)'k',
   (char)'E',
   (char)'Q',
   (char)'f',
   (char)'q',
   (char)'F',
   (char)'1',
   (char)'r',
   (char)'e',
   (char)'G',
   (char)'W',
   (char)'j',
   (char)'/',
   (char)'t',
   (char)'o',
   (char)'d',
   (char)'/',
   (char)'g',
   (char)'C',
   (char)'p',
   (char)'f',
   (char)'\r',
   (char)'\n',
   (char)'D',
   (char)'F',
   (char)'i',
   (char)'6',
   (char)'X',
   (char)'0',
   (char)'E',
   (char)'C',
   (char)'g',
   (char)'Y',
   (char)'E',
   (char)'A',
   (char)'4',
   (char)'w',
   (char)'O',
   (char)'v',
   (char)'/',
   (char)'p',
   (char)'j',
   (char)'S',
   (char)'C',
   (char)'3',
   (char)'t',
   (char)'y',
   (char)'6',
   (char)'T',
   (char)'u',
   (char)'O',
   (char)'v',
   (char)'K',
   (char)'X',
   (char)'2',
   (char)'r',
   (char)'O',
   (char)'U',
   (char)'i',
   (char)'B',
   (char)'r',
   (char)'L',
   (char)'X',
   (char)'X',
   (char)'v',
   (char)'2',
   (char)'J',
   (char)'S',
   (char)'x',
   (char)'Z',
   (char)'n',
   (char)'M',
   (char)'o',
   (char)'M',
   (char)'i',
   (char)'W',
   (char)'I',
   (char)'5',
   (char)'i',
   (char)'p',
   (char)'L',
   (char)'Q',
   (char)'t',
   (char)'+',
   (char)'R',
   (char)'Y',
   (char)'T',
   (char)'\r',
   (char)'\n',
   (char)'V',
   (char)'P',
   (char)'a',
   (char)'f',
   (char)'L',
   (char)'/',
   (char)'m',
   (char)'7',
   (char)'D',
   (char)'n',
   (char)'6',
   (char)'M',
   (char)'b',
   (char)'w',
   (char)'j',
   (char)'a',
   (char)'y',
   (char)'O',
   (char)'k',
   (char)'c',
   (char)'Z',
   (char)'h',
   (char)'B',
   (char)'w',
   (char)'k',
   (char)'5',
   (char)'C',
   (char)'N',
   (char)'z',
   (char)'5',
   (char)'A',
   (char)'6',
   (char)'Q',
   (char)'4',
   (char)'l',
   (char)'J',
   (char)'6',
   (char)'4',
   (char)'M',
   (char)'q',
   (char)'/',
   (char)'l',
   (char)'q',
   (char)'H',
   (char)'z',
   (char)'n',
   (char)'R',
   (char)'C',
   (char)'Q',
   (char)'Q',
   (char)'2',
   (char)'M',
   (char)'c',
   (char)'1',
   (char)'G',
   (char)'8',
   (char)'e',
   (char)'y',
   (char)'D',
   (char)'F',
   (char)'/',
   (char)'f',
   (char)'Y',
   (char)'L',
   (char)'\r',
   (char)'\n',
   (char)'Z',
   (char)'e',
   (char)'2',
   (char)'p',
   (char)'L',
   (char)'v',
   (char)'w',
   (char)'P',
   (char)'9',
   (char)'V',
   (char)'D',
   (char)'5',
   (char)'j',
   (char)'T',
   (char)'c',
   (char)'2',
   (char)'m',
   (char)'i',
   (char)'D',
   (char)'f',
   (char)'w',
   (char)'+',
   (char)'M',
   (char)'n',
   (char)'v',
   (char)'J',
   (char)'h',
   (char)'y',
   (char)'w',
   (char)'R',
   (char)'R',
   (char)'L',
   (char)'c',
   (char)'e',
   (char)'m',
   (char)'D',
   (char)'F',
   (char)'P',
   (char)'8',
   (char)'k',
   (char)'4',
   (char)'h',
   (char)'Q',
   (char)'V',
   (char)'t',
   (char)'m',
   (char)'8',
   (char)'P',
   (char)'M',
   (char)'p',
   (char)'3',
   (char)'Z',
   (char)'m',
   (char)'N',
   (char)'E',
   (char)'C',
   (char)'g',
   (char)'Y',
   (char)'E',
   (char)'A',
   (char)'4',
   (char)'g',
   (char)'z',
   (char)'7',
   (char)'\r',
   (char)'\n',
   (char)'w',
   (char)'z',
   (char)'O',
   (char)'b',
   (char)'R',
   (char)'4',
   (char)'g',
   (char)'n',
   (char)'8',
   (char)'i',
   (char)'b',
   (char)'e',
   (char)'6',
   (char)'1',
   (char)'7',
   (char)'u',
   (char)'Q',
   (char)'P',
   (char)'Z',
   (char)'j',
   (char)'W',
   (char)'z',
   (char)'U',
   (char)'j',
   (char)'9',
   (char)'d',
   (char)'U',
   (char)'H',
   (char)'Y',
   (char)'d',
   (char)'+',
   (char)'i',
   (char)'n',
   (char)'1',
   (char)'g',
   (char)'w',
   (char)'B',
   (char)'C',
   (char)'I',
   (char)'r',
   (char)'t',
   (char)'N',
   (char)'n',
   (char)'a',
   (char)'R',
   (char)'n',
   (char)'9',
   (char)'I',
   (char)'9',
   (char)'U',
   (char)'/',
   (char)'Q',
   (char)'6',
   (char)'t',
   (char)'e',
   (char)'g',
   (char)'R',
   (char)'Y',
   (char)'p',
   (char)'i',
   (char)'i',
   (char)'4',
   (char)'y',
   (char)'s',
   (char)'\r',
   (char)'\n',
   (char)'c',
   (char)'1',
   (char)'7',
   (char)'6',
   (char)'N',
   (char)'m',
   (char)'U',
   (char)'+',
   (char)'u',
   (char)'m',
   (char)'y',
   (char)'6',
   (char)'X',
   (char)'m',
   (char)'u',
   (char)'S',
   (char)'K',
   (char)'V',
   (char)'5',
   (char)'q',
   (char)'D',
   (char)'9',
   (char)'b',
   (char)'S',
   (char)'p',
   (char)'Z',
   (char)'W',
   (char)'G',
   (char)'2',
   (char)'n',
   (char)'L',
   (char)'F',
   (char)'n',
   (char)'s',
   (char)'l',
   (char)'r',
   (char)'N',
   (char)'1',
   (char)'5',
   (char)'L',
   (char)'m',
   (char)'3',
   (char)'f',
   (char)'h',
   (char)'Z',
   (char)'x',
   (char)'o',
   (char)'e',
   (char)'M',
   (char)'N',
   (char)'h',
   (char)'B',
   (char)'a',
   (char)'E',
   (char)'D',
   (char)'T',
   (char)'n',
   (char)'L',
   (char)'T',
   (char)'2',
   (char)'6',
   (char)'y',
   (char)'o',
   (char)'i',
   (char)'\r',
   (char)'\n',
   (char)'3',
   (char)'3',
   (char)'g',
   (char)'p',
   (char)'0',
   (char)'m',
   (char)'S',
   (char)'S',
   (char)'W',
   (char)'y',
   (char)'9',
   (char)'4',
   (char)'Z',
   (char)'E',
   (char)'q',
   (char)'i',
   (char)'p',
   (char)'m',
   (char)'s',
   (char)'+',
   (char)'U',
   (char)'L',
   (char)'F',
   (char)'6',
   (char)'s',
   (char)'Y',
   (char)'1',
   (char)'Z',
   (char)'t',
   (char)'F',
   (char)'W',
   (char)'6',
   (char)'t',
   (char)'p',
   (char)'G',
   (char)'F',
   (char)'o',
   (char)'y',
   (char)'8',
   (char)'C',
   (char)'g',
   (char)'Y',
   (char)'A',
   (char)'Q',
   (char)'H',
   (char)'h',
   (char)'n',
   (char)'n',
   (char)'v',
   (char)'J',
   (char)'f',
   (char)'l',
   (char)'I',
   (char)'s',
   (char)'2',
   (char)'k',
   (char)'y',
   (char)'4',
   (char)'q',
   (char)'1',
   (char)'0',
   (char)'B',
   (char)'6',
   (char)'0',
   (char)'\r',
   (char)'\n',
   (char)'Z',
   (char)'c',
   (char)'x',
   (char)'F',
   (char)'p',
   (char)'3',
   (char)'r',
   (char)'t',
   (char)'D',
   (char)'p',
   (char)'k',
   (char)'p',
   (char)'0',
   (char)'J',
   (char)'x',
   (char)'h',
   (char)'F',
   (char)'L',
   (char)'h',
   (char)'i',
   (char)'i',
   (char)'z',
   (char)'F',
   (char)'r',
   (char)'u',
   (char)'j',
   (char)'M',
   (char)'t',
   (char)'Z',
   (char)'S',
   (char)'j',
   (char)'Y',
   (char)'N',
   (char)'m',
   (char)'5',
   (char)'U',
   (char)'7',
   (char)'K',
   (char)'k',
   (char)'g',
   (char)'P',
   (char)'V',
   (char)'H',
   (char)'h',
   (char)'L',
   (char)'E',
   (char)'L',
   (char)'E',
   (char)'U',
   (char)'v',
   (char)'C',
   (char)'m',
   (char)'O',
   (char)'n',
   (char)'K',
   (char)'T',
   (char)'t',
   (char)'4',
   (char)'a',
   (char)'p',
   (char)'/',
   (char)'v',
   (char)'Z',
   (char)'0',
   (char)'\r',
   (char)'\n',
   (char)'B',
   (char)'x',
   (char)'J',
   (char)'N',
   (char)'e',
   (char)'1',
   (char)'G',
   (char)'Z',
   (char)'H',
   (char)'3',
   (char)'p',
   (char)'W',
   (char)'6',
   (char)'S',
   (char)'A',
   (char)'v',
   (char)'G',
   (char)'D',
   (char)'Q',
   (char)'p',
   (char)'l',
   (char)'9',
   (char)'s',
   (char)'G',
   (char)'7',
   (char)'u',
   (char)'u',
   (char)'/',
   (char)'v',
   (char)'T',
   (char)'F',
   (char)'P',
   (char)'+',
   (char)'l',
   (char)'C',
   (char)'x',
   (char)'u',
   (char)'k',
   (char)'m',
   (char)'z',
   (char)'x',
   (char)'B',
   (char)'0',
   (char)'D',
   (char)'r',
   (char)'r',
   (char)'D',
   (char)'c',
   (char)'v',
   (char)'o',
   (char)'r',
   (char)'E',
   (char)'k',
   (char)'K',
   (char)'M',
   (char)'o',
   (char)'m',
   (char)'7',
   (char)'Z',
   (char)'C',
   (char)'C',
   (char)'R',
   (char)'v',
   (char)'W',
   (char)'\r',
   (char)'\n',
   (char)'K',
   (char)'Z',
   (char)'s',
   (char)'Z',
   (char)'6',
   (char)'Y',
   (char)'e',
   (char)'H',
   (char)'2',
   (char)'Z',
   (char)'8',
   (char)'1',
   (char)'B',
   (char)'a',
   (char)'u',
   (char)'R',
   (char)'j',
   (char)'2',
   (char)'1',
   (char)'8',
   (char)'k',
   (char)'Q',
   (char)'K',
   (char)'B',
   (char)'g',
   (char)'Q',
   (char)'C',
   (char)'U',
   (char)'V',
   (char)'/',
   (char)'D',
   (char)'g',
   (char)'K',
   (char)'P',
   (char)'2',
   (char)'9',
   (char)'8',
   (char)'5',
   (char)'x',
   (char)'D',
   (char)'T',
   (char)'T',
   (char)'7',
   (char)'9',
   (char)'N',
   (char)'0',
   (char)'8',
   (char)'j',
   (char)'U',
   (char)'o',
   (char)'3',
   (char)'h',
   (char)'T',
   (char)'P',
   (char)'5',
   (char)'M',
   (char)'V',
   (char)'Y',
   (char)'C',
   (char)'C',
   (char)'u',
   (char)'j',
   (char)'/',
   (char)'+',
   (char)'\r',
   (char)'\n',
   (char)'U',
   (char)'e',
   (char)'E',
   (char)'w',
   (char)'1',
   (char)'T',
   (char)'v',
   (char)'Z',
   (char)'c',
   (char)'x',
   (char)'3',
   (char)'L',
   (char)'J',
   (char)'b',
   (char)'y',
   (char)'7',
   (char)'P',
   (char)'6',
   (char)'X',
   (char)'a',
   (char)'d',
   (char)'6',
   (char)'a',
   (char)'1',
   (char)'/',
   (char)'B',
   (char)'q',
   (char)'v',
   (char)'e',
   (char)'a',
   (char)'G',
   (char)'y',
   (char)'F',
   (char)'K',
   (char)'I',
   (char)'f',
   (char)'E',
   (char)'F',
   (char)'I',
   (char)'a',
   (char)'B',
   (char)'U',
   (char)'B',
   (char)'I',
   (char)'t',
   (char)'k',
   (char)'8',
   (char)'0',
   (char)'1',
   (char)'s',
   (char)'D',
   (char)'D',
   (char)'p',
   (char)'D',
   (char)'a',
   (char)'Y',
   (char)'c',
   (char)'4',
   (char)'g',
   (char)'L',
   (char)'0',
   (char)'0',
   (char)'X',
   (char)'c',
   (char)'\r',
   (char)'\n',
   (char)'7',
   (char)'l',
   (char)'F',
   (char)'u',
   (char)'B',
   (char)'H',
   (char)'O',
   (char)'Z',
   (char)'k',
   (char)'x',
   (char)'J',
   (char)'Y',
   (char)'l',
   (char)'s',
   (char)'s',
   (char)'5',
   (char)'Q',
   (char)'r',
   (char)'G',
   (char)'p',
   (char)'u',
   (char)'O',
   (char)'E',
   (char)'l',
   (char)'9',
   (char)'Z',
   (char)'w',
   (char)'U',
   (char)'t',
   (char)'5',
   (char)'I',
   (char)'r',
   (char)'F',
   (char)'L',
   (char)'B',
   (char)'d',
   (char)'Y',
   (char)'a',
   (char)'K',
   (char)'q',
   (char)'N',
   (char)'H',
   (char)'z',
   (char)'N',
   (char)'V',
   (char)'C',
   (char)'1',
   (char)'p',
   (char)'C',
   (char)'P',
   (char)'f',
   (char)'b',
   (char)'/',
   (char)'J',
   (char)'y',
   (char)'H',
   (char)'6',
   (char)'D',
   (char)'r',
   (char)'2',
   (char)'H',
   (char)'U',
   (char)'x',
   (char)'q',
   (char)'\r',
   (char)'\n',
   (char)'g',
   (char)'x',
   (char)'U',
   (char)'w',
   (char)'A',
   (char)'Q',
   (char)'K',
   (char)'B',
   (char)'g',
   (char)'Q',
   (char)'C',
   (char)'c',
   (char)'U',
   (char)'6',
   (char)'G',
   (char)'2',
   (char)'L',
   (char)'8',
   (char)'A',
   (char)'G',
   (char)'9',
   (char)'d',
   (char)'9',
   (char)'c',
   (char)'0',
   (char)'U',
   (char)'p',
   (char)'O',
   (char)'y',
   (char)'L',
   (char)'1',
   (char)'t',
   (char)'M',
   (char)'v',
   (char)'F',
   (char)'e',
   (char)'5',
   (char)'T',
   (char)'t',
   (char)'w',
   (char)'0',
   (char)'K',
   (char)'j',
   (char)'l',
   (char)'Q',
   (char)'V',
   (char)'d',
   (char)'s',
   (char)'h',
   (char)'1',
   (char)'M',
   (char)'P',
   (char)'6',
   (char)'y',
   (char)'i',
   (char)'g',
   (char)'Y',
   (char)'o',
   (char)'9',
   (char)'D',
   (char)'Y',
   (char)'u',
   (char)'w',
   (char)'u',
   (char)'\r',
   (char)'\n',
   (char)'b',
   (char)'H',
   (char)'F',
   (char)'V',
   (char)'W',
   (char)'2',
   (char)'r',
   (char)'0',
   (char)'d',
   (char)'B',
   (char)'T',
   (char)'q',
   (char)'e',
   (char)'g',
   (char)'P',
   (char)'2',
   (char)'/',
   (char)'K',
   (char)'T',
   (char)'O',
   (char)'x',
   (char)'K',
   (char)'z',
   (char)'a',
   (char)'H',
   (char)'f',
   (char)'C',
   (char)'1',
   (char)'q',
   (char)'f',
   (char)'0',
   (char)'R',
   (char)'G',
   (char)'D',
   (char)'s',
   (char)'U',
   (char)'o',
   (char)'J',
   (char)'C',
   (char)'N',
   (char)'J',
   (char)'r',
   (char)'d',
   (char)'1',
   (char)'c',
   (char)'w',
   (char)'o',
   (char)'C',
   (char)'L',
   (char)'G',
   (char)'8',
   (char)'P',
   (char)'2',
   (char)'E',
   (char)'F',
   (char)'4',
   (char)'w',
   (char)'3',
   (char)'O',
   (char)'B',
   (char)'r',
   (char)'K',
   (char)'q',
   (char)'v',
   (char)'\r',
   (char)'\n',
   (char)'8',
   (char)'u',
   (char)'4',
   (char)'y',
   (char)'t',
   (char)'Y',
   (char)'0',
   (char)'F',
   (char)'+',
   (char)'V',
   (char)'l',
   (char)'a',
   (char)'n',
   (char)'j',
   (char)'5',
   (char)'l',
   (char)'m',
   (char)'3',
   (char)'T',
   (char)'a',
   (char)'o',
   (char)'H',
   (char)'S',
   (char)'V',
   (char)'F',
   (char)'1',
   (char)'+',
   (char)'N',
   (char)'W',
   (char)'P',
   (char)'y',
   (char)'O',
   (char)'T',
   (char)'i',
   (char)'w',
   (char)'e',
   (char)'v',
   (char)'I',
   (char)'E',
   (char)'C',
   (char)'G',
   (char)'K',
   (char)'w',
   (char)'S',
   (char)'x',
   (char)'v',
   (char)'l',
   (char)'k',
   (char)'i',
   (char)'4',
   (char)'f',
   (char)'D',
   (char)'A',
   (char)'A',
   (char)'=',
   (char)'=',
   (char)'\r',
   (char)'\n',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'E',
   (char)'N',
   (char)'D',
   (char)' ',
   (char)'R',
   (char)'S',
   (char)'A',
   (char)' ',
   (char)'P',
   (char)'R',
   (char)'I',
   (char)'V',
   (char)'A',
   (char)'T',
   (char)'E',
   (char)' ',
   (char)'K',
   (char)'E',
   (char)'Y',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'\r',
   (char)'\n',
   (char)'\000'};
char const test_dhm_params[251] =
  {(char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'B',
   (char)'E',
   (char)'G',
   (char)'I',
   (char)'N',
   (char)' ',
   (char)'D',
   (char)'H',
   (char)' ',
   (char)'P',
   (char)'A',
   (char)'R',
   (char)'A',
   (char)'M',
   (char)'E',
   (char)'T',
   (char)'E',
   (char)'R',
   (char)'S',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'\r',
   (char)'\n',
   (char)'M',
   (char)'I',
   (char)'G',
   (char)'H',
   (char)'A',
   (char)'o',
   (char)'G',
   (char)'B',
   (char)'A',
   (char)'J',
   (char)'4',
   (char)'1',
   (char)'9',
   (char)'D',
   (char)'B',
   (char)'E',
   (char)'O',
   (char)'g',
   (char)'m',
   (char)'Q',
   (char)'T',
   (char)'z',
   (char)'o',
   (char)'5',
   (char)'q',
   (char)'X',
   (char)'l',
   (char)'5',
   (char)'f',
   (char)'Q',
   (char)'c',
   (char)'N',
   (char)'9',
   (char)'T',
   (char)'N',
   (char)'4',
   (char)'5',
   (char)'5',
   (char)'w',
   (char)'k',
   (char)'O',
   (char)'L',
   (char)'7',
   (char)'0',
   (char)'5',
   (char)'2',
   (char)'H',
   (char)'z',
   (char)'x',
   (char)'x',
   (char)'R',
   (char)'V',
   (char)'M',
   (char)'y',
   (char)'h',
   (char)'Y',
   (char)'m',
   (char)'w',
   (char)'Q',
   (char)'c',
   (char)'g',
   (char)'J',
   (char)'v',
   (char)'h',
   (char)'\r',
   (char)'\n',
   (char)'1',
   (char)'s',
   (char)'a',
   (char)'1',
   (char)'8',
   (char)'f',
   (char)'y',
   (char)'f',
   (char)'R',
   (char)'9',
   (char)'O',
   (char)'i',
   (char)'V',
   (char)'E',
   (char)'M',
   (char)'Y',
   (char)'g',
   (char)'l',
   (char)'O',
   (char)'p',
   (char)'k',
   (char)'q',
   (char)'V',
   (char)'o',
   (char)'G',
   (char)'L',
   (char)'N',
   (char)'7',
   (char)'q',
   (char)'d',
   (char)'5',
   (char)'a',
   (char)'Q',
   (char)'N',
   (char)'N',
   (char)'i',
   (char)'5',
   (char)'W',
   (char)'7',
   (char)'/',
   (char)'C',
   (char)'+',
   (char)'V',
   (char)'B',
   (char)'d',
   (char)'H',
   (char)'T',
   (char)'B',
   (char)'J',
   (char)'c',
   (char)'G',
   (char)'Z',
   (char)'J',
   (char)'y',
   (char)'y',
   (char)'P',
   (char)'5',
   (char)'B',
   (char)'3',
   (char)'q',
   (char)'c',
   (char)'z',
   (char)'3',
   (char)'2',
   (char)'\r',
   (char)'\n',
   (char)'9',
   (char)'m',
   (char)'L',
   (char)'J',
   (char)'K',
   (char)'u',
   (char)'d',
   (char)'l',
   (char)'V',
   (char)'u',
   (char)'d',
   (char)'V',
   (char)'0',
   (char)'Q',
   (char)'x',
   (char)'k',
   (char)'5',
   (char)'q',
   (char)'U',
   (char)'J',
   (char)'a',
   (char)'P',
   (char)'Z',
   (char)'/',
   (char)'x',
   (char)'u',
   (char)'p',
   (char)'z',
   (char)'0',
   (char)'N',
   (char)'y',
   (char)'o',
   (char)'V',
   (char)'p',
   (char)'v',
   (char)'i',
   (char)'u',
   (char)'i',
   (char)'B',
   (char)'O',
   (char)'I',
   (char)'1',
   (char)'g',
   (char)'N',
   (char)'i',
   (char)'8',
   (char)'o',
   (char)'v',
   (char)'S',
   (char)'X',
   (char)'W',
   (char)'z',
   (char)'A',
   (char)'g',
   (char)'E',
   (char)'C',
   (char)'\r',
   (char)'\n',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'E',
   (char)'N',
   (char)'D',
   (char)' ',
   (char)'D',
   (char)'H',
   (char)' ',
   (char)'P',
   (char)'A',
   (char)'R',
   (char)'A',
   (char)'M',
   (char)'E',
   (char)'T',
   (char)'E',
   (char)'R',
   (char)'S',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'-',
   (char)'\r',
   (char)'\n',
   (char)'\000'};
int const *cipher_list(void);

cipher_info_t const *cipher_info_from_string(char const *cipher_name);

cipher_info_t const *cipher_info_from_type(cipher_type_t const cipher_type);

int cipher_init_ctx(cipher_context_t *ctx, cipher_info_t const *cipher_info);

int cipher_free_ctx(cipher_context_t *ctx);

__inline static unsigned int cipher_get_block_size(cipher_context_t const *ctx)
{
  unsigned int __retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = (unsigned int)0;
    goto return_label;
  }
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) {
      __retres = (unsigned int)0;
      goto return_label;
    }
  __retres = (ctx->cipher_info)->block_size;
  return_label: return __retres;
}

__inline static cipher_mode_t cipher_get_cipher_mode(cipher_context_t const *ctx)
{
  cipher_mode_t __retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = POLARSSL_MODE_NONE;
    goto return_label;
  }
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) {
      __retres = POLARSSL_MODE_NONE;
      goto return_label;
    }
  __retres = (ctx->cipher_info)->mode;
  return_label: return __retres;
}

__inline static int cipher_get_iv_size(cipher_context_t const *ctx)
{
  int __retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = 0;
    goto return_label;
  }
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) {
      __retres = 0;
      goto return_label;
    }
  __retres = (int)(ctx->cipher_info)->iv_size;
  return_label: return __retres;
}

__inline static cipher_type_t cipher_get_type(cipher_context_t const *ctx)
{
  cipher_type_t __retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = (cipher_type_t)0;
    goto return_label;
  }
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) {
      __retres = (cipher_type_t)0;
      goto return_label;
    }
  __retres = (ctx->cipher_info)->type;
  return_label: return __retres;
}

__inline static char const *cipher_get_name(cipher_context_t const *ctx)
{
  char const *__retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = (char const *)0;
    goto return_label;
  }
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) {
      __retres = (char const *)0;
      goto return_label;
    }
  __retres = (ctx->cipher_info)->name;
  return_label: return __retres;
}

__inline static int cipher_get_key_size(cipher_context_t const *ctx)
{
  int __retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = POLARSSL_KEY_LENGTH_NONE;
    goto return_label;
  }
  __retres = ctx->key_length;
  return_label: return __retres;
}

__inline static operation_t cipher_get_operation(cipher_context_t const *ctx)
{
  operation_t __retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = POLARSSL_OPERATION_NONE;
    goto return_label;
  }
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) {
      __retres = POLARSSL_OPERATION_NONE;
      goto return_label;
    }
  __retres = ctx->operation;
  return_label: return __retres;
}

int cipher_setkey(cipher_context_t *ctx, unsigned char const *key,
                  int key_length, operation_t const operation);

int cipher_reset(cipher_context_t *ctx, unsigned char const *iv);

int cipher_update(cipher_context_t *ctx, unsigned char const *input,
                  size_t ilen, unsigned char *output, size_t *olen);

int cipher_finish(cipher_context_t *ctx, unsigned char *output, size_t *olen);

int cipher_self_test(int verbose);

cipher_info_t const aes_128_cbc_info;

cipher_info_t const aes_192_cbc_info;

cipher_info_t const aes_256_cbc_info;

cipher_info_t const aes_128_cfb128_info;

cipher_info_t const aes_192_cfb128_info;

cipher_info_t const aes_256_cfb128_info;

cipher_info_t const aes_128_ctr_info;

cipher_info_t const aes_192_ctr_info;

cipher_info_t const aes_256_ctr_info;

cipher_info_t const camellia_128_cbc_info;

cipher_info_t const camellia_192_cbc_info;

cipher_info_t const camellia_256_cbc_info;

cipher_info_t const camellia_128_cfb128_info;

cipher_info_t const camellia_192_cfb128_info;

cipher_info_t const camellia_256_cfb128_info;

cipher_info_t const camellia_128_ctr_info;

cipher_info_t const camellia_192_ctr_info;

cipher_info_t const camellia_256_ctr_info;

cipher_info_t const des_cbc_info;

cipher_info_t const des_ede_cbc_info;

cipher_info_t const des_ede3_cbc_info;

static int const supported_ciphers[22] =
  {POLARSSL_CIPHER_AES_128_CBC,
   POLARSSL_CIPHER_AES_192_CBC,
   POLARSSL_CIPHER_AES_256_CBC,
   POLARSSL_CIPHER_AES_128_CFB128,
   POLARSSL_CIPHER_AES_192_CFB128,
   POLARSSL_CIPHER_AES_256_CFB128,
   POLARSSL_CIPHER_AES_128_CTR,
   POLARSSL_CIPHER_AES_192_CTR,
   POLARSSL_CIPHER_AES_256_CTR,
   POLARSSL_CIPHER_CAMELLIA_128_CBC,
   POLARSSL_CIPHER_CAMELLIA_192_CBC,
   POLARSSL_CIPHER_CAMELLIA_256_CBC,
   POLARSSL_CIPHER_CAMELLIA_128_CFB128,
   POLARSSL_CIPHER_CAMELLIA_192_CFB128,
   POLARSSL_CIPHER_CAMELLIA_256_CFB128,
   POLARSSL_CIPHER_CAMELLIA_128_CTR,
   POLARSSL_CIPHER_CAMELLIA_192_CTR,
   POLARSSL_CIPHER_CAMELLIA_256_CTR,
   POLARSSL_CIPHER_DES_CBC,
   POLARSSL_CIPHER_DES_EDE_CBC,
   POLARSSL_CIPHER_DES_EDE3_CBC,
   0};
int const *cipher_list(void)
{
  int const *__retres;
  __retres = supported_ciphers;
  return __retres;
}

cipher_info_t const *cipher_info_from_type(cipher_type_t const cipher_type)
{
  cipher_info_t const *__retres;
  switch (cipher_type) {
    case POLARSSL_CIPHER_AES_128_CBC: __retres = & aes_128_cbc_info;
    goto return_label;
    case POLARSSL_CIPHER_AES_192_CBC: __retres = & aes_192_cbc_info;
    goto return_label;
    case POLARSSL_CIPHER_AES_256_CBC: __retres = & aes_256_cbc_info;
    goto return_label;
    case POLARSSL_CIPHER_AES_128_CFB128: __retres = & aes_128_cfb128_info;
    goto return_label;
    case POLARSSL_CIPHER_AES_192_CFB128: __retres = & aes_192_cfb128_info;
    goto return_label;
    case POLARSSL_CIPHER_AES_256_CFB128: __retres = & aes_256_cfb128_info;
    goto return_label;
    case POLARSSL_CIPHER_AES_128_CTR: __retres = & aes_128_ctr_info;
    goto return_label;
    case POLARSSL_CIPHER_AES_192_CTR: __retres = & aes_192_ctr_info;
    goto return_label;
    case POLARSSL_CIPHER_AES_256_CTR: __retres = & aes_256_ctr_info;
    goto return_label;
    case POLARSSL_CIPHER_CAMELLIA_128_CBC:
    __retres = & camellia_128_cbc_info;
    goto return_label;
    case POLARSSL_CIPHER_CAMELLIA_192_CBC:
    __retres = & camellia_192_cbc_info;
    goto return_label;
    case POLARSSL_CIPHER_CAMELLIA_256_CBC:
    __retres = & camellia_256_cbc_info;
    goto return_label;
    case POLARSSL_CIPHER_CAMELLIA_128_CFB128:
    __retres = & camellia_128_cfb128_info;
    goto return_label;
    case POLARSSL_CIPHER_CAMELLIA_192_CFB128:
    __retres = & camellia_192_cfb128_info;
    goto return_label;
    case POLARSSL_CIPHER_CAMELLIA_256_CFB128:
    __retres = & camellia_256_cfb128_info;
    goto return_label;
    case POLARSSL_CIPHER_CAMELLIA_128_CTR:
    __retres = & camellia_128_ctr_info;
    goto return_label;
    case POLARSSL_CIPHER_CAMELLIA_192_CTR:
    __retres = & camellia_192_ctr_info;
    goto return_label;
    case POLARSSL_CIPHER_CAMELLIA_256_CTR:
    __retres = & camellia_256_ctr_info;
    goto return_label;
    case POLARSSL_CIPHER_DES_CBC: __retres = & des_cbc_info;
    goto return_label;
    case POLARSSL_CIPHER_DES_EDE_CBC: __retres = & des_ede_cbc_info;
    goto return_label;
    case POLARSSL_CIPHER_DES_EDE3_CBC: __retres = & des_ede3_cbc_info;
    goto return_label;
    default: __retres = (cipher_info_t const *)0;
    goto return_label;
  }
  return_label: return __retres;
}

cipher_info_t const *cipher_info_from_string(char const *cipher_name)
{
  cipher_info_t const *__retres;
  int tmp_0;
  int tmp_2;
  int tmp_4;
  int tmp_6;
  int tmp_8;
  int tmp_10;
  int tmp_12;
  int tmp_14;
  int tmp_16;
  int tmp_18;
  int tmp_20;
  int tmp_22;
  int tmp_24;
  int tmp_26;
  int tmp_28;
  int tmp_30;
  int tmp_32;
  int tmp_34;
  int tmp_36;
  int tmp_38;
  int tmp_40;
  if ((char const *)0 == cipher_name) {
    __retres = (cipher_info_t const *)0;
    goto return_label;
  }
  tmp_0 = strcasecmp("CAMELLIA-128-CBC",cipher_name);
  if (! tmp_0) {
    cipher_info_t const *tmp;
    tmp = cipher_info_from_type(POLARSSL_CIPHER_CAMELLIA_128_CBC);
    __retres = tmp;
    goto return_label;
  }
  tmp_2 = strcasecmp("CAMELLIA-192-CBC",cipher_name);
  if (! tmp_2) {
    cipher_info_t const *tmp_1;
    tmp_1 = cipher_info_from_type(POLARSSL_CIPHER_CAMELLIA_192_CBC);
    __retres = tmp_1;
    goto return_label;
  }
  tmp_4 = strcasecmp("CAMELLIA-256-CBC",cipher_name);
  if (! tmp_4) {
    cipher_info_t const *tmp_3;
    tmp_3 = cipher_info_from_type(POLARSSL_CIPHER_CAMELLIA_256_CBC);
    __retres = tmp_3;
    goto return_label;
  }
  tmp_6 = strcasecmp("CAMELLIA-128-CFB128",cipher_name);
  if (! tmp_6) {
    cipher_info_t const *tmp_5;
    tmp_5 = cipher_info_from_type(POLARSSL_CIPHER_CAMELLIA_128_CFB128);
    __retres = tmp_5;
    goto return_label;
  }
  tmp_8 = strcasecmp("CAMELLIA-192-CFB128",cipher_name);
  if (! tmp_8) {
    cipher_info_t const *tmp_7;
    tmp_7 = cipher_info_from_type(POLARSSL_CIPHER_CAMELLIA_192_CFB128);
    __retres = tmp_7;
    goto return_label;
  }
  tmp_10 = strcasecmp("CAMELLIA-256-CFB128",cipher_name);
  if (! tmp_10) {
    cipher_info_t const *tmp_9;
    tmp_9 = cipher_info_from_type(POLARSSL_CIPHER_CAMELLIA_256_CFB128);
    __retres = tmp_9;
    goto return_label;
  }
  tmp_12 = strcasecmp("CAMELLIA-128-CTR",cipher_name);
  if (! tmp_12) {
    cipher_info_t const *tmp_11;
    tmp_11 = cipher_info_from_type(POLARSSL_CIPHER_CAMELLIA_128_CTR);
    __retres = tmp_11;
    goto return_label;
  }
  tmp_14 = strcasecmp("CAMELLIA-192-CTR",cipher_name);
  if (! tmp_14) {
    cipher_info_t const *tmp_13;
    tmp_13 = cipher_info_from_type(POLARSSL_CIPHER_CAMELLIA_192_CTR);
    __retres = tmp_13;
    goto return_label;
  }
  tmp_16 = strcasecmp("CAMELLIA-256-CTR",cipher_name);
  if (! tmp_16) {
    cipher_info_t const *tmp_15;
    tmp_15 = cipher_info_from_type(POLARSSL_CIPHER_CAMELLIA_256_CTR);
    __retres = tmp_15;
    goto return_label;
  }
  tmp_18 = strcasecmp("AES-128-CBC",cipher_name);
  if (! tmp_18) {
    cipher_info_t const *tmp_17;
    tmp_17 = cipher_info_from_type(POLARSSL_CIPHER_AES_128_CBC);
    __retres = tmp_17;
    goto return_label;
  }
  tmp_20 = strcasecmp("AES-192-CBC",cipher_name);
  if (! tmp_20) {
    cipher_info_t const *tmp_19;
    tmp_19 = cipher_info_from_type(POLARSSL_CIPHER_AES_192_CBC);
    __retres = tmp_19;
    goto return_label;
  }
  tmp_22 = strcasecmp("AES-256-CBC",cipher_name);
  if (! tmp_22) {
    cipher_info_t const *tmp_21;
    tmp_21 = cipher_info_from_type(POLARSSL_CIPHER_AES_256_CBC);
    __retres = tmp_21;
    goto return_label;
  }
  tmp_24 = strcasecmp("AES-128-CFB128",cipher_name);
  if (! tmp_24) {
    cipher_info_t const *tmp_23;
    tmp_23 = cipher_info_from_type(POLARSSL_CIPHER_AES_128_CFB128);
    __retres = tmp_23;
    goto return_label;
  }
  tmp_26 = strcasecmp("AES-192-CFB128",cipher_name);
  if (! tmp_26) {
    cipher_info_t const *tmp_25;
    tmp_25 = cipher_info_from_type(POLARSSL_CIPHER_AES_192_CFB128);
    __retres = tmp_25;
    goto return_label;
  }
  tmp_28 = strcasecmp("AES-256-CFB128",cipher_name);
  if (! tmp_28) {
    cipher_info_t const *tmp_27;
    tmp_27 = cipher_info_from_type(POLARSSL_CIPHER_AES_256_CFB128);
    __retres = tmp_27;
    goto return_label;
  }
  tmp_30 = strcasecmp("AES-128-CTR",cipher_name);
  if (! tmp_30) {
    cipher_info_t const *tmp_29;
    tmp_29 = cipher_info_from_type(POLARSSL_CIPHER_AES_128_CTR);
    __retres = tmp_29;
    goto return_label;
  }
  tmp_32 = strcasecmp("AES-192-CTR",cipher_name);
  if (! tmp_32) {
    cipher_info_t const *tmp_31;
    tmp_31 = cipher_info_from_type(POLARSSL_CIPHER_AES_192_CTR);
    __retres = tmp_31;
    goto return_label;
  }
  tmp_34 = strcasecmp("AES-256-CTR",cipher_name);
  if (! tmp_34) {
    cipher_info_t const *tmp_33;
    tmp_33 = cipher_info_from_type(POLARSSL_CIPHER_AES_256_CTR);
    __retres = tmp_33;
    goto return_label;
  }
  tmp_36 = strcasecmp("DES-CBC",cipher_name);
  if (! tmp_36) {
    cipher_info_t const *tmp_35;
    tmp_35 = cipher_info_from_type(POLARSSL_CIPHER_DES_CBC);
    __retres = tmp_35;
    goto return_label;
  }
  tmp_38 = strcasecmp("DES-EDE-CBC",cipher_name);
  if (! tmp_38) {
    cipher_info_t const *tmp_37;
    tmp_37 = cipher_info_from_type(POLARSSL_CIPHER_DES_EDE_CBC);
    __retres = tmp_37;
    goto return_label;
  }
  tmp_40 = strcasecmp("DES-EDE3-CBC",cipher_name);
  if (! tmp_40) {
    cipher_info_t const *tmp_39;
    tmp_39 = cipher_info_from_type(POLARSSL_CIPHER_DES_EDE3_CBC);
    __retres = tmp_39;
    goto return_label;
  }
  __retres = (cipher_info_t const *)0;
  return_label: return __retres;
}

int cipher_init_ctx(cipher_context_t *ctx, cipher_info_t const *cipher_info)
{
  int __retres;
  void *tmp;
  if ((cipher_info_t const *)0 == cipher_info) {
    __retres = -0x6100;
    goto return_label;
  }
  else 
    if ((cipher_context_t *)0 == ctx) {
      __retres = -0x6100;
      goto return_label;
    }
  memset((void *)ctx,0,sizeof(cipher_context_t));
  tmp = (*((cipher_info->base)->ctx_alloc_func))();
  ctx->cipher_ctx = tmp;
  if ((void *)0 == tmp) {
    __retres = -0x6180;
    goto return_label;
  }
  ctx->cipher_info = cipher_info;
  __retres = 0;
  return_label: return __retres;
}

int cipher_free_ctx(cipher_context_t *ctx)
{
  int __retres;
  if (ctx == (cipher_context_t *)0) {
    __retres = -0x6100;
    goto return_label;
  }
  else 
    if (ctx->cipher_info == (cipher_info_t const *)0) {
      __retres = -0x6100;
      goto return_label;
    }
  (*(((ctx->cipher_info)->base)->ctx_free_func))(ctx->cipher_ctx);
  __retres = 0;
  return_label: return __retres;
}

int cipher_setkey(cipher_context_t *ctx, unsigned char const *key,
                  int key_length, operation_t const operation)
{
  int __retres;
  if ((cipher_context_t *)0 == ctx) {
    __retres = -0x6100;
    goto return_label;
  }
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) {
      __retres = -0x6100;
      goto return_label;
    }
  ctx->key_length = key_length;
  ctx->operation = operation;
  if (POLARSSL_ENCRYPT == operation) goto _LOR;
  else 
    if ((unsigned int)POLARSSL_MODE_CFB128 == (ctx->cipher_info)->mode) 
      goto _LOR;
    else 
      if ((unsigned int)POLARSSL_MODE_CTR == (ctx->cipher_info)->mode) {
        _LOR:
        {
          int tmp;
          tmp = (*(((ctx->cipher_info)->base)->setkey_enc_func))(ctx->cipher_ctx,
                                                                 key,
                                                                 (unsigned int)ctx->key_length);
          __retres = tmp;
          goto return_label;
        }
      }
  if (POLARSSL_DECRYPT == operation) {
    int tmp_0;
    tmp_0 = (*(((ctx->cipher_info)->base)->setkey_dec_func))(ctx->cipher_ctx,
                                                             key,
                                                             (unsigned int)ctx->key_length);
    __retres = tmp_0;
    goto return_label;
  }
  __retres = -0x6100;
  return_label: return __retres;
}

int cipher_reset(cipher_context_t *ctx, unsigned char const *iv)
{
  int __retres;
  int tmp;
  if ((cipher_context_t *)0 == ctx) {
    __retres = -0x6100;
    goto return_label;
  }
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) {
      __retres = -0x6100;
      goto return_label;
    }
    else 
      if ((unsigned char const *)0 == iv) {
        __retres = -0x6100;
        goto return_label;
      }
  ctx->unprocessed_len = (size_t)0;
  tmp = cipher_get_iv_size((cipher_context_t const *)ctx);
  ;
  ;
  memcpy((void *)(ctx->iv),(void const *)iv,(size_t)tmp);
  __retres = 0;
  return_label: return __retres;
}

int cipher_update(cipher_context_t *ctx, unsigned char const *input,
                  size_t ilen, unsigned char *output, size_t *olen)
{
  int __retres;
  int ret;
  size_t copy_len = (size_t)0;
  if ((cipher_context_t *)0 == ctx) goto _LOR;
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) goto _LOR;
    else 
      if ((size_t *)0 == olen) goto _LOR;
      else 
        if ((void *)input == (void *)output) {
          _LOR: {
                  __retres = -0x6100;
                  goto return_label;
                }
        }
  *olen = (size_t)0;
  if ((ctx->cipher_info)->mode == (unsigned int)POLARSSL_MODE_CBC) {
    if (ctx->operation == POLARSSL_DECRYPT) {
      unsigned int tmp;
      tmp = cipher_get_block_size((cipher_context_t const *)ctx);
      ;
      if (ilen + ctx->unprocessed_len <= tmp) goto _LOR_0; else goto _LAND;
    }
    else {
      _LAND: ;
      if (ctx->operation == POLARSSL_ENCRYPT) {
        unsigned int tmp_0;
        tmp_0 = cipher_get_block_size((cipher_context_t const *)ctx);
        ;
        if (ilen + ctx->unprocessed_len < tmp_0) {
          _LOR_0:
          {
            memcpy((void *)(& ctx->unprocessed_data[ctx->unprocessed_len]),
                   (void const *)input,ilen);
            ctx->unprocessed_len += ilen;
            __retres = 0;
            goto return_label;
          }
        }
      }
    }
    if (ctx->unprocessed_len != (size_t)0) {
      unsigned int tmp_1;
      unsigned int tmp_2;
      unsigned int tmp_3;
      unsigned int tmp_4;
      tmp_1 = cipher_get_block_size((cipher_context_t const *)ctx);
      copy_len = tmp_1 - ctx->unprocessed_len;
      memcpy((void *)(& ctx->unprocessed_data[ctx->unprocessed_len]),
             (void const *)input,copy_len);
      ;
      ;
      ;
      tmp_2 = cipher_get_block_size((cipher_context_t const *)ctx);
      ;
      ;
      ret = (*(((ctx->cipher_info)->base)->cbc_func))(ctx->cipher_ctx,
                                                      ctx->operation,tmp_2,
                                                      ctx->iv,
                                                      (unsigned char const *)(ctx->unprocessed_data),
                                                      output);
      if (0 != ret) {
        __retres = ret;
        goto return_label;
      }
      tmp_3 = cipher_get_block_size((cipher_context_t const *)ctx);
      *olen += tmp_3;
      tmp_4 = cipher_get_block_size((cipher_context_t const *)ctx);
      output += tmp_4;
      ctx->unprocessed_len = (size_t)0;
      input += copy_len;
      ilen -= copy_len;
    }
    if ((size_t)0 != ilen) {
      unsigned int tmp_5;
      tmp_5 = cipher_get_block_size((cipher_context_t const *)ctx);
      copy_len = ilen % tmp_5;
      if (copy_len == (size_t)0) 
        if (ctx->operation == POLARSSL_DECRYPT) copy_len = cipher_get_block_size
                                                ((cipher_context_t const *)ctx);
      memcpy((void *)(ctx->unprocessed_data),
             (void const *)(input + (ilen - copy_len)),copy_len);
      ctx->unprocessed_len += copy_len;
      ilen -= copy_len;
    }
    if (ilen) {
      ret = (*(((ctx->cipher_info)->base)->cbc_func))(ctx->cipher_ctx,
                                                      ctx->operation,ilen,
                                                      ctx->iv,input,output);
      if (0 != ret) {
        __retres = ret;
        goto return_label;
      }
      *olen += ilen;
    }
    __retres = 0;
    goto return_label;
  }
  if ((ctx->cipher_info)->mode == (unsigned int)POLARSSL_MODE_CFB128) {
    ret = (*(((ctx->cipher_info)->base)->cfb128_func))(ctx->cipher_ctx,
                                                       ctx->operation,ilen,
                                                       & ctx->unprocessed_len,
                                                       ctx->iv,input,output);
    if (0 != ret) {
      __retres = ret;
      goto return_label;
    }
    *olen = ilen;
    __retres = 0;
    goto return_label;
  }
  if ((ctx->cipher_info)->mode == (unsigned int)POLARSSL_MODE_CTR) {
    ret = (*(((ctx->cipher_info)->base)->ctr_func))(ctx->cipher_ctx,ilen,
                                                    & ctx->unprocessed_len,
                                                    ctx->iv,
                                                    ctx->unprocessed_data,
                                                    input,output);
    if (0 != ret) {
      __retres = ret;
      goto return_label;
    }
    *olen = ilen;
    __retres = 0;
    goto return_label;
  }
  __retres = -0x6080;
  return_label: return __retres;
}

static void add_pkcs_padding(unsigned char *output, size_t output_len,
                             size_t data_len)
{
  size_t padding_len = output_len - data_len;
  unsigned char i = (unsigned char)0;
  i = (unsigned char)0;
  while ((size_t)i < padding_len) {
    *(output + (data_len + (size_t)i)) = (unsigned char)padding_len;
    i = (unsigned char)((int)i + 1);
  }
  return;
}

static int get_pkcs_padding(unsigned char *input, unsigned int input_len,
                            size_t *data_len)
{
  int __retres;
  unsigned int i;
  unsigned int padding_len = (unsigned int)0;
  if ((unsigned char *)0 == input) {
    __retres = -0x6100;
    goto return_label;
  }
  else 
    if ((size_t *)0 == data_len) {
      __retres = -0x6100;
      goto return_label;
    }
  padding_len = (unsigned int)*(input + (input_len - (unsigned int)1));
  if (padding_len > input_len) {
    __retres = -0x6200;
    goto return_label;
  }
  i = input_len - padding_len;
  while (i < input_len) {
    if ((unsigned int)*(input + i) != padding_len) {
      __retres = -0x6200;
      goto return_label;
    }
    i ++;
  }
  *data_len = input_len - padding_len;
  __retres = 0;
  return_label: return __retres;
}

int cipher_finish(cipher_context_t *ctx, unsigned char *output, size_t *olen)
{
  int __retres;
  int ret = 0;
  if ((cipher_context_t *)0 == ctx) {
    __retres = -0x6100;
    goto return_label;
  }
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) {
      __retres = -0x6100;
      goto return_label;
    }
    else 
      if ((size_t *)0 == olen) {
        __retres = -0x6100;
        goto return_label;
      }
  *olen = (size_t)0;
  if ((unsigned int)POLARSSL_MODE_CFB128 == (ctx->cipher_info)->mode) 
    goto _LOR;
  else 
    if ((unsigned int)POLARSSL_MODE_CTR == (ctx->cipher_info)->mode) {
      _LOR: {
              __retres = 0;
              goto return_label;
            }
    }
  if ((unsigned int)POLARSSL_MODE_CBC == (ctx->cipher_info)->mode) {
    unsigned int tmp_1;
    if (POLARSSL_ENCRYPT == ctx->operation) {
      int tmp;
      ;
      tmp = cipher_get_iv_size((cipher_context_t const *)ctx);
      ;
      add_pkcs_padding(ctx->unprocessed_data,(size_t)tmp,
                       ctx->unprocessed_len);
    }
    else {
      unsigned int tmp_0;
      tmp_0 = cipher_get_block_size((cipher_context_t const *)ctx);
      ;
      if (tmp_0 != ctx->unprocessed_len) {
        __retres = -0x6280;
        goto return_label;
      }
    }
    ;
    ;
    ;
    tmp_1 = cipher_get_block_size((cipher_context_t const *)ctx);
    ;
    ;
    ret = (*(((ctx->cipher_info)->base)->cbc_func))(ctx->cipher_ctx,
                                                    ctx->operation,tmp_1,
                                                    ctx->iv,
                                                    (unsigned char const *)(ctx->unprocessed_data),
                                                    output);
    if (0 != ret) {
      __retres = ret;
      goto return_label;
    }
    if (POLARSSL_DECRYPT == ctx->operation) {
      int tmp_3;
      unsigned int tmp_2;
      ;
      tmp_2 = cipher_get_block_size((cipher_context_t const *)ctx);
      ;
      tmp_3 = get_pkcs_padding(output,tmp_2,olen);
      __retres = tmp_3;
      goto return_label;
    }
    *olen = cipher_get_block_size((cipher_context_t const *)ctx);
    __retres = 0;
    goto return_label;
  }
  __retres = -0x6080;
  return_label: return __retres;
}

int cipher_self_test(int verbose)
{
  int __retres;
  __retres = 0;
  return __retres;
}

__inline static unsigned int cipher_get_block_size_0(cipher_context_t const *ctx)
{
  unsigned int __retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = (unsigned int)0;
    goto return_label;
  }
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) {
      __retres = (unsigned int)0;
      goto return_label;
    }
  __retres = (ctx->cipher_info)->block_size;
  return_label: return __retres;
}

__inline static cipher_mode_t cipher_get_cipher_mode_0(cipher_context_t const *ctx)
{
  cipher_mode_t __retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = POLARSSL_MODE_NONE;
    goto return_label;
  }
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) {
      __retres = POLARSSL_MODE_NONE;
      goto return_label;
    }
  __retres = (ctx->cipher_info)->mode;
  return_label: return __retres;
}

__inline static int cipher_get_iv_size_0(cipher_context_t const *ctx)
{
  int __retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = 0;
    goto return_label;
  }
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) {
      __retres = 0;
      goto return_label;
    }
  __retres = (int)(ctx->cipher_info)->iv_size;
  return_label: return __retres;
}

__inline static cipher_type_t cipher_get_type_0(cipher_context_t const *ctx)
{
  cipher_type_t __retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = (cipher_type_t)0;
    goto return_label;
  }
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) {
      __retres = (cipher_type_t)0;
      goto return_label;
    }
  __retres = (ctx->cipher_info)->type;
  return_label: return __retres;
}

__inline static char const *cipher_get_name_0(cipher_context_t const *ctx)
{
  char const *__retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = (char const *)0;
    goto return_label;
  }
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) {
      __retres = (char const *)0;
      goto return_label;
    }
  __retres = (ctx->cipher_info)->name;
  return_label: return __retres;
}

__inline static int cipher_get_key_size_0(cipher_context_t const *ctx)
{
  int __retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = POLARSSL_KEY_LENGTH_NONE;
    goto return_label;
  }
  __retres = ctx->key_length;
  return_label: return __retres;
}

__inline static operation_t cipher_get_operation_0(cipher_context_t const *ctx)
{
  operation_t __retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = POLARSSL_OPERATION_NONE;
    goto return_label;
  }
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) {
      __retres = POLARSSL_OPERATION_NONE;
      goto return_label;
    }
  __retres = ctx->operation;
  return_label: return __retres;
}

int aes_crypt_cbc_wrap(void *ctx, operation_t operation, size_t length,
                       unsigned char *iv, unsigned char const *input,
                       unsigned char *output)
{
  int tmp;
  tmp = aes_crypt_cbc((aes_context *)ctx,operation,length,iv,input,output);
  return tmp;
}

int aes_crypt_cfb128_wrap(void *ctx, operation_t operation, size_t length,
                          size_t *iv_off, unsigned char *iv,
                          unsigned char const *input, unsigned char *output)
{
  int tmp;
  tmp = aes_crypt_cfb128((aes_context *)ctx,operation,length,iv_off,iv,input,
                         output);
  return tmp;
}

int aes_crypt_ctr_wrap(void *ctx, size_t length, size_t *nc_off,
                       unsigned char *nonce_counter,
                       unsigned char *stream_block,
                       unsigned char const *input, unsigned char *output)
{
  int tmp;
  tmp = aes_crypt_ctr((aes_context *)ctx,length,nc_off,nonce_counter,
                      stream_block,input,output);
  return tmp;
}

int aes_setkey_dec_wrap(void *ctx, unsigned char const *key,
                        unsigned int key_length)
{
  int tmp;
  tmp = aes_setkey_dec((aes_context *)ctx,key,key_length);
  return tmp;
}

int aes_setkey_enc_wrap(void *ctx, unsigned char const *key,
                        unsigned int key_length)
{
  int tmp;
  tmp = aes_setkey_enc((aes_context *)ctx,key,key_length);
  return tmp;
}

static void *aes_ctx_alloc(void)
{
  void *tmp;
  tmp = malloc(sizeof(aes_context));
  return tmp;
}

static void aes_ctx_free(void *ctx)
{
  free(ctx);
  return;
}

cipher_base_t const aes_info =
  {.cipher = POLARSSL_CIPHER_ID_AES,
   .cbc_func = & aes_crypt_cbc_wrap,
   .cfb128_func = & aes_crypt_cfb128_wrap,
   .ctr_func = & aes_crypt_ctr_wrap,
   .setkey_enc_func = & aes_setkey_enc_wrap,
   .setkey_dec_func = & aes_setkey_dec_wrap,
   .ctx_alloc_func = & aes_ctx_alloc,
   .ctx_free_func = & aes_ctx_free};
cipher_info_t const aes_128_cbc_info =
  {.type = POLARSSL_CIPHER_AES_128_CBC,
   .mode = POLARSSL_MODE_CBC,
   .key_length = (unsigned int)128,
   .name = "AES-128-CBC",
   .iv_size = (unsigned int)16,
   .block_size = (unsigned int)16,
   .base = & aes_info};
cipher_info_t const aes_192_cbc_info =
  {.type = POLARSSL_CIPHER_AES_192_CBC,
   .mode = POLARSSL_MODE_CBC,
   .key_length = (unsigned int)192,
   .name = "AES-192-CBC",
   .iv_size = (unsigned int)16,
   .block_size = (unsigned int)16,
   .base = & aes_info};
cipher_info_t const aes_256_cbc_info =
  {.type = POLARSSL_CIPHER_AES_256_CBC,
   .mode = POLARSSL_MODE_CBC,
   .key_length = (unsigned int)256,
   .name = "AES-256-CBC",
   .iv_size = (unsigned int)16,
   .block_size = (unsigned int)16,
   .base = & aes_info};
cipher_info_t const aes_128_cfb128_info =
  {.type = POLARSSL_CIPHER_AES_128_CFB128,
   .mode = POLARSSL_MODE_CFB128,
   .key_length = (unsigned int)128,
   .name = "AES-128-CFB128",
   .iv_size = (unsigned int)16,
   .block_size = (unsigned int)16,
   .base = & aes_info};
cipher_info_t const aes_192_cfb128_info =
  {.type = POLARSSL_CIPHER_AES_192_CFB128,
   .mode = POLARSSL_MODE_CFB128,
   .key_length = (unsigned int)192,
   .name = "AES-192-CFB128",
   .iv_size = (unsigned int)16,
   .block_size = (unsigned int)16,
   .base = & aes_info};
cipher_info_t const aes_256_cfb128_info =
  {.type = POLARSSL_CIPHER_AES_256_CFB128,
   .mode = POLARSSL_MODE_CFB128,
   .key_length = (unsigned int)256,
   .name = "AES-256-CFB128",
   .iv_size = (unsigned int)16,
   .block_size = (unsigned int)16,
   .base = & aes_info};
cipher_info_t const aes_128_ctr_info =
  {.type = POLARSSL_CIPHER_AES_128_CTR,
   .mode = POLARSSL_MODE_CTR,
   .key_length = (unsigned int)128,
   .name = "AES-128-CTR",
   .iv_size = (unsigned int)16,
   .block_size = (unsigned int)16,
   .base = & aes_info};
cipher_info_t const aes_192_ctr_info =
  {.type = POLARSSL_CIPHER_AES_192_CTR,
   .mode = POLARSSL_MODE_CTR,
   .key_length = (unsigned int)192,
   .name = "AES-192-CTR",
   .iv_size = (unsigned int)16,
   .block_size = (unsigned int)16,
   .base = & aes_info};
cipher_info_t const aes_256_ctr_info =
  {.type = POLARSSL_CIPHER_AES_256_CTR,
   .mode = POLARSSL_MODE_CTR,
   .key_length = (unsigned int)256,
   .name = "AES-256-CTR",
   .iv_size = (unsigned int)16,
   .block_size = (unsigned int)16,
   .base = & aes_info};
int camellia_crypt_cbc_wrap(void *ctx, operation_t operation, size_t length,
                            unsigned char *iv, unsigned char const *input,
                            unsigned char *output)
{
  int tmp;
  tmp = camellia_crypt_cbc((camellia_context *)ctx,operation,length,iv,input,
                           output);
  return tmp;
}

int camellia_crypt_cfb128_wrap(void *ctx, operation_t operation,
                               size_t length, size_t *iv_off,
                               unsigned char *iv, unsigned char const *input,
                               unsigned char *output)
{
  int tmp;
  tmp = camellia_crypt_cfb128((camellia_context *)ctx,operation,length,
                              iv_off,iv,input,output);
  return tmp;
}

int camellia_crypt_ctr_wrap(void *ctx, size_t length, size_t *nc_off,
                            unsigned char *nonce_counter,
                            unsigned char *stream_block,
                            unsigned char const *input, unsigned char *output)
{
  int tmp;
  tmp = camellia_crypt_ctr((camellia_context *)ctx,length,nc_off,
                           nonce_counter,stream_block,input,output);
  return tmp;
}

int camellia_setkey_dec_wrap(void *ctx, unsigned char const *key,
                             unsigned int key_length)
{
  int tmp;
  tmp = camellia_setkey_dec((camellia_context *)ctx,key,key_length);
  return tmp;
}

int camellia_setkey_enc_wrap(void *ctx, unsigned char const *key,
                             unsigned int key_length)
{
  int tmp;
  tmp = camellia_setkey_enc((camellia_context *)ctx,key,key_length);
  return tmp;
}

static void *camellia_ctx_alloc(void)
{
  void *tmp;
  tmp = malloc(sizeof(camellia_context));
  return tmp;
}

static void camellia_ctx_free(void *ctx)
{
  free(ctx);
  return;
}

cipher_base_t const camellia_info =
  {.cipher = POLARSSL_CIPHER_ID_CAMELLIA,
   .cbc_func = & camellia_crypt_cbc_wrap,
   .cfb128_func = & camellia_crypt_cfb128_wrap,
   .ctr_func = & camellia_crypt_ctr_wrap,
   .setkey_enc_func = & camellia_setkey_enc_wrap,
   .setkey_dec_func = & camellia_setkey_dec_wrap,
   .ctx_alloc_func = & camellia_ctx_alloc,
   .ctx_free_func = & camellia_ctx_free};
cipher_info_t const camellia_128_cbc_info =
  {.type = POLARSSL_CIPHER_CAMELLIA_128_CBC,
   .mode = POLARSSL_MODE_CBC,
   .key_length = (unsigned int)128,
   .name = "CAMELLIA-128-CBC",
   .iv_size = (unsigned int)16,
   .block_size = (unsigned int)16,
   .base = & camellia_info};
cipher_info_t const camellia_192_cbc_info =
  {.type = POLARSSL_CIPHER_CAMELLIA_192_CBC,
   .mode = POLARSSL_MODE_CBC,
   .key_length = (unsigned int)192,
   .name = "CAMELLIA-192-CBC",
   .iv_size = (unsigned int)16,
   .block_size = (unsigned int)16,
   .base = & camellia_info};
cipher_info_t const camellia_256_cbc_info =
  {.type = POLARSSL_CIPHER_CAMELLIA_256_CBC,
   .mode = POLARSSL_MODE_CBC,
   .key_length = (unsigned int)256,
   .name = "CAMELLIA-256-CBC",
   .iv_size = (unsigned int)16,
   .block_size = (unsigned int)16,
   .base = & camellia_info};
cipher_info_t const camellia_128_cfb128_info =
  {.type = POLARSSL_CIPHER_CAMELLIA_128_CFB128,
   .mode = POLARSSL_MODE_CFB128,
   .key_length = (unsigned int)128,
   .name = "CAMELLIA-128-CFB128",
   .iv_size = (unsigned int)16,
   .block_size = (unsigned int)16,
   .base = & camellia_info};
cipher_info_t const camellia_192_cfb128_info =
  {.type = POLARSSL_CIPHER_CAMELLIA_192_CFB128,
   .mode = POLARSSL_MODE_CFB128,
   .key_length = (unsigned int)192,
   .name = "CAMELLIA-192-CFB128",
   .iv_size = (unsigned int)16,
   .block_size = (unsigned int)16,
   .base = & camellia_info};
cipher_info_t const camellia_256_cfb128_info =
  {.type = POLARSSL_CIPHER_CAMELLIA_256_CFB128,
   .mode = POLARSSL_MODE_CFB128,
   .key_length = (unsigned int)256,
   .name = "CAMELLIA-256-CFB128",
   .iv_size = (unsigned int)16,
   .block_size = (unsigned int)16,
   .base = & camellia_info};
cipher_info_t const camellia_128_ctr_info =
  {.type = POLARSSL_CIPHER_CAMELLIA_128_CTR,
   .mode = POLARSSL_MODE_CTR,
   .key_length = (unsigned int)128,
   .name = "CAMELLIA-128-CTR",
   .iv_size = (unsigned int)16,
   .block_size = (unsigned int)16,
   .base = & camellia_info};
cipher_info_t const camellia_192_ctr_info =
  {.type = POLARSSL_CIPHER_CAMELLIA_192_CTR,
   .mode = POLARSSL_MODE_CTR,
   .key_length = (unsigned int)192,
   .name = "CAMELLIA-192-CTR",
   .iv_size = (unsigned int)16,
   .block_size = (unsigned int)16,
   .base = & camellia_info};
cipher_info_t const camellia_256_ctr_info =
  {.type = POLARSSL_CIPHER_CAMELLIA_256_CTR,
   .mode = POLARSSL_MODE_CTR,
   .key_length = (unsigned int)256,
   .name = "CAMELLIA-256-CTR",
   .iv_size = (unsigned int)16,
   .block_size = (unsigned int)16,
   .base = & camellia_info};
int des_crypt_cbc_wrap(void *ctx, operation_t operation, size_t length,
                       unsigned char *iv, unsigned char const *input,
                       unsigned char *output)
{
  int tmp;
  tmp = des_crypt_cbc((des_context *)ctx,operation,length,iv,input,output);
  return tmp;
}

int des3_crypt_cbc_wrap(void *ctx, operation_t operation, size_t length,
                        unsigned char *iv, unsigned char const *input,
                        unsigned char *output)
{
  int tmp;
  tmp = des3_crypt_cbc((des3_context *)ctx,operation,length,iv,input,output);
  return tmp;
}

int des_crypt_cfb128_wrap(void *ctx, operation_t operation, size_t length,
                          size_t *iv_off, unsigned char *iv,
                          unsigned char const *input, unsigned char *output)
{
  int __retres;
  __retres = -0x6080;
  return __retres;
}

int des_crypt_ctr_wrap(void *ctx, size_t length, size_t *nc_off,
                       unsigned char *nonce_counter,
                       unsigned char *stream_block,
                       unsigned char const *input, unsigned char *output)
{
  int __retres;
  __retres = -0x6080;
  return __retres;
}

int des_setkey_dec_wrap(void *ctx, unsigned char const *key,
                        unsigned int key_length)
{
  int tmp;
  tmp = des_setkey_dec((des_context *)ctx,key);
  return tmp;
}

int des_setkey_enc_wrap(void *ctx, unsigned char const *key,
                        unsigned int key_length)
{
  int tmp;
  tmp = des_setkey_enc((des_context *)ctx,key);
  return tmp;
}

int des3_set2key_dec_wrap(void *ctx, unsigned char const *key,
                          unsigned int key_length)
{
  int tmp;
  tmp = des3_set2key_dec((des3_context *)ctx,key);
  return tmp;
}

int des3_set2key_enc_wrap(void *ctx, unsigned char const *key,
                          unsigned int key_length)
{
  int tmp;
  tmp = des3_set2key_enc((des3_context *)ctx,key);
  return tmp;
}

int des3_set3key_dec_wrap(void *ctx, unsigned char const *key,
                          unsigned int key_length)
{
  int tmp;
  tmp = des3_set3key_dec((des3_context *)ctx,key);
  return tmp;
}

int des3_set3key_enc_wrap(void *ctx, unsigned char const *key,
                          unsigned int key_length)
{
  int tmp;
  tmp = des3_set3key_enc((des3_context *)ctx,key);
  return tmp;
}

static void *des_ctx_alloc(void)
{
  void *tmp;
  tmp = malloc(sizeof(des_context));
  return tmp;
}

static void *des3_ctx_alloc(void)
{
  void *tmp;
  tmp = malloc(sizeof(des3_context));
  return tmp;
}

static void des_ctx_free(void *ctx)
{
  free(ctx);
  return;
}

cipher_base_t const des_info =
  {.cipher = POLARSSL_CIPHER_ID_DES,
   .cbc_func = & des_crypt_cbc_wrap,
   .cfb128_func = & des_crypt_cfb128_wrap,
   .ctr_func = & des_crypt_ctr_wrap,
   .setkey_enc_func = & des_setkey_enc_wrap,
   .setkey_dec_func = & des_setkey_dec_wrap,
   .ctx_alloc_func = & des_ctx_alloc,
   .ctx_free_func = & des_ctx_free};
cipher_info_t const des_cbc_info =
  {.type = POLARSSL_CIPHER_DES_CBC,
   .mode = POLARSSL_MODE_CBC,
   .key_length = (unsigned int)POLARSSL_KEY_LENGTH_DES,
   .name = "DES-CBC",
   .iv_size = (unsigned int)8,
   .block_size = (unsigned int)8,
   .base = & des_info};
cipher_base_t const des_ede_info =
  {.cipher = POLARSSL_CIPHER_ID_DES,
   .cbc_func = & des3_crypt_cbc_wrap,
   .cfb128_func = & des_crypt_cfb128_wrap,
   .ctr_func = & des_crypt_ctr_wrap,
   .setkey_enc_func = & des3_set2key_enc_wrap,
   .setkey_dec_func = & des3_set2key_dec_wrap,
   .ctx_alloc_func = & des3_ctx_alloc,
   .ctx_free_func = & des_ctx_free};
cipher_info_t const des_ede_cbc_info =
  {.type = POLARSSL_CIPHER_DES_EDE_CBC,
   .mode = POLARSSL_MODE_CBC,
   .key_length = (unsigned int)POLARSSL_KEY_LENGTH_DES_EDE,
   .name = "DES-EDE-CBC",
   .iv_size = (unsigned int)8,
   .block_size = (unsigned int)8,
   .base = & des_ede_info};
cipher_base_t const des_ede3_info =
  {.cipher = POLARSSL_CIPHER_ID_DES,
   .cbc_func = & des3_crypt_cbc_wrap,
   .cfb128_func = & des_crypt_cfb128_wrap,
   .ctr_func = & des_crypt_ctr_wrap,
   .setkey_enc_func = & des3_set3key_enc_wrap,
   .setkey_dec_func = & des3_set3key_dec_wrap,
   .ctx_alloc_func = & des3_ctx_alloc,
   .ctx_free_func = & des_ctx_free};
cipher_info_t const des_ede3_cbc_info =
  {.type = POLARSSL_CIPHER_DES_EDE3_CBC,
   .mode = POLARSSL_MODE_CBC,
   .key_length = (unsigned int)POLARSSL_KEY_LENGTH_DES_EDE3,
   .name = "DES-EDE3-CBC",
   .iv_size = (unsigned int)8,
   .block_size = (unsigned int)8,
   .base = & des_ede3_info};
int ctr_drbg_init_entropy_len(ctr_drbg_context *ctx,
                              int (*f_entropy)(void *, unsigned char *,
                                               size_t ),
                              void *p_entropy, unsigned char const *custom,
                              size_t len, size_t entropy_len)
{
  int __retres;
  int ret;
  unsigned char key[32];
  memset((void *)ctx,0,sizeof(ctr_drbg_context));
  memset((void *)(key),0,(size_t)32);
  ctx->f_entropy = f_entropy;
  ctx->p_entropy = p_entropy;
  ctx->entropy_len = entropy_len;
  ctx->reseed_interval = 10000;
  aes_setkey_enc(& ctx->aes_ctx,(unsigned char const *)(key),
                 (unsigned int)(32 * 8));
  ret = ctr_drbg_reseed(ctx,custom,len);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int ctr_drbg_init(ctr_drbg_context *ctx,
                  int (*f_entropy)(void *, unsigned char *, size_t ),
                  void *p_entropy, unsigned char const *custom, size_t len)
{
  int tmp;
  tmp = ctr_drbg_init_entropy_len(ctx,f_entropy,p_entropy,custom,len,
                                  (size_t)48);
  return tmp;
}

void ctr_drbg_set_prediction_resistance(ctr_drbg_context *ctx, int resistance)
{
  ctx->prediction_resistance = resistance;
  return;
}

void ctr_drbg_set_entropy_len(ctr_drbg_context *ctx, size_t len)
{
  ctx->entropy_len = len;
  return;
}

void ctr_drbg_set_reseed_interval(ctr_drbg_context *ctx, int interval)
{
  ctx->reseed_interval = interval;
  return;
}

int block_cipher_df(unsigned char *output, unsigned char const *data,
                    size_t data_len)
{
  int __retres;
  unsigned char buf[(384 + 16) + 16];
  unsigned char tmp[32 + 16];
  unsigned char key[32];
  unsigned char chain[16];
  unsigned char *iv;
  aes_context aes_ctx;
  int i;
  int j;
  int buf_len;
  int use_len;
  unsigned char *tmp_0;
  unsigned char *tmp_1;
  unsigned char *tmp_2;
  unsigned char *tmp_3;
  unsigned char *tmp_4;
  unsigned char *p = buf;
  memset((void *)(buf),0,(size_t)((384 + 16) + 16));
  p = & buf[16];
  tmp_0 = p;
  p ++;
  *tmp_0 = (unsigned char)((data_len >> 24) & (unsigned int)0xff);
  tmp_1 = p;
  p ++;
  *tmp_1 = (unsigned char)((data_len >> 16) & (unsigned int)0xff);
  tmp_2 = p;
  p ++;
  *tmp_2 = (unsigned char)((data_len >> 8) & (unsigned int)0xff);
  tmp_3 = p;
  p ++;
  *tmp_3 = (unsigned char)(data_len & (unsigned int)0xff);
  p += 3;
  tmp_4 = p;
  p ++;
  *tmp_4 = (unsigned char)(32 + 16);
  memcpy((void *)p,(void const *)data,data_len);
  *(p + data_len) = (unsigned char)0x80;
  buf_len = (int)(((size_t)(16 + 8) + data_len) + (size_t)1);
  i = 0;
  /*@ loop unroll 32; */
  while (i < 32) {
    key[i] = (unsigned char)i;
    i ++;
  }
  aes_setkey_enc(& aes_ctx,(unsigned char const *)(key),
                 (unsigned int)(32 * 8));
  j = 0;
  /*@ loop unroll 3; */
  while (j < 32 + 16) {
    p = buf;
    memset((void *)(chain),0,(size_t)16);
    use_len = buf_len;
    while (use_len > 0) {
      i = 0;
      /*@ loop unroll 16; */
      while (i < 16) {
        chain[i] = (unsigned char)((int)chain[i] ^ (int)*(p + i));
        i ++;
      }
      p += 16;
      use_len -= 16;
      aes_crypt_ecb(& aes_ctx,1,(unsigned char const *)(chain),chain);
    }
    memcpy((void *)(& tmp[j]),(void const *)(chain),(size_t)16);
    buf[3] = (unsigned char)((int)buf[3] + 1);
    j += 16;
  }
  aes_setkey_enc(& aes_ctx,(unsigned char const *)(tmp),
                 (unsigned int)(32 * 8));
  iv = & tmp[32];
  p = output;
  j = 0;
  /*@ loop unroll 3; */
  while (j < 32 + 16) {
    aes_crypt_ecb(& aes_ctx,1,(unsigned char const *)iv,iv);
    memcpy((void *)p,(void const *)iv,(size_t)16);
    p += 16;
    j += 16;
  }
  __retres = 0;
  return __retres;
}

int ctr_drbg_update_internal(ctr_drbg_context *ctx,
                             unsigned char const data[48])
{
  int __retres;
  unsigned char tmp[32 + 16];
  int cb;
  int i;
  int j;
  unsigned char *p = tmp;
  memset((void *)(tmp),0,(size_t)(32 + 16));
  j = 0;
  /*@ loop unroll 3; */
  while (j < 32 + 16) {
    i = 16 - 1;
    /*@ loop unroll 16; */
    while (1) {
      int tmp_0;
      ctx->counter[i] = (unsigned char)((int)ctx->counter[i] + 1);
      cb = (int)ctx->counter[i] == 0;
      tmp_0 = i;
      i --;
      ;
      if (tmp_0) {
        if (! cb) break;
      }
      else break;
    }
    aes_crypt_ecb(& ctx->aes_ctx,1,(unsigned char const *)(ctx->counter),p);
    p += 16;
    j += 16;
  }
  i = 0;
  /*@ loop unroll 48; */
  while (i < 32 + 16) {
    tmp[i] = (unsigned char)((int)tmp[i] ^ (int)*(data + i));
    i ++;
  }
  aes_setkey_enc(& ctx->aes_ctx,(unsigned char const *)(tmp),
                 (unsigned int)(32 * 8));
  memcpy((void *)(ctx->counter),(void const *)(& tmp[32]),(size_t)16);
  __retres = 0;
  return __retres;
}

void ctr_drbg_update(ctr_drbg_context *ctx, unsigned char const *additional,
                     size_t add_len)
{
  unsigned char add_input[32 + 16];
  if (add_len > (size_t)0) {
    block_cipher_df(add_input,additional,add_len);
    ctr_drbg_update_internal(ctx,(unsigned char const *)(add_input));
  }
  return;
}

int ctr_drbg_reseed(ctr_drbg_context *ctx, unsigned char const *additional,
                    size_t len)
{
  int __retres;
  unsigned char seed[384];
  int tmp;
  size_t seedlen = (size_t)0;
  if (ctx->entropy_len + len > (size_t)384) {
    __retres = -0x0038;
    goto return_label;
  }
  memset((void *)(seed),0,(size_t)384);
  tmp = (*(ctx->f_entropy))(ctx->p_entropy,seed,ctx->entropy_len);
  if (0 != tmp) {
    __retres = -0x0034;
    goto return_label;
  }
  seedlen += ctx->entropy_len;
  if (additional) 
    if (len) {
      memcpy((void *)(& seed[seedlen]),(void const *)additional,len);
      seedlen += len;
    }
  block_cipher_df(seed,(unsigned char const *)(seed),seedlen);
  ctr_drbg_update_internal(ctx,(unsigned char const *)(seed));
  ctx->reseed_counter = 1;
  __retres = 0;
  return_label: return __retres;
}

int ctr_drbg_random_with_add(void *p_rng, unsigned char *output,
                             size_t output_len,
                             unsigned char const *additional, size_t add_len)
{
  int __retres;
  unsigned char add_input[32 + 16];
  unsigned char tmp[16];
  int cb;
  int i;
  size_t use_len;
  int ret = 0;
  ctr_drbg_context *ctx = (ctr_drbg_context *)p_rng;
  unsigned char *p = output;
  if (output_len > (size_t)1024) {
    __retres = -0x0036;
    goto return_label;
  }
  if (add_len > (size_t)256) {
    __retres = -0x0038;
    goto return_label;
  }
  memset((void *)(add_input),0,(size_t)(32 + 16));
  if (ctx->reseed_counter > ctx->reseed_interval) goto _LOR;
  else 
    if (ctx->prediction_resistance) {
      _LOR:
      {
        ret = ctr_drbg_reseed(ctx,additional,add_len);
        if (ret != 0) {
          __retres = ret;
          goto return_label;
        }
        add_len = (size_t)0;
      }
    }
  if (add_len > (size_t)0) {
    block_cipher_df(add_input,additional,add_len);
    ctr_drbg_update_internal(ctx,(unsigned char const *)(add_input));
  }
  while (output_len > (size_t)0) {
    i = 16 - 1;
    while (1) {
      int tmp_0;
      ctx->counter[i] = (unsigned char)((int)ctx->counter[i] + 1);
      cb = (int)ctx->counter[i] == 0;
      tmp_0 = i;
      i --;
      ;
      if (tmp_0) {
        if (! cb) break;
      }
      else break;
    }
    aes_crypt_ecb(& ctx->aes_ctx,1,(unsigned char const *)(ctx->counter),tmp);
    if (output_len > (size_t)16) use_len = (size_t)16;
    else use_len = output_len;
    memcpy((void *)p,(void const *)(tmp),use_len);
    p += use_len;
    output_len -= use_len;
  }
  ctr_drbg_update_internal(ctx,(unsigned char const *)(add_input));
  (ctx->reseed_counter) ++;
  __retres = 0;
  return_label: return __retres;
}

/*@ requires \valid((ctr_drbg_context *)p_rng);
    requires \valid(output + (0 .. output_len - 1));
    ensures \initialized(\old(output) + (0 .. \old(output_len) - 1));
    assigns *(output + (0 .. output_len - 1)), _ctr_drbg_random_source,
            \result;
    assigns *(output + (0 .. output_len - 1)) \from _ctr_drbg_random_source;
    assigns _ctr_drbg_random_source \from _ctr_drbg_random_source;
    assigns \result \from _ctr_drbg_random_source;
 */
int ctr_drbg_random(void *p_rng, unsigned char *output, size_t output_len)
{
  int tmp;
  tmp = ctr_drbg_random_with_add(p_rng,output,output_len,
                                 (unsigned char const *)0,(size_t)0);
  return tmp;
}

int ctr_drbg_write_seed_file(ctr_drbg_context *ctx, char const *path)
{
  int __retres;
  int ret;
  FILE *f;
  unsigned char buf[256];
  size_t tmp;
  f = fopen(path,"wb");
  if (f == (FILE *)0) {
    __retres = -0x003A;
    goto return_label;
  }
  ret = ctr_drbg_random((void *)ctx,buf,(size_t)256);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  tmp = fwrite((void const *)(buf),(size_t)1,(size_t)256,f);
  if (tmp != (size_t)256) {
    fclose(f);
    __retres = -0x003A;
    goto return_label;
  }
  fclose(f);
  __retres = 0;
  return_label: return __retres;
}

int ctr_drbg_update_seed_file(ctr_drbg_context *ctx, char const *path)
{
  int __retres;
  FILE *f;
  size_t n;
  unsigned char buf[256];
  long tmp;
  size_t tmp_0;
  int tmp_1;
  f = fopen(path,"rb");
  if (f == (FILE *)0) {
    __retres = -0x003A;
    goto return_label;
  }
  fseek(f,(long)0,2);
  tmp = ftell(f);
  n = (size_t)tmp;
  fseek(f,(long)0,0);
  if (n > (size_t)256) {
    __retres = -0x0038;
    goto return_label;
  }
  tmp_0 = fread((void *)(buf),(size_t)1,n,f);
  ;
  if (tmp_0 != n) {
    fclose(f);
    __retres = -0x003A;
    goto return_label;
  }
  ctr_drbg_update(ctx,(unsigned char const *)(buf),n);
  fclose(f);
  tmp_1 = ctr_drbg_write_seed_file(ctx,path);
  __retres = tmp_1;
  return_label: return __retres;
}

unsigned char entropy_source_pr[96] =
  {(unsigned char)0xc1,
   (unsigned char)0x80,
   (unsigned char)0x81,
   (unsigned char)0xa6,
   (unsigned char)0x5d,
   (unsigned char)0x44,
   (unsigned char)0x02,
   (unsigned char)0x16,
   (unsigned char)0x19,
   (unsigned char)0xb3,
   (unsigned char)0xf1,
   (unsigned char)0x80,
   (unsigned char)0xb1,
   (unsigned char)0xc9,
   (unsigned char)0x20,
   (unsigned char)0x02,
   (unsigned char)0x6a,
   (unsigned char)0x54,
   (unsigned char)0x6f,
   (unsigned char)0x0c,
   (unsigned char)0x70,
   (unsigned char)0x81,
   (unsigned char)0x49,
   (unsigned char)0x8b,
   (unsigned char)0x6e,
   (unsigned char)0xa6,
   (unsigned char)0x62,
   (unsigned char)0x52,
   (unsigned char)0x6d,
   (unsigned char)0x51,
   (unsigned char)0xb1,
   (unsigned char)0xcb,
   (unsigned char)0x58,
   (unsigned char)0x3b,
   (unsigned char)0xfa,
   (unsigned char)0xd5,
   (unsigned char)0x37,
   (unsigned char)0x5f,
   (unsigned char)0xfb,
   (unsigned char)0xc9,
   (unsigned char)0xff,
   (unsigned char)0x46,
   (unsigned char)0xd2,
   (unsigned char)0x19,
   (unsigned char)0xc7,
   (unsigned char)0x22,
   (unsigned char)0x3e,
   (unsigned char)0x95,
   (unsigned char)0x45,
   (unsigned char)0x9d,
   (unsigned char)0x82,
   (unsigned char)0xe1,
   (unsigned char)0xe7,
   (unsigned char)0x22,
   (unsigned char)0x9f,
   (unsigned char)0x63,
   (unsigned char)0x31,
   (unsigned char)0x69,
   (unsigned char)0xd2,
   (unsigned char)0x6b,
   (unsigned char)0x57,
   (unsigned char)0x47,
   (unsigned char)0x4f,
   (unsigned char)0xa3,
   (unsigned char)0x37,
   (unsigned char)0xc9,
   (unsigned char)0x98,
   (unsigned char)0x1c,
   (unsigned char)0x0b,
   (unsigned char)0xfb,
   (unsigned char)0x91,
   (unsigned char)0x31,
   (unsigned char)0x4d,
   (unsigned char)0x55,
   (unsigned char)0xb9,
   (unsigned char)0xe9,
   (unsigned char)0x1c,
   (unsigned char)0x5a,
   (unsigned char)0x5e,
   (unsigned char)0xe4,
   (unsigned char)0x93,
   (unsigned char)0x92,
   (unsigned char)0xcf,
   (unsigned char)0xc5,
   (unsigned char)0x23,
   (unsigned char)0x12,
   (unsigned char)0xd5,
   (unsigned char)0x56,
   (unsigned char)0x2c,
   (unsigned char)0x4a,
   (unsigned char)0x6e,
   (unsigned char)0xff,
   (unsigned char)0xdc,
   (unsigned char)0x10,
   (unsigned char)0xd0,
   (unsigned char)0x68};
unsigned char entropy_source_nopr[64] =
  {(unsigned char)0x5a,
   (unsigned char)0x19,
   (unsigned char)0x4d,
   (unsigned char)0x5e,
   (unsigned char)0x2b,
   (unsigned char)0x31,
   (unsigned char)0x58,
   (unsigned char)0x14,
   (unsigned char)0x54,
   (unsigned char)0xde,
   (unsigned char)0xf6,
   (unsigned char)0x75,
   (unsigned char)0xfb,
   (unsigned char)0x79,
   (unsigned char)0x58,
   (unsigned char)0xfe,
   (unsigned char)0xc7,
   (unsigned char)0xdb,
   (unsigned char)0x87,
   (unsigned char)0x3e,
   (unsigned char)0x56,
   (unsigned char)0x89,
   (unsigned char)0xfc,
   (unsigned char)0x9d,
   (unsigned char)0x03,
   (unsigned char)0x21,
   (unsigned char)0x7c,
   (unsigned char)0x68,
   (unsigned char)0xd8,
   (unsigned char)0x03,
   (unsigned char)0x38,
   (unsigned char)0x20,
   (unsigned char)0xf9,
   (unsigned char)0xe6,
   (unsigned char)0x5e,
   (unsigned char)0x04,
   (unsigned char)0xd8,
   (unsigned char)0x56,
   (unsigned char)0xf3,
   (unsigned char)0xa9,
   (unsigned char)0xc4,
   (unsigned char)0x4a,
   (unsigned char)0x4c,
   (unsigned char)0xbd,
   (unsigned char)0xc1,
   (unsigned char)0xd0,
   (unsigned char)0x08,
   (unsigned char)0x46,
   (unsigned char)0xf5,
   (unsigned char)0x98,
   (unsigned char)0x3d,
   (unsigned char)0x77,
   (unsigned char)0x1c,
   (unsigned char)0x1b,
   (unsigned char)0x13,
   (unsigned char)0x7e,
   (unsigned char)0x4e,
   (unsigned char)0x0f,
   (unsigned char)0x9d,
   (unsigned char)0x8e,
   (unsigned char)0xf4,
   (unsigned char)0x09,
   (unsigned char)0xf9,
   (unsigned char)0x2e};
unsigned char nonce_pers_pr[16] =
  {(unsigned char)0xd2,
   (unsigned char)0x54,
   (unsigned char)0xfc,
   (unsigned char)0xff,
   (unsigned char)0x02,
   (unsigned char)0x1e,
   (unsigned char)0x69,
   (unsigned char)0xd2,
   (unsigned char)0x29,
   (unsigned char)0xc9,
   (unsigned char)0xcf,
   (unsigned char)0xad,
   (unsigned char)0x85,
   (unsigned char)0xfa,
   (unsigned char)0x48,
   (unsigned char)0x6c};
unsigned char nonce_pers_nopr[16] =
  {(unsigned char)0x1b,
   (unsigned char)0x54,
   (unsigned char)0xb8,
   (unsigned char)0xff,
   (unsigned char)0x06,
   (unsigned char)0x42,
   (unsigned char)0xbf,
   (unsigned char)0xf5,
   (unsigned char)0x21,
   (unsigned char)0xf1,
   (unsigned char)0x5c,
   (unsigned char)0x1c,
   (unsigned char)0x0b,
   (unsigned char)0x66,
   (unsigned char)0x5f,
   (unsigned char)0x3f};
unsigned char result_pr[16] =
  {(unsigned char)0x34,
   (unsigned char)0x01,
   (unsigned char)0x16,
   (unsigned char)0x56,
   (unsigned char)0xb4,
   (unsigned char)0x29,
   (unsigned char)0x00,
   (unsigned char)0x8f,
   (unsigned char)0x35,
   (unsigned char)0x63,
   (unsigned char)0xec,
   (unsigned char)0xb5,
   (unsigned char)0xf2,
   (unsigned char)0x59,
   (unsigned char)0x07,
   (unsigned char)0x23};
unsigned char result_nopr[16] =
  {(unsigned char)0xa0,
   (unsigned char)0x54,
   (unsigned char)0x30,
   (unsigned char)0x3d,
   (unsigned char)0x8a,
   (unsigned char)0x7e,
   (unsigned char)0xa9,
   (unsigned char)0x88,
   (unsigned char)0x9d,
   (unsigned char)0x90,
   (unsigned char)0x3e,
   (unsigned char)0x07,
   (unsigned char)0x7c,
   (unsigned char)0x6f,
   (unsigned char)0x21,
   (unsigned char)0x8f};
int test_offset;
int ctr_drbg_self_test_entropy(void *data, unsigned char *buf, size_t len)
{
  int __retres;
  unsigned char *p = (unsigned char *)data;
  memcpy((void *)buf,(void const *)(p + test_offset),len);
  test_offset += 32;
  __retres = 0;
  return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_61(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_62(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_63(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_64(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_65(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_66(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_67(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_68(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_69(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_70(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_71(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_72(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_73(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_74(char const * restrict format);

int ctr_drbg_self_test(int verbose)
{
  int __retres;
  ctr_drbg_context ctx;
  unsigned char buf[16];
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  int tmp_4;
  int tmp_5;
  int tmp_6;
  int tmp_7;
  if (verbose != 0) printf("  CTR_DRBG (PR = TRUE) : "); /* printf_va_61 */
  test_offset = 0;
  tmp = ctr_drbg_init_entropy_len(& ctx,& ctr_drbg_self_test_entropy,
                                  (void *)(entropy_source_pr),
                                  (unsigned char const *)(nonce_pers_pr),
                                  (size_t)16,(size_t)32);
  if (tmp != 0) {
    if (verbose != 0) printf("failed\n"); /* printf_va_62 */
    __retres = 1;
    goto return_label;
  }
  ctr_drbg_set_prediction_resistance(& ctx,1);
  tmp_0 = ctr_drbg_random((void *)(& ctx),buf,(size_t)16);
  if (tmp_0 != 0) {
    if (verbose != 0) printf("failed\n"); /* printf_va_63 */
    __retres = 1;
    goto return_label;
  }
  tmp_1 = ctr_drbg_random((void *)(& ctx),buf,(size_t)16);
  if (tmp_1 != 0) {
    if (verbose != 0) printf("failed\n"); /* printf_va_64 */
    __retres = 1;
    goto return_label;
  }
  tmp_2 = memcmp((void const *)(buf),(void const *)(result_pr),(size_t)16);
  if (tmp_2 != 0) {
    if (verbose != 0) printf("failed\n"); /* printf_va_65 */
    __retres = 1;
    goto return_label;
  }
  if (verbose != 0) printf("passed\n"); /* printf_va_66 */
  if (verbose != 0) printf("  CTR_DRBG (PR = FALSE): "); /* printf_va_67 */
  test_offset = 0;
  tmp_3 = ctr_drbg_init_entropy_len(& ctx,& ctr_drbg_self_test_entropy,
                                    (void *)(entropy_source_nopr),
                                    (unsigned char const *)(nonce_pers_nopr),
                                    (size_t)16,(size_t)32);
  if (tmp_3 != 0) {
    if (verbose != 0) printf("failed\n"); /* printf_va_68 */
    __retres = 1;
    goto return_label;
  }
  tmp_4 = ctr_drbg_random((void *)(& ctx),buf,(size_t)16);
  if (tmp_4 != 0) {
    if (verbose != 0) printf("failed\n"); /* printf_va_69 */
    __retres = 1;
    goto return_label;
  }
  tmp_5 = ctr_drbg_reseed(& ctx,(unsigned char const *)0,(size_t)0);
  if (tmp_5 != 0) {
    if (verbose != 0) printf("failed\n"); /* printf_va_70 */
    __retres = 1;
    goto return_label;
  }
  tmp_6 = ctr_drbg_random((void *)(& ctx),buf,(size_t)16);
  if (tmp_6 != 0) {
    if (verbose != 0) printf("failed\n"); /* printf_va_71 */
    __retres = 1;
    goto return_label;
  }
  tmp_7 = memcmp((void const *)(buf),(void const *)(result_nopr),(size_t)16);
  if (tmp_7 != 0) {
    if (verbose != 0) printf("failed\n"); /* printf_va_72 */
    __retres = 1;
    goto return_label;
  }
  if (verbose != 0) printf("passed\n"); /* printf_va_73 */
  if (verbose != 0) printf("\n"); /* printf_va_74 */
  __retres = 0;
  return_label: return __retres;
}

__inline static int const *ssl_list_ciphersuites_0(void)
{
  int const *__retres;
  __retres = (int const *)(ssl_default_ciphersuites);
  return __retres;
}

char *debug_fmt(char const *format, void * const *__va_params);

void debug_print_msg(ssl_context const *ssl, int level, char const *file,
                     int line, char const *text);

void debug_print_ret(ssl_context const *ssl, int level, char const *file,
                     int line, char const *text, int ret);

void debug_print_buf(ssl_context const *ssl, int level, char const *file,
                     int line, char const *text, unsigned char *buf,
                     size_t len);

void debug_print_mpi(ssl_context const *ssl, int level, char const *file,
                     int line, char const *text, mpi const *X);

void debug_print_crt(ssl_context const *ssl, int level, char const *file,
                     int line, char const *text, x509_cert const *crt);

static char debug_fmt_str[512];
char *debug_fmt(char const *format, void * const *__va_params)
{
  char *__retres;
  va_list argp;
  int maxlen = (int)(sizeof(debug_fmt_str) - (unsigned int)1);
  argp = __va_params;
  vsnprintf(debug_fmt_str,(size_t)maxlen,format,argp);
  debug_fmt_str[maxlen] = (char)'\000';
  __retres = debug_fmt_str;
  return __retres;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(param2);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: *(param2 + (0 ..))), (indirect: param1),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))),
            *(param2 + (0 ..)), param1, *(param0 + (0 ..));
 */
int snprintf_va_1(char * restrict s, size_t n, char const * restrict format,
                  char *param0, int param1, char *param2);

void debug_print_msg(ssl_context const *ssl, int level, char const *file,
                     int line, char const *text)
{
  char str[512];
  int maxlen = (int)(sizeof(str) - (unsigned int)1);
  if (ssl->f_dbg == (void (*)(void *, int , char const *))0) goto return_label;
  snprintf(str,(size_t)maxlen,"%s(%04d): %s\n",(char *)file,line,
           (char *)text); /* snprintf_va_1 */
  str[maxlen] = (char)'\000';
  (*(ssl->f_dbg))(ssl->p_dbg,level,(char const *)(str));
  return_label: return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(param2);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: param4), (indirect: param3),
            (indirect: *(param2 + (0 ..))), (indirect: param1),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param4, param3,
            *(param2 + (0 ..)), param1, *(param0 + (0 ..));
 */
int snprintf_va_2(char * restrict s, size_t n, char const * restrict format,
                  char *param0, int param1, char *param2, int param3,
                  unsigned int param4);

void debug_print_ret(ssl_context const *ssl, int level, char const *file,
                     int line, char const *text, int ret)
{
  char str[512];
  int maxlen = (int)(sizeof(str) - (unsigned int)1);
  if (ssl->f_dbg == (void (*)(void *, int , char const *))0) goto return_label;
  snprintf(str,(size_t)maxlen,"%s(%04d): %s() returned %d (0x%x)\n",
           (char *)file,line,(char *)text,ret,(unsigned int)ret); /* snprintf_va_2 */
  str[maxlen] = (char)'\000';
  (*(ssl->f_dbg))(ssl->p_dbg,level,(char const *)(str));
  return_label: return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(param2);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: param3), (indirect: *(param2 + (0 ..))),
            (indirect: param1), (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param3,
            *(param2 + (0 ..)), param1, *(param0 + (0 ..));
 */
int snprintf_va_3(char * restrict s, size_t n, char const * restrict format,
                  char *param0, int param1, char *param2, int param3);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: param2), (indirect: param1),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param2, param1,
            *(param0 + (0 ..));
 */
int snprintf_va_4(char * restrict s, size_t n, char const * restrict format,
                  char *param0, int param1, unsigned int param2);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))), (indirect: param0);
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param0;
 */
int snprintf_va_5(char * restrict s, size_t n, char const * restrict format,
                  unsigned int param0);

void debug_print_buf(ssl_context const *ssl, int level, char const *file,
                     int line, char const *text, unsigned char *buf,
                     size_t len)
{
  char str[512];
  size_t i;
  size_t maxlen = sizeof(str) - (unsigned int)1;
  if (ssl->f_dbg == (void (*)(void *, int , char const *))0) goto return_label;
  snprintf(str,maxlen,"%s(%04d): dumping \'%s\' (%d bytes)\n",(char *)file,
           line,(char *)text,(int)len); /* snprintf_va_3 */
  str[maxlen] = (char)'\000';
  (*(ssl->f_dbg))(ssl->p_dbg,level,(char const *)(str));
  i = (size_t)0;
  while (i < len) {
    if (i >= (size_t)4096) break;
    if (i % (unsigned int)16 == (unsigned int)0) {
      if (i > (size_t)0) (*(ssl->f_dbg))(ssl->p_dbg,level,"\n");
      snprintf(str,maxlen,"%s(%04d): %04x: ",(char *)file,line,i); /* snprintf_va_4 */
      str[maxlen] = (char)'\000';
      (*(ssl->f_dbg))(ssl->p_dbg,level,(char const *)(str));
    }
    snprintf(str,maxlen," %02x",(unsigned int)*(buf + i)); /* snprintf_va_5 */
    str[maxlen] = (char)'\000';
    (*(ssl->f_dbg))(ssl->p_dbg,level,(char const *)(str));
    i ++;
  }
  if (len > (size_t)0) (*(ssl->f_dbg))(ssl->p_dbg,level,"\n");
  return_label: return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(param2);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: param3), (indirect: *(param2 + (0 ..))),
            (indirect: param1), (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param3,
            *(param2 + (0 ..)), param1, *(param0 + (0 ..));
 */
int snprintf_va_6(char * restrict s, size_t n, char const * restrict format,
                  char *param0, int param1, char *param2,
                  unsigned long param3);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: param1), (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param1,
            *(param0 + (0 ..));
 */
int snprintf_va_7(char * restrict s, size_t n, char const * restrict format,
                  char *param0, int param1);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))), (indirect: param0);
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param0;
 */
int snprintf_va_8(char * restrict s, size_t n, char const * restrict format,
                  unsigned int param0);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: param1), (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param1,
            *(param0 + (0 ..));
 */
int snprintf_va_9(char * restrict s, size_t n, char const * restrict format,
                  char *param0, int param1);

void debug_print_mpi(ssl_context const *ssl, int level, char const *file,
                     int line, char const *text, mpi const *X)
{
  char str[512];
  int j;
  int k;
  size_t i;
  size_t n;
  int maxlen = (int)(sizeof(str) - (unsigned int)1);
  int zeros = 1;
  if (ssl->f_dbg == (void (*)(void *, int , char const *))0) goto return_label;
  else 
    if (X == (mpi const *)0) goto return_label;
  n = X->n - (size_t)1;
  while (n > (size_t)0) {
    if (*(X->p + n) != (t_uint)0) break;
    n --;
  }
  j = (int)((sizeof(t_uint) << 3) - (unsigned int)1);
  while (j >= 0) {
    if (((*(X->p + n) >> j) & (unsigned long)1) != (unsigned long)0) 
      break;
    j --;
  }
  snprintf(str,(size_t)maxlen,"%s(%04d): value of \'%s\' (%lu bits) is:\n",
           (char *)file,line,(char *)text,
           (unsigned long)((n * (sizeof(t_uint) << 3) + (size_t)j) + (size_t)1)); /* snprintf_va_6 */
  str[maxlen] = (char)'\000';
  (*(ssl->f_dbg))(ssl->p_dbg,level,(char const *)(str));
  i = n + (size_t)1;
  j = 0;
  while (i > (size_t)0) {
    if (zeros) 
      if (*(X->p + (i - (size_t)1)) == (t_uint)0) goto __Cont;
    k = (int)(sizeof(t_uint) - (unsigned int)1);
    while (k >= 0) {
      if (zeros) {
        if (((*(X->p + (i - (size_t)1)) >> (k << 3)) & (unsigned long)0xFF) == (unsigned long)0) 
          goto __Cont_0;
        else zeros = 0;
      }
      else zeros = 0;
      if (j % 16 == 0) {
        if (j > 0) (*(ssl->f_dbg))(ssl->p_dbg,level,"\n");
        snprintf(str,(size_t)maxlen,"%s(%04d): ",(char *)file,line); /* snprintf_va_7 */
        str[maxlen] = (char)'\000';
        (*(ssl->f_dbg))(ssl->p_dbg,level,(char const *)(str));
      }
      snprintf(str,(size_t)maxlen," %02x",
               (unsigned int)(*(X->p + (i - (size_t)1)) >> (k << 3)) & (unsigned int)0xFF); /* snprintf_va_8 */
      str[maxlen] = (char)'\000';
      (*(ssl->f_dbg))(ssl->p_dbg,level,(char const *)(str));
      j ++;
      __Cont_0: k --;
    }
    __Cont: i --;
  }
  if (zeros == 1) {
    snprintf(str,(size_t)maxlen,"%s(%04d): ",(char *)file,line); /* snprintf_va_9 */
    str[maxlen] = (char)'\000';
    (*(ssl->f_dbg))(ssl->p_dbg,level,(char const *)(str));
    (*(ssl->f_dbg))(ssl->p_dbg,level," 00");
  }
  (*(ssl->f_dbg))(ssl->p_dbg,level,"\n");
  return_label: return;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: param1), (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param1,
            *(param0 + (0 ..));
 */
int snprintf_va_10(char * restrict s, size_t n, char const * restrict format,
                   char *param0, int param1);

/*@ requires valid_read_string(param0);
    requires valid_read_string(param2);
    requires valid_read_string(param4);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: *(param4 + (0 ..))), (indirect: param3),
            (indirect: *(param2 + (0 ..))), (indirect: param1),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))),
            *(param4 + (0 ..)), param3, *(param2 + (0 ..)), param1,
            *(param0 + (0 ..));
 */
int snprintf_va_11(char * restrict s, size_t n, char const * restrict format,
                   char *param0, int param1, char *param2, int param3,
                   char *param4);

void debug_print_crt(ssl_context const *ssl, int level, char const *file,
                     int line, char const *text, x509_cert const *crt)
{
  char str[1024];
  char prefix[64];
  int i = 0;
  int maxlen = (int)(sizeof(prefix) - (unsigned int)1);
  if (ssl->f_dbg == (void (*)(void *, int , char const *))0) goto return_label;
  else 
    if (crt == (x509_cert const *)0) goto return_label;
  snprintf(prefix,(size_t)maxlen,"%s(%04d): ",(char *)file,line); /* snprintf_va_10 */
  prefix[maxlen] = (char)'\000';
  maxlen = (int)(sizeof(str) - (unsigned int)1);
  while (crt != (x509_cert const *)0) {
    char buf[1024];
    x509parse_cert_info(buf,sizeof(buf) - (unsigned int)1,
                        (char const *)(prefix),crt);
    i ++;
    ;
    ;
    ;
    ;
    snprintf(str,(size_t)maxlen,"%s(%04d): %s #%d:\n%s",(char *)file,line,
             (char *)text,i,buf); /* snprintf_va_11 */
    str[maxlen] = (char)'\000';
    (*(ssl->f_dbg))(ssl->p_dbg,level,(char const *)(str));
    debug_print_mpi(ssl,level,file,line,"crt->rsa.N",& crt->rsa.N);
    debug_print_mpi(ssl,level,file,line,"crt->rsa.E",& crt->rsa.E);
    crt = (x509_cert const *)crt->next;
  }
  return_label: return;
}

static unsigned long const SB1[64] =
  {(unsigned long)0x01010400,
   (unsigned long)0x00000000,
   (unsigned long)0x00010000,
   (unsigned long)0x01010404,
   (unsigned long)0x01010004,
   (unsigned long)0x00010404,
   (unsigned long)0x00000004,
   (unsigned long)0x00010000,
   (unsigned long)0x00000400,
   (unsigned long)0x01010400,
   (unsigned long)0x01010404,
   (unsigned long)0x00000400,
   (unsigned long)0x01000404,
   (unsigned long)0x01010004,
   (unsigned long)0x01000000,
   (unsigned long)0x00000004,
   (unsigned long)0x00000404,
   (unsigned long)0x01000400,
   (unsigned long)0x01000400,
   (unsigned long)0x00010400,
   (unsigned long)0x00010400,
   (unsigned long)0x01010000,
   (unsigned long)0x01010000,
   (unsigned long)0x01000404,
   (unsigned long)0x00010004,
   (unsigned long)0x01000004,
   (unsigned long)0x01000004,
   (unsigned long)0x00010004,
   (unsigned long)0x00000000,
   (unsigned long)0x00000404,
   (unsigned long)0x00010404,
   (unsigned long)0x01000000,
   (unsigned long)0x00010000,
   (unsigned long)0x01010404,
   (unsigned long)0x00000004,
   (unsigned long)0x01010000,
   (unsigned long)0x01010400,
   (unsigned long)0x01000000,
   (unsigned long)0x01000000,
   (unsigned long)0x00000400,
   (unsigned long)0x01010004,
   (unsigned long)0x00010000,
   (unsigned long)0x00010400,
   (unsigned long)0x01000004,
   (unsigned long)0x00000400,
   (unsigned long)0x00000004,
   (unsigned long)0x01000404,
   (unsigned long)0x00010404,
   (unsigned long)0x01010404,
   (unsigned long)0x00010004,
   (unsigned long)0x01010000,
   (unsigned long)0x01000404,
   (unsigned long)0x01000004,
   (unsigned long)0x00000404,
   (unsigned long)0x00010404,
   (unsigned long)0x01010400,
   (unsigned long)0x00000404,
   (unsigned long)0x01000400,
   (unsigned long)0x01000400,
   (unsigned long)0x00000000,
   (unsigned long)0x00010004,
   (unsigned long)0x00010400,
   (unsigned long)0x00000000,
   (unsigned long)0x01010004};
static unsigned long const SB2[64] =
  {(unsigned long)0x80108020,
   (unsigned long)0x80008000,
   (unsigned long)0x00008000,
   (unsigned long)0x00108020,
   (unsigned long)0x00100000,
   (unsigned long)0x00000020,
   (unsigned long)0x80100020,
   (unsigned long)0x80008020,
   (unsigned long)0x80000020,
   (unsigned long)0x80108020,
   (unsigned long)0x80108000,
   (unsigned long)0x80000000,
   (unsigned long)0x80008000,
   (unsigned long)0x00100000,
   (unsigned long)0x00000020,
   (unsigned long)0x80100020,
   (unsigned long)0x00108000,
   (unsigned long)0x00100020,
   (unsigned long)0x80008020,
   (unsigned long)0x00000000,
   (unsigned long)0x80000000,
   (unsigned long)0x00008000,
   (unsigned long)0x00108020,
   (unsigned long)0x80100000,
   (unsigned long)0x00100020,
   (unsigned long)0x80000020,
   (unsigned long)0x00000000,
   (unsigned long)0x00108000,
   (unsigned long)0x00008020,
   (unsigned long)0x80108000,
   (unsigned long)0x80100000,
   (unsigned long)0x00008020,
   (unsigned long)0x00000000,
   (unsigned long)0x00108020,
   (unsigned long)0x80100020,
   (unsigned long)0x00100000,
   (unsigned long)0x80008020,
   (unsigned long)0x80100000,
   (unsigned long)0x80108000,
   (unsigned long)0x00008000,
   (unsigned long)0x80100000,
   (unsigned long)0x80008000,
   (unsigned long)0x00000020,
   (unsigned long)0x80108020,
   (unsigned long)0x00108020,
   (unsigned long)0x00000020,
   (unsigned long)0x00008000,
   (unsigned long)0x80000000,
   (unsigned long)0x00008020,
   (unsigned long)0x80108000,
   (unsigned long)0x00100000,
   (unsigned long)0x80000020,
   (unsigned long)0x00100020,
   (unsigned long)0x80008020,
   (unsigned long)0x80000020,
   (unsigned long)0x00100020,
   (unsigned long)0x00108000,
   (unsigned long)0x00000000,
   (unsigned long)0x80008000,
   (unsigned long)0x00008020,
   (unsigned long)0x80000000,
   (unsigned long)0x80100020,
   (unsigned long)0x80108020,
   (unsigned long)0x00108000};
static unsigned long const SB3[64] =
  {(unsigned long)0x00000208,
   (unsigned long)0x08020200,
   (unsigned long)0x00000000,
   (unsigned long)0x08020008,
   (unsigned long)0x08000200,
   (unsigned long)0x00000000,
   (unsigned long)0x00020208,
   (unsigned long)0x08000200,
   (unsigned long)0x00020008,
   (unsigned long)0x08000008,
   (unsigned long)0x08000008,
   (unsigned long)0x00020000,
   (unsigned long)0x08020208,
   (unsigned long)0x00020008,
   (unsigned long)0x08020000,
   (unsigned long)0x00000208,
   (unsigned long)0x08000000,
   (unsigned long)0x00000008,
   (unsigned long)0x08020200,
   (unsigned long)0x00000200,
   (unsigned long)0x00020200,
   (unsigned long)0x08020000,
   (unsigned long)0x08020008,
   (unsigned long)0x00020208,
   (unsigned long)0x08000208,
   (unsigned long)0x00020200,
   (unsigned long)0x00020000,
   (unsigned long)0x08000208,
   (unsigned long)0x00000008,
   (unsigned long)0x08020208,
   (unsigned long)0x00000200,
   (unsigned long)0x08000000,
   (unsigned long)0x08020200,
   (unsigned long)0x08000000,
   (unsigned long)0x00020008,
   (unsigned long)0x00000208,
   (unsigned long)0x00020000,
   (unsigned long)0x08020200,
   (unsigned long)0x08000200,
   (unsigned long)0x00000000,
   (unsigned long)0x00000200,
   (unsigned long)0x00020008,
   (unsigned long)0x08020208,
   (unsigned long)0x08000200,
   (unsigned long)0x08000008,
   (unsigned long)0x00000200,
   (unsigned long)0x00000000,
   (unsigned long)0x08020008,
   (unsigned long)0x08000208,
   (unsigned long)0x00020000,
   (unsigned long)0x08000000,
   (unsigned long)0x08020208,
   (unsigned long)0x00000008,
   (unsigned long)0x00020208,
   (unsigned long)0x00020200,
   (unsigned long)0x08000008,
   (unsigned long)0x08020000,
   (unsigned long)0x08000208,
   (unsigned long)0x00000208,
   (unsigned long)0x08020000,
   (unsigned long)0x00020208,
   (unsigned long)0x00000008,
   (unsigned long)0x08020008,
   (unsigned long)0x00020200};
static unsigned long const SB4[64] =
  {(unsigned long)0x00802001,
   (unsigned long)0x00002081,
   (unsigned long)0x00002081,
   (unsigned long)0x00000080,
   (unsigned long)0x00802080,
   (unsigned long)0x00800081,
   (unsigned long)0x00800001,
   (unsigned long)0x00002001,
   (unsigned long)0x00000000,
   (unsigned long)0x00802000,
   (unsigned long)0x00802000,
   (unsigned long)0x00802081,
   (unsigned long)0x00000081,
   (unsigned long)0x00000000,
   (unsigned long)0x00800080,
   (unsigned long)0x00800001,
   (unsigned long)0x00000001,
   (unsigned long)0x00002000,
   (unsigned long)0x00800000,
   (unsigned long)0x00802001,
   (unsigned long)0x00000080,
   (unsigned long)0x00800000,
   (unsigned long)0x00002001,
   (unsigned long)0x00002080,
   (unsigned long)0x00800081,
   (unsigned long)0x00000001,
   (unsigned long)0x00002080,
   (unsigned long)0x00800080,
   (unsigned long)0x00002000,
   (unsigned long)0x00802080,
   (unsigned long)0x00802081,
   (unsigned long)0x00000081,
   (unsigned long)0x00800080,
   (unsigned long)0x00800001,
   (unsigned long)0x00802000,
   (unsigned long)0x00802081,
   (unsigned long)0x00000081,
   (unsigned long)0x00000000,
   (unsigned long)0x00000000,
   (unsigned long)0x00802000,
   (unsigned long)0x00002080,
   (unsigned long)0x00800080,
   (unsigned long)0x00800081,
   (unsigned long)0x00000001,
   (unsigned long)0x00802001,
   (unsigned long)0x00002081,
   (unsigned long)0x00002081,
   (unsigned long)0x00000080,
   (unsigned long)0x00802081,
   (unsigned long)0x00000081,
   (unsigned long)0x00000001,
   (unsigned long)0x00002000,
   (unsigned long)0x00800001,
   (unsigned long)0x00002001,
   (unsigned long)0x00802080,
   (unsigned long)0x00800081,
   (unsigned long)0x00002001,
   (unsigned long)0x00002080,
   (unsigned long)0x00800000,
   (unsigned long)0x00802001,
   (unsigned long)0x00000080,
   (unsigned long)0x00800000,
   (unsigned long)0x00002000,
   (unsigned long)0x00802080};
static unsigned long const SB5[64] =
  {(unsigned long)0x00000100,
   (unsigned long)0x02080100,
   (unsigned long)0x02080000,
   (unsigned long)0x42000100,
   (unsigned long)0x00080000,
   (unsigned long)0x00000100,
   (unsigned long)0x40000000,
   (unsigned long)0x02080000,
   (unsigned long)0x40080100,
   (unsigned long)0x00080000,
   (unsigned long)0x02000100,
   (unsigned long)0x40080100,
   (unsigned long)0x42000100,
   (unsigned long)0x42080000,
   (unsigned long)0x00080100,
   (unsigned long)0x40000000,
   (unsigned long)0x02000000,
   (unsigned long)0x40080000,
   (unsigned long)0x40080000,
   (unsigned long)0x00000000,
   (unsigned long)0x40000100,
   (unsigned long)0x42080100,
   (unsigned long)0x42080100,
   (unsigned long)0x02000100,
   (unsigned long)0x42080000,
   (unsigned long)0x40000100,
   (unsigned long)0x00000000,
   (unsigned long)0x42000000,
   (unsigned long)0x02080100,
   (unsigned long)0x02000000,
   (unsigned long)0x42000000,
   (unsigned long)0x00080100,
   (unsigned long)0x00080000,
   (unsigned long)0x42000100,
   (unsigned long)0x00000100,
   (unsigned long)0x02000000,
   (unsigned long)0x40000000,
   (unsigned long)0x02080000,
   (unsigned long)0x42000100,
   (unsigned long)0x40080100,
   (unsigned long)0x02000100,
   (unsigned long)0x40000000,
   (unsigned long)0x42080000,
   (unsigned long)0x02080100,
   (unsigned long)0x40080100,
   (unsigned long)0x00000100,
   (unsigned long)0x02000000,
   (unsigned long)0x42080000,
   (unsigned long)0x42080100,
   (unsigned long)0x00080100,
   (unsigned long)0x42000000,
   (unsigned long)0x42080100,
   (unsigned long)0x02080000,
   (unsigned long)0x00000000,
   (unsigned long)0x40080000,
   (unsigned long)0x42000000,
   (unsigned long)0x00080100,
   (unsigned long)0x02000100,
   (unsigned long)0x40000100,
   (unsigned long)0x00080000,
   (unsigned long)0x00000000,
   (unsigned long)0x40080000,
   (unsigned long)0x02080100,
   (unsigned long)0x40000100};
static unsigned long const SB6[64] =
  {(unsigned long)0x20000010,
   (unsigned long)0x20400000,
   (unsigned long)0x00004000,
   (unsigned long)0x20404010,
   (unsigned long)0x20400000,
   (unsigned long)0x00000010,
   (unsigned long)0x20404010,
   (unsigned long)0x00400000,
   (unsigned long)0x20004000,
   (unsigned long)0x00404010,
   (unsigned long)0x00400000,
   (unsigned long)0x20000010,
   (unsigned long)0x00400010,
   (unsigned long)0x20004000,
   (unsigned long)0x20000000,
   (unsigned long)0x00004010,
   (unsigned long)0x00000000,
   (unsigned long)0x00400010,
   (unsigned long)0x20004010,
   (unsigned long)0x00004000,
   (unsigned long)0x00404000,
   (unsigned long)0x20004010,
   (unsigned long)0x00000010,
   (unsigned long)0x20400010,
   (unsigned long)0x20400010,
   (unsigned long)0x00000000,
   (unsigned long)0x00404010,
   (unsigned long)0x20404000,
   (unsigned long)0x00004010,
   (unsigned long)0x00404000,
   (unsigned long)0x20404000,
   (unsigned long)0x20000000,
   (unsigned long)0x20004000,
   (unsigned long)0x00000010,
   (unsigned long)0x20400010,
   (unsigned long)0x00404000,
   (unsigned long)0x20404010,
   (unsigned long)0x00400000,
   (unsigned long)0x00004010,
   (unsigned long)0x20000010,
   (unsigned long)0x00400000,
   (unsigned long)0x20004000,
   (unsigned long)0x20000000,
   (unsigned long)0x00004010,
   (unsigned long)0x20000010,
   (unsigned long)0x20404010,
   (unsigned long)0x00404000,
   (unsigned long)0x20400000,
   (unsigned long)0x00404010,
   (unsigned long)0x20404000,
   (unsigned long)0x00000000,
   (unsigned long)0x20400010,
   (unsigned long)0x00000010,
   (unsigned long)0x00004000,
   (unsigned long)0x20400000,
   (unsigned long)0x00404010,
   (unsigned long)0x00004000,
   (unsigned long)0x00400010,
   (unsigned long)0x20004010,
   (unsigned long)0x00000000,
   (unsigned long)0x20404000,
   (unsigned long)0x20000000,
   (unsigned long)0x00400010,
   (unsigned long)0x20004010};
static unsigned long const SB7[64] =
  {(unsigned long)0x00200000,
   (unsigned long)0x04200002,
   (unsigned long)0x04000802,
   (unsigned long)0x00000000,
   (unsigned long)0x00000800,
   (unsigned long)0x04000802,
   (unsigned long)0x00200802,
   (unsigned long)0x04200800,
   (unsigned long)0x04200802,
   (unsigned long)0x00200000,
   (unsigned long)0x00000000,
   (unsigned long)0x04000002,
   (unsigned long)0x00000002,
   (unsigned long)0x04000000,
   (unsigned long)0x04200002,
   (unsigned long)0x00000802,
   (unsigned long)0x04000800,
   (unsigned long)0x00200802,
   (unsigned long)0x00200002,
   (unsigned long)0x04000800,
   (unsigned long)0x04000002,
   (unsigned long)0x04200000,
   (unsigned long)0x04200800,
   (unsigned long)0x00200002,
   (unsigned long)0x04200000,
   (unsigned long)0x00000800,
   (unsigned long)0x00000802,
   (unsigned long)0x04200802,
   (unsigned long)0x00200800,
   (unsigned long)0x00000002,
   (unsigned long)0x04000000,
   (unsigned long)0x00200800,
   (unsigned long)0x04000000,
   (unsigned long)0x00200800,
   (unsigned long)0x00200000,
   (unsigned long)0x04000802,
   (unsigned long)0x04000802,
   (unsigned long)0x04200002,
   (unsigned long)0x04200002,
   (unsigned long)0x00000002,
   (unsigned long)0x00200002,
   (unsigned long)0x04000000,
   (unsigned long)0x04000800,
   (unsigned long)0x00200000,
   (unsigned long)0x04200800,
   (unsigned long)0x00000802,
   (unsigned long)0x00200802,
   (unsigned long)0x04200800,
   (unsigned long)0x00000802,
   (unsigned long)0x04000002,
   (unsigned long)0x04200802,
   (unsigned long)0x04200000,
   (unsigned long)0x00200800,
   (unsigned long)0x00000000,
   (unsigned long)0x00000002,
   (unsigned long)0x04200802,
   (unsigned long)0x00000000,
   (unsigned long)0x00200802,
   (unsigned long)0x04200000,
   (unsigned long)0x00000800,
   (unsigned long)0x04000002,
   (unsigned long)0x04000800,
   (unsigned long)0x00000800,
   (unsigned long)0x00200002};
static unsigned long const SB8[64] =
  {(unsigned long)0x10001040,
   (unsigned long)0x00001000,
   (unsigned long)0x00040000,
   (unsigned long)0x10041040,
   (unsigned long)0x10000000,
   (unsigned long)0x10001040,
   (unsigned long)0x00000040,
   (unsigned long)0x10000000,
   (unsigned long)0x00040040,
   (unsigned long)0x10040000,
   (unsigned long)0x10041040,
   (unsigned long)0x00041000,
   (unsigned long)0x10041000,
   (unsigned long)0x00041040,
   (unsigned long)0x00001000,
   (unsigned long)0x00000040,
   (unsigned long)0x10040000,
   (unsigned long)0x10000040,
   (unsigned long)0x10001000,
   (unsigned long)0x00001040,
   (unsigned long)0x00041000,
   (unsigned long)0x00040040,
   (unsigned long)0x10040040,
   (unsigned long)0x10041000,
   (unsigned long)0x00001040,
   (unsigned long)0x00000000,
   (unsigned long)0x00000000,
   (unsigned long)0x10040040,
   (unsigned long)0x10000040,
   (unsigned long)0x10001000,
   (unsigned long)0x00041040,
   (unsigned long)0x00040000,
   (unsigned long)0x00041040,
   (unsigned long)0x00040000,
   (unsigned long)0x10041000,
   (unsigned long)0x00001000,
   (unsigned long)0x00000040,
   (unsigned long)0x10040040,
   (unsigned long)0x00001000,
   (unsigned long)0x00041040,
   (unsigned long)0x10001000,
   (unsigned long)0x00000040,
   (unsigned long)0x10000040,
   (unsigned long)0x10040000,
   (unsigned long)0x10040040,
   (unsigned long)0x10000000,
   (unsigned long)0x00040000,
   (unsigned long)0x10001040,
   (unsigned long)0x00000000,
   (unsigned long)0x10041040,
   (unsigned long)0x00040040,
   (unsigned long)0x10000040,
   (unsigned long)0x10040000,
   (unsigned long)0x10001000,
   (unsigned long)0x10001040,
   (unsigned long)0x00000000,
   (unsigned long)0x10041040,
   (unsigned long)0x00041000,
   (unsigned long)0x00041000,
   (unsigned long)0x00001040,
   (unsigned long)0x00001040,
   (unsigned long)0x00040040,
   (unsigned long)0x10000000,
   (unsigned long)0x10041000};
static unsigned long const LHs[16] =
  {(unsigned long)0x00000000,
   (unsigned long)0x00000001,
   (unsigned long)0x00000100,
   (unsigned long)0x00000101,
   (unsigned long)0x00010000,
   (unsigned long)0x00010001,
   (unsigned long)0x00010100,
   (unsigned long)0x00010101,
   (unsigned long)0x01000000,
   (unsigned long)0x01000001,
   (unsigned long)0x01000100,
   (unsigned long)0x01000101,
   (unsigned long)0x01010000,
   (unsigned long)0x01010001,
   (unsigned long)0x01010100,
   (unsigned long)0x01010101};
static unsigned long const RHs[16] =
  {(unsigned long)0x00000000,
   (unsigned long)0x01000000,
   (unsigned long)0x00010000,
   (unsigned long)0x01010000,
   (unsigned long)0x00000100,
   (unsigned long)0x01000100,
   (unsigned long)0x00010100,
   (unsigned long)0x01010100,
   (unsigned long)0x00000001,
   (unsigned long)0x01000001,
   (unsigned long)0x00010001,
   (unsigned long)0x01010001,
   (unsigned long)0x00000101,
   (unsigned long)0x01000101,
   (unsigned long)0x00010101,
   (unsigned long)0x01010101};
static unsigned char const odd_parity_table[128] =
  {(unsigned char)1,
   (unsigned char)2,
   (unsigned char)4,
   (unsigned char)7,
   (unsigned char)8,
   (unsigned char)11,
   (unsigned char)13,
   (unsigned char)14,
   (unsigned char)16,
   (unsigned char)19,
   (unsigned char)21,
   (unsigned char)22,
   (unsigned char)25,
   (unsigned char)26,
   (unsigned char)28,
   (unsigned char)31,
   (unsigned char)32,
   (unsigned char)35,
   (unsigned char)37,
   (unsigned char)38,
   (unsigned char)41,
   (unsigned char)42,
   (unsigned char)44,
   (unsigned char)47,
   (unsigned char)49,
   (unsigned char)50,
   (unsigned char)52,
   (unsigned char)55,
   (unsigned char)56,
   (unsigned char)59,
   (unsigned char)61,
   (unsigned char)62,
   (unsigned char)64,
   (unsigned char)67,
   (unsigned char)69,
   (unsigned char)70,
   (unsigned char)73,
   (unsigned char)74,
   (unsigned char)76,
   (unsigned char)79,
   (unsigned char)81,
   (unsigned char)82,
   (unsigned char)84,
   (unsigned char)87,
   (unsigned char)88,
   (unsigned char)91,
   (unsigned char)93,
   (unsigned char)94,
   (unsigned char)97,
   (unsigned char)98,
   (unsigned char)100,
   (unsigned char)103,
   (unsigned char)104,
   (unsigned char)107,
   (unsigned char)109,
   (unsigned char)110,
   (unsigned char)112,
   (unsigned char)115,
   (unsigned char)117,
   (unsigned char)118,
   (unsigned char)121,
   (unsigned char)122,
   (unsigned char)124,
   (unsigned char)127,
   (unsigned char)128,
   (unsigned char)131,
   (unsigned char)133,
   (unsigned char)134,
   (unsigned char)137,
   (unsigned char)138,
   (unsigned char)140,
   (unsigned char)143,
   (unsigned char)145,
   (unsigned char)146,
   (unsigned char)148,
   (unsigned char)151,
   (unsigned char)152,
   (unsigned char)155,
   (unsigned char)157,
   (unsigned char)158,
   (unsigned char)161,
   (unsigned char)162,
   (unsigned char)164,
   (unsigned char)167,
   (unsigned char)168,
   (unsigned char)171,
   (unsigned char)173,
   (unsigned char)174,
   (unsigned char)176,
   (unsigned char)179,
   (unsigned char)181,
   (unsigned char)182,
   (unsigned char)185,
   (unsigned char)186,
   (unsigned char)188,
   (unsigned char)191,
   (unsigned char)193,
   (unsigned char)194,
   (unsigned char)196,
   (unsigned char)199,
   (unsigned char)200,
   (unsigned char)203,
   (unsigned char)205,
   (unsigned char)206,
   (unsigned char)208,
   (unsigned char)211,
   (unsigned char)213,
   (unsigned char)214,
   (unsigned char)217,
   (unsigned char)218,
   (unsigned char)220,
   (unsigned char)223,
   (unsigned char)224,
   (unsigned char)227,
   (unsigned char)229,
   (unsigned char)230,
   (unsigned char)233,
   (unsigned char)234,
   (unsigned char)236,
   (unsigned char)239,
   (unsigned char)241,
   (unsigned char)242,
   (unsigned char)244,
   (unsigned char)247,
   (unsigned char)248,
   (unsigned char)251,
   (unsigned char)253,
   (unsigned char)254};
void des_key_set_parity(unsigned char key[8])
{
  int i;
  i = 0;
  while (i < 8) {
    *(key + i) = odd_parity_table[(int)*(key + i) / 2];
    i ++;
  }
  return;
}

int des_key_check_key_parity(unsigned char const key[8])
{
  int __retres;
  int i;
  i = 0;
  while (i < 8) {
    if ((int)*(key + i) != (int)odd_parity_table[(int)*(key + i) / 2]) {
      __retres = 1;
      goto return_label;
    }
    i ++;
  }
  __retres = 0;
  return_label: return __retres;
}

static unsigned char const weak_key_table[16][8] =
  {{(unsigned char)0x01,
    (unsigned char)0x01,
    (unsigned char)0x01,
    (unsigned char)0x01,
    (unsigned char)0x01,
    (unsigned char)0x01,
    (unsigned char)0x01,
    (unsigned char)0x01},
   {(unsigned char)0xFE,
    (unsigned char)0xFE,
    (unsigned char)0xFE,
    (unsigned char)0xFE,
    (unsigned char)0xFE,
    (unsigned char)0xFE,
    (unsigned char)0xFE,
    (unsigned char)0xFE},
   {(unsigned char)0x1F,
    (unsigned char)0x1F,
    (unsigned char)0x1F,
    (unsigned char)0x1F,
    (unsigned char)0x0E,
    (unsigned char)0x0E,
    (unsigned char)0x0E,
    (unsigned char)0x0E},
   {(unsigned char)0xE0,
    (unsigned char)0xE0,
    (unsigned char)0xE0,
    (unsigned char)0xE0,
    (unsigned char)0xF1,
    (unsigned char)0xF1,
    (unsigned char)0xF1,
    (unsigned char)0xF1},
   {(unsigned char)0x01,
    (unsigned char)0x1F,
    (unsigned char)0x01,
    (unsigned char)0x1F,
    (unsigned char)0x01,
    (unsigned char)0x0E,
    (unsigned char)0x01,
    (unsigned char)0x0E},
   {(unsigned char)0x1F,
    (unsigned char)0x01,
    (unsigned char)0x1F,
    (unsigned char)0x01,
    (unsigned char)0x0E,
    (unsigned char)0x01,
    (unsigned char)0x0E,
    (unsigned char)0x01},
   {(unsigned char)0x01,
    (unsigned char)0xE0,
    (unsigned char)0x01,
    (unsigned char)0xE0,
    (unsigned char)0x01,
    (unsigned char)0xF1,
    (unsigned char)0x01,
    (unsigned char)0xF1},
   {(unsigned char)0xE0,
    (unsigned char)0x01,
    (unsigned char)0xE0,
    (unsigned char)0x01,
    (unsigned char)0xF1,
    (unsigned char)0x01,
    (unsigned char)0xF1,
    (unsigned char)0x01},
   {(unsigned char)0x01,
    (unsigned char)0xFE,
    (unsigned char)0x01,
    (unsigned char)0xFE,
    (unsigned char)0x01,
    (unsigned char)0xFE,
    (unsigned char)0x01,
    (unsigned char)0xFE},
   {(unsigned char)0xFE,
    (unsigned char)0x01,
    (unsigned char)0xFE,
    (unsigned char)0x01,
    (unsigned char)0xFE,
    (unsigned char)0x01,
    (unsigned char)0xFE,
    (unsigned char)0x01},
   {(unsigned char)0x1F,
    (unsigned char)0xE0,
    (unsigned char)0x1F,
    (unsigned char)0xE0,
    (unsigned char)0x0E,
    (unsigned char)0xF1,
    (unsigned char)0x0E,
    (unsigned char)0xF1},
   {(unsigned char)0xE0,
    (unsigned char)0x1F,
    (unsigned char)0xE0,
    (unsigned char)0x1F,
    (unsigned char)0xF1,
    (unsigned char)0x0E,
    (unsigned char)0xF1,
    (unsigned char)0x0E},
   {(unsigned char)0x1F,
    (unsigned char)0xFE,
    (unsigned char)0x1F,
    (unsigned char)0xFE,
    (unsigned char)0x0E,
    (unsigned char)0xFE,
    (unsigned char)0x0E,
    (unsigned char)0xFE},
   {(unsigned char)0xFE,
    (unsigned char)0x1F,
    (unsigned char)0xFE,
    (unsigned char)0x1F,
    (unsigned char)0xFE,
    (unsigned char)0x0E,
    (unsigned char)0xFE,
    (unsigned char)0x0E},
   {(unsigned char)0xE0,
    (unsigned char)0xFE,
    (unsigned char)0xE0,
    (unsigned char)0xFE,
    (unsigned char)0xF1,
    (unsigned char)0xFE,
    (unsigned char)0xF1,
    (unsigned char)0xFE},
   {(unsigned char)0xFE,
    (unsigned char)0xE0,
    (unsigned char)0xFE,
    (unsigned char)0xE0,
    (unsigned char)0xFE,
    (unsigned char)0xF1,
    (unsigned char)0xFE,
    (unsigned char)0xF1}};
int des_key_check_weak(unsigned char const key[8])
{
  int __retres;
  int i;
  i = 0;
  while (i < 16) {
    int tmp;
    tmp = memcmp((void const *)(weak_key_table[i]),(void const *)key,
                 (size_t)8);
    if (tmp == 0) {
      __retres = 1;
      goto return_label;
    }
    i ++;
  }
  __retres = 0;
  return_label: return __retres;
}

/*@ requires \valid(SK);
    requires \valid_read(key);
    ensures \initialized(\old(SK) + (0 .. 31));
    assigns *(SK + (0 .. 31)), _state;
    assigns *(SK + (0 .. 31)) \from _state;
    assigns _state \from _state;
 */
static void des_setkey(unsigned long SK[32], unsigned char const key[8])
{
  int i;
  unsigned long X;
  unsigned long Y;
  unsigned long T;
  X = ((((unsigned long)*(key + 0) << 24) | ((unsigned long)*(key + (0 + 1)) << 16)) | (
       (unsigned long)*(key + (0 + 2)) << 8)) | (unsigned long)*(key + (
                                                                 0 + 3));
  Y = ((((unsigned long)*(key + 4) << 24) | ((unsigned long)*(key + (4 + 1)) << 16)) | (
       (unsigned long)*(key + (4 + 2)) << 8)) | (unsigned long)*(key + (
                                                                 4 + 3));
  T = ((Y >> 4) ^ X) & (unsigned long)0x0F0F0F0F;
  X ^= T;
  Y ^= T << 4;
  T = (Y ^ X) & (unsigned long)0x10101010;
  X ^= T;
  Y ^= T;
  X = (((((((LHs[X & (unsigned long)0xF] << 3) | (LHs[(X >> 8) & (unsigned long)0xF] << 2)) | (
           LHs[(X >> 16) & (unsigned long)0xF] << 1)) | LHs[(X >> 24) & (unsigned long)0xF]) | (
         LHs[(X >> 5) & (unsigned long)0xF] << 7)) | (LHs[(X >> 13) & (unsigned long)0xF] << 6)) | (
       LHs[(X >> 21) & (unsigned long)0xF] << 5)) | (LHs[(X >> 29) & (unsigned long)0xF] << 4);
  Y = (((((((RHs[(Y >> 1) & (unsigned long)0xF] << 3) | (RHs[(Y >> 9) & (unsigned long)0xF] << 2)) | (
           RHs[(Y >> 17) & (unsigned long)0xF] << 1)) | RHs[(Y >> 25) & (unsigned long)0xF]) | (
         RHs[(Y >> 4) & (unsigned long)0xF] << 7)) | (RHs[(Y >> 12) & (unsigned long)0xF] << 6)) | (
       RHs[(Y >> 20) & (unsigned long)0xF] << 5)) | (RHs[(Y >> 28) & (unsigned long)0xF] << 4);
  X &= (unsigned long)0x0FFFFFFF;
  Y &= (unsigned long)0x0FFFFFFF;
  i = 0;
  while (i < 16) {
    {
      unsigned long * /*[32]*/ tmp;
      unsigned long * /*[32]*/ tmp_0;
      if (i < 2) goto _LOR;
      else 
        if (i == 8) goto _LOR;
        else 
          if (i == 15) {
            _LOR:
            {
              X = ((X << 1) | (X >> 27)) & (unsigned long)0x0FFFFFFF;
              Y = ((Y << 1) | (Y >> 27)) & (unsigned long)0x0FFFFFFF;
            }
          }
          else {
            X = ((X << 2) | (X >> 26)) & (unsigned long)0x0FFFFFFF;
            Y = ((Y << 2) | (Y >> 26)) & (unsigned long)0x0FFFFFFF;
          }
      tmp = SK;
      SK ++;
      *tmp = ((((((((((((((((((((((X << 4) & (unsigned long)0x24000000) | (
                                 (X << 28) & (unsigned long)0x10000000)) | (
                                (X << 14) & (unsigned long)0x08000000)) | (
                               (X << 18) & (unsigned long)0x02080000)) | (
                              (X << 6) & (unsigned long)0x01000000)) | (
                             (X << 9) & (unsigned long)0x00200000)) | (
                            (X >> 1) & (unsigned long)0x00100000)) | (
                           (X << 10) & (unsigned long)0x00040000)) | (
                          (X << 2) & (unsigned long)0x00020000)) | ((
                                                                    X >> 10) & (unsigned long)0x00010000)) | (
                        (Y >> 13) & (unsigned long)0x00002000)) | ((Y >> 4) & (unsigned long)0x00001000)) | (
                      (Y << 6) & (unsigned long)0x00000800)) | ((Y >> 1) & (unsigned long)0x00000400)) | (
                    (Y >> 14) & (unsigned long)0x00000200)) | (Y & (unsigned long)0x00000100)) | (
                  (Y >> 5) & (unsigned long)0x00000020)) | ((Y >> 10) & (unsigned long)0x00000010)) | (
                (Y >> 3) & (unsigned long)0x00000008)) | ((Y >> 18) & (unsigned long)0x00000004)) | (
              (Y >> 26) & (unsigned long)0x00000002)) | ((Y >> 24) & (unsigned long)0x00000001);
      tmp_0 = SK;
      SK ++;
      *tmp_0 = ((((((((((((((((((((((X << 15) & (unsigned long)0x20000000) | (
                                   (X << 17) & (unsigned long)0x10000000)) | (
                                  (X << 10) & (unsigned long)0x08000000)) | (
                                 (X << 22) & (unsigned long)0x04000000)) | (
                                (X >> 2) & (unsigned long)0x02000000)) | (
                               (X << 1) & (unsigned long)0x01000000)) | (
                              (X << 16) & (unsigned long)0x00200000)) | (
                             (X << 11) & (unsigned long)0x00100000)) | (
                            (X << 3) & (unsigned long)0x00080000)) | (
                           (X >> 6) & (unsigned long)0x00040000)) | (
                          (X << 15) & (unsigned long)0x00020000)) | (
                         (X >> 4) & (unsigned long)0x00010000)) | ((Y >> 2) & (unsigned long)0x00002000)) | (
                       (Y << 8) & (unsigned long)0x00001000)) | ((Y >> 14) & (unsigned long)0x00000808)) | (
                     (Y >> 9) & (unsigned long)0x00000400)) | (Y & (unsigned long)0x00000200)) | (
                   (Y << 7) & (unsigned long)0x00000100)) | ((Y >> 7) & (unsigned long)0x00000020)) | (
                 (Y >> 3) & (unsigned long)0x00000011)) | ((Y << 2) & (unsigned long)0x00000004)) | (
               (Y >> 21) & (unsigned long)0x00000002);
    }
    i ++;
  }
  return;
}

int des_setkey_enc(des_context *ctx, unsigned char const key[8])
{
  int __retres;
  des_setkey(ctx->sk,key);
  __retres = 0;
  return __retres;
}

int des_setkey_dec(des_context *ctx, unsigned char const key[8])
{
  int __retres;
  int i;
  des_setkey(ctx->sk,key);
  i = 0;
  while (i < 16) {
    {
      unsigned long t = ctx->sk[i];
      ctx->sk[i] = ctx->sk[30 - i];
      ctx->sk[30 - i] = t;
      t = (unsigned long)0;
    }
    {
      unsigned long t_0 = ctx->sk[i + 1];
      ctx->sk[i + 1] = ctx->sk[31 - i];
      ctx->sk[31 - i] = t_0;
      t_0 = (unsigned long)0;
    }
    i += 2;
  }
  __retres = 0;
  return __retres;
}

static void des3_set2key(unsigned long esk[96], unsigned long dsk[96],
                         unsigned char const key[16])
{
  int i;
  des_setkey(esk,key);
  des_setkey(dsk + 32,key + 8);
  i = 0;
  while (i < 32) {
    *(dsk + i) = *(esk + (30 - i));
    *(dsk + (i + 1)) = *(esk + (31 - i));
    *(esk + (i + 32)) = *(dsk + (62 - i));
    *(esk + (i + 33)) = *(dsk + (63 - i));
    *(esk + (i + 64)) = *(esk + i);
    *(esk + (i + 65)) = *(esk + (i + 1));
    *(dsk + (i + 64)) = *(dsk + i);
    *(dsk + (i + 65)) = *(dsk + (i + 1));
    i += 2;
  }
  return;
}

int des3_set2key_enc(des3_context *ctx, unsigned char const key[16])
{
  int __retres;
  unsigned long sk[96];
  des3_set2key(ctx->sk,sk,key);
  memset((void *)(sk),0,sizeof(sk));
  __retres = 0;
  return __retres;
}

int des3_set2key_dec(des3_context *ctx, unsigned char const key[16])
{
  int __retres;
  unsigned long sk[96];
  des3_set2key(sk,ctx->sk,key);
  memset((void *)(sk),0,sizeof(sk));
  __retres = 0;
  return __retres;
}

static void des3_set3key(unsigned long esk[96], unsigned long dsk[96],
                         unsigned char const key[24])
{
  int i;
  des_setkey(esk,key);
  des_setkey(dsk + 32,key + 8);
  des_setkey(esk + 64,key + 16);
  i = 0;
  /*@ loop unroll 16; */
  while (i < 32) {
    *(dsk + i) = *(esk + (94 - i));
    *(dsk + (i + 1)) = *(esk + (95 - i));
    *(esk + (i + 32)) = *(dsk + (62 - i));
    *(esk + (i + 33)) = *(dsk + (63 - i));
    *(dsk + (i + 64)) = *(esk + (30 - i));
    *(dsk + (i + 65)) = *(esk + (31 - i));
    i += 2;
  }
  return;
}

int des3_set3key_enc(des3_context *ctx, unsigned char const key[24])
{
  int __retres;
  unsigned long sk[96];
  des3_set3key(ctx->sk,sk,key);
  memset((void *)(sk),0,sizeof(sk));
  __retres = 0;
  return __retres;
}

int des3_set3key_dec(des3_context *ctx, unsigned char const key[24])
{
  int __retres;
  unsigned long sk[96];
  des3_set3key(sk,ctx->sk,key);
  memset((void *)(sk),0,sizeof(sk));
  __retres = 0;
  return __retres;
}

int des_crypt_ecb(des_context *ctx, unsigned char const input[8],
                  unsigned char output[8])
{
  int __retres;
  int i;
  unsigned long X;
  unsigned long Y;
  unsigned long T;
  unsigned long *SK;
  SK = ctx->sk;
  X = ((((unsigned long)*(input + 0) << 24) | ((unsigned long)*(input + (
                                                                0 + 1)) << 16)) | (
       (unsigned long)*(input + (0 + 2)) << 8)) | (unsigned long)*(input + (
                                                                   0 + 3));
  Y = ((((unsigned long)*(input + 4) << 24) | ((unsigned long)*(input + (
                                                                4 + 1)) << 16)) | (
       (unsigned long)*(input + (4 + 2)) << 8)) | (unsigned long)*(input + (
                                                                   4 + 3));
  T = ((X >> 4) ^ Y) & (unsigned long)0x0F0F0F0F;
  Y ^= T;
  X ^= T << 4;
  T = ((X >> 16) ^ Y) & (unsigned long)0x0000FFFF;
  Y ^= T;
  X ^= T << 16;
  T = ((Y >> 2) ^ X) & (unsigned long)0x33333333;
  X ^= T;
  Y ^= T << 2;
  T = ((Y >> 8) ^ X) & (unsigned long)0x00FF00FF;
  X ^= T;
  Y ^= T << 8;
  Y = ((Y << 1) | (Y >> 31)) & (unsigned long)0xFFFFFFFF;
  T = (X ^ Y) & (unsigned long)0xAAAAAAAA;
  Y ^= T;
  X ^= T;
  X = ((X << 1) | (X >> 31)) & (unsigned long)0xFFFFFFFF;
  i = 0;
  while (i < 8) {
    {
      unsigned long *tmp;
      unsigned long *tmp_0;
      tmp = SK;
      SK ++;
      T = *tmp ^ Y;
      X ^= ((SB8[T & (unsigned long)0x3F] ^ SB6[(T >> 8) & (unsigned long)0x3F]) ^ SB4[
            (T >> 16) & (unsigned long)0x3F]) ^ SB2[(T >> 24) & (unsigned long)0x3F];
      tmp_0 = SK;
      SK ++;
      T = *tmp_0 ^ ((Y << 28) | (Y >> 4));
      X ^= ((SB7[T & (unsigned long)0x3F] ^ SB5[(T >> 8) & (unsigned long)0x3F]) ^ SB3[
            (T >> 16) & (unsigned long)0x3F]) ^ SB1[(T >> 24) & (unsigned long)0x3F];
    }
    {
      unsigned long *tmp_1;
      unsigned long *tmp_2;
      tmp_1 = SK;
      SK ++;
      T = *tmp_1 ^ X;
      Y ^= ((SB8[T & (unsigned long)0x3F] ^ SB6[(T >> 8) & (unsigned long)0x3F]) ^ SB4[
            (T >> 16) & (unsigned long)0x3F]) ^ SB2[(T >> 24) & (unsigned long)0x3F];
      tmp_2 = SK;
      SK ++;
      T = *tmp_2 ^ ((X << 28) | (X >> 4));
      Y ^= ((SB7[T & (unsigned long)0x3F] ^ SB5[(T >> 8) & (unsigned long)0x3F]) ^ SB3[
            (T >> 16) & (unsigned long)0x3F]) ^ SB1[(T >> 24) & (unsigned long)0x3F];
    }
    i ++;
  }
  Y = ((Y << 31) | (Y >> 1)) & (unsigned long)0xFFFFFFFF;
  T = (Y ^ X) & (unsigned long)0xAAAAAAAA;
  Y ^= T;
  X ^= T;
  X = ((X << 31) | (X >> 1)) & (unsigned long)0xFFFFFFFF;
  T = ((X >> 8) ^ Y) & (unsigned long)0x00FF00FF;
  Y ^= T;
  X ^= T << 8;
  T = ((X >> 2) ^ Y) & (unsigned long)0x33333333;
  Y ^= T;
  X ^= T << 2;
  T = ((Y >> 16) ^ X) & (unsigned long)0x0000FFFF;
  X ^= T;
  Y ^= T << 16;
  T = ((Y >> 4) ^ X) & (unsigned long)0x0F0F0F0F;
  X ^= T;
  Y ^= T << 4;
  *(output + 0) = (unsigned char)(Y >> 24);
  *(output + (0 + 1)) = (unsigned char)(Y >> 16);
  *(output + (0 + 2)) = (unsigned char)(Y >> 8);
  *(output + (0 + 3)) = (unsigned char)Y;
  *(output + 4) = (unsigned char)(X >> 24);
  *(output + (4 + 1)) = (unsigned char)(X >> 16);
  *(output + (4 + 2)) = (unsigned char)(X >> 8);
  *(output + (4 + 3)) = (unsigned char)X;
  __retres = 0;
  return __retres;
}

int des_crypt_cbc(des_context *ctx, int mode, size_t length,
                  unsigned char iv[8], unsigned char const *input,
                  unsigned char *output)
{
  int __retres;
  int i;
  unsigned char temp[8];
  if (length % (unsigned int)8) {
    __retres = -0x0032;
    goto return_label;
  }
  if (mode == 1) 
    while (length > (size_t)0) {
      i = 0;
      while (i < 8) {
        *(output + i) = (unsigned char)((int)*(input + i) ^ (int)*(iv + i));
        i ++;
      }
      des_crypt_ecb(ctx,(unsigned char const *)output,output);
      memcpy((void *)iv,(void const *)output,(size_t)8);
      input += 8;
      output += 8;
      length -= (size_t)8;
    }
  else 
    while (length > (size_t)0) {
      memcpy((void *)(temp),(void const *)input,(size_t)8);
      des_crypt_ecb(ctx,input,output);
      i = 0;
      while (i < 8) {
        *(output + i) = (unsigned char)((int)*(output + i) ^ (int)*(iv + i));
        i ++;
      }
      memcpy((void *)iv,(void const *)(temp),(size_t)8);
      input += 8;
      output += 8;
      length -= (size_t)8;
    }
  __retres = 0;
  return_label: return __retres;
}

/*@ requires \valid(ctx);
    requires \initialized(input + (0 .. 7));
    ensures \initialized(\old(output) + (0 .. 7));
    assigns \result, _state, *(output + (0 .. 7));
    assigns \result \from _state;
    assigns _state \from _state;
    assigns *(output + (0 .. 7)) \from *(input + (0 .. 7));
 */
int des3_crypt_ecb(des3_context *ctx, unsigned char const input[8],
                   unsigned char output[8])
{
  int __retres;
  int i;
  unsigned long X;
  unsigned long Y;
  unsigned long T;
  unsigned long *SK;
  SK = ctx->sk;
  X = ((((unsigned long)*(input + 0) << 24) | ((unsigned long)*(input + (
                                                                0 + 1)) << 16)) | (
       (unsigned long)*(input + (0 + 2)) << 8)) | (unsigned long)*(input + (
                                                                   0 + 3));
  Y = ((((unsigned long)*(input + 4) << 24) | ((unsigned long)*(input + (
                                                                4 + 1)) << 16)) | (
       (unsigned long)*(input + (4 + 2)) << 8)) | (unsigned long)*(input + (
                                                                   4 + 3));
  T = ((X >> 4) ^ Y) & (unsigned long)0x0F0F0F0F;
  Y ^= T;
  X ^= T << 4;
  T = ((X >> 16) ^ Y) & (unsigned long)0x0000FFFF;
  Y ^= T;
  X ^= T << 16;
  T = ((Y >> 2) ^ X) & (unsigned long)0x33333333;
  X ^= T;
  Y ^= T << 2;
  T = ((Y >> 8) ^ X) & (unsigned long)0x00FF00FF;
  X ^= T;
  Y ^= T << 8;
  Y = ((Y << 1) | (Y >> 31)) & (unsigned long)0xFFFFFFFF;
  T = (X ^ Y) & (unsigned long)0xAAAAAAAA;
  Y ^= T;
  X ^= T;
  X = ((X << 1) | (X >> 31)) & (unsigned long)0xFFFFFFFF;
  i = 0;
  while (i < 8) {
    {
      unsigned long *tmp;
      unsigned long *tmp_0;
      tmp = SK;
      SK ++;
      T = *tmp ^ Y;
      X ^= ((SB8[T & (unsigned long)0x3F] ^ SB6[(T >> 8) & (unsigned long)0x3F]) ^ SB4[
            (T >> 16) & (unsigned long)0x3F]) ^ SB2[(T >> 24) & (unsigned long)0x3F];
      tmp_0 = SK;
      SK ++;
      T = *tmp_0 ^ ((Y << 28) | (Y >> 4));
      X ^= ((SB7[T & (unsigned long)0x3F] ^ SB5[(T >> 8) & (unsigned long)0x3F]) ^ SB3[
            (T >> 16) & (unsigned long)0x3F]) ^ SB1[(T >> 24) & (unsigned long)0x3F];
    }
    {
      unsigned long *tmp_1;
      unsigned long *tmp_2;
      tmp_1 = SK;
      SK ++;
      T = *tmp_1 ^ X;
      Y ^= ((SB8[T & (unsigned long)0x3F] ^ SB6[(T >> 8) & (unsigned long)0x3F]) ^ SB4[
            (T >> 16) & (unsigned long)0x3F]) ^ SB2[(T >> 24) & (unsigned long)0x3F];
      tmp_2 = SK;
      SK ++;
      T = *tmp_2 ^ ((X << 28) | (X >> 4));
      Y ^= ((SB7[T & (unsigned long)0x3F] ^ SB5[(T >> 8) & (unsigned long)0x3F]) ^ SB3[
            (T >> 16) & (unsigned long)0x3F]) ^ SB1[(T >> 24) & (unsigned long)0x3F];
    }
    i ++;
  }
  i = 0;
  while (i < 8) {
    {
      unsigned long *tmp_3;
      unsigned long *tmp_4;
      tmp_3 = SK;
      SK ++;
      T = *tmp_3 ^ X;
      Y ^= ((SB8[T & (unsigned long)0x3F] ^ SB6[(T >> 8) & (unsigned long)0x3F]) ^ SB4[
            (T >> 16) & (unsigned long)0x3F]) ^ SB2[(T >> 24) & (unsigned long)0x3F];
      tmp_4 = SK;
      SK ++;
      T = *tmp_4 ^ ((X << 28) | (X >> 4));
      Y ^= ((SB7[T & (unsigned long)0x3F] ^ SB5[(T >> 8) & (unsigned long)0x3F]) ^ SB3[
            (T >> 16) & (unsigned long)0x3F]) ^ SB1[(T >> 24) & (unsigned long)0x3F];
    }
    {
      unsigned long *tmp_5;
      unsigned long *tmp_6;
      tmp_5 = SK;
      SK ++;
      T = *tmp_5 ^ Y;
      X ^= ((SB8[T & (unsigned long)0x3F] ^ SB6[(T >> 8) & (unsigned long)0x3F]) ^ SB4[
            (T >> 16) & (unsigned long)0x3F]) ^ SB2[(T >> 24) & (unsigned long)0x3F];
      tmp_6 = SK;
      SK ++;
      T = *tmp_6 ^ ((Y << 28) | (Y >> 4));
      X ^= ((SB7[T & (unsigned long)0x3F] ^ SB5[(T >> 8) & (unsigned long)0x3F]) ^ SB3[
            (T >> 16) & (unsigned long)0x3F]) ^ SB1[(T >> 24) & (unsigned long)0x3F];
    }
    i ++;
  }
  i = 0;
  while (i < 8) {
    {
      unsigned long *tmp_7;
      unsigned long *tmp_8;
      tmp_7 = SK;
      SK ++;
      T = *tmp_7 ^ Y;
      X ^= ((SB8[T & (unsigned long)0x3F] ^ SB6[(T >> 8) & (unsigned long)0x3F]) ^ SB4[
            (T >> 16) & (unsigned long)0x3F]) ^ SB2[(T >> 24) & (unsigned long)0x3F];
      tmp_8 = SK;
      SK ++;
      T = *tmp_8 ^ ((Y << 28) | (Y >> 4));
      X ^= ((SB7[T & (unsigned long)0x3F] ^ SB5[(T >> 8) & (unsigned long)0x3F]) ^ SB3[
            (T >> 16) & (unsigned long)0x3F]) ^ SB1[(T >> 24) & (unsigned long)0x3F];
    }
    {
      unsigned long *tmp_9;
      unsigned long *tmp_10;
      tmp_9 = SK;
      SK ++;
      T = *tmp_9 ^ X;
      Y ^= ((SB8[T & (unsigned long)0x3F] ^ SB6[(T >> 8) & (unsigned long)0x3F]) ^ SB4[
            (T >> 16) & (unsigned long)0x3F]) ^ SB2[(T >> 24) & (unsigned long)0x3F];
      tmp_10 = SK;
      SK ++;
      T = *tmp_10 ^ ((X << 28) | (X >> 4));
      Y ^= ((SB7[T & (unsigned long)0x3F] ^ SB5[(T >> 8) & (unsigned long)0x3F]) ^ SB3[
            (T >> 16) & (unsigned long)0x3F]) ^ SB1[(T >> 24) & (unsigned long)0x3F];
    }
    i ++;
  }
  Y = ((Y << 31) | (Y >> 1)) & (unsigned long)0xFFFFFFFF;
  T = (Y ^ X) & (unsigned long)0xAAAAAAAA;
  Y ^= T;
  X ^= T;
  X = ((X << 31) | (X >> 1)) & (unsigned long)0xFFFFFFFF;
  T = ((X >> 8) ^ Y) & (unsigned long)0x00FF00FF;
  Y ^= T;
  X ^= T << 8;
  T = ((X >> 2) ^ Y) & (unsigned long)0x33333333;
  Y ^= T;
  X ^= T << 2;
  T = ((Y >> 16) ^ X) & (unsigned long)0x0000FFFF;
  X ^= T;
  Y ^= T << 16;
  T = ((Y >> 4) ^ X) & (unsigned long)0x0F0F0F0F;
  X ^= T;
  Y ^= T << 4;
  *(output + 0) = (unsigned char)(Y >> 24);
  *(output + (0 + 1)) = (unsigned char)(Y >> 16);
  *(output + (0 + 2)) = (unsigned char)(Y >> 8);
  *(output + (0 + 3)) = (unsigned char)Y;
  *(output + 4) = (unsigned char)(X >> 24);
  *(output + (4 + 1)) = (unsigned char)(X >> 16);
  *(output + (4 + 2)) = (unsigned char)(X >> 8);
  *(output + (4 + 3)) = (unsigned char)X;
  __retres = 0;
  return __retres;
}

/*@ assigns *(output + (0 .. length - 1)), *(iv + (0 .. 7)), \result;
    assigns *(output + (0 .. length - 1))
      \from *(output + (0 .. length - 1)), *(iv + (0 .. 7));
    assigns *(iv + (0 .. 7))
      \from *(output + (0 .. length - 1)), *(iv + (0 .. 7));
    assigns \result \from length;
    
    behavior invalid_length:
      assumes length % 8 ≢ 0;
      ensures \result ≡ -0x0032;
      assigns \result;
      assigns \result \from length;
    
    behavior des3_cbc_ok:
      assumes length % 8 ≡ 0;
      requires \valid(ctx);
      requires \valid_read(input + (0 .. length - 1));
      requires \initialized(input + (0 .. length - 1));
      requires \initialized(iv + (0 .. 7));
      ensures \initialized(\old(output) + (0 .. \old(length) - 1));
      ensures \result ≡ 0;
      assigns *(output + (0 .. length - 1)), *(iv + (0 .. 7)), \result;
      assigns *(output + (0 .. length - 1))
        \from *(output + (0 .. length - 1)), *(iv + (0 .. 7));
      assigns *(iv + (0 .. 7))
        \from *(output + (0 .. length - 1)), *(iv + (0 .. 7));
      assigns \result \from length;
    
    complete behaviors des3_cbc_ok, invalid_length;
    disjoint behaviors des3_cbc_ok, invalid_length;
 */
int des3_crypt_cbc(des3_context *ctx, int mode, size_t length,
                   unsigned char iv[8], unsigned char const *input,
                   unsigned char *output)
{
  int __retres;
  int i;
  unsigned char temp[8];
  if (length % (unsigned int)8) {
    __retres = -0x0032;
    goto return_label;
  }
  if (mode == 1) 
    while (length > (size_t)0) {
      i = 0;
      while (i < 8) {
        *(output + i) = (unsigned char)((int)*(input + i) ^ (int)*(iv + i));
        i ++;
      }
      des3_crypt_ecb(ctx,(unsigned char const *)output,output);
      memcpy((void *)iv,(void const *)output,(size_t)8);
      input += 8;
      output += 8;
      length -= (size_t)8;
    }
  else 
    while (length > (size_t)0) {
      memcpy((void *)(temp),(void const *)input,(size_t)8);
      des3_crypt_ecb(ctx,input,output);
      i = 0;
      while (i < 8) {
        *(output + i) = (unsigned char)((int)*(output + i) ^ (int)*(iv + i));
        i ++;
      }
      memcpy((void *)iv,(void const *)(temp),(size_t)8);
      input += 8;
      output += 8;
      length -= (size_t)8;
    }
  __retres = 0;
  return_label: return __retres;
}

static unsigned char const des3_test_keys[24] =
  {(unsigned char)0x01,
   (unsigned char)0x23,
   (unsigned char)0x45,
   (unsigned char)0x67,
   (unsigned char)0x89,
   (unsigned char)0xAB,
   (unsigned char)0xCD,
   (unsigned char)0xEF,
   (unsigned char)0x23,
   (unsigned char)0x45,
   (unsigned char)0x67,
   (unsigned char)0x89,
   (unsigned char)0xAB,
   (unsigned char)0xCD,
   (unsigned char)0xEF,
   (unsigned char)0x01,
   (unsigned char)0x45,
   (unsigned char)0x67,
   (unsigned char)0x89,
   (unsigned char)0xAB,
   (unsigned char)0xCD,
   (unsigned char)0xEF,
   (unsigned char)0x01,
   (unsigned char)0x23};
static unsigned char const des3_test_iv[8] =
  {(unsigned char)0x12,
   (unsigned char)0x34,
   (unsigned char)0x56,
   (unsigned char)0x78,
   (unsigned char)0x90,
   (unsigned char)0xAB,
   (unsigned char)0xCD,
   (unsigned char)0xEF};
static unsigned char const des3_test_buf[8] =
  {(unsigned char)0x4E,
   (unsigned char)0x6F,
   (unsigned char)0x77,
   (unsigned char)0x20,
   (unsigned char)0x69,
   (unsigned char)0x73,
   (unsigned char)0x20,
   (unsigned char)0x74};
static unsigned char const des3_test_ecb_dec[3][8] =
  {{(unsigned char)0xCD,
    (unsigned char)0xD6,
    (unsigned char)0x4F,
    (unsigned char)0x2F,
    (unsigned char)0x94,
    (unsigned char)0x27,
    (unsigned char)0xC1,
    (unsigned char)0x5D},
   {(unsigned char)0x69,
    (unsigned char)0x96,
    (unsigned char)0xC8,
    (unsigned char)0xFA,
    (unsigned char)0x47,
    (unsigned char)0xA2,
    (unsigned char)0xAB,
    (unsigned char)0xEB},
   {(unsigned char)0x83,
    (unsigned char)0x25,
    (unsigned char)0x39,
    (unsigned char)0x76,
    (unsigned char)0x44,
    (unsigned char)0x09,
    (unsigned char)0x1A,
    (unsigned char)0x0A}};
static unsigned char const des3_test_ecb_enc[3][8] =
  {{(unsigned char)0x6A,
    (unsigned char)0x2A,
    (unsigned char)0x19,
    (unsigned char)0xF4,
    (unsigned char)0x1E,
    (unsigned char)0xCA,
    (unsigned char)0x85,
    (unsigned char)0x4B},
   {(unsigned char)0x03,
    (unsigned char)0xE6,
    (unsigned char)0x9F,
    (unsigned char)0x5B,
    (unsigned char)0xFA,
    (unsigned char)0x58,
    (unsigned char)0xEB,
    (unsigned char)0x42},
   {(unsigned char)0xDD,
    (unsigned char)0x17,
    (unsigned char)0xE8,
    (unsigned char)0xB8,
    (unsigned char)0xB4,
    (unsigned char)0x37,
    (unsigned char)0xD2,
    (unsigned char)0x32}};
static unsigned char const des3_test_cbc_dec[3][8] =
  {{(unsigned char)0x12,
    (unsigned char)0x9F,
    (unsigned char)0x40,
    (unsigned char)0xB9,
    (unsigned char)0xD2,
    (unsigned char)0x00,
    (unsigned char)0x56,
    (unsigned char)0xB3},
   {(unsigned char)0x47,
    (unsigned char)0x0E,
    (unsigned char)0xFC,
    (unsigned char)0x9A,
    (unsigned char)0x6B,
    (unsigned char)0x8E,
    (unsigned char)0xE3,
    (unsigned char)0x93},
   {(unsigned char)0xC5,
    (unsigned char)0xCE,
    (unsigned char)0xCF,
    (unsigned char)0x63,
    (unsigned char)0xEC,
    (unsigned char)0xEC,
    (unsigned char)0x51,
    (unsigned char)0x4C}};
static unsigned char const des3_test_cbc_enc[3][8] =
  {{(unsigned char)0x54,
    (unsigned char)0xF1,
    (unsigned char)0x5A,
    (unsigned char)0xF6,
    (unsigned char)0xEB,
    (unsigned char)0xE3,
    (unsigned char)0xA4,
    (unsigned char)0xB4},
   {(unsigned char)0x35,
    (unsigned char)0x76,
    (unsigned char)0x11,
    (unsigned char)0x56,
    (unsigned char)0x5F,
    (unsigned char)0xA1,
    (unsigned char)0x8E,
    (unsigned char)0x4D},
   {(unsigned char)0xCB,
    (unsigned char)0x19,
    (unsigned char)0x1F,
    (unsigned char)0x85,
    (unsigned char)0xD1,
    (unsigned char)0xED,
    (unsigned char)0x84,
    (unsigned char)0x39}};
/*@ requires valid_read_string(param2);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param2 + (0 ..))),
            (indirect: param1), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param2 + (0 ..)), param1, param0;
 */
int printf_va_75(char const * restrict format, int param0, int param1,
                 char *param2);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_76(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_77(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_78(char const * restrict format);

/*@ requires valid_read_string(param2);
    requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param2 + (0 ..))),
            (indirect: param1), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            *(param2 + (0 ..)), param1, param0;
 */
int printf_va_79(char const * restrict format, int param0, int param1,
                 char *param2);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_80(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_81(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_82(char const * restrict format);

int des_self_test(int verbose)
{
  int __retres;
  int i;
  int j;
  int u;
  int v;
  des_context ctx;
  des3_context ctx3;
  unsigned char key[24];
  unsigned char buf[8];
  unsigned char prv_0[8];
  unsigned char iv[8];
  memset((void *)(key),0,(size_t)24);
  i = 0;
  while (i < 6) {
    u = i >> 1;
    v = i & 1;
    if (verbose != 0) {
      char const *tmp;
      int tmp_0;
      if (v == 0) tmp = "dec"; else tmp = "enc";
      ;
      if (u == 0) tmp_0 = ' '; else tmp_0 = '3';
      printf("  DES%c-ECB-%3d (%s): ",tmp_0,56 + u * 56,(char *)tmp); /* printf_va_75 */
    }
    memcpy((void *)(buf),(void const *)(des3_test_buf),(size_t)8);
    switch (i) {
      case 0: des_setkey_dec(& ctx,des3_test_keys);
      break;
      case 1: des_setkey_enc(& ctx,des3_test_keys);
      break;
      case 2: des3_set2key_dec(& ctx3,des3_test_keys);
      break;
      case 3: des3_set2key_enc(& ctx3,des3_test_keys);
      break;
      case 4: des3_set3key_dec(& ctx3,des3_test_keys);
      break;
      case 5: des3_set3key_enc(& ctx3,des3_test_keys);
      break;
      default: __retres = 1;
      goto return_label;
    }
    j = 0;
    while (j < 10000) {
      if (u == 0) des_crypt_ecb(& ctx,(unsigned char const *)(buf),buf);
      else des3_crypt_ecb(& ctx3,(unsigned char const *)(buf),buf);
      j ++;
    }
    if (v == 0) {
      int tmp_1;
      tmp_1 = memcmp((void const *)(buf),
                     (void const *)(des3_test_ecb_dec[u]),(size_t)8);
      if (tmp_1 != 0) goto _LOR; else goto _LAND;
    }
    else {
      _LAND: ;
      if (v != 0) {
        int tmp_2;
        tmp_2 = memcmp((void const *)(buf),
                       (void const *)(des3_test_ecb_enc[u]),(size_t)8);
        if (tmp_2 != 0) {
          _LOR:
          {
            if (verbose != 0) printf("failed\n"); /* printf_va_76 */
            __retres = 1;
            goto return_label;
          }
        }
      }
    }
    if (verbose != 0) printf("passed\n"); /* printf_va_77 */
    i ++;
  }
  if (verbose != 0) printf("\n"); /* printf_va_78 */
  i = 0;
  while (i < 6) {
    u = i >> 1;
    v = i & 1;
    if (verbose != 0) {
      char const *tmp_3;
      int tmp_4;
      if (v == 0) tmp_3 = "dec"; else tmp_3 = "enc";
      ;
      if (u == 0) tmp_4 = ' '; else tmp_4 = '3';
      printf("  DES%c-CBC-%3d (%s): ",tmp_4,56 + u * 56,(char *)tmp_3); /* printf_va_79 */
    }
    memcpy((void *)(iv),(void const *)(des3_test_iv),(size_t)8);
    memcpy((void *)(prv_0),(void const *)(des3_test_iv),(size_t)8);
    memcpy((void *)(buf),(void const *)(des3_test_buf),(size_t)8);
    switch (i) {
      case 0: des_setkey_dec(& ctx,des3_test_keys);
      break;
      case 1: des_setkey_enc(& ctx,des3_test_keys);
      break;
      case 2: des3_set2key_dec(& ctx3,des3_test_keys);
      break;
      case 3: des3_set2key_enc(& ctx3,des3_test_keys);
      break;
      case 4: des3_set3key_dec(& ctx3,des3_test_keys);
      break;
      case 5: des3_set3key_enc(& ctx3,des3_test_keys);
      break;
      default: __retres = 1;
      goto return_label;
    }
    if (v == 0) {
      j = 0;
      while (j < 10000) {
        if (u == 0) des_crypt_cbc(& ctx,v,(size_t)8,iv,
                                  (unsigned char const *)(buf),buf);
        else des3_crypt_cbc(& ctx3,v,(size_t)8,iv,
                            (unsigned char const *)(buf),buf);
        j ++;
      }
    }
    else {
      j = 0;
      while (j < 10000) {
        {
          unsigned char tmp_5[8];
          if (u == 0) des_crypt_cbc(& ctx,v,(size_t)8,iv,
                                    (unsigned char const *)(buf),buf);
          else des3_crypt_cbc(& ctx3,v,(size_t)8,iv,
                              (unsigned char const *)(buf),buf);
          memcpy((void *)(tmp_5),(void const *)(prv_0),(size_t)8);
          memcpy((void *)(prv_0),(void const *)(buf),(size_t)8);
          memcpy((void *)(buf),(void const *)(tmp_5),(size_t)8);
        }
        j ++;
      }
      memcpy((void *)(buf),(void const *)(prv_0),(size_t)8);
    }
    if (v == 0) {
      int tmp_6;
      tmp_6 = memcmp((void const *)(buf),
                     (void const *)(des3_test_cbc_dec[u]),(size_t)8);
      if (tmp_6 != 0) goto _LOR_0; else goto _LAND_0;
    }
    else {
      _LAND_0: ;
      if (v != 0) {
        int tmp_7;
        tmp_7 = memcmp((void const *)(buf),
                       (void const *)(des3_test_cbc_enc[u]),(size_t)8);
        if (tmp_7 != 0) {
          _LOR_0:
          {
            if (verbose != 0) printf("failed\n"); /* printf_va_80 */
            __retres = 1;
            goto return_label;
          }
        }
      }
    }
    if (verbose != 0) printf("passed\n"); /* printf_va_81 */
    i ++;
  }
  if (verbose != 0) printf("\n"); /* printf_va_82 */
  __retres = 0;
  return_label: return __retres;
}

static int dhm_read_bignum(mpi *X, unsigned char **p,
                           unsigned char const *end)
{
  int __retres;
  int ret;
  int n;
  if (end - *p < 2) {
    __retres = -0x3080;
    goto return_label;
  }
  n = ((int)*(*p + 0) << 8) | (int)*(*p + 1);
  *p += 2;
  if (end - *p < n) {
    __retres = -0x3080;
    goto return_label;
  }
  ret = mpi_read_binary(X,(unsigned char const *)*p,(size_t)n);
  if (ret != 0) {
    __retres = -0x3100 + ret;
    goto return_label;
  }
  *p += n;
  __retres = 0;
  return_label: return __retres;
}

/*@ requires \valid_read(param);
    requires \valid_read(P);
    assigns \result, _state;
    assigns \result \from _state;
    assigns _state \from _state;
 */
static int dhm_check_range(mpi const *param, mpi const *P)
{
  mpi L;
  mpi U;
  int tmp;
  int ret = -0x3080;
  mpi_init(& L);
  mpi_init(& U);
  mpi_lset(& L,(t_sint)2);
  mpi_sub_int(& U,P,(t_sint)2);
  tmp = mpi_cmp_mpi(param,(mpi const *)(& L));
  if (tmp >= 0) {
    int tmp_0;
    tmp_0 = mpi_cmp_mpi(param,(mpi const *)(& U));
    if (tmp_0 <= 0) ret = 0;
  }
  mpi_free(& L);
  mpi_free(& U);
  return ret;
}

int dhm_read_params(dhm_context *ctx, unsigned char **p,
                    unsigned char const *end)
{
  int __retres;
  int ret;
  int n;
  memset((void *)ctx,0,sizeof(dhm_context));
  ret = dhm_read_bignum(& ctx->P,p,end);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  else {
    ret = dhm_read_bignum(& ctx->G,p,end);
    if (ret != 0) {
      __retres = ret;
      goto return_label;
    }
    else {
      ret = dhm_read_bignum(& ctx->GY,p,end);
      if (ret != 0) {
        __retres = ret;
        goto return_label;
      }
    }
  }
  ret = dhm_check_range((mpi const *)(& ctx->GY),(mpi const *)(& ctx->P));
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  ctx->len = mpi_size((mpi const *)(& ctx->P));
  if (end - *p < 2) {
    __retres = -0x3080;
    goto return_label;
  }
  n = ((int)*(*p + 0) << 8) | (int)*(*p + 1);
  *p += 2;
  if ((void *)end != (void *)(*p + n)) {
    __retres = -0x3080;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

/*@ requires \valid(ctx);
    requires \valid(olen);
    ensures \initialized(&\old(ctx)->len);
    ensures \initialized(\old(olen));
    ensures \old(ctx)->len ≡ 128;
    assigns \result, _state, *olen, ctx->len, ctx->X, ctx->P, ctx->G,
            ctx->GX;
    assigns \result \from _state;
    assigns _state \from _state;
    assigns *olen \from _state;
    assigns ctx->len \from _state;
    assigns ctx->X \from _state;
    assigns ctx->P \from _state;
    assigns ctx->G \from _state;
    assigns ctx->GX \from _state;
 */
int dhm_make_params(dhm_context *ctx, int x_size, unsigned char *output,
                    size_t *olen,
                    int (*f_rng)(void *, unsigned char *, size_t ),
                    void *p_rng)
{
  int __retres;
  int ret;
  size_t n1;
  size_t n2;
  size_t n3;
  unsigned char *p;
  unsigned char *tmp_2;
  unsigned char *tmp_3;
  unsigned char *tmp_4;
  unsigned char *tmp_5;
  unsigned char *tmp_6;
  unsigned char *tmp_7;
  int count = 0;
  while (1) {
    int tmp_1;
    {
      int tmp_0;
      mpi_fill_random(& ctx->X,(size_t)x_size,f_rng,p_rng);
      while (1) {
        int tmp;
        tmp = mpi_cmp_mpi((mpi const *)(& ctx->X),(mpi const *)(& ctx->P));
        if (! (tmp >= 0)) break;
        mpi_shift_r(& ctx->X,(size_t)1);
      }
      tmp_0 = count;
      count ++;
      ;
      if (tmp_0 > 10) {
        __retres = -0x3180;
        goto return_label;
      }
    }
    tmp_1 = dhm_check_range((mpi const *)(& ctx->X),(mpi const *)(& ctx->P));
    if (! (tmp_1 != 0)) break;
  }
  ret = mpi_exp_mod(& ctx->GX,(mpi const *)(& ctx->G),
                    (mpi const *)(& ctx->X),(mpi const *)(& ctx->P),
                    & ctx->RP);
  if (ret != 0) goto cleanup;
  ret = dhm_check_range((mpi const *)(& ctx->GX),(mpi const *)(& ctx->P));
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  n1 = mpi_size((mpi const *)(& ctx->P));
  n2 = mpi_size((mpi const *)(& ctx->G));
  n3 = mpi_size((mpi const *)(& ctx->GX));
  p = output;
  ret = mpi_write_binary((mpi const *)(& ctx->P),p + 2,n1);
  if (ret != 0) goto cleanup;
  tmp_2 = p;
  p ++;
  *tmp_2 = (unsigned char)(n1 >> 8);
  tmp_3 = p;
  p ++;
  *tmp_3 = (unsigned char)n1;
  p += n1;
  ret = mpi_write_binary((mpi const *)(& ctx->G),p + 2,n2);
  if (ret != 0) goto cleanup;
  tmp_4 = p;
  p ++;
  *tmp_4 = (unsigned char)(n2 >> 8);
  tmp_5 = p;
  p ++;
  *tmp_5 = (unsigned char)n2;
  p += n2;
  ret = mpi_write_binary((mpi const *)(& ctx->GX),p + 2,n3);
  if (ret != 0) goto cleanup;
  tmp_6 = p;
  p ++;
  *tmp_6 = (unsigned char)(n3 >> 8);
  tmp_7 = p;
  p ++;
  *tmp_7 = (unsigned char)n3;
  p += n3;
  *olen = (size_t)(p - output);
  ctx->len = n1;
  cleanup: ;
  if (ret != 0) {
    __retres = -0x3180 + ret;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int dhm_read_public(dhm_context *ctx, unsigned char const *input, size_t ilen)
{
  int __retres;
  int ret;
  if (ctx == (dhm_context *)0) {
    __retres = -0x3080;
    goto return_label;
  }
  else 
    if (ilen < (size_t)1) {
      __retres = -0x3080;
      goto return_label;
    }
    else 
      if (ilen > ctx->len) {
        __retres = -0x3080;
        goto return_label;
      }
  ret = mpi_read_binary(& ctx->GY,input,ilen);
  if (ret != 0) {
    __retres = -0x3200 + ret;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int dhm_make_public(dhm_context *ctx, int x_size, unsigned char *output,
                    size_t olen,
                    int (*f_rng)(void *, unsigned char *, size_t ),
                    void *p_rng)
{
  int __retres;
  int ret;
  int count = 0;
  if (ctx == (dhm_context *)0) {
    __retres = -0x3080;
    goto return_label;
  }
  else 
    if (olen < (size_t)1) {
      __retres = -0x3080;
      goto return_label;
    }
    else 
      if (olen > ctx->len) {
        __retres = -0x3080;
        goto return_label;
      }
  while (1) {
    int tmp_1;
    {
      int tmp_0;
      mpi_fill_random(& ctx->X,(size_t)x_size,f_rng,p_rng);
      while (1) {
        int tmp;
        tmp = mpi_cmp_mpi((mpi const *)(& ctx->X),(mpi const *)(& ctx->P));
        if (! (tmp >= 0)) break;
        mpi_shift_r(& ctx->X,(size_t)1);
      }
      tmp_0 = count;
      count ++;
      ;
      if (tmp_0 > 10) {
        __retres = -0x3280;
        goto return_label;
      }
    }
    tmp_1 = dhm_check_range((mpi const *)(& ctx->X),(mpi const *)(& ctx->P));
    if (! (tmp_1 != 0)) break;
  }
  ret = mpi_exp_mod(& ctx->GX,(mpi const *)(& ctx->G),
                    (mpi const *)(& ctx->X),(mpi const *)(& ctx->P),
                    & ctx->RP);
  if (ret != 0) goto cleanup;
  ret = dhm_check_range((mpi const *)(& ctx->GX),(mpi const *)(& ctx->P));
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  ret = mpi_write_binary((mpi const *)(& ctx->GX),output,olen);
  if (ret != 0) goto cleanup;
  cleanup: ;
  if (ret != 0) {
    __retres = -0x3280 + ret;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int dhm_calc_secret(dhm_context *ctx, unsigned char *output, size_t *olen)
{
  int __retres;
  int ret;
  if (ctx == (dhm_context *)0) {
    __retres = -0x3080;
    goto return_label;
  }
  else 
    if (*olen < ctx->len) {
      __retres = -0x3080;
      goto return_label;
    }
  ret = mpi_exp_mod(& ctx->K,(mpi const *)(& ctx->GY),
                    (mpi const *)(& ctx->X),(mpi const *)(& ctx->P),
                    & ctx->RP);
  if (ret != 0) goto cleanup;
  ret = dhm_check_range((mpi const *)(& ctx->GY),(mpi const *)(& ctx->P));
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  *olen = mpi_size((mpi const *)(& ctx->K));
  /*@ assert 0 ≤ *olen ≤ 256; */ ;
  ret = mpi_write_binary((mpi const *)(& ctx->K),output,*olen);
  if (ret != 0) goto cleanup;
  cleanup: ;
  if (ret != 0) {
    __retres = -0x3300 + ret;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

void dhm_free(dhm_context *ctx)
{
  mpi_free(& ctx->RP);
  mpi_free(& ctx->K);
  mpi_free(& ctx->GY);
  mpi_free(& ctx->GX);
  mpi_free(& ctx->X);
  mpi_free(& ctx->G);
  mpi_free(& ctx->P);
  return;
}

int dhm_self_test(int verbose)
{
  int tmp;
  tmp = verbose;
  verbose ++;
  ;
  return tmp;
}

void entropy_init(entropy_context *ctx);

int entropy_add_source(entropy_context *ctx,
                       int (*f_source)(void *, unsigned char *, size_t ,
                                       size_t *),
                       void *p_source, size_t threshold);

int entropy_gather(entropy_context *ctx);

int entropy_func(void *data, unsigned char *output, size_t len);

int entropy_update_manual(entropy_context *ctx, unsigned char const *data,
                          size_t len);

int platform_entropy_poll(void *data, unsigned char *output, size_t len,
                          size_t *olen);

int hardclock_poll(void *data, unsigned char *output, size_t len,
                   size_t *olen);

void entropy_init(entropy_context *ctx)
{
  memset((void *)ctx,0,sizeof(entropy_context));
  sha4_starts(& ctx->accumulator,0);
  entropy_add_source(ctx,& platform_entropy_poll,(void *)0,(size_t)128);
  entropy_add_source(ctx,& hardclock_poll,(void *)0,(size_t)32);
  return;
}

int entropy_add_source(entropy_context *ctx,
                       int (*f_source)(void *, unsigned char *, size_t ,
                                       size_t *),
                       void *p_source, size_t threshold)
{
  int __retres;
  int index_0 = ctx->source_count;
  if (index_0 >= 20) {
    __retres = -0x003E;
    goto return_label;
  }
  ctx->source[index_0].f_source = f_source;
  ctx->source[index_0].p_source = p_source;
  ctx->source[index_0].threshold = threshold;
  (ctx->source_count) ++;
  __retres = 0;
  return_label: return __retres;
}

int entropy_update(entropy_context *ctx, unsigned char source_id,
                   unsigned char const *data, size_t len)
{
  int __retres;
  unsigned char header[2];
  unsigned char tmp[64];
  size_t use_len = len;
  unsigned char const *p = data;
  if (use_len > (size_t)64) {
    sha4(data,len,tmp,0);
    p = (unsigned char const *)(tmp);
    use_len = (size_t)64;
  }
  header[0] = source_id;
  header[1] = (unsigned char)(use_len & (unsigned int)0xFF);
  sha4_update(& ctx->accumulator,(unsigned char const *)(header),(size_t)2);
  sha4_update(& ctx->accumulator,p,use_len);
  __retres = 0;
  return __retres;
}

int entropy_update_manual(entropy_context *ctx, unsigned char const *data,
                          size_t len)
{
  int tmp;
  tmp = entropy_update(ctx,(unsigned char)20,data,len);
  return tmp;
}

int entropy_gather(entropy_context *ctx)
{
  int __retres;
  int ret;
  int i;
  unsigned char buf[128];
  size_t olen;
  if (ctx->source_count == 0) {
    __retres = -0x0040;
    goto return_label;
  }
  i = 0;
  /*@ loop unroll 2; */
  while (i < ctx->source_count) {
    olen = (size_t)0;
    ret = (*(ctx->source[i].f_source))(ctx->source[i].p_source,buf,
                                       (size_t)128,& olen);
    if (ret != 0) {
      __retres = ret;
      goto return_label;
    }
    if (olen > (size_t)0) {
      entropy_update(ctx,(unsigned char)i,(unsigned char const *)(buf),olen);
      ctx->source[i].size += olen;
    }
    i ++;
  }
  __retres = 0;
  return_label: return __retres;
}

int entropy_func(void *data, unsigned char *output, size_t len)
{
  int __retres;
  int ret;
  int i;
  int reached;
  unsigned char buf[64];
  int count = 0;
  entropy_context *ctx = (entropy_context *)data;
  if (len > (size_t)64) {
    __retres = -0x003C;
    goto return_label;
  }
  while (1) {
    {
      int tmp;
      tmp = count;
      count ++;
      ;
      if (tmp > 256) {
        __retres = -0x003C;
        goto return_label;
      }
      ret = entropy_gather(ctx);
      if (ret != 0) {
        __retres = ret;
        goto return_label;
      }
      reached = 0;
      i = 0;
      /*@ loop unroll 2; */
      while (i < ctx->source_count) {
        if (ctx->source[i].size >= ctx->source[i].threshold) reached ++;
        i ++;
      }
    }
    if (! (reached != ctx->source_count)) break;
  }
  memset((void *)(buf),0,(size_t)64);
  sha4_finish(& ctx->accumulator,buf);
  sha4((unsigned char const *)(buf),(size_t)64,buf,0);
  memset((void *)(& ctx->accumulator),0,sizeof(sha4_context));
  sha4_starts(& ctx->accumulator,0);
  sha4_update(& ctx->accumulator,(unsigned char const *)(buf),(size_t)64);
  i = 0;
  /*@ loop unroll 2; */
  while (i < ctx->source_count) {
    ctx->source[i].size = (size_t)0;
    i ++;
  }
  memcpy((void *)output,(void const *)(buf),len);
  __retres = 0;
  return_label: return __retres;
}

int platform_entropy_poll(void *data, unsigned char *output, size_t len,
                          size_t *olen)
{
  int __retres;
  FILE *file;
  size_t ret;
  *olen = (size_t)0;
  file = fopen("/dev/urandom","rb");
  if (file == (FILE *)0) {
    __retres = -0x003C;
    goto return_label;
  }
  ret = fread((void *)output,(size_t)1,len,file);
  if (ret != len) {
    fclose(file);
    __retres = -0x003C;
    goto return_label;
  }
  fclose(file);
  *olen = len;
  __retres = 0;
  return_label: return __retres;
}

int hardclock_poll(void *data, unsigned char *output, size_t len,
                   size_t *olen)
{
  int __retres;
  unsigned long timer = hardclock();
  *olen = (size_t)0;
  if (len < sizeof(unsigned long)) {
    __retres = 0;
    goto return_label;
  }
  memcpy((void *)output,(void const *)(& timer),sizeof(unsigned long));
  *olen = sizeof(unsigned long);
  __retres = 0;
  return_label: return __retres;
}

__inline static unsigned int cipher_get_block_size_1(cipher_context_t const *ctx)
{
  unsigned int __retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = (unsigned int)0;
    goto return_label;
  }
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) {
      __retres = (unsigned int)0;
      goto return_label;
    }
  __retres = (ctx->cipher_info)->block_size;
  return_label: return __retres;
}

__inline static cipher_mode_t cipher_get_cipher_mode_1(cipher_context_t const *ctx)
{
  cipher_mode_t __retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = POLARSSL_MODE_NONE;
    goto return_label;
  }
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) {
      __retres = POLARSSL_MODE_NONE;
      goto return_label;
    }
  __retres = (ctx->cipher_info)->mode;
  return_label: return __retres;
}

__inline static int cipher_get_iv_size_1(cipher_context_t const *ctx)
{
  int __retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = 0;
    goto return_label;
  }
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) {
      __retres = 0;
      goto return_label;
    }
  __retres = (int)(ctx->cipher_info)->iv_size;
  return_label: return __retres;
}

__inline static cipher_type_t cipher_get_type_1(cipher_context_t const *ctx)
{
  cipher_type_t __retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = (cipher_type_t)0;
    goto return_label;
  }
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) {
      __retres = (cipher_type_t)0;
      goto return_label;
    }
  __retres = (ctx->cipher_info)->type;
  return_label: return __retres;
}

__inline static char const *cipher_get_name_1(cipher_context_t const *ctx)
{
  char const *__retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = (char const *)0;
    goto return_label;
  }
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) {
      __retres = (char const *)0;
      goto return_label;
    }
  __retres = (ctx->cipher_info)->name;
  return_label: return __retres;
}

__inline static int cipher_get_key_size_1(cipher_context_t const *ctx)
{
  int __retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = POLARSSL_KEY_LENGTH_NONE;
    goto return_label;
  }
  __retres = ctx->key_length;
  return_label: return __retres;
}

__inline static operation_t cipher_get_operation_1(cipher_context_t const *ctx)
{
  operation_t __retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = POLARSSL_OPERATION_NONE;
    goto return_label;
  }
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) {
      __retres = POLARSSL_OPERATION_NONE;
      goto return_label;
    }
  __retres = ctx->operation;
  return_label: return __retres;
}

int const *md_list(void);

md_info_t const *md_info_from_string(char const *md_name);

md_info_t const *md_info_from_type(md_type_t md_type);

int md_init_ctx(md_context_t *ctx, md_info_t const *md_info);

int md_free_ctx(md_context_t *ctx);

__inline static unsigned char md_get_size(md_info_t const *md_info)
{
  unsigned char __retres;
  __retres = (unsigned char)md_info->size;
  return __retres;
}

__inline static md_type_t md_get_type(md_info_t const *md_info)
{
  md_type_t __retres;
  __retres = md_info->type;
  return __retres;
}

__inline static char const *md_get_name(md_info_t const *md_info)
{
  char const *__retres;
  __retres = md_info->name;
  return __retres;
}

int md_starts(md_context_t *ctx);

int md_update(md_context_t *ctx, unsigned char const *input, size_t ilen);

int md_finish(md_context_t *ctx, unsigned char *output);

int md(md_info_t const *md_info, unsigned char const *input, size_t ilen,
       unsigned char *output);

int md_file(md_info_t const *md_info, char const *path, unsigned char *output);

int md_hmac_starts(md_context_t *ctx, unsigned char const *key, size_t keylen);

int md_hmac_update(md_context_t *ctx, unsigned char const *input, size_t ilen);

int md_hmac_finish(md_context_t *ctx, unsigned char *output);

int md_hmac_reset(md_context_t *ctx);

int md_hmac(md_info_t const *md_info, unsigned char const *key,
            size_t keylen, unsigned char const *input, size_t ilen,
            unsigned char *output);

void pem_init(pem_context *ctx);

int pem_read_buffer(pem_context *ctx, char *header, char *footer,
                    unsigned char const *data, unsigned char const *pwd,
                    size_t pwdlen, size_t *use_len);

void pem_free(pem_context *ctx);

void sha2_starts(sha2_context *ctx, int is224);

void sha2_update(sha2_context *ctx, unsigned char const *input, size_t ilen);

void sha2_finish(sha2_context *ctx, unsigned char output[32]);

void sha2(unsigned char const *input, size_t ilen, unsigned char output[32],
          int is224);

int sha2_file(char const *path, unsigned char output[32], int is224);

void sha2_hmac_starts(sha2_context *ctx, unsigned char const *key,
                      size_t keylen, int is224);

void sha2_hmac_update(sha2_context *ctx, unsigned char const *input,
                      size_t ilen);

void sha2_hmac_finish(sha2_context *ctx, unsigned char output[32]);

void sha2_hmac_reset(sha2_context *ctx);

void sha2_hmac(unsigned char const *key, size_t keylen,
               unsigned char const *input, size_t ilen,
               unsigned char output[32], int is224);

int sha2_self_test(int verbose);

void sha2_process(sha2_context *ctx, unsigned char const data[64]);

__inline static int const *ssl_list_ciphersuites_1(void)
{
  int const *__retres;
  __retres = (int const *)(ssl_default_ciphersuites);
  return __retres;
}

void xtea_setup(xtea_context *ctx, unsigned char key[16]);

int xtea_crypt_ecb(xtea_context *ctx, int mode, unsigned char input[8],
                   unsigned char output[8]);

int xtea_crypt_cbc(xtea_context *ctx, int mode, size_t length,
                   unsigned char iv[8], unsigned char *input,
                   unsigned char *output);

int xtea_self_test(int verbose);

void error_strerror(int ret, char *buf, size_t buflen)
{
  size_t len;
  int use_ret;
  size_t tmp_0_0;
  memset((void *)buf,0x00,buflen);
  if (ret < 0) ret = - ret;
  if (ret & 0xFF80) {
    size_t tmp_0;
    use_ret = ret & 0xFF80;
    int tmp = use_ret == - (-0x6080);
    int tmp_3 = use_ret == - (-0x6100);
    int tmp_5 = use_ret == - (-0x6180);
    int tmp_7 = use_ret == - (-0x6200);
    int tmp_9 = use_ret == - (-0x6280);
    int tmp_11 = use_ret == - (-0x3080);
    int tmp_13 = use_ret == - (-0x3100);
    int tmp_15 = use_ret == - (-0x3180);
    int tmp_17 = use_ret == - (-0x3200);
    int tmp_19 = use_ret == - (-0x3280);
    int tmp_21 = use_ret == - (-0x3300);
    int tmp_23 = use_ret == - (-0x5080);
    int tmp_25 = use_ret == - (-0x5100);
    int tmp_27 = use_ret == - (-0x5180);
    int tmp_29 = use_ret == - (-0x5200);
    int tmp_31 = use_ret == - (-0x1080);
    int tmp_33 = use_ret == - (-0x1100);
    int tmp_35 = use_ret == - (-0x1180);
    int tmp_37 = use_ret == - (-0x1200);
    int tmp_39 = use_ret == - (-0x1280);
    int tmp_41 = use_ret == - (-0x1300);
    int tmp_43 = use_ret == - (-0x1380);
    int tmp_45 = use_ret == - (-0x1400);
    int tmp_47 = use_ret == - (-0x1480);
    int tmp_49 = use_ret == - (-0x4080);
    int tmp_51 = use_ret == - (-0x4100);
    int tmp_53 = use_ret == - (-0x4180);
    int tmp_55 = use_ret == - (-0x4200);
    int tmp_57 = use_ret == - (-0x4280);
    int tmp_59 = use_ret == - (-0x4300);
    int tmp_61 = use_ret == - (-0x4380);
    int tmp_63 = use_ret == - (-0x4400);
    int tmp_65 = use_ret == - (-0x4480);
    int tmp_67 = use_ret == - (-0x7080);
    int tmp_69 = use_ret == - (-0x7100);
    int tmp_71 = use_ret == - (-0x7180);
    int tmp_73 = use_ret == - (-0x7200);
    int tmp_75 = use_ret == - (-0x7280);
    int tmp_77 = use_ret == - (-0x7300);
    int tmp_79 = use_ret == - (-0x7380);
    int tmp_81 = use_ret == - (-0x7400);
    int tmp_83 = use_ret == - (-0x7480);
    int tmp_85 = use_ret == - (-0x7500);
    int tmp_87 = use_ret == - (-0x7580);
    int tmp_89 = use_ret == - (-0x7600);
    int tmp_91 = use_ret == - (-0x7680);
    int tmp_93 = use_ret == - (-0x7700);
    int tmp_95 = use_ret == - (-0x7780);
    int tmp_97 = use_ret == - (-0x7800);
    int tmp_99 = use_ret == - (-0x7880);
    int tmp_101 = use_ret == - (-0x7900);
    int tmp_103 = use_ret == - (-0x7980);
    int tmp_105 = use_ret == - (-0x7A00);
    int tmp_107 = use_ret == - (-0x7A80);
    int tmp_109 = use_ret == - (-0x7B00);
    int tmp_111 = use_ret == - (-0x7B80);
    int tmp_113 = use_ret == - (-0x7C00);
    int tmp_115 = use_ret == - (-0x7C80);
    int tmp_117 = use_ret == - (-0x7D00);
    int tmp_119 = use_ret == - (-0x7D80);
    int tmp_121 = use_ret == - (-0x7E00);
    int tmp_123 = use_ret == - (-0x7E80);
    int tmp_125 = use_ret == - (-0x7F00);
    int tmp_127 = use_ret == - (-0x2080);
    int tmp_129 = use_ret == - (-0x2100);
    int tmp_131 = use_ret == - (-0x2180);
    int tmp_133 = use_ret == - (-0x2200);
    int tmp_135 = use_ret == - (-0x2280);
    int tmp_137 = use_ret == - (-0x2300);
    int tmp_139 = use_ret == - (-0x2380);
    int tmp_141 = use_ret == - (-0x2400);
    int tmp_143 = use_ret == - (-0x2480);
    int tmp_145 = use_ret == - (-0x2500);
    int tmp_147 = use_ret == - (-0x2580);
    int tmp_149 = use_ret == - (-0x2600);
    int tmp_151 = use_ret == - (-0x2680);
    int tmp_153 = use_ret == - (-0x2700);
    int tmp_155 = use_ret == - (-0x2780);
    int tmp_157 = use_ret == - (-0x2800);
    int tmp_159 = use_ret == - (-0x2880);
    int tmp_161 = use_ret == - (-0x2900);
    int tmp_163 = use_ret == - (-0x2980);
    int tmp_165 = use_ret == - (-0x2A00);
    int tmp_167 = use_ret == - (-0x2A80);
    int tmp_169 = use_ret == - (-0x2B00);
    tmp_0 = strlen((char const *)buf);
  }
  use_ret = ret & ~ 0xFF80;
  if (use_ret == 0) goto return_label;
  len = strlen((char const *)buf);
  if (len > (size_t)0) {
    if (buflen - len < (size_t)5) goto return_label;
    buf += len + (size_t)3;
    buflen -= len + (size_t)3;
  }
  int tmp_171 = use_ret == - (-0x0020);
  int tmp_173 = use_ret == - (-0x0022);
  int tmp_175 = use_ret == - (-0x0014);
  int tmp_177 = use_ret == - (-0x0016);
  int tmp_179 = use_ret == - (-0x0018);
  int tmp_181 = use_ret == - (-0x001A);
  int tmp_183 = use_ret == - (-0x001C);
  int tmp_185 = use_ret == - (-0x001E);
  int tmp_187 = use_ret == - (-0x002A);
  int tmp_189 = use_ret == - (-0x002C);
  int tmp_191 = use_ret == - (-0x0002);
  int tmp_193 = use_ret == - (-0x0004);
  int tmp_195 = use_ret == - (-0x0006);
  int tmp_197 = use_ret == - (-0x0008);
  int tmp_199 = use_ret == - (-0x000A);
  int tmp_201 = use_ret == - (-0x000C);
  int tmp_203 = use_ret == - (-0x000E);
  int tmp_205 = use_ret == - (-0x0010);
  int tmp_207 = use_ret == - (-0x0024);
  int tmp_209 = use_ret == - (-0x0026);
  int tmp_211 = use_ret == - (-0x0034);
  int tmp_213 = use_ret == - (-0x0036);
  int tmp_215 = use_ret == - (-0x0038);
  int tmp_217 = use_ret == - (-0x003A);
  int tmp_219 = use_ret == - (-0x0032);
  int tmp_221 = use_ret == - (-0x003C);
  int tmp_223 = use_ret == - (-0x003E);
  int tmp_225 = use_ret == - (-0x0040);
  int tmp_227 = use_ret == - (-0x0074);
  int tmp_229 = use_ret == - (-0x0040);
  int tmp_231 = use_ret == - (-0x0042);
  int tmp_233 = use_ret == - (-0x0044);
  int tmp_235 = use_ret == - (-0x0046);
  int tmp_237 = use_ret == - (-0x0048);
  int tmp_239 = use_ret == - (-0x004A);
  int tmp_241 = use_ret == - (-0x004C);
  int tmp_243 = use_ret == - (-0x004E);
  int tmp_245 = use_ret == - (-0x0050);
  int tmp_247 = use_ret == - (-0x0052);
  int tmp_249 = use_ret == - (-0x0054);
  int tmp_251 = use_ret == - (-0x0030);
  int tmp_253 = use_ret == - (-0x0076);
  int tmp_255 = use_ret == - (-0x0078);
  int tmp_257 = use_ret == - (-0x007A);
  int tmp_259 = use_ret == - (-0x0028);
  tmp_0_0 = strlen((char const *)buf);
  if (tmp_0_0 != (size_t)0) goto return_label;
  return_label: return;
}

__inline static unsigned char md_get_size_0(md_info_t const *md_info)
{
  unsigned char __retres;
  __retres = (unsigned char)md_info->size;
  return __retres;
}

__inline static md_type_t md_get_type_0(md_info_t const *md_info)
{
  md_type_t __retres;
  __retres = md_info->type;
  return __retres;
}

__inline static char const *md_get_name_0(md_info_t const *md_info)
{
  char const *__retres;
  __retres = md_info->name;
  return __retres;
}

md_info_t const md5_info;

md_info_t const sha1_info;

md_info_t const sha224_info;

md_info_t const sha256_info;

md_info_t const sha384_info;

md_info_t const sha512_info;

static int const supported_digests[7] =
  {POLARSSL_MD_MD5,
   POLARSSL_MD_SHA1,
   POLARSSL_MD_SHA224,
   POLARSSL_MD_SHA256,
   POLARSSL_MD_SHA384,
   POLARSSL_MD_SHA512,
   0};
int const *md_list(void)
{
  int const *__retres;
  __retres = supported_digests;
  return __retres;
}

md_info_t const *md_info_from_string(char const *md_name)
{
  md_info_t const *__retres;
  int tmp_0;
  int tmp_2;
  int tmp_5;
  int tmp_7;
  int tmp_9;
  int tmp_11;
  if ((char const *)0 == md_name) {
    __retres = (md_info_t const *)0;
    goto return_label;
  }
  tmp_0 = strcasecmp("MD5",md_name);
  if (! tmp_0) {
    md_info_t const *tmp;
    tmp = md_info_from_type(POLARSSL_MD_MD5);
    __retres = tmp;
    goto return_label;
  }
  tmp_2 = strcasecmp("SHA1",md_name);
  if (tmp_2) {
    int tmp_3;
    tmp_3 = strcasecmp("SHA",md_name);
    if (! tmp_3) {
      md_info_t const *tmp_1;
      _LOR: tmp_1 = md_info_from_type(POLARSSL_MD_SHA1);
      __retres = tmp_1;
      goto return_label;
    }
  }
  else goto _LOR;
  tmp_5 = strcasecmp("SHA224",md_name);
  if (! tmp_5) {
    md_info_t const *tmp_4;
    tmp_4 = md_info_from_type(POLARSSL_MD_SHA224);
    __retres = tmp_4;
    goto return_label;
  }
  tmp_7 = strcasecmp("SHA256",md_name);
  if (! tmp_7) {
    md_info_t const *tmp_6;
    tmp_6 = md_info_from_type(POLARSSL_MD_SHA256);
    __retres = tmp_6;
    goto return_label;
  }
  tmp_9 = strcasecmp("SHA384",md_name);
  if (! tmp_9) {
    md_info_t const *tmp_8;
    tmp_8 = md_info_from_type(POLARSSL_MD_SHA384);
    __retres = tmp_8;
    goto return_label;
  }
  tmp_11 = strcasecmp("SHA512",md_name);
  if (! tmp_11) {
    md_info_t const *tmp_10;
    tmp_10 = md_info_from_type(POLARSSL_MD_SHA512);
    __retres = tmp_10;
    goto return_label;
  }
  __retres = (md_info_t const *)0;
  return_label: return __retres;
}

md_info_t const *md_info_from_type(md_type_t md_type)
{
  md_info_t const *__retres;
  switch (md_type) {
    case POLARSSL_MD_MD5: __retres = & md5_info;
    goto return_label;
    case POLARSSL_MD_SHA1: __retres = & sha1_info;
    goto return_label;
    case POLARSSL_MD_SHA224: __retres = & sha224_info;
    goto return_label;
    case POLARSSL_MD_SHA256: __retres = & sha256_info;
    goto return_label;
    case POLARSSL_MD_SHA384: __retres = & sha384_info;
    goto return_label;
    case POLARSSL_MD_SHA512: __retres = & sha512_info;
    goto return_label;
    default: __retres = (md_info_t const *)0;
    goto return_label;
  }
  return_label: return __retres;
}

int md_init_ctx(md_context_t *ctx, md_info_t const *md_info)
{
  int __retres;
  void *tmp;
  if (md_info == (md_info_t const *)0) {
    __retres = -0x5100;
    goto return_label;
  }
  else 
    if (ctx == (md_context_t *)0) {
      __retres = -0x5100;
      goto return_label;
    }
  memset((void *)ctx,0,sizeof(md_context_t));
  tmp = (*(md_info->ctx_alloc_func))();
  ctx->md_ctx = tmp;
  if (tmp == (void *)0) {
    __retres = -0x5180;
    goto return_label;
  }
  ctx->md_info = md_info;
  (*(md_info->starts_func))(ctx->md_ctx);
  __retres = 0;
  return_label: return __retres;
}

int md_free_ctx(md_context_t *ctx)
{
  int __retres;
  if (ctx == (md_context_t *)0) {
    __retres = -0x5100;
    goto return_label;
  }
  else 
    if (ctx->md_info == (md_info_t const *)0) {
      __retres = -0x5100;
      goto return_label;
    }
  (*((ctx->md_info)->ctx_free_func))(ctx->md_ctx);
  ctx->md_ctx = (void *)0;
  __retres = 0;
  return_label: return __retres;
}

int md_starts(md_context_t *ctx)
{
  int __retres;
  if (ctx == (md_context_t *)0) {
    __retres = -0x5100;
    goto return_label;
  }
  else 
    if (ctx->md_info == (md_info_t const *)0) {
      __retres = -0x5100;
      goto return_label;
    }
  (*((ctx->md_info)->starts_func))(ctx->md_ctx);
  __retres = 0;
  return_label: return __retres;
}

int md_update(md_context_t *ctx, unsigned char const *input, size_t ilen)
{
  int __retres;
  if (ctx == (md_context_t *)0) {
    __retres = -0x5100;
    goto return_label;
  }
  else 
    if (ctx->md_info == (md_info_t const *)0) {
      __retres = -0x5100;
      goto return_label;
    }
  (*((ctx->md_info)->update_func))(ctx->md_ctx,input,ilen);
  __retres = 0;
  return_label: return __retres;
}

int md_finish(md_context_t *ctx, unsigned char *output)
{
  int __retres;
  if (ctx == (md_context_t *)0) {
    __retres = -0x5100;
    goto return_label;
  }
  else 
    if (ctx->md_info == (md_info_t const *)0) {
      __retres = -0x5100;
      goto return_label;
    }
  (*((ctx->md_info)->finish_func))(ctx->md_ctx,output);
  __retres = 0;
  return_label: return __retres;
}

int md(md_info_t const *md_info, unsigned char const *input, size_t ilen,
       unsigned char *output)
{
  int __retres;
  if (md_info == (md_info_t const *)0) {
    __retres = -0x5100;
    goto return_label;
  }
  (*(md_info->digest_func))(input,ilen,output);
  __retres = 0;
  return_label: return __retres;
}

int md_file(md_info_t const *md_info, char const *path, unsigned char *output)
{
  int __retres;
  int ret;
  if (md_info == (md_info_t const *)0) {
    __retres = -0x5100;
    goto return_label;
  }
  ret = (*(md_info->file_func))(path,output);
  if (ret != 0) {
    __retres = -0x5200 + ret;
    goto return_label;
  }
  __retres = ret;
  return_label: return __retres;
}

int md_hmac_starts(md_context_t *ctx, unsigned char const *key, size_t keylen)
{
  int __retres;
  if (ctx == (md_context_t *)0) {
    __retres = -0x5100;
    goto return_label;
  }
  else 
    if (ctx->md_info == (md_info_t const *)0) {
      __retres = -0x5100;
      goto return_label;
    }
  (*((ctx->md_info)->hmac_starts_func))(ctx->md_ctx,key,keylen);
  __retres = 0;
  return_label: return __retres;
}

int md_hmac_update(md_context_t *ctx, unsigned char const *input, size_t ilen)
{
  int __retres;
  if (ctx == (md_context_t *)0) {
    __retres = -0x5100;
    goto return_label;
  }
  else 
    if (ctx->md_info == (md_info_t const *)0) {
      __retres = -0x5100;
      goto return_label;
    }
  (*((ctx->md_info)->hmac_update_func))(ctx->md_ctx,input,ilen);
  __retres = 0;
  return_label: return __retres;
}

int md_hmac_finish(md_context_t *ctx, unsigned char *output)
{
  int __retres;
  if (ctx == (md_context_t *)0) {
    __retres = -0x5100;
    goto return_label;
  }
  else 
    if (ctx->md_info == (md_info_t const *)0) {
      __retres = -0x5100;
      goto return_label;
    }
  (*((ctx->md_info)->hmac_finish_func))(ctx->md_ctx,output);
  __retres = 0;
  return_label: return __retres;
}

int md_hmac_reset(md_context_t *ctx)
{
  int __retres;
  if (ctx == (md_context_t *)0) {
    __retres = -0x5100;
    goto return_label;
  }
  else 
    if (ctx->md_info == (md_info_t const *)0) {
      __retres = -0x5100;
      goto return_label;
    }
  (*((ctx->md_info)->hmac_reset_func))(ctx->md_ctx);
  __retres = 0;
  return_label: return __retres;
}

int md_hmac(md_info_t const *md_info, unsigned char const *key,
            size_t keylen, unsigned char const *input, size_t ilen,
            unsigned char *output)
{
  int __retres;
  if (md_info == (md_info_t const *)0) {
    __retres = -0x5100;
    goto return_label;
  }
  (*(md_info->hmac_func))(key,keylen,input,ilen,output);
  __retres = 0;
  return_label: return __retres;
}

void md5_starts(md5_context *ctx)
{
  ctx->total[0] = (unsigned long)0;
  ctx->total[1] = (unsigned long)0;
  ctx->state[0] = (unsigned long)0x67452301;
  ctx->state[1] = (unsigned long)0xEFCDAB89;
  ctx->state[2] = (unsigned long)0x98BADCFE;
  ctx->state[3] = (unsigned long)0x10325476;
  return;
}

/*@ requires \valid(ctx);
    requires \valid_read(data + (0 .. 63));
    ensures \initialized(&\old(ctx)->state[0 .. 3]);
    assigns ctx->state[0 .. 3];
    assigns ctx->state[0 .. 3] \from _state;
 */
void md5_process(md5_context *ctx, unsigned char const data[64])
{
  unsigned long X[16];
  unsigned long A;
  unsigned long B;
  unsigned long C;
  unsigned long D;
  X[0] = (((unsigned long)*(data + 0) | ((unsigned long)*(data + (0 + 1)) << 8)) | (
          (unsigned long)*(data + (0 + 2)) << 16)) | ((unsigned long)*(
                                                      data + (0 + 3)) << 24);
  X[1] = (((unsigned long)*(data + 4) | ((unsigned long)*(data + (4 + 1)) << 8)) | (
          (unsigned long)*(data + (4 + 2)) << 16)) | ((unsigned long)*(
                                                      data + (4 + 3)) << 24);
  X[2] = (((unsigned long)*(data + 8) | ((unsigned long)*(data + (8 + 1)) << 8)) | (
          (unsigned long)*(data + (8 + 2)) << 16)) | ((unsigned long)*(
                                                      data + (8 + 3)) << 24);
  X[3] = (((unsigned long)*(data + 12) | ((unsigned long)*(data + (12 + 1)) << 8)) | (
          (unsigned long)*(data + (12 + 2)) << 16)) | ((unsigned long)*(
                                                       data + (12 + 3)) << 24);
  X[4] = (((unsigned long)*(data + 16) | ((unsigned long)*(data + (16 + 1)) << 8)) | (
          (unsigned long)*(data + (16 + 2)) << 16)) | ((unsigned long)*(
                                                       data + (16 + 3)) << 24);
  X[5] = (((unsigned long)*(data + 20) | ((unsigned long)*(data + (20 + 1)) << 8)) | (
          (unsigned long)*(data + (20 + 2)) << 16)) | ((unsigned long)*(
                                                       data + (20 + 3)) << 24);
  X[6] = (((unsigned long)*(data + 24) | ((unsigned long)*(data + (24 + 1)) << 8)) | (
          (unsigned long)*(data + (24 + 2)) << 16)) | ((unsigned long)*(
                                                       data + (24 + 3)) << 24);
  X[7] = (((unsigned long)*(data + 28) | ((unsigned long)*(data + (28 + 1)) << 8)) | (
          (unsigned long)*(data + (28 + 2)) << 16)) | ((unsigned long)*(
                                                       data + (28 + 3)) << 24);
  X[8] = (((unsigned long)*(data + 32) | ((unsigned long)*(data + (32 + 1)) << 8)) | (
          (unsigned long)*(data + (32 + 2)) << 16)) | ((unsigned long)*(
                                                       data + (32 + 3)) << 24);
  X[9] = (((unsigned long)*(data + 36) | ((unsigned long)*(data + (36 + 1)) << 8)) | (
          (unsigned long)*(data + (36 + 2)) << 16)) | ((unsigned long)*(
                                                       data + (36 + 3)) << 24);
  X[10] = (((unsigned long)*(data + 40) | ((unsigned long)*(data + (40 + 1)) << 8)) | (
           (unsigned long)*(data + (40 + 2)) << 16)) | ((unsigned long)*(
                                                        data + (40 + 3)) << 24);
  X[11] = (((unsigned long)*(data + 44) | ((unsigned long)*(data + (44 + 1)) << 8)) | (
           (unsigned long)*(data + (44 + 2)) << 16)) | ((unsigned long)*(
                                                        data + (44 + 3)) << 24);
  X[12] = (((unsigned long)*(data + 48) | ((unsigned long)*(data + (48 + 1)) << 8)) | (
           (unsigned long)*(data + (48 + 2)) << 16)) | ((unsigned long)*(
                                                        data + (48 + 3)) << 24);
  X[13] = (((unsigned long)*(data + 52) | ((unsigned long)*(data + (52 + 1)) << 8)) | (
           (unsigned long)*(data + (52 + 2)) << 16)) | ((unsigned long)*(
                                                        data + (52 + 3)) << 24);
  X[14] = (((unsigned long)*(data + 56) | ((unsigned long)*(data + (56 + 1)) << 8)) | (
           (unsigned long)*(data + (56 + 2)) << 16)) | ((unsigned long)*(
                                                        data + (56 + 3)) << 24);
  X[15] = (((unsigned long)*(data + 60) | ((unsigned long)*(data + (60 + 1)) << 8)) | (
           (unsigned long)*(data + (60 + 2)) << 16)) | ((unsigned long)*(
                                                        data + (60 + 3)) << 24);
  A = ctx->state[0];
  B = ctx->state[1];
  C = ctx->state[2];
  D = ctx->state[3];
  A += ((D ^ (B & (C ^ D))) + X[0]) + (unsigned long)0xD76AA478;
  A = ((A << 7) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 7))) + B;
  D += ((C ^ (A & (B ^ C))) + X[1]) + (unsigned long)0xE8C7B756;
  D = ((D << 12) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 12))) + A;
  C += ((B ^ (D & (A ^ B))) + X[2]) + (unsigned long)0x242070DB;
  C = ((C << 17) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 17))) + D;
  B += ((A ^ (C & (D ^ A))) + X[3]) + (unsigned long)0xC1BDCEEE;
  B = ((B << 22) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 22))) + C;
  A += ((D ^ (B & (C ^ D))) + X[4]) + (unsigned long)0xF57C0FAF;
  A = ((A << 7) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 7))) + B;
  D += ((C ^ (A & (B ^ C))) + X[5]) + (unsigned long)0x4787C62A;
  D = ((D << 12) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 12))) + A;
  C += ((B ^ (D & (A ^ B))) + X[6]) + (unsigned long)0xA8304613;
  C = ((C << 17) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 17))) + D;
  B += ((A ^ (C & (D ^ A))) + X[7]) + (unsigned long)0xFD469501;
  B = ((B << 22) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 22))) + C;
  A += ((D ^ (B & (C ^ D))) + X[8]) + (unsigned long)0x698098D8;
  A = ((A << 7) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 7))) + B;
  D += ((C ^ (A & (B ^ C))) + X[9]) + (unsigned long)0x8B44F7AF;
  D = ((D << 12) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 12))) + A;
  C += ((B ^ (D & (A ^ B))) + X[10]) + (unsigned long)0xFFFF5BB1;
  C = ((C << 17) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 17))) + D;
  B += ((A ^ (C & (D ^ A))) + X[11]) + (unsigned long)0x895CD7BE;
  B = ((B << 22) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 22))) + C;
  A += ((D ^ (B & (C ^ D))) + X[12]) + (unsigned long)0x6B901122;
  A = ((A << 7) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 7))) + B;
  D += ((C ^ (A & (B ^ C))) + X[13]) + (unsigned long)0xFD987193;
  D = ((D << 12) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 12))) + A;
  C += ((B ^ (D & (A ^ B))) + X[14]) + (unsigned long)0xA679438E;
  C = ((C << 17) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 17))) + D;
  B += ((A ^ (C & (D ^ A))) + X[15]) + (unsigned long)0x49B40821;
  B = ((B << 22) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 22))) + C;
  A += ((C ^ (D & (B ^ C))) + X[1]) + (unsigned long)0xF61E2562;
  A = ((A << 5) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + B;
  D += ((B ^ (C & (A ^ B))) + X[6]) + (unsigned long)0xC040B340;
  D = ((D << 9) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 9))) + A;
  C += ((A ^ (B & (D ^ A))) + X[11]) + (unsigned long)0x265E5A51;
  C = ((C << 14) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 14))) + D;
  B += ((D ^ (A & (C ^ D))) + X[0]) + (unsigned long)0xE9B6C7AA;
  B = ((B << 20) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 20))) + C;
  A += ((C ^ (D & (B ^ C))) + X[5]) + (unsigned long)0xD62F105D;
  A = ((A << 5) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + B;
  D += ((B ^ (C & (A ^ B))) + X[10]) + (unsigned long)0x02441453;
  D = ((D << 9) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 9))) + A;
  C += ((A ^ (B & (D ^ A))) + X[15]) + (unsigned long)0xD8A1E681;
  C = ((C << 14) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 14))) + D;
  B += ((D ^ (A & (C ^ D))) + X[4]) + (unsigned long)0xE7D3FBC8;
  B = ((B << 20) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 20))) + C;
  A += ((C ^ (D & (B ^ C))) + X[9]) + (unsigned long)0x21E1CDE6;
  A = ((A << 5) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + B;
  D += ((B ^ (C & (A ^ B))) + X[14]) + (unsigned long)0xC33707D6;
  D = ((D << 9) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 9))) + A;
  C += ((A ^ (B & (D ^ A))) + X[3]) + (unsigned long)0xF4D50D87;
  C = ((C << 14) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 14))) + D;
  B += ((D ^ (A & (C ^ D))) + X[8]) + (unsigned long)0x455A14ED;
  B = ((B << 20) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 20))) + C;
  A += ((C ^ (D & (B ^ C))) + X[13]) + (unsigned long)0xA9E3E905;
  A = ((A << 5) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + B;
  D += ((B ^ (C & (A ^ B))) + X[2]) + (unsigned long)0xFCEFA3F8;
  D = ((D << 9) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 9))) + A;
  C += ((A ^ (B & (D ^ A))) + X[7]) + (unsigned long)0x676F02D9;
  C = ((C << 14) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 14))) + D;
  B += ((D ^ (A & (C ^ D))) + X[12]) + (unsigned long)0x8D2A4C8A;
  B = ((B << 20) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 20))) + C;
  A += (((B ^ C) ^ D) + X[5]) + (unsigned long)0xFFFA3942;
  A = ((A << 4) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 4))) + B;
  D += (((A ^ B) ^ C) + X[8]) + (unsigned long)0x8771F681;
  D = ((D << 11) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 11))) + A;
  C += (((D ^ A) ^ B) + X[11]) + (unsigned long)0x6D9D6122;
  C = ((C << 16) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 16))) + D;
  B += (((C ^ D) ^ A) + X[14]) + (unsigned long)0xFDE5380C;
  B = ((B << 23) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 23))) + C;
  A += (((B ^ C) ^ D) + X[1]) + (unsigned long)0xA4BEEA44;
  A = ((A << 4) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 4))) + B;
  D += (((A ^ B) ^ C) + X[4]) + (unsigned long)0x4BDECFA9;
  D = ((D << 11) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 11))) + A;
  C += (((D ^ A) ^ B) + X[7]) + (unsigned long)0xF6BB4B60;
  C = ((C << 16) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 16))) + D;
  B += (((C ^ D) ^ A) + X[10]) + (unsigned long)0xBEBFBC70;
  B = ((B << 23) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 23))) + C;
  A += (((B ^ C) ^ D) + X[13]) + (unsigned long)0x289B7EC6;
  A = ((A << 4) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 4))) + B;
  D += (((A ^ B) ^ C) + X[0]) + (unsigned long)0xEAA127FA;
  D = ((D << 11) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 11))) + A;
  C += (((D ^ A) ^ B) + X[3]) + (unsigned long)0xD4EF3085;
  C = ((C << 16) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 16))) + D;
  B += (((C ^ D) ^ A) + X[6]) + (unsigned long)0x04881D05;
  B = ((B << 23) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 23))) + C;
  A += (((B ^ C) ^ D) + X[9]) + (unsigned long)0xD9D4D039;
  A = ((A << 4) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 4))) + B;
  D += (((A ^ B) ^ C) + X[12]) + (unsigned long)0xE6DB99E5;
  D = ((D << 11) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 11))) + A;
  C += (((D ^ A) ^ B) + X[15]) + (unsigned long)0x1FA27CF8;
  C = ((C << 16) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 16))) + D;
  B += (((C ^ D) ^ A) + X[2]) + (unsigned long)0xC4AC5665;
  B = ((B << 23) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 23))) + C;
  A += ((C ^ (B | ~ D)) + X[0]) + (unsigned long)0xF4292244;
  A = ((A << 6) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 6))) + B;
  D += ((B ^ (A | ~ C)) + X[7]) + (unsigned long)0x432AFF97;
  D = ((D << 10) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 10))) + A;
  C += ((A ^ (D | ~ B)) + X[14]) + (unsigned long)0xAB9423A7;
  C = ((C << 15) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 15))) + D;
  B += ((D ^ (C | ~ A)) + X[5]) + (unsigned long)0xFC93A039;
  B = ((B << 21) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 21))) + C;
  A += ((C ^ (B | ~ D)) + X[12]) + (unsigned long)0x655B59C3;
  A = ((A << 6) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 6))) + B;
  D += ((B ^ (A | ~ C)) + X[3]) + (unsigned long)0x8F0CCC92;
  D = ((D << 10) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 10))) + A;
  C += ((A ^ (D | ~ B)) + X[10]) + (unsigned long)0xFFEFF47D;
  C = ((C << 15) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 15))) + D;
  B += ((D ^ (C | ~ A)) + X[1]) + (unsigned long)0x85845DD1;
  B = ((B << 21) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 21))) + C;
  A += ((C ^ (B | ~ D)) + X[8]) + (unsigned long)0x6FA87E4F;
  A = ((A << 6) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 6))) + B;
  D += ((B ^ (A | ~ C)) + X[15]) + (unsigned long)0xFE2CE6E0;
  D = ((D << 10) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 10))) + A;
  C += ((A ^ (D | ~ B)) + X[6]) + (unsigned long)0xA3014314;
  C = ((C << 15) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 15))) + D;
  B += ((D ^ (C | ~ A)) + X[13]) + (unsigned long)0x4E0811A1;
  B = ((B << 21) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 21))) + C;
  A += ((C ^ (B | ~ D)) + X[4]) + (unsigned long)0xF7537E82;
  A = ((A << 6) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 6))) + B;
  D += ((B ^ (A | ~ C)) + X[11]) + (unsigned long)0xBD3AF235;
  D = ((D << 10) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 10))) + A;
  C += ((A ^ (D | ~ B)) + X[2]) + (unsigned long)0x2AD7D2BB;
  C = ((C << 15) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 15))) + D;
  B += ((D ^ (C | ~ A)) + X[9]) + (unsigned long)0xEB86D391;
  B = ((B << 21) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 21))) + C;
  ctx->state[0] += A;
  ctx->state[1] += B;
  ctx->state[2] += C;
  ctx->state[3] += D;
  return;
}

void md5_update(md5_context *ctx, unsigned char const *input, size_t ilen)
{
  size_t fill;
  unsigned long left;
  if (ilen <= (size_t)0) goto return_label;
  left = ctx->total[0] & (unsigned long)0x3F;
  fill = (size_t)((unsigned long)64 - left);
  ctx->total[0] += (unsigned long)ilen;
  ctx->total[0] &= (unsigned long)0xFFFFFFFF;
  if (ctx->total[0] < (unsigned long)ilen) (ctx->total[1]) ++;
  if (left) 
    if (ilen >= fill) {
      memcpy((void *)(& ctx->buffer[left]),(void const *)input,fill);
      md5_process(ctx,(unsigned char const *)(ctx->buffer));
      input += fill;
      ilen -= fill;
      left = (unsigned long)0;
    }
  while (ilen >= (size_t)64) {
    md5_process(ctx,input);
    input += 64;
    ilen -= (size_t)64;
  }
  if (ilen > (size_t)0) memcpy((void *)(& ctx->buffer[left]),
                               (void const *)input,ilen);
  return_label: return;
}

static unsigned char const md5_padding[64] =
  {(unsigned char)0x80,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0};
/*@ requires \valid(output + (0 .. 15)); */
void md5_finish(md5_context *ctx, unsigned char output[16])
{
  unsigned long last;
  unsigned long padn;
  unsigned long high;
  unsigned long low;
  unsigned char msglen[8];
  high = (ctx->total[0] >> 29) | (ctx->total[1] << 3);
  low = ctx->total[0] << 3;
  msglen[0] = (unsigned char)low;
  msglen[0 + 1] = (unsigned char)(low >> 8);
  msglen[0 + 2] = (unsigned char)(low >> 16);
  msglen[0 + 3] = (unsigned char)(low >> 24);
  msglen[4] = (unsigned char)high;
  msglen[4 + 1] = (unsigned char)(high >> 8);
  msglen[4 + 2] = (unsigned char)(high >> 16);
  msglen[4 + 3] = (unsigned char)(high >> 24);
  last = ctx->total[0] & (unsigned long)0x3F;
  if (last < (unsigned long)56) padn = (unsigned long)56 - last;
  else padn = (unsigned long)120 - last;
  md5_update(ctx,md5_padding,(size_t)padn);
  md5_update(ctx,(unsigned char const *)(msglen),(size_t)8);
  *(output + 0) = (unsigned char)ctx->state[0];
  *(output + (0 + 1)) = (unsigned char)(ctx->state[0] >> 8);
  *(output + (0 + 2)) = (unsigned char)(ctx->state[0] >> 16);
  *(output + (0 + 3)) = (unsigned char)(ctx->state[0] >> 24);
  *(output + 4) = (unsigned char)ctx->state[1];
  *(output + (4 + 1)) = (unsigned char)(ctx->state[1] >> 8);
  *(output + (4 + 2)) = (unsigned char)(ctx->state[1] >> 16);
  *(output + (4 + 3)) = (unsigned char)(ctx->state[1] >> 24);
  *(output + 8) = (unsigned char)ctx->state[2];
  *(output + (8 + 1)) = (unsigned char)(ctx->state[2] >> 8);
  *(output + (8 + 2)) = (unsigned char)(ctx->state[2] >> 16);
  *(output + (8 + 3)) = (unsigned char)(ctx->state[2] >> 24);
  *(output + 12) = (unsigned char)ctx->state[3];
  *(output + (12 + 1)) = (unsigned char)(ctx->state[3] >> 8);
  *(output + (12 + 2)) = (unsigned char)(ctx->state[3] >> 16);
  *(output + (12 + 3)) = (unsigned char)(ctx->state[3] >> 24);
  return;
}

/*@ requires \valid(output + (0 .. 15)); */
void md5(unsigned char const *input, size_t ilen, unsigned char output[16])
{
  md5_context ctx;
  md5_starts(& ctx);
  md5_update(& ctx,input,ilen);
  md5_finish(& ctx,output);
  memset((void *)(& ctx),0,sizeof(md5_context));
  return;
}

int md5_file(char const *path, unsigned char output[16])
{
  int __retres;
  FILE *f;
  size_t n;
  md5_context ctx;
  unsigned char buf[1024];
  int tmp;
  f = fopen(path,"rb");
  if (f == (FILE *)0) {
    __retres = -0x0074;
    goto return_label;
  }
  md5_starts(& ctx);
  while (1) {
    n = fread((void *)(buf),(size_t)1,sizeof(buf),f);
    if (! (n > (size_t)0)) break;
    md5_update(& ctx,(unsigned char const *)(buf),n);
  }
  md5_finish(& ctx,output);
  memset((void *)(& ctx),0,sizeof(md5_context));
  tmp = ferror(f);
  if (tmp != 0) {
    fclose(f);
    __retres = -0x0074;
    goto return_label;
  }
  fclose(f);
  __retres = 0;
  return_label: return __retres;
}

void md5_hmac_starts(md5_context *ctx, unsigned char const *key,
                     size_t keylen)
{
  size_t i;
  unsigned char sum[16];
  if (keylen > (size_t)64) {
    md5(key,keylen,sum);
    keylen = (size_t)16;
    key = (unsigned char const *)(sum);
  }
  memset((void *)(ctx->ipad),0x36,(size_t)64);
  memset((void *)(ctx->opad),0x5C,(size_t)64);
  i = (size_t)0;
  /*@ loop unroll 64; */
  while (i < keylen) {
    ctx->ipad[i] = (unsigned char)((int)ctx->ipad[i] ^ (int)*(key + i));
    ctx->opad[i] = (unsigned char)((int)ctx->opad[i] ^ (int)*(key + i));
    i ++;
  }
  md5_starts(ctx);
  md5_update(ctx,(unsigned char const *)(ctx->ipad),(size_t)64);
  memset((void *)(sum),0,sizeof(sum));
  return;
}

void md5_hmac_update(md5_context *ctx, unsigned char const *input,
                     size_t ilen)
{
  md5_update(ctx,input,ilen);
  return;
}

void md5_hmac_finish(md5_context *ctx, unsigned char output[16])
{
  unsigned char tmpbuf[16];
  md5_finish(ctx,tmpbuf);
  md5_starts(ctx);
  md5_update(ctx,(unsigned char const *)(ctx->opad),(size_t)64);
  md5_update(ctx,(unsigned char const *)(tmpbuf),(size_t)16);
  md5_finish(ctx,output);
  memset((void *)(tmpbuf),0,sizeof(tmpbuf));
  return;
}

void md5_hmac_reset(md5_context *ctx)
{
  md5_starts(ctx);
  md5_update(ctx,(unsigned char const *)(ctx->ipad),(size_t)64);
  return;
}

void md5_hmac(unsigned char const *key, size_t keylen,
              unsigned char const *input, size_t ilen,
              unsigned char output[16])
{
  md5_context ctx;
  md5_hmac_starts(& ctx,key,keylen);
  md5_hmac_update(& ctx,input,ilen);
  md5_hmac_finish(& ctx,output);
  memset((void *)(& ctx),0,sizeof(md5_context));
  return;
}

static unsigned char md5_test_buf[7][81] =
  {{(unsigned char)'\000'},
   {(unsigned char)'a', (unsigned char)'\000'},
   {(unsigned char)'a',
    (unsigned char)'b',
    (unsigned char)'c',
    (unsigned char)'\000'},
   {(unsigned char)'m',
    (unsigned char)'e',
    (unsigned char)'s',
    (unsigned char)'s',
    (unsigned char)'a',
    (unsigned char)'g',
    (unsigned char)'e',
    (unsigned char)' ',
    (unsigned char)'d',
    (unsigned char)'i',
    (unsigned char)'g',
    (unsigned char)'e',
    (unsigned char)'s',
    (unsigned char)'t',
    (unsigned char)'\000'},
   {(unsigned char)'a',
    (unsigned char)'b',
    (unsigned char)'c',
    (unsigned char)'d',
    (unsigned char)'e',
    (unsigned char)'f',
    (unsigned char)'g',
    (unsigned char)'h',
    (unsigned char)'i',
    (unsigned char)'j',
    (unsigned char)'k',
    (unsigned char)'l',
    (unsigned char)'m',
    (unsigned char)'n',
    (unsigned char)'o',
    (unsigned char)'p',
    (unsigned char)'q',
    (unsigned char)'r',
    (unsigned char)'s',
    (unsigned char)'t',
    (unsigned char)'u',
    (unsigned char)'v',
    (unsigned char)'w',
    (unsigned char)'x',
    (unsigned char)'y',
    (unsigned char)'z',
    (unsigned char)'\000'},
   {(unsigned char)'A',
    (unsigned char)'B',
    (unsigned char)'C',
    (unsigned char)'D',
    (unsigned char)'E',
    (unsigned char)'F',
    (unsigned char)'G',
    (unsigned char)'H',
    (unsigned char)'I',
    (unsigned char)'J',
    (unsigned char)'K',
    (unsigned char)'L',
    (unsigned char)'M',
    (unsigned char)'N',
    (unsigned char)'O',
    (unsigned char)'P',
    (unsigned char)'Q',
    (unsigned char)'R',
    (unsigned char)'S',
    (unsigned char)'T',
    (unsigned char)'U',
    (unsigned char)'V',
    (unsigned char)'W',
    (unsigned char)'X',
    (unsigned char)'Y',
    (unsigned char)'Z',
    (unsigned char)'a',
    (unsigned char)'b',
    (unsigned char)'c',
    (unsigned char)'d',
    (unsigned char)'e',
    (unsigned char)'f',
    (unsigned char)'g',
    (unsigned char)'h',
    (unsigned char)'i',
    (unsigned char)'j',
    (unsigned char)'k',
    (unsigned char)'l',
    (unsigned char)'m',
    (unsigned char)'n',
    (unsigned char)'o',
    (unsigned char)'p',
    (unsigned char)'q',
    (unsigned char)'r',
    (unsigned char)'s',
    (unsigned char)'t',
    (unsigned char)'u',
    (unsigned char)'v',
    (unsigned char)'w',
    (unsigned char)'x',
    (unsigned char)'y',
    (unsigned char)'z',
    (unsigned char)'0',
    (unsigned char)'1',
    (unsigned char)'2',
    (unsigned char)'3',
    (unsigned char)'4',
    (unsigned char)'5',
    (unsigned char)'6',
    (unsigned char)'7',
    (unsigned char)'8',
    (unsigned char)'9',
    (unsigned char)'\000'},
   {(unsigned char)'1',
    (unsigned char)'2',
    (unsigned char)'3',
    (unsigned char)'4',
    (unsigned char)'5',
    (unsigned char)'6',
    (unsigned char)'7',
    (unsigned char)'8',
    (unsigned char)'9',
    (unsigned char)'0',
    (unsigned char)'1',
    (unsigned char)'2',
    (unsigned char)'3',
    (unsigned char)'4',
    (unsigned char)'5',
    (unsigned char)'6',
    (unsigned char)'7',
    (unsigned char)'8',
    (unsigned char)'9',
    (unsigned char)'0',
    (unsigned char)'1',
    (unsigned char)'2',
    (unsigned char)'3',
    (unsigned char)'4',
    (unsigned char)'5',
    (unsigned char)'6',
    (unsigned char)'7',
    (unsigned char)'8',
    (unsigned char)'9',
    (unsigned char)'0',
    (unsigned char)'1',
    (unsigned char)'2',
    (unsigned char)'3',
    (unsigned char)'4',
    (unsigned char)'5',
    (unsigned char)'6',
    (unsigned char)'7',
    (unsigned char)'8',
    (unsigned char)'9',
    (unsigned char)'0',
    (unsigned char)'1',
    (unsigned char)'2',
    (unsigned char)'3',
    (unsigned char)'4',
    (unsigned char)'5',
    (unsigned char)'6',
    (unsigned char)'7',
    (unsigned char)'8',
    (unsigned char)'9',
    (unsigned char)'0',
    (unsigned char)'1',
    (unsigned char)'2',
    (unsigned char)'3',
    (unsigned char)'4',
    (unsigned char)'5',
    (unsigned char)'6',
    (unsigned char)'7',
    (unsigned char)'8',
    (unsigned char)'9',
    (unsigned char)'0',
    (unsigned char)'1',
    (unsigned char)'2',
    (unsigned char)'3',
    (unsigned char)'4',
    (unsigned char)'5',
    (unsigned char)'6',
    (unsigned char)'7',
    (unsigned char)'8',
    (unsigned char)'9',
    (unsigned char)'0',
    (unsigned char)'1',
    (unsigned char)'2',
    (unsigned char)'3',
    (unsigned char)'4',
    (unsigned char)'5',
    (unsigned char)'6',
    (unsigned char)'7',
    (unsigned char)'8',
    (unsigned char)'9',
    (unsigned char)'0',
    (unsigned char)'\000'}};
static int const md5_test_buflen[7] = {0, 1, 3, 14, 26, 62, 80};
static unsigned char const md5_test_sum[7][16] =
  {{(unsigned char)0xD4,
    (unsigned char)0x1D,
    (unsigned char)0x8C,
    (unsigned char)0xD9,
    (unsigned char)0x8F,
    (unsigned char)0x00,
    (unsigned char)0xB2,
    (unsigned char)0x04,
    (unsigned char)0xE9,
    (unsigned char)0x80,
    (unsigned char)0x09,
    (unsigned char)0x98,
    (unsigned char)0xEC,
    (unsigned char)0xF8,
    (unsigned char)0x42,
    (unsigned char)0x7E},
   {(unsigned char)0x0C,
    (unsigned char)0xC1,
    (unsigned char)0x75,
    (unsigned char)0xB9,
    (unsigned char)0xC0,
    (unsigned char)0xF1,
    (unsigned char)0xB6,
    (unsigned char)0xA8,
    (unsigned char)0x31,
    (unsigned char)0xC3,
    (unsigned char)0x99,
    (unsigned char)0xE2,
    (unsigned char)0x69,
    (unsigned char)0x77,
    (unsigned char)0x26,
    (unsigned char)0x61},
   {(unsigned char)0x90,
    (unsigned char)0x01,
    (unsigned char)0x50,
    (unsigned char)0x98,
    (unsigned char)0x3C,
    (unsigned char)0xD2,
    (unsigned char)0x4F,
    (unsigned char)0xB0,
    (unsigned char)0xD6,
    (unsigned char)0x96,
    (unsigned char)0x3F,
    (unsigned char)0x7D,
    (unsigned char)0x28,
    (unsigned char)0xE1,
    (unsigned char)0x7F,
    (unsigned char)0x72},
   {(unsigned char)0xF9,
    (unsigned char)0x6B,
    (unsigned char)0x69,
    (unsigned char)0x7D,
    (unsigned char)0x7C,
    (unsigned char)0xB7,
    (unsigned char)0x93,
    (unsigned char)0x8D,
    (unsigned char)0x52,
    (unsigned char)0x5A,
    (unsigned char)0x2F,
    (unsigned char)0x31,
    (unsigned char)0xAA,
    (unsigned char)0xF1,
    (unsigned char)0x61,
    (unsigned char)0xD0},
   {(unsigned char)0xC3,
    (unsigned char)0xFC,
    (unsigned char)0xD3,
    (unsigned char)0xD7,
    (unsigned char)0x61,
    (unsigned char)0x92,
    (unsigned char)0xE4,
    (unsigned char)0x00,
    (unsigned char)0x7D,
    (unsigned char)0xFB,
    (unsigned char)0x49,
    (unsigned char)0x6C,
    (unsigned char)0xCA,
    (unsigned char)0x67,
    (unsigned char)0xE1,
    (unsigned char)0x3B},
   {(unsigned char)0xD1,
    (unsigned char)0x74,
    (unsigned char)0xAB,
    (unsigned char)0x98,
    (unsigned char)0xD2,
    (unsigned char)0x77,
    (unsigned char)0xD9,
    (unsigned char)0xF5,
    (unsigned char)0xA5,
    (unsigned char)0x61,
    (unsigned char)0x1C,
    (unsigned char)0x2C,
    (unsigned char)0x9F,
    (unsigned char)0x41,
    (unsigned char)0x9D,
    (unsigned char)0x9F},
   {(unsigned char)0x57,
    (unsigned char)0xED,
    (unsigned char)0xF4,
    (unsigned char)0xA2,
    (unsigned char)0x2B,
    (unsigned char)0xE3,
    (unsigned char)0xC9,
    (unsigned char)0x55,
    (unsigned char)0xAC,
    (unsigned char)0x49,
    (unsigned char)0xDA,
    (unsigned char)0x2E,
    (unsigned char)0x21,
    (unsigned char)0x07,
    (unsigned char)0xB6,
    (unsigned char)0x7A}};
static unsigned char md5_hmac_test_key[7][26] =
  {{(unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\000'},
   {(unsigned char)'J',
    (unsigned char)'e',
    (unsigned char)'f',
    (unsigned char)'e',
    (unsigned char)'\000'},
   {(unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\000'},
   {(unsigned char)'\001',
    (unsigned char)'\002',
    (unsigned char)'\003',
    (unsigned char)'\004',
    (unsigned char)'\005',
    (unsigned char)'\006',
    (unsigned char)'\a',
    (unsigned char)'\b',
    (unsigned char)'\t',
    (unsigned char)'\n',
    (unsigned char)'\v',
    (unsigned char)'\f',
    (unsigned char)'\r',
    (unsigned char)'\016',
    (unsigned char)'\017',
    (unsigned char)'\020',
    (unsigned char)'\021',
    (unsigned char)'\022',
    (unsigned char)'\023',
    (unsigned char)'\024',
    (unsigned char)'\025',
    (unsigned char)'\026',
    (unsigned char)'\027',
    (unsigned char)'\030',
    (unsigned char)'\031',
    (unsigned char)'\000'},
   {(unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\000'},
   {(unsigned char)'\000'},
   {(unsigned char)'\000'}};
static int const md5_hmac_test_keylen[7] = {16, 4, 16, 25, 16, 80, 80};
static unsigned char md5_hmac_test_buf[7][74] =
  {{(unsigned char)'H',
    (unsigned char)'i',
    (unsigned char)' ',
    (unsigned char)'T',
    (unsigned char)'h',
    (unsigned char)'e',
    (unsigned char)'r',
    (unsigned char)'e',
    (unsigned char)'\000'},
   {(unsigned char)'w',
    (unsigned char)'h',
    (unsigned char)'a',
    (unsigned char)'t',
    (unsigned char)' ',
    (unsigned char)'d',
    (unsigned char)'o',
    (unsigned char)' ',
    (unsigned char)'y',
    (unsigned char)'a',
    (unsigned char)' ',
    (unsigned char)'w',
    (unsigned char)'a',
    (unsigned char)'n',
    (unsigned char)'t',
    (unsigned char)' ',
    (unsigned char)'f',
    (unsigned char)'o',
    (unsigned char)'r',
    (unsigned char)' ',
    (unsigned char)'n',
    (unsigned char)'o',
    (unsigned char)'t',
    (unsigned char)'h',
    (unsigned char)'i',
    (unsigned char)'n',
    (unsigned char)'g',
    (unsigned char)'?',
    (unsigned char)'\000'},
   {(unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\000'},
   {(unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\000'},
   {(unsigned char)'T',
    (unsigned char)'e',
    (unsigned char)'s',
    (unsigned char)'t',
    (unsigned char)' ',
    (unsigned char)'W',
    (unsigned char)'i',
    (unsigned char)'t',
    (unsigned char)'h',
    (unsigned char)' ',
    (unsigned char)'T',
    (unsigned char)'r',
    (unsigned char)'u',
    (unsigned char)'n',
    (unsigned char)'c',
    (unsigned char)'a',
    (unsigned char)'t',
    (unsigned char)'i',
    (unsigned char)'o',
    (unsigned char)'n',
    (unsigned char)'\000'},
   {(unsigned char)'T',
    (unsigned char)'e',
    (unsigned char)'s',
    (unsigned char)'t',
    (unsigned char)' ',
    (unsigned char)'U',
    (unsigned char)'s',
    (unsigned char)'i',
    (unsigned char)'n',
    (unsigned char)'g',
    (unsigned char)' ',
    (unsigned char)'L',
    (unsigned char)'a',
    (unsigned char)'r',
    (unsigned char)'g',
    (unsigned char)'e',
    (unsigned char)'r',
    (unsigned char)' ',
    (unsigned char)'T',
    (unsigned char)'h',
    (unsigned char)'a',
    (unsigned char)'n',
    (unsigned char)' ',
    (unsigned char)'B',
    (unsigned char)'l',
    (unsigned char)'o',
    (unsigned char)'c',
    (unsigned char)'k',
    (unsigned char)'-',
    (unsigned char)'S',
    (unsigned char)'i',
    (unsigned char)'z',
    (unsigned char)'e',
    (unsigned char)' ',
    (unsigned char)'K',
    (unsigned char)'e',
    (unsigned char)'y',
    (unsigned char)' ',
    (unsigned char)'-',
    (unsigned char)' ',
    (unsigned char)'H',
    (unsigned char)'a',
    (unsigned char)'s',
    (unsigned char)'h',
    (unsigned char)' ',
    (unsigned char)'K',
    (unsigned char)'e',
    (unsigned char)'y',
    (unsigned char)' ',
    (unsigned char)'F',
    (unsigned char)'i',
    (unsigned char)'r',
    (unsigned char)'s',
    (unsigned char)'t',
    (unsigned char)'\000'},
   {(unsigned char)'T',
    (unsigned char)'e',
    (unsigned char)'s',
    (unsigned char)'t',
    (unsigned char)' ',
    (unsigned char)'U',
    (unsigned char)'s',
    (unsigned char)'i',
    (unsigned char)'n',
    (unsigned char)'g',
    (unsigned char)' ',
    (unsigned char)'L',
    (unsigned char)'a',
    (unsigned char)'r',
    (unsigned char)'g',
    (unsigned char)'e',
    (unsigned char)'r',
    (unsigned char)' ',
    (unsigned char)'T',
    (unsigned char)'h',
    (unsigned char)'a',
    (unsigned char)'n',
    (unsigned char)' ',
    (unsigned char)'B',
    (unsigned char)'l',
    (unsigned char)'o',
    (unsigned char)'c',
    (unsigned char)'k',
    (unsigned char)'-',
    (unsigned char)'S',
    (unsigned char)'i',
    (unsigned char)'z',
    (unsigned char)'e',
    (unsigned char)' ',
    (unsigned char)'K',
    (unsigned char)'e',
    (unsigned char)'y',
    (unsigned char)' ',
    (unsigned char)'a',
    (unsigned char)'n',
    (unsigned char)'d',
    (unsigned char)' ',
    (unsigned char)'L',
    (unsigned char)'a',
    (unsigned char)'r',
    (unsigned char)'g',
    (unsigned char)'e',
    (unsigned char)'r',
    (unsigned char)' ',
    (unsigned char)'T',
    (unsigned char)'h',
    (unsigned char)'a',
    (unsigned char)'n',
    (unsigned char)' ',
    (unsigned char)'O',
    (unsigned char)'n',
    (unsigned char)'e',
    (unsigned char)' ',
    (unsigned char)'B',
    (unsigned char)'l',
    (unsigned char)'o',
    (unsigned char)'c',
    (unsigned char)'k',
    (unsigned char)'-',
    (unsigned char)'S',
    (unsigned char)'i',
    (unsigned char)'z',
    (unsigned char)'e',
    (unsigned char)' ',
    (unsigned char)'D',
    (unsigned char)'a',
    (unsigned char)'t',
    (unsigned char)'a',
    (unsigned char)'\000'}};
static int const md5_hmac_test_buflen[7] = {8, 28, 50, 50, 20, 54, 73};
static unsigned char const md5_hmac_test_sum[7][16] =
  {{(unsigned char)0x92,
    (unsigned char)0x94,
    (unsigned char)0x72,
    (unsigned char)0x7A,
    (unsigned char)0x36,
    (unsigned char)0x38,
    (unsigned char)0xBB,
    (unsigned char)0x1C,
    (unsigned char)0x13,
    (unsigned char)0xF4,
    (unsigned char)0x8E,
    (unsigned char)0xF8,
    (unsigned char)0x15,
    (unsigned char)0x8B,
    (unsigned char)0xFC,
    (unsigned char)0x9D},
   {(unsigned char)0x75,
    (unsigned char)0x0C,
    (unsigned char)0x78,
    (unsigned char)0x3E,
    (unsigned char)0x6A,
    (unsigned char)0xB0,
    (unsigned char)0xB5,
    (unsigned char)0x03,
    (unsigned char)0xEA,
    (unsigned char)0xA8,
    (unsigned char)0x6E,
    (unsigned char)0x31,
    (unsigned char)0x0A,
    (unsigned char)0x5D,
    (unsigned char)0xB7,
    (unsigned char)0x38},
   {(unsigned char)0x56,
    (unsigned char)0xBE,
    (unsigned char)0x34,
    (unsigned char)0x52,
    (unsigned char)0x1D,
    (unsigned char)0x14,
    (unsigned char)0x4C,
    (unsigned char)0x88,
    (unsigned char)0xDB,
    (unsigned char)0xB8,
    (unsigned char)0xC7,
    (unsigned char)0x33,
    (unsigned char)0xF0,
    (unsigned char)0xE8,
    (unsigned char)0xB3,
    (unsigned char)0xF6},
   {(unsigned char)0x69,
    (unsigned char)0x7E,
    (unsigned char)0xAF,
    (unsigned char)0x0A,
    (unsigned char)0xCA,
    (unsigned char)0x3A,
    (unsigned char)0x3A,
    (unsigned char)0xEA,
    (unsigned char)0x3A,
    (unsigned char)0x75,
    (unsigned char)0x16,
    (unsigned char)0x47,
    (unsigned char)0x46,
    (unsigned char)0xFF,
    (unsigned char)0xAA,
    (unsigned char)0x79},
   {(unsigned char)0x56,
    (unsigned char)0x46,
    (unsigned char)0x1E,
    (unsigned char)0xF2,
    (unsigned char)0x34,
    (unsigned char)0x2E,
    (unsigned char)0xDC,
    (unsigned char)0x00,
    (unsigned char)0xF9,
    (unsigned char)0xBA,
    (unsigned char)0xB9,
    (unsigned char)0x95},
   {(unsigned char)0x6B,
    (unsigned char)0x1A,
    (unsigned char)0xB7,
    (unsigned char)0xFE,
    (unsigned char)0x4B,
    (unsigned char)0xD7,
    (unsigned char)0xBF,
    (unsigned char)0x8F,
    (unsigned char)0x0B,
    (unsigned char)0x62,
    (unsigned char)0xE6,
    (unsigned char)0xCE,
    (unsigned char)0x61,
    (unsigned char)0xB9,
    (unsigned char)0xD0,
    (unsigned char)0xCD},
   {(unsigned char)0x6F,
    (unsigned char)0x63,
    (unsigned char)0x0F,
    (unsigned char)0xAD,
    (unsigned char)0x67,
    (unsigned char)0xCD,
    (unsigned char)0xA0,
    (unsigned char)0xEE,
    (unsigned char)0x1F,
    (unsigned char)0xB1,
    (unsigned char)0xF5,
    (unsigned char)0x62,
    (unsigned char)0xDB,
    (unsigned char)0x3A,
    (unsigned char)0xA5,
    (unsigned char)0x3E}};
/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_83(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_84(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_85(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_86(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_87(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_88(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_89(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_90(char const * restrict format);

int md5_self_test(int verbose)
{
  int __retres;
  int i;
  int buflen;
  unsigned char buf[1024];
  unsigned char md5sum[16];
  md5_context ctx;
  i = 0;
  while (i < 7) {
    {
      int tmp;
      if (verbose != 0) printf("  MD5 test #%d: ",i + 1); /* printf_va_83 */
      md5((unsigned char const *)(md5_test_buf[i]),
          (size_t)md5_test_buflen[i],md5sum);
      tmp = memcmp((void const *)(md5sum),(void const *)(md5_test_sum[i]),
                   (size_t)16);
      if (tmp != 0) {
        if (verbose != 0) printf("failed\n"); /* printf_va_84 */
        __retres = 1;
        goto return_label;
      }
      if (verbose != 0) printf("passed\n"); /* printf_va_85 */
    }
    i ++;
  }
  if (verbose != 0) printf("\n"); /* printf_va_86 */
  i = 0;
  while (i < 7) {
    {
      int tmp_0;
      if (verbose != 0) printf("  HMAC-MD5 test #%d: ",i + 1); /* printf_va_87 */
      if (i == 5) goto _LOR;
      else 
        if (i == 6) {
          _LOR:
          {
            buflen = 80;
            memset((void *)(buf),'\252',(size_t)buflen);
            md5_hmac_starts(& ctx,(unsigned char const *)(buf),
                            (size_t)buflen);
          }
        }
        else md5_hmac_starts(& ctx,
                             (unsigned char const *)(md5_hmac_test_key[i]),
                             (size_t)md5_hmac_test_keylen[i]);
      md5_hmac_update(& ctx,(unsigned char const *)(md5_hmac_test_buf[i]),
                      (size_t)md5_hmac_test_buflen[i]);
      md5_hmac_finish(& ctx,md5sum);
      if (i == 4) buflen = 12; else buflen = 16;
      tmp_0 = memcmp((void const *)(md5sum),
                     (void const *)(md5_hmac_test_sum[i]),(size_t)buflen);
      if (tmp_0 != 0) {
        if (verbose != 0) printf("failed\n"); /* printf_va_88 */
        __retres = 1;
        goto return_label;
      }
      if (verbose != 0) printf("passed\n"); /* printf_va_89 */
    }
    i ++;
  }
  if (verbose != 0) printf("\n"); /* printf_va_90 */
  __retres = 0;
  return_label: return __retres;
}

__inline static unsigned char md_get_size_1(md_info_t const *md_info)
{
  unsigned char __retres;
  __retres = (unsigned char)md_info->size;
  return __retres;
}

__inline static md_type_t md_get_type_1(md_info_t const *md_info)
{
  md_type_t __retres;
  __retres = md_info->type;
  return __retres;
}

__inline static char const *md_get_name_1(md_info_t const *md_info)
{
  char const *__retres;
  __retres = md_info->name;
  return __retres;
}

static void md5_starts_wrap(void *ctx)
{
  md5_starts((md5_context *)ctx);
  return;
}

static void md5_update_wrap(void *ctx, unsigned char const *input,
                            size_t ilen)
{
  md5_update((md5_context *)ctx,input,ilen);
  return;
}

static void md5_finish_wrap(void *ctx, unsigned char *output)
{
  md5_finish((md5_context *)ctx,output);
  return;
}

int md5_file_wrap(char const *path, unsigned char *output)
{
  int tmp;
  tmp = md5_file(path,output);
  return tmp;
}

static void md5_hmac_starts_wrap(void *ctx, unsigned char const *key,
                                 size_t keylen)
{
  md5_hmac_starts((md5_context *)ctx,key,keylen);
  return;
}

static void md5_hmac_update_wrap(void *ctx, unsigned char const *input,
                                 size_t ilen)
{
  md5_hmac_update((md5_context *)ctx,input,ilen);
  return;
}

static void md5_hmac_finish_wrap(void *ctx, unsigned char *output)
{
  md5_hmac_finish((md5_context *)ctx,output);
  return;
}

static void md5_hmac_reset_wrap(void *ctx)
{
  md5_hmac_reset((md5_context *)ctx);
  return;
}

static void *md5_ctx_alloc(void)
{
  void *tmp;
  tmp = malloc(sizeof(md5_context));
  return tmp;
}

static void md5_ctx_free(void *ctx)
{
  free(ctx);
  return;
}

md_info_t const md5_info =
  {.type = POLARSSL_MD_MD5,
   .name = "MD5",
   .size = 16,
   .starts_func = & md5_starts_wrap,
   .update_func = & md5_update_wrap,
   .finish_func = & md5_finish_wrap,
   .digest_func = & md5,
   .file_func = & md5_file_wrap,
   .hmac_starts_func = & md5_hmac_starts_wrap,
   .hmac_update_func = & md5_hmac_update_wrap,
   .hmac_finish_func = & md5_hmac_finish_wrap,
   .hmac_reset_func = & md5_hmac_reset_wrap,
   .hmac_func = & md5_hmac,
   .ctx_alloc_func = & md5_ctx_alloc,
   .ctx_free_func = & md5_ctx_free};
void sha1_starts_wrap(void *ctx)
{
  sha1_starts((sha1_context *)ctx);
  return;
}

void sha1_update_wrap(void *ctx, unsigned char const *input, size_t ilen)
{
  sha1_update((sha1_context *)ctx,input,ilen);
  return;
}

void sha1_finish_wrap(void *ctx, unsigned char *output)
{
  sha1_finish((sha1_context *)ctx,output);
  return;
}

int sha1_file_wrap(char const *path, unsigned char *output)
{
  int tmp;
  tmp = sha1_file(path,output);
  return tmp;
}

void sha1_hmac_starts_wrap(void *ctx, unsigned char const *key, size_t keylen)
{
  sha1_hmac_starts((sha1_context *)ctx,key,keylen);
  return;
}

void sha1_hmac_update_wrap(void *ctx, unsigned char const *input, size_t ilen)
{
  sha1_hmac_update((sha1_context *)ctx,input,ilen);
  return;
}

void sha1_hmac_finish_wrap(void *ctx, unsigned char *output)
{
  sha1_hmac_finish((sha1_context *)ctx,output);
  return;
}

void sha1_hmac_reset_wrap(void *ctx)
{
  sha1_hmac_reset((sha1_context *)ctx);
  return;
}

void *sha1_ctx_alloc(void)
{
  void *tmp;
  tmp = malloc(sizeof(sha1_context));
  return tmp;
}

void sha1_ctx_free(void *ctx)
{
  free(ctx);
  return;
}

md_info_t const sha1_info =
  {.type = POLARSSL_MD_SHA1,
   .name = "SHA1",
   .size = 20,
   .starts_func = & sha1_starts_wrap,
   .update_func = & sha1_update_wrap,
   .finish_func = & sha1_finish_wrap,
   .digest_func = & sha1,
   .file_func = & sha1_file_wrap,
   .hmac_starts_func = & sha1_hmac_starts_wrap,
   .hmac_update_func = & sha1_hmac_update_wrap,
   .hmac_finish_func = & sha1_hmac_finish_wrap,
   .hmac_reset_func = & sha1_hmac_reset_wrap,
   .hmac_func = & sha1_hmac,
   .ctx_alloc_func = & sha1_ctx_alloc,
   .ctx_free_func = & sha1_ctx_free};
void sha224_starts_wrap(void *ctx)
{
  sha2_starts((sha2_context *)ctx,1);
  return;
}

void sha224_update_wrap(void *ctx, unsigned char const *input, size_t ilen)
{
  sha2_update((sha2_context *)ctx,input,ilen);
  return;
}

void sha224_finish_wrap(void *ctx, unsigned char *output)
{
  sha2_finish((sha2_context *)ctx,output);
  return;
}

void sha224_wrap(unsigned char const *input, size_t ilen,
                 unsigned char *output)
{
  sha2(input,ilen,output,1);
  return;
}

int sha224_file_wrap(char const *path, unsigned char *output)
{
  int tmp;
  tmp = sha2_file(path,output,1);
  return tmp;
}

void sha224_hmac_starts_wrap(void *ctx, unsigned char const *key,
                             size_t keylen)
{
  sha2_hmac_starts((sha2_context *)ctx,key,keylen,1);
  return;
}

void sha224_hmac_update_wrap(void *ctx, unsigned char const *input,
                             size_t ilen)
{
  sha2_hmac_update((sha2_context *)ctx,input,ilen);
  return;
}

void sha224_hmac_finish_wrap(void *ctx, unsigned char *output)
{
  sha2_hmac_finish((sha2_context *)ctx,output);
  return;
}

void sha224_hmac_reset_wrap(void *ctx)
{
  sha2_hmac_reset((sha2_context *)ctx);
  return;
}

void sha224_hmac_wrap(unsigned char const *key, size_t keylen,
                      unsigned char const *input, size_t ilen,
                      unsigned char *output)
{
  sha2_hmac(key,keylen,input,ilen,output,1);
  return;
}

void *sha224_ctx_alloc(void)
{
  void *tmp;
  tmp = malloc(sizeof(sha2_context));
  return tmp;
}

void sha224_ctx_free(void *ctx)
{
  free(ctx);
  return;
}

md_info_t const sha224_info =
  {.type = POLARSSL_MD_SHA224,
   .name = "SHA224",
   .size = 28,
   .starts_func = & sha224_starts_wrap,
   .update_func = & sha224_update_wrap,
   .finish_func = & sha224_finish_wrap,
   .digest_func = & sha224_wrap,
   .file_func = & sha224_file_wrap,
   .hmac_starts_func = & sha224_hmac_starts_wrap,
   .hmac_update_func = & sha224_hmac_update_wrap,
   .hmac_finish_func = & sha224_hmac_finish_wrap,
   .hmac_reset_func = & sha224_hmac_reset_wrap,
   .hmac_func = & sha224_hmac_wrap,
   .ctx_alloc_func = & sha224_ctx_alloc,
   .ctx_free_func = & sha224_ctx_free};
void sha256_starts_wrap(void *ctx)
{
  sha2_starts((sha2_context *)ctx,0);
  return;
}

void sha256_update_wrap(void *ctx, unsigned char const *input, size_t ilen)
{
  sha2_update((sha2_context *)ctx,input,ilen);
  return;
}

void sha256_finish_wrap(void *ctx, unsigned char *output)
{
  sha2_finish((sha2_context *)ctx,output);
  return;
}

void sha256_wrap(unsigned char const *input, size_t ilen,
                 unsigned char *output)
{
  sha2(input,ilen,output,0);
  return;
}

int sha256_file_wrap(char const *path, unsigned char *output)
{
  int tmp;
  tmp = sha2_file(path,output,0);
  return tmp;
}

void sha256_hmac_starts_wrap(void *ctx, unsigned char const *key,
                             size_t keylen)
{
  sha2_hmac_starts((sha2_context *)ctx,key,keylen,0);
  return;
}

void sha256_hmac_update_wrap(void *ctx, unsigned char const *input,
                             size_t ilen)
{
  sha2_hmac_update((sha2_context *)ctx,input,ilen);
  return;
}

void sha256_hmac_finish_wrap(void *ctx, unsigned char *output)
{
  sha2_hmac_finish((sha2_context *)ctx,output);
  return;
}

void sha256_hmac_reset_wrap(void *ctx)
{
  sha2_hmac_reset((sha2_context *)ctx);
  return;
}

void sha256_hmac_wrap(unsigned char const *key, size_t keylen,
                      unsigned char const *input, size_t ilen,
                      unsigned char *output)
{
  sha2_hmac(key,keylen,input,ilen,output,0);
  return;
}

void *sha256_ctx_alloc(void)
{
  void *tmp;
  tmp = malloc(sizeof(sha2_context));
  return tmp;
}

void sha256_ctx_free(void *ctx)
{
  free(ctx);
  return;
}

md_info_t const sha256_info =
  {.type = POLARSSL_MD_SHA256,
   .name = "SHA256",
   .size = 32,
   .starts_func = & sha256_starts_wrap,
   .update_func = & sha256_update_wrap,
   .finish_func = & sha256_finish_wrap,
   .digest_func = & sha256_wrap,
   .file_func = & sha256_file_wrap,
   .hmac_starts_func = & sha256_hmac_starts_wrap,
   .hmac_update_func = & sha256_hmac_update_wrap,
   .hmac_finish_func = & sha256_hmac_finish_wrap,
   .hmac_reset_func = & sha256_hmac_reset_wrap,
   .hmac_func = & sha256_hmac_wrap,
   .ctx_alloc_func = & sha256_ctx_alloc,
   .ctx_free_func = & sha256_ctx_free};
void sha384_starts_wrap(void *ctx)
{
  sha4_starts((sha4_context *)ctx,1);
  return;
}

void sha384_update_wrap(void *ctx, unsigned char const *input, size_t ilen)
{
  sha4_update((sha4_context *)ctx,input,ilen);
  return;
}

void sha384_finish_wrap(void *ctx, unsigned char *output)
{
  sha4_finish((sha4_context *)ctx,output);
  return;
}

void sha384_wrap(unsigned char const *input, size_t ilen,
                 unsigned char *output)
{
  sha4(input,ilen,output,1);
  return;
}

int sha384_file_wrap(char const *path, unsigned char *output)
{
  int tmp;
  tmp = sha4_file(path,output,1);
  return tmp;
}

void sha384_hmac_starts_wrap(void *ctx, unsigned char const *key,
                             size_t keylen)
{
  sha4_hmac_starts((sha4_context *)ctx,key,keylen,1);
  return;
}

void sha384_hmac_update_wrap(void *ctx, unsigned char const *input,
                             size_t ilen)
{
  sha4_hmac_update((sha4_context *)ctx,input,ilen);
  return;
}

void sha384_hmac_finish_wrap(void *ctx, unsigned char *output)
{
  sha4_hmac_finish((sha4_context *)ctx,output);
  return;
}

void sha384_hmac_reset_wrap(void *ctx)
{
  sha4_hmac_reset((sha4_context *)ctx);
  return;
}

void sha384_hmac_wrap(unsigned char const *key, size_t keylen,
                      unsigned char const *input, size_t ilen,
                      unsigned char *output)
{
  sha4_hmac(key,keylen,input,ilen,output,1);
  return;
}

void *sha384_ctx_alloc(void)
{
  void *tmp;
  tmp = malloc(sizeof(sha4_context));
  return tmp;
}

void sha384_ctx_free(void *ctx)
{
  free(ctx);
  return;
}

md_info_t const sha384_info =
  {.type = POLARSSL_MD_SHA384,
   .name = "SHA384",
   .size = 48,
   .starts_func = & sha384_starts_wrap,
   .update_func = & sha384_update_wrap,
   .finish_func = & sha384_finish_wrap,
   .digest_func = & sha384_wrap,
   .file_func = & sha384_file_wrap,
   .hmac_starts_func = & sha384_hmac_starts_wrap,
   .hmac_update_func = & sha384_hmac_update_wrap,
   .hmac_finish_func = & sha384_hmac_finish_wrap,
   .hmac_reset_func = & sha384_hmac_reset_wrap,
   .hmac_func = & sha384_hmac_wrap,
   .ctx_alloc_func = & sha384_ctx_alloc,
   .ctx_free_func = & sha384_ctx_free};
void sha512_starts_wrap(void *ctx)
{
  sha4_starts((sha4_context *)ctx,0);
  return;
}

void sha512_update_wrap(void *ctx, unsigned char const *input, size_t ilen)
{
  sha4_update((sha4_context *)ctx,input,ilen);
  return;
}

void sha512_finish_wrap(void *ctx, unsigned char *output)
{
  sha4_finish((sha4_context *)ctx,output);
  return;
}

void sha512_wrap(unsigned char const *input, size_t ilen,
                 unsigned char *output)
{
  sha4(input,ilen,output,0);
  return;
}

int sha512_file_wrap(char const *path, unsigned char *output)
{
  int tmp;
  tmp = sha4_file(path,output,0);
  return tmp;
}

void sha512_hmac_starts_wrap(void *ctx, unsigned char const *key,
                             size_t keylen)
{
  sha4_hmac_starts((sha4_context *)ctx,key,keylen,0);
  return;
}

void sha512_hmac_update_wrap(void *ctx, unsigned char const *input,
                             size_t ilen)
{
  sha4_hmac_update((sha4_context *)ctx,input,ilen);
  return;
}

void sha512_hmac_finish_wrap(void *ctx, unsigned char *output)
{
  sha4_hmac_finish((sha4_context *)ctx,output);
  return;
}

void sha512_hmac_reset_wrap(void *ctx)
{
  sha4_hmac_reset((sha4_context *)ctx);
  return;
}

void sha512_hmac_wrap(unsigned char const *key, size_t keylen,
                      unsigned char const *input, size_t ilen,
                      unsigned char *output)
{
  sha4_hmac(key,keylen,input,ilen,output,0);
  return;
}

void *sha512_ctx_alloc(void)
{
  void *tmp;
  tmp = malloc(sizeof(sha4_context));
  return tmp;
}

void sha512_ctx_free(void *ctx)
{
  free(ctx);
  return;
}

md_info_t const sha512_info =
  {.type = POLARSSL_MD_SHA512,
   .name = "SHA512",
   .size = 64,
   .starts_func = & sha512_starts_wrap,
   .update_func = & sha512_update_wrap,
   .finish_func = & sha512_finish_wrap,
   .digest_func = & sha512_wrap,
   .file_func = & sha512_file_wrap,
   .hmac_starts_func = & sha512_hmac_starts_wrap,
   .hmac_update_func = & sha512_hmac_update_wrap,
   .hmac_finish_func = & sha512_hmac_finish_wrap,
   .hmac_reset_func = & sha512_hmac_reset_wrap,
   .hmac_func = & sha512_hmac_wrap,
   .ctx_alloc_func = & sha512_ctx_alloc,
   .ctx_free_func = & sha512_ctx_free};
int net_connect(int *fd, char const *host, int port)
{
  int __retres;
  struct sockaddr_in server_addr;
  struct hostent *server_host;
  int tmp;
  int tmp_0;
  signal(13,SIG_IGN);
  server_host = gethostbyname(host);
  if (server_host == (struct hostent *)0) {
    __retres = -0x0040;
    goto return_label;
  }
  tmp = socket(2,1,IPPROTO_IP);
  *fd = tmp;
  if (tmp < 0) {
    __retres = -0x0042;
    goto return_label;
  }
  memcpy((void *)(& server_addr.sin_addr),
         (void const *)*(server_host->h_addr_list + 0),
         (size_t)server_host->h_length);
  server_addr.sin_family = (sa_family_t)2;
  server_addr.sin_port = (in_port_t)((((int)((unsigned short)port) & 0xFF) << 8) | (
                                     ((int)((unsigned short)port) & 0xFF00) >> 8));
  tmp_0 = connect(*fd,(struct sockaddr const *)(& server_addr),
                  sizeof(server_addr));
  if (tmp_0 < 0) {
    close(*fd);
    __retres = -0x0044;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

/*@ requires \valid(param0);
    requires \valid(param1);
    requires \valid(param2);
    requires \valid(param3);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    ensures \initialized(param2);
    ensures \initialized(param3);
    assigns \result, *param3, *param2, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param3
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param2
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_1(char const * restrict s, char const * restrict format,
                int *param0, int *param1, int *param2, int *param3);

int net_bind(int *fd, char const *bind_ip, int port)
{
  int __retres;
  int n;
  int c[4];
  struct sockaddr_in server_addr;
  int tmp;
  int tmp_0;
  int tmp_1;
  signal(13,SIG_IGN);
  tmp = socket(2,1,IPPROTO_IP);
  *fd = tmp;
  if (tmp < 0) {
    __retres = -0x0042;
    goto return_label;
  }
  n = 1;
  setsockopt(*fd,1,2,(void const *)(& n),sizeof(n));
  server_addr.sin_addr.s_addr = (in_addr_t)((((((unsigned long)0 & (unsigned long)0xFF) << 24) | (
                                              ((unsigned long)0 & (unsigned long)0xFF00) << 8)) | (
                                             ((unsigned long)0 & (unsigned long)0xFF0000) >> 8)) | (
                                            ((unsigned long)0 & (unsigned long)0xFF000000) >> 24));
  server_addr.sin_family = (sa_family_t)2;
  server_addr.sin_port = (in_port_t)((((int)((unsigned short)port) & 0xFF) << 8) | (
                                     ((int)((unsigned short)port) & 0xFF00) >> 8));
  if (bind_ip != (char const *)0) {
    memset((void *)(c),0,sizeof(c));
    sscanf(bind_ip,"%d.%d.%d.%d",c,& c[1],& c[2],& c[3]); /* sscanf_va_1 */
    n = 0;
    /*@ loop unroll 4; */
    while (n < 4) {
      if (c[n] < 0) break;
      else 
        if (c[n] > 255) break;
      n ++;
    }
    if (n == 4) server_addr.sin_addr.s_addr = (in_addr_t)((((((((((unsigned long)c[0] << 24) | (
                                                                 (unsigned long)c[1] << 16)) | (
                                                                (unsigned long)c[2] << 8)) | (unsigned long)c[3]) & (unsigned long)0xFF) << 24) | (
                                                            ((((((unsigned long)c[0] << 24) | (
                                                                (unsigned long)c[1] << 16)) | (
                                                               (unsigned long)c[2] << 8)) | (unsigned long)c[3]) & (unsigned long)0xFF00) << 8)) | (
                                                           ((((((unsigned long)c[0] << 24) | (
                                                               (unsigned long)c[1] << 16)) | (
                                                              (unsigned long)c[2] << 8)) | (unsigned long)c[3]) & (unsigned long)0xFF0000) >> 8)) | (
                                                          ((((((unsigned long)c[0] << 24) | (
                                                              (unsigned long)c[1] << 16)) | (
                                                             (unsigned long)c[2] << 8)) | (unsigned long)c[3]) & (unsigned long)0xFF000000) >> 24));
  }
  tmp_0 = bind(*fd,(struct sockaddr const *)(& server_addr),
               sizeof(server_addr));
  if (tmp_0 < 0) {
    close(*fd);
    __retres = -0x0046;
    goto return_label;
  }
  tmp_1 = listen(*fd,10);
  if (tmp_1 != 0) {
    close(*fd);
    __retres = -0x0048;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static int net_is_blocking(void)
{
  int __retres;
  switch (__fc_errno) {
    case 11: __retres = 1;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int net_accept(int bind_fd, int *client_fd, void *client_ip)
{
  int __retres;
  struct sockaddr_in client_addr;
  socklen_t n = sizeof(client_addr);
  *client_fd = accept(bind_fd,(struct sockaddr *)(& client_addr),& n);
  if (*client_fd < 0) {
    int tmp;
    tmp = net_is_blocking();
    if (tmp != 0) {
      __retres = -0x0052;
      goto return_label;
    }
    __retres = -0x004A;
    goto return_label;
  }
  if (client_ip != (void *)0) memcpy(client_ip,
                                     (void const *)(& client_addr.sin_addr.s_addr),
                                     sizeof(client_addr.sin_addr.s_addr));
  __retres = 0;
  return_label: return __retres;
}

int net_set_block(int fd)
{
  int tmp_0;
  int tmp;
  tmp = fcntl(fd,3); /* __va_fcntl_void */
  ;
  tmp_0 = fcntl(fd,4,tmp & ~ 0x800); /* __va_fcntl_int */
  return tmp_0;
}

int net_set_nonblock(int fd)
{
  int tmp_0;
  int tmp;
  tmp = fcntl(fd,3); /* __va_fcntl_void */
  ;
  tmp_0 = fcntl(fd,4,tmp | 0x800); /* __va_fcntl_int */
  return tmp_0;
}

void net_usleep(unsigned long usec)
{
  struct timeval tv;
  tv.tv_sec = (time_t)0;
  tv.tv_usec = (suseconds_t)usec;
  select(0,(fd_set *)0,(fd_set *)0,(fd_set *)0,& tv);
  return;
}

int net_recv(void *ctx, unsigned char *buf, size_t len)
{
  int __retres;
  int ret = read(*((int *)ctx),(void *)buf,len);
  if (ret < 0) {
    int tmp_0;
    tmp_0 = net_is_blocking();
    if (tmp_0 != 0) {
      __retres = -0x0052;
      goto return_label;
    }
    if (__fc_errno == 32) {
      __retres = -0x0050;
      goto return_label;
    }
    else 
      if (__fc_errno == 104) {
        __retres = -0x0050;
        goto return_label;
      }
    if (__fc_errno == 4) {
      __retres = -0x0052;
      goto return_label;
    }
    __retres = -0x004C;
    goto return_label;
  }
  __retres = ret;
  return_label: return __retres;
}

int net_send(void *ctx, unsigned char const *buf, size_t len)
{
  int __retres;
  int ret = write(*((int *)ctx),(void const *)buf,len);
  if (ret < 0) {
    int tmp_0;
    tmp_0 = net_is_blocking();
    if (tmp_0 != 0) {
      __retres = -0x0054;
      goto return_label;
    }
    if (__fc_errno == 32) {
      __retres = -0x0050;
      goto return_label;
    }
    else 
      if (__fc_errno == 104) {
        __retres = -0x0050;
        goto return_label;
      }
    if (__fc_errno == 4) {
      __retres = -0x0054;
      goto return_label;
    }
    __retres = -0x004E;
    goto return_label;
  }
  __retres = ret;
  return_label: return __retres;
}

void net_close(int fd)
{
  shutdown(fd,2);
  close(fd);
  return;
}

static int padlock_supports_flags = -1;
int padlock_supports(int feature)
{
  int __retres;
  int ebx;
  int edx;
  if (padlock_supports_flags == -1) {
    /*@ assigns ebx, edx;
        assigns ebx \from ebx;
        assigns edx \from ebx; */
    __asm__ (
      "movl  %%ebx, %0           \n"
      "movl  $0xC0000000, %%eax  \n"
      "cpuid                     \n"
      "cmpl  $0xC0000001, %%eax  \n"
      "movl  $0, %%edx           \n"
      "jb    unsupported         \n"
      "movl  $0xC0000001, %%eax  \n"
      "cpuid                     \n"
      "unsupported:              \n"
      "movl  %%edx, %1           \n"
      "movl  %2, %%ebx           \n"
      : "=m" (ebx), "=m" (edx)
      : "m" (ebx)
      : "eax", "ecx", "edx"
      );
    padlock_supports_flags = edx;
  }
  __retres = padlock_supports_flags & feature;
  return __retres;
}

int padlock_xcryptecb(aes_context *ctx, int mode,
                      unsigned char const input[16], unsigned char output[16])
{
  int __retres;
  int ebx;
  unsigned long *rk;
  unsigned long *blk;
  unsigned long *ctrl;
  unsigned char buf[256];
  rk = ctx->rk;
  blk = (unsigned long *)((long)16 + ((long)(buf) & (long)(~ 15)));
  memcpy((void *)blk,(void const *)input,(size_t)16);
  ctrl = blk + 4;
  *ctrl = (unsigned long)((0x80 | ctx->nr) | (((ctx->nr + (mode ^ 1)) - 10) << 9));
  /*@ assigns ebx, *(ctrl + (..)), *(rk + (..)), *(blk + (..));
      assigns ebx
        \from ebx, (indirect: ctrl), (indirect: rk), (indirect: blk),
              *(ctrl + (..)), *(rk + (..)), *(blk + (..));
      assigns *(ctrl + (..))
        \from ebx, (indirect: ctrl), (indirect: rk), (indirect: blk),
              *(ctrl + (..)), *(rk + (..)), *(blk + (..));
      assigns *(rk + (..))
        \from ebx, (indirect: ctrl), (indirect: rk), (indirect: blk),
              *(ctrl + (..)), *(rk + (..)), *(blk + (..));
      assigns *(blk + (..))
        \from ebx, (indirect: ctrl), (indirect: rk), (indirect: blk),
              *(ctrl + (..)), *(rk + (..)), *(blk + (..));
  */
  __asm__ (
    "pushfl; popfl         \n"
    "movl    %%ebx, %0     \n"
    "movl    $1, %%ecx     \n"
    "movl    %2, %%edx     \n"
    "movl    %3, %%ebx     \n"
    "movl    %4, %%esi     \n"
    "movl    %4, %%edi     \n"
    ".byte  0xf3,0x0f,0xa7,0xc8\n"
    "movl    %1, %%ebx     \n"
    : "=m" (ebx)
    : "m" (ebx), "m" (ctrl), "m" (rk), "m" (blk)
    : "ecx", "edx", "esi", "edi"
    );
  memcpy((void *)output,(void const *)blk,(size_t)16);
  __retres = 0;
  return __retres;
}

int padlock_xcryptcbc(aes_context *ctx, int mode, size_t length,
                      unsigned char iv[16], unsigned char const *input,
                      unsigned char *output)
{
  int __retres;
  int ebx;
  size_t count;
  unsigned long *rk;
  unsigned long *iw;
  unsigned long *ctrl;
  unsigned char buf[256];
  if (((long)input & (long)15) != (long)0) {
    __retres = -0x0030;
    goto return_label;
  }
  else 
    if (((long)output & (long)15) != (long)0) {
      __retres = -0x0030;
      goto return_label;
    }
  rk = ctx->rk;
  iw = (unsigned long *)((long)16 + ((long)(buf) & (long)(~ 15)));
  memcpy((void *)iw,(void const *)iv,(size_t)16);
  ctrl = iw + 4;
  *ctrl = (unsigned long)((0x80 | ctx->nr) | (((ctx->nr + (mode ^ 1)) - 10) << 9));
  count = (length + (size_t)15) >> 4;
  /*@ assigns ebx, *(ctrl + (..)), *(rk + (..)), *(input + (..)),
              *(output + (..)), *(iw + (..));
      assigns ebx
        \from ebx, count, (indirect: ctrl), (indirect: rk),
              (indirect: input), (indirect: output), (indirect: iw),
              *(ctrl + (..)), *(rk + (..)), *(input + (..)),
              *(output + (..)), *(iw + (..));
      assigns *(ctrl + (..))
        \from ebx, count, (indirect: ctrl), (indirect: rk),
              (indirect: input), (indirect: output), (indirect: iw),
              *(ctrl + (..)), *(rk + (..)), *(input + (..)),
              *(output + (..)), *(iw + (..));
      assigns *(rk + (..))
        \from ebx, count, (indirect: ctrl), (indirect: rk),
              (indirect: input), (indirect: output), (indirect: iw),
              *(ctrl + (..)), *(rk + (..)), *(input + (..)),
              *(output + (..)), *(iw + (..));
      assigns *(input + (..))
        \from ebx, count, (indirect: ctrl), (indirect: rk),
              (indirect: input), (indirect: output), (indirect: iw),
              *(ctrl + (..)), *(rk + (..)), *(input + (..)),
              *(output + (..)), *(iw + (..));
      assigns *(output + (..))
        \from ebx, count, (indirect: ctrl), (indirect: rk),
              (indirect: input), (indirect: output), (indirect: iw),
              *(ctrl + (..)), *(rk + (..)), *(input + (..)),
              *(output + (..)), *(iw + (..));
      assigns *(iw + (..))
        \from ebx, count, (indirect: ctrl), (indirect: rk),
              (indirect: input), (indirect: output), (indirect: iw),
              *(ctrl + (..)), *(rk + (..)), *(input + (..)),
              *(output + (..)), *(iw + (..));
  */
  __asm__ (
    "pushfl; popfl         \n"
    "movl    %%ebx, %0     \n"
    "movl    %2, %%ecx     \n"
    "movl    %3, %%edx     \n"
    "movl    %4, %%ebx     \n"
    "movl    %5, %%esi     \n"
    "movl    %6, %%edi     \n"
    "movl    %7, %%eax     \n"
    ".byte  0xf3,0x0f,0xa7,0xd0\n"
    "movl    %1, %%ebx     \n"
    : "=m" (ebx)
    : "m" (ebx), "m" (count), "m" (ctrl), "m" (rk), "m" (input),
      "m" (output), "m" (iw)
    : "eax", "ecx", "edx", "esi", "edi"
    );
  memcpy((void *)iv,(void const *)iw,(size_t)16);
  __retres = 0;
  return_label: return __retres;
}

__inline static unsigned int cipher_get_block_size_2(cipher_context_t const *ctx)
{
  unsigned int __retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = (unsigned int)0;
    goto return_label;
  }
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) {
      __retres = (unsigned int)0;
      goto return_label;
    }
  __retres = (ctx->cipher_info)->block_size;
  return_label: return __retres;
}

__inline static cipher_mode_t cipher_get_cipher_mode_2(cipher_context_t const *ctx)
{
  cipher_mode_t __retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = POLARSSL_MODE_NONE;
    goto return_label;
  }
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) {
      __retres = POLARSSL_MODE_NONE;
      goto return_label;
    }
  __retres = (ctx->cipher_info)->mode;
  return_label: return __retres;
}

__inline static int cipher_get_iv_size_2(cipher_context_t const *ctx)
{
  int __retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = 0;
    goto return_label;
  }
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) {
      __retres = 0;
      goto return_label;
    }
  __retres = (int)(ctx->cipher_info)->iv_size;
  return_label: return __retres;
}

__inline static cipher_type_t cipher_get_type_2(cipher_context_t const *ctx)
{
  cipher_type_t __retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = (cipher_type_t)0;
    goto return_label;
  }
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) {
      __retres = (cipher_type_t)0;
      goto return_label;
    }
  __retres = (ctx->cipher_info)->type;
  return_label: return __retres;
}

__inline static char const *cipher_get_name_2(cipher_context_t const *ctx)
{
  char const *__retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = (char const *)0;
    goto return_label;
  }
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) {
      __retres = (char const *)0;
      goto return_label;
    }
  __retres = (ctx->cipher_info)->name;
  return_label: return __retres;
}

__inline static int cipher_get_key_size_2(cipher_context_t const *ctx)
{
  int __retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = POLARSSL_KEY_LENGTH_NONE;
    goto return_label;
  }
  __retres = ctx->key_length;
  return_label: return __retres;
}

__inline static operation_t cipher_get_operation_2(cipher_context_t const *ctx)
{
  operation_t __retres;
  if ((cipher_context_t const *)0 == ctx) {
    __retres = POLARSSL_OPERATION_NONE;
    goto return_label;
  }
  else 
    if ((cipher_info_t const *)0 == ctx->cipher_info) {
      __retres = POLARSSL_OPERATION_NONE;
      goto return_label;
    }
  __retres = ctx->operation;
  return_label: return __retres;
}

void pem_init(pem_context *ctx)
{
  memset((void *)ctx,0,sizeof(pem_context));
  return;
}

static int pem_get_iv(unsigned char const *s, unsigned char *iv,
                      size_t iv_len)
{
  int __retres;
  size_t i;
  size_t j;
  size_t k;
  memset((void *)iv,0,iv_len);
  i = (size_t)0;
  while (i < iv_len * (size_t)2) {
    if ((int)*s >= '0') {
      if ((int)*s <= '9') j = (size_t)((int)*s - '0'); else goto _LAND_0;
    }
    else {
      _LAND_0: ;
      if ((int)*s >= 'A') {
        if ((int)*s <= 'F') j = (size_t)((int)*s - '7'); else goto _LAND;
      }
      else {
        _LAND: ;
        if ((int)*s >= 'a') 
          if ((int)*s <= 'f') j = (size_t)((int)*s - 'W');
          else {
            __retres = -0x1200;
            goto return_label;
          }
        else {
          __retres = -0x1200;
          goto return_label;
        }
      }
    }
    if ((i & (unsigned int)1) != (unsigned int)0) k = j; else k = j << 4;
    *(iv + (i >> 1)) = (unsigned char)((unsigned int)*(iv + (i >> 1)) | k);
    i ++;
    s ++;
  }
  __retres = 0;
  return_label: return __retres;
}

static void pem_pbkdf1(unsigned char *key, size_t keylen, unsigned char *iv,
                       unsigned char const *pwd, size_t pwdlen)
{
  md5_context md5_ctx;
  unsigned char md5sum[16];
  size_t use_len;
  md5_starts(& md5_ctx);
  md5_update(& md5_ctx,pwd,pwdlen);
  md5_update(& md5_ctx,(unsigned char const *)iv,(size_t)8);
  md5_finish(& md5_ctx,md5sum);
  if (keylen <= (size_t)16) {
    memcpy((void *)key,(void const *)(md5sum),keylen);
    memset((void *)(& md5_ctx),0,sizeof(md5_ctx));
    memset((void *)(md5sum),0,(size_t)16);
    goto return_label;
  }
  memcpy((void *)key,(void const *)(md5sum),(size_t)16);
  md5_starts(& md5_ctx);
  md5_update(& md5_ctx,(unsigned char const *)(md5sum),(size_t)16);
  md5_update(& md5_ctx,pwd,pwdlen);
  md5_update(& md5_ctx,(unsigned char const *)iv,(size_t)8);
  md5_finish(& md5_ctx,md5sum);
  use_len = (size_t)16;
  if (keylen < (size_t)32) use_len = keylen - (size_t)16;
  memcpy((void *)(key + 16),(void const *)(md5sum),use_len);
  memset((void *)(& md5_ctx),0,sizeof(md5_ctx));
  memset((void *)(md5sum),0,(size_t)16);
  return_label: return;
}

static void pem_des_decrypt(unsigned char des_iv[8], unsigned char *buf,
                            size_t buflen, unsigned char const *pwd,
                            size_t pwdlen)
{
  des_context des_ctx;
  unsigned char des_key[8];
  pem_pbkdf1(des_key,(size_t)8,des_iv,pwd,pwdlen);
  des_setkey_dec(& des_ctx,(unsigned char const *)(des_key));
  des_crypt_cbc(& des_ctx,0,buflen,des_iv,(unsigned char const *)buf,buf);
  memset((void *)(& des_ctx),0,sizeof(des_ctx));
  memset((void *)(des_key),0,(size_t)8);
  return;
}

static void pem_des3_decrypt(unsigned char des3_iv[8], unsigned char *buf,
                             size_t buflen, unsigned char const *pwd,
                             size_t pwdlen)
{
  des3_context des3_ctx;
  unsigned char des3_key[24];
  pem_pbkdf1(des3_key,(size_t)24,des3_iv,pwd,pwdlen);
  des3_set3key_dec(& des3_ctx,(unsigned char const *)(des3_key));
  des3_crypt_cbc(& des3_ctx,0,buflen,des3_iv,(unsigned char const *)buf,buf);
  memset((void *)(& des3_ctx),0,sizeof(des3_ctx));
  memset((void *)(des3_key),0,(size_t)24);
  return;
}

static void pem_aes_decrypt(unsigned char aes_iv[16], unsigned int keylen,
                            unsigned char *buf, size_t buflen,
                            unsigned char const *pwd, size_t pwdlen)
{
  aes_context aes_ctx;
  unsigned char aes_key[32];
  pem_pbkdf1(aes_key,keylen,aes_iv,pwd,pwdlen);
  aes_setkey_dec(& aes_ctx,(unsigned char const *)(aes_key),
                 keylen * (unsigned int)8);
  aes_crypt_cbc(& aes_ctx,0,buflen,aes_iv,(unsigned char const *)buf,buf);
  memset((void *)(& aes_ctx),0,sizeof(aes_ctx));
  memset((void *)(aes_key),0,keylen);
  return;
}

int pem_read_buffer(pem_context *ctx, char *header, char *footer,
                    unsigned char const *data, unsigned char const *pwd,
                    size_t pwdlen, size_t *use_len)
{
  int __retres;
  int ret;
  int enc;
  size_t len;
  unsigned char *buf;
  unsigned char const *s1;
  unsigned char const *s2;
  unsigned char const *end;
  unsigned char pem_iv[16];
  size_t tmp_1;
  size_t tmp_2;
  int tmp_12;
  cipher_type_t enc_alg = POLARSSL_CIPHER_NONE;
  if (ctx == (pem_context *)0) {
    __retres = -0x1480;
    goto return_label;
  }
  s1 = (unsigned char const *)strstr((char const *)data,(char const *)header);
  if (s1 == (unsigned char const *)0) {
    __retres = -0x1080;
    goto return_label;
  }
  s2 = (unsigned char const *)strstr((char const *)data,(char const *)footer);
  if (s2 == (unsigned char const *)0) {
    __retres = -0x1080;
    goto return_label;
  }
  else 
    if (s2 <= s1) {
      __retres = -0x1080;
      goto return_label;
    }
  tmp_1 = strlen((char const *)header);
  s1 += tmp_1;
  if ((int)*s1 == '\r') s1 ++;
  if ((int)*s1 == '\n') s1 ++;
  else {
    __retres = -0x1080;
    goto return_label;
  }
  end = s2;
  tmp_2 = strlen((char const *)footer);
  end += tmp_2;
  if ((int)*end == '\r') end ++;
  if ((int)*end == '\n') end ++;
  *use_len = (size_t)(end - data);
  enc = 0;
  tmp_12 = memcmp((void const *)s1,(void const *)"Proc-Type: 4,ENCRYPTED",
                  (size_t)22);
  if (tmp_12 == 0) {
    int tmp_6;
    int tmp_11;
    enc ++;
    s1 += 22;
    if ((int)*s1 == '\r') s1 ++;
    if ((int)*s1 == '\n') s1 ++;
    else {
      __retres = -0x1100;
      goto return_label;
    }
    tmp_6 = memcmp((void const *)s1,(void const *)"DEK-Info: DES-EDE3-CBC,",
                   (size_t)23);
    if (tmp_6 == 0) {
      int tmp_3;
      enc_alg = POLARSSL_CIPHER_DES_EDE3_CBC;
      s1 += 23;
      tmp_3 = pem_get_iv(s1,pem_iv,(size_t)8);
      if (tmp_3 != 0) {
        __retres = -0x1200;
        goto return_label;
      }
      s1 += 16;
    }
    else {
      int tmp_5;
      tmp_5 = memcmp((void const *)s1,(void const *)"DEK-Info: DES-CBC,",
                     (size_t)18);
      if (tmp_5 == 0) {
        int tmp_4;
        enc_alg = POLARSSL_CIPHER_DES_CBC;
        s1 += 18;
        tmp_4 = pem_get_iv(s1,pem_iv,(size_t)8);
        if (tmp_4 != 0) {
          __retres = -0x1200;
          goto return_label;
        }
        s1 += 16;
      }
    }
    tmp_11 = memcmp((void const *)s1,(void const *)"DEK-Info: AES-",
                    (size_t)14);
    if (tmp_11 == 0) {
      int tmp_9;
      int tmp_10;
      tmp_9 = memcmp((void const *)s1,(void const *)"DEK-Info: AES-128-CBC,",
                     (size_t)22);
      if (tmp_9 == 0) enc_alg = POLARSSL_CIPHER_AES_128_CBC;
      else {
        int tmp_8;
        tmp_8 = memcmp((void const *)s1,
                       (void const *)"DEK-Info: AES-192-CBC,",(size_t)22);
        if (tmp_8 == 0) enc_alg = POLARSSL_CIPHER_AES_192_CBC;
        else {
          int tmp_7;
          tmp_7 = memcmp((void const *)s1,
                         (void const *)"DEK-Info: AES-256-CBC,",(size_t)22);
          if (tmp_7 == 0) enc_alg = POLARSSL_CIPHER_AES_256_CBC;
          else {
            __retres = -0x1280;
            goto return_label;
          }
        }
      }
      s1 += 22;
      tmp_10 = pem_get_iv(s1,pem_iv,(size_t)16);
      if (tmp_10 != 0) {
        __retres = -0x1200;
        goto return_label;
      }
      s1 += 32;
    }
    if (enc_alg == (unsigned int)POLARSSL_CIPHER_NONE) {
      __retres = -0x1280;
      goto return_label;
    }
    if ((int)*s1 == '\r') s1 ++;
    if ((int)*s1 == '\n') s1 ++;
    else {
      __retres = -0x1100;
      goto return_label;
    }
  }
  len = (size_t)0;
  ret = base64_decode((unsigned char *)0,& len,s1,(size_t)(s2 - s1));
  if (ret == -0x002C) {
    __retres = -0x1100 + ret;
    goto return_label;
  }
  buf = (unsigned char *)malloc(len);
  if (buf == (unsigned char *)0) {
    __retres = -0x1180;
    goto return_label;
  }
  ret = base64_decode(buf,& len,s1,(size_t)(s2 - s1));
  if (ret != 0) {
    free((void *)buf);
    __retres = -0x1100 + ret;
    goto return_label;
  }
  if (enc != 0) {
    if (pwd == (unsigned char const *)0) {
      free((void *)buf);
      __retres = -0x1300;
      goto return_label;
    }
    if (enc_alg == (unsigned int)POLARSSL_CIPHER_DES_EDE3_CBC) pem_des3_decrypt
                                                               (pem_iv,buf,
                                                                len,pwd,
                                                                pwdlen);
    else 
      if (enc_alg == (unsigned int)POLARSSL_CIPHER_DES_CBC) pem_des_decrypt
                                                            (pem_iv,buf,len,
                                                             pwd,pwdlen);
    if (enc_alg == (unsigned int)POLARSSL_CIPHER_AES_128_CBC) pem_aes_decrypt
                                                              (pem_iv,
                                                               (unsigned int)16,
                                                               buf,len,pwd,
                                                               pwdlen);
    else 
      if (enc_alg == (unsigned int)POLARSSL_CIPHER_AES_192_CBC) pem_aes_decrypt
                                                                (pem_iv,
                                                                 (unsigned int)24,
                                                                 buf,len,pwd,
                                                                 pwdlen);
      else 
        if (enc_alg == (unsigned int)POLARSSL_CIPHER_AES_256_CBC) pem_aes_decrypt
                                                                  (pem_iv,
                                                                   (unsigned int)32,
                                                                   buf,len,
                                                                   pwd,
                                                                   pwdlen);
    if ((int)*(buf + 0) != 0x30) goto _LOR;
    else 
      if ((int)*(buf + 1) != 0x82) goto _LOR;
      else 
        if ((int)*(buf + 4) != 0x02) goto _LOR;
        else 
          if ((int)*(buf + 5) != 0x01) {
            _LOR:
            {
              free((void *)buf);
              __retres = -0x1380;
              goto return_label;
            }
          }
  }
  ctx->buf = buf;
  ctx->buflen = len;
  __retres = 0;
  return_label: return __retres;
}

void pem_free(pem_context *ctx)
{
  if (ctx->buf) free((void *)ctx->buf);
  if (ctx->info) free((void *)ctx->info);
  memset((void *)ctx,0,sizeof(pem_context));
  return;
}

__inline static unsigned char md_get_size_2(md_info_t const *md_info)
{
  unsigned char __retres;
  __retres = (unsigned char)md_info->size;
  return __retres;
}

__inline static md_type_t md_get_type_2(md_info_t const *md_info)
{
  md_type_t __retres;
  __retres = md_info->type;
  return __retres;
}

__inline static char const *md_get_name_2(md_info_t const *md_info)
{
  char const *__retres;
  __retres = md_info->name;
  return __retres;
}

void rsa_init(rsa_context *ctx, int padding, int hash_id)
{
  memset((void *)ctx,0,sizeof(rsa_context));
  ctx->padding = padding;
  ctx->hash_id = hash_id;
  return;
}

int rsa_gen_key(rsa_context *ctx,
                int (*f_rng)(void *, unsigned char *, size_t ), void *p_rng,
                unsigned int nbits, int exponent)
{
  int __retres;
  int ret;
  mpi P1;
  mpi Q1;
  mpi H;
  mpi G;
  size_t tmp_3;
  if (f_rng == (int (*)(void *, unsigned char *, size_t ))0) {
    __retres = -0x4080;
    goto return_label;
  }
  else 
    if (nbits < (unsigned int)128) {
      __retres = -0x4080;
      goto return_label;
    }
    else 
      if (exponent < 3) {
        __retres = -0x4080;
        goto return_label;
      }
  mpi_init(& P1);
  mpi_init(& Q1);
  mpi_init(& H);
  mpi_init(& G);
  ret = mpi_lset(& ctx->E,(t_sint)exponent);
  if (ret != 0) goto cleanup;
  while (1) {
    int tmp_2;
    {
      int tmp;
      int tmp_0;
      size_t tmp_1;
      ret = mpi_gen_prime(& ctx->P,(nbits + (unsigned int)1) >> 1,0,f_rng,
                          p_rng);
      if (ret != 0) goto cleanup;
      ret = mpi_gen_prime(& ctx->Q,(nbits + (unsigned int)1) >> 1,0,f_rng,
                          p_rng);
      if (ret != 0) goto cleanup;
      tmp = mpi_cmp_mpi((mpi const *)(& ctx->P),(mpi const *)(& ctx->Q));
      if (tmp < 0) mpi_swap(& ctx->P,& ctx->Q);
      tmp_0 = mpi_cmp_mpi((mpi const *)(& ctx->P),(mpi const *)(& ctx->Q));
      if (tmp_0 == 0) goto __Cont;
      ret = mpi_mul_mpi(& ctx->N,(mpi const *)(& ctx->P),
                        (mpi const *)(& ctx->Q));
      if (ret != 0) goto cleanup;
      tmp_1 = mpi_msb((mpi const *)(& ctx->N));
      ;
      if (tmp_1 != nbits) goto __Cont;
      ret = mpi_sub_int(& P1,(mpi const *)(& ctx->P),(t_sint)1);
      if (ret != 0) goto cleanup;
      ret = mpi_sub_int(& Q1,(mpi const *)(& ctx->Q),(t_sint)1);
      if (ret != 0) goto cleanup;
      ret = mpi_mul_mpi(& H,(mpi const *)(& P1),(mpi const *)(& Q1));
      if (ret != 0) goto cleanup;
      ret = mpi_gcd(& G,(mpi const *)(& ctx->E),(mpi const *)(& H));
      if (ret != 0) goto cleanup;
    }
    __Cont: tmp_2 = mpi_cmp_int((mpi const *)(& G),(t_sint)1);
    if (! (tmp_2 != 0)) break;
  }
  ret = mpi_inv_mod(& ctx->D,(mpi const *)(& ctx->E),(mpi const *)(& H));
  if (ret != 0) goto cleanup;
  ret = mpi_mod_mpi(& ctx->DP,(mpi const *)(& ctx->D),(mpi const *)(& P1));
  if (ret != 0) goto cleanup;
  ret = mpi_mod_mpi(& ctx->DQ,(mpi const *)(& ctx->D),(mpi const *)(& Q1));
  if (ret != 0) goto cleanup;
  ret = mpi_inv_mod(& ctx->QP,(mpi const *)(& ctx->Q),
                    (mpi const *)(& ctx->P));
  if (ret != 0) goto cleanup;
  tmp_3 = mpi_msb((mpi const *)(& ctx->N));
  ctx->len = (tmp_3 + (size_t)7) >> 3;
  cleanup: mpi_free(& P1);
  mpi_free(& Q1);
  mpi_free(& H);
  mpi_free(& G);
  if (ret != 0) {
    rsa_free(ctx);
    __retres = -0x4180 + ret;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int rsa_check_pubkey(rsa_context const *ctx)
{
  int __retres;
  size_t tmp;
  size_t tmp_1;
  if (! ctx->N.p) {
    __retres = -0x4200;
    goto return_label;
  }
  else 
    if (! ctx->E.p) {
      __retres = -0x4200;
      goto return_label;
    }
  if ((*(ctx->N.p + 0) & (unsigned long)1) == (unsigned long)0) {
    __retres = -0x4200;
    goto return_label;
  }
  else 
    if ((*(ctx->E.p + 0) & (unsigned long)1) == (unsigned long)0) {
      __retres = -0x4200;
      goto return_label;
    }
  tmp = mpi_msb(& ctx->N);
  if (tmp < (size_t)128) {
    __retres = -0x4200;
    goto return_label;
  }
  else {
    size_t tmp_0;
    tmp_0 = mpi_msb(& ctx->N);
    if (tmp_0 > (size_t)(8 * 512)) {
      __retres = -0x4200;
      goto return_label;
    }
  }
  tmp_1 = mpi_msb(& ctx->E);
  if (tmp_1 < (size_t)2) {
    __retres = -0x4200;
    goto return_label;
  }
  else {
    size_t tmp_2;
    tmp_2 = mpi_msb(& ctx->E);
    if (tmp_2 > (size_t)64) {
      __retres = -0x4200;
      goto return_label;
    }
  }
  __retres = 0;
  return_label: return __retres;
}

int rsa_check_privkey(rsa_context const *ctx)
{
  int __retres;
  int ret;
  mpi PQ;
  mpi DE;
  mpi P1;
  mpi Q1;
  mpi H;
  mpi I;
  mpi G;
  mpi G2;
  mpi L1;
  mpi L2;
  int tmp;
  ret = rsa_check_pubkey(ctx);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  if (! ctx->P.p) {
    __retres = -0x4200;
    goto return_label;
  }
  else 
    if (! ctx->Q.p) {
      __retres = -0x4200;
      goto return_label;
    }
    else 
      if (! ctx->D.p) {
        __retres = -0x4200;
        goto return_label;
      }
  mpi_init(& PQ);
  mpi_init(& DE);
  mpi_init(& P1);
  mpi_init(& Q1);
  mpi_init(& H);
  mpi_init(& I);
  mpi_init(& G);
  mpi_init(& G2);
  mpi_init(& L1);
  mpi_init(& L2);
  ret = mpi_mul_mpi(& PQ,& ctx->P,& ctx->Q);
  if (ret != 0) goto cleanup;
  ret = mpi_mul_mpi(& DE,& ctx->D,& ctx->E);
  if (ret != 0) goto cleanup;
  ret = mpi_sub_int(& P1,& ctx->P,(t_sint)1);
  if (ret != 0) goto cleanup;
  ret = mpi_sub_int(& Q1,& ctx->Q,(t_sint)1);
  if (ret != 0) goto cleanup;
  ret = mpi_mul_mpi(& H,(mpi const *)(& P1),(mpi const *)(& Q1));
  if (ret != 0) goto cleanup;
  ret = mpi_gcd(& G,& ctx->E,(mpi const *)(& H));
  if (ret != 0) goto cleanup;
  ret = mpi_gcd(& G2,(mpi const *)(& P1),(mpi const *)(& Q1));
  if (ret != 0) goto cleanup;
  ret = mpi_div_mpi(& L1,& L2,(mpi const *)(& H),(mpi const *)(& G2));
  if (ret != 0) goto cleanup;
  ret = mpi_mod_mpi(& I,(mpi const *)(& DE),(mpi const *)(& L1));
  if (ret != 0) goto cleanup;
  tmp = mpi_cmp_mpi((mpi const *)(& PQ),& ctx->N);
  if (tmp != 0) goto _LOR;
  else {
    int tmp_0;
    tmp_0 = mpi_cmp_int((mpi const *)(& L2),(t_sint)0);
    if (tmp_0 != 0) goto _LOR;
    else {
      int tmp_1;
      tmp_1 = mpi_cmp_int((mpi const *)(& I),(t_sint)1);
      if (tmp_1 != 0) goto _LOR;
      else {
        int tmp_2;
        tmp_2 = mpi_cmp_int((mpi const *)(& G),(t_sint)1);
        if (tmp_2 != 0) _LOR: ret = -0x4200;
      }
    }
  }
  cleanup: mpi_free(& PQ);
  mpi_free(& DE);
  mpi_free(& P1);
  mpi_free(& Q1);
  mpi_free(& H);
  mpi_free(& I);
  mpi_free(& G);
  mpi_free(& G2);
  mpi_free(& L1);
  mpi_free(& L2);
  if (ret == -0x4200) {
    __retres = ret;
    goto return_label;
  }
  if (ret != 0) {
    __retres = -0x4200 + ret;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int rsa_public(rsa_context *ctx, unsigned char const *input,
               unsigned char *output)
{
  int __retres;
  int ret;
  size_t olen;
  mpi T;
  int tmp;
  mpi_init(& T);
  ret = mpi_read_binary(& T,input,ctx->len);
  if (ret != 0) goto cleanup;
  tmp = mpi_cmp_mpi((mpi const *)(& T),(mpi const *)(& ctx->N));
  if (tmp >= 0) {
    mpi_free(& T);
    __retres = -0x4080;
    goto return_label;
  }
  olen = ctx->len;
  ret = mpi_exp_mod(& T,(mpi const *)(& T),(mpi const *)(& ctx->E),
                    (mpi const *)(& ctx->N),& ctx->RN);
  if (ret != 0) goto cleanup;
  ret = mpi_write_binary((mpi const *)(& T),output,olen);
  if (ret != 0) goto cleanup;
  cleanup: mpi_free(& T);
  if (ret != 0) {
    __retres = -0x4280 + ret;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int rsa_private(rsa_context *ctx, unsigned char const *input,
                unsigned char *output)
{
  int __retres;
  int ret;
  size_t olen;
  mpi T;
  mpi T1;
  mpi T2;
  int tmp;
  mpi_init(& T);
  mpi_init(& T1);
  mpi_init(& T2);
  ret = mpi_read_binary(& T,input,ctx->len);
  if (ret != 0) goto cleanup;
  tmp = mpi_cmp_mpi((mpi const *)(& T),(mpi const *)(& ctx->N));
  if (tmp >= 0) {
    mpi_free(& T);
    __retres = -0x4080;
    goto return_label;
  }
  ret = mpi_exp_mod(& T1,(mpi const *)(& T),(mpi const *)(& ctx->DP),
                    (mpi const *)(& ctx->P),& ctx->RP);
  if (ret != 0) goto cleanup;
  ret = mpi_exp_mod(& T2,(mpi const *)(& T),(mpi const *)(& ctx->DQ),
                    (mpi const *)(& ctx->Q),& ctx->RQ);
  if (ret != 0) goto cleanup;
  ret = mpi_sub_mpi(& T,(mpi const *)(& T1),(mpi const *)(& T2));
  if (ret != 0) goto cleanup;
  ret = mpi_mul_mpi(& T1,(mpi const *)(& T),(mpi const *)(& ctx->QP));
  if (ret != 0) goto cleanup;
  ret = mpi_mod_mpi(& T,(mpi const *)(& T1),(mpi const *)(& ctx->P));
  if (ret != 0) goto cleanup;
  ret = mpi_mul_mpi(& T1,(mpi const *)(& T),(mpi const *)(& ctx->Q));
  if (ret != 0) goto cleanup;
  ret = mpi_add_mpi(& T,(mpi const *)(& T2),(mpi const *)(& T1));
  if (ret != 0) goto cleanup;
  olen = ctx->len;
  ret = mpi_write_binary((mpi const *)(& T),output,olen);
  if (ret != 0) goto cleanup;
  cleanup: mpi_free(& T);
  mpi_free(& T1);
  mpi_free(& T2);
  if (ret != 0) {
    __retres = -0x4300 + ret;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static void mgf_mask(unsigned char *dst, size_t dlen, unsigned char *src,
                     size_t slen, md_context_t *md_ctx)
{
  unsigned char mask[64];
  unsigned char counter[4];
  unsigned char *p;
  unsigned int hlen;
  size_t i;
  size_t use_len;
  memset((void *)(mask),0,(size_t)64);
  memset((void *)(counter),0,(size_t)4);
  hlen = (unsigned int)(md_ctx->md_info)->size;
  p = dst;
  while (dlen > (size_t)0) {
    use_len = hlen;
    if (dlen < hlen) use_len = dlen;
    md_starts(md_ctx);
    md_update(md_ctx,(unsigned char const *)src,slen);
    md_update(md_ctx,(unsigned char const *)(counter),(size_t)4);
    md_finish(md_ctx,mask);
    i = (size_t)0;
    while (i < use_len) {
      unsigned char *tmp;
      tmp = p;
      p ++;
      *tmp = (unsigned char)((int)*tmp ^ (int)mask[i]);
      i ++;
    }
    counter[3] = (unsigned char)((int)counter[3] + 1);
    dlen -= use_len;
  }
  return;
}

int rsa_pkcs1_encrypt(rsa_context *ctx,
                      int (*f_rng)(void *, unsigned char *, size_t ),
                      void *p_rng, int mode, size_t ilen,
                      unsigned char const *input, unsigned char *output)
{
  int __retres;
  size_t nb_pad;
  size_t olen;
  int ret;
  unsigned int hlen;
  md_info_t const *md_info;
  md_context_t md_ctx;
  int tmp_11;
  unsigned char *p = output;
  olen = ctx->len;
  if (f_rng == (int (*)(void *, unsigned char *, size_t ))0) {
    __retres = -0x4080;
    goto return_label;
  }
  switch (ctx->padding) {
    unsigned char *tmp;
    unsigned char *tmp_5;
    unsigned char tmp_6;
    unsigned char *tmp_7;
    unsigned char *tmp_8;
    case 0: ;
    if (olen < ilen + (size_t)11) {
      __retres = -0x4080;
      goto return_label;
    }
    nb_pad = (olen - (size_t)3) - ilen;
    tmp = p;
    p ++;
    *tmp = (unsigned char)0;
    if (mode == 0) {
      unsigned char *tmp_0;
      tmp_0 = p;
      p ++;
      *tmp_0 = (unsigned char)2;
      while (1) {
        size_t tmp_1;
        tmp_1 = nb_pad;
        nb_pad --;
        ;
        if (! (tmp_1 > (size_t)0)) break;
        {
          int rng_dl = 100;
          while (1) {
            ret = (*f_rng)(p_rng,p,(size_t)1);
            if ((int)*p == 0) {
              rng_dl --;
              if (rng_dl) {
                if (! (ret == 0)) break;
              }
              else break;
            }
            else break;
          }
          if (rng_dl == 0) {
            __retres = -0x4480 + ret;
            goto return_label;
          }
          else 
            if (ret != 0) {
              __retres = -0x4480 + ret;
              goto return_label;
            }
          p ++;
        }
      }
    }
    else {
      unsigned char *tmp_2;
      tmp_2 = p;
      p ++;
      *tmp_2 = (unsigned char)1;
      while (1) {
        size_t tmp_4;
        unsigned char *tmp_3;
        tmp_4 = nb_pad;
        nb_pad --;
        ;
        if (! (tmp_4 > (size_t)0)) break;
        tmp_3 = p;
        p ++;
        *tmp_3 = (unsigned char)0xFF;
      }
    }
    tmp_5 = p;
    p ++;
    *tmp_5 = (unsigned char)0;
    memcpy((void *)p,(void const *)input,ilen);
    break;
    case 1: md_info = md_info_from_type((md_type_t)ctx->hash_id);
    if (md_info == (md_info_t const *)0) {
      __retres = -0x4080;
      goto return_label;
    }
    tmp_6 = md_get_size_2(md_info);
    hlen = (unsigned int)tmp_6;
    if (olen < (ilen + (unsigned int)2 * hlen) + (size_t)2) {
      __retres = -0x4080;
      goto return_label;
    }
    else 
      if (f_rng == (int (*)(void *, unsigned char *, size_t ))0) {
        __retres = -0x4080;
        goto return_label;
      }
    memset((void *)output,0,olen);
    tmp_7 = p;
    p ++;
    *tmp_7 = (unsigned char)0;
    ret = (*f_rng)(p_rng,p,hlen);
    if (ret != 0) {
      __retres = -0x4480 + ret;
      goto return_label;
    }
    p += hlen;
    md(md_info,(unsigned char const *)p,(size_t)0,p);
    p += hlen;
    p += ((olen - (unsigned int)2 * hlen) - (size_t)2) - ilen;
    tmp_8 = p;
    p ++;
    *tmp_8 = (unsigned char)1;
    memcpy((void *)p,(void const *)input,ilen);
    md_init_ctx(& md_ctx,md_info);
    mgf_mask((output + hlen) + 1,(olen - hlen) - (size_t)1,output + 1,hlen,
             & md_ctx);
    mgf_mask(output + 1,hlen,(output + hlen) + 1,(olen - hlen) - (size_t)1,
             & md_ctx);
    md_free_ctx(& md_ctx);
    break;
    default: __retres = -0x4100;
    goto return_label;
  }
  if (mode == 0) tmp_11 = rsa_public(ctx,(unsigned char const *)output,
                                     output);
  else tmp_11 = rsa_private(ctx,(unsigned char const *)output,output);
  __retres = tmp_11;
  return_label: return __retres;
}

int rsa_pkcs1_decrypt(rsa_context *ctx, int mode, size_t *olen,
                      unsigned char const *input, unsigned char *output,
                      size_t output_max_len)
{
  int __retres;
  int ret;
  size_t ilen;
  unsigned char *p;
  unsigned char *q;
  unsigned char bt;
  unsigned char buf[1024];
  unsigned char lhash[64];
  unsigned int hlen;
  md_info_t const *md_info;
  md_context_t md_ctx;
  int correct = 1;
  size_t pad_count = (size_t)0;
  ilen = ctx->len;
  if (ilen < (size_t)16) {
    __retres = -0x4080;
    goto return_label;
  }
  else 
    if (ilen > sizeof(buf)) {
      __retres = -0x4080;
      goto return_label;
    }
  if (mode == 0) ret = rsa_public(ctx,input,buf);
  else ret = rsa_private(ctx,input,buf);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  p = buf;
  switch (ctx->padding) {
    unsigned char *tmp_1;
    unsigned char *tmp_2;
    unsigned char *tmp_9;
    unsigned char tmp_10;
    int tmp_11;
    unsigned char *tmp_12;
    case 0: { /* sequence */
              tmp_1 = p;
              p ++;
              ;
            }
    if ((int)*tmp_1 != 0) correct = 0;
    tmp_2 = p;
    p ++;
    bt = *tmp_2;
    if ((int)bt != 2) {
      if (mode == 1) goto _LOR; else goto _LAND;
    }
    else {
      _LAND: ;
      if ((int)bt != 1) 
        if (mode == 0) _LOR: correct = 0;
    }
    if ((int)bt == 2) {
      int tmp_4;
      while (1) {
        unsigned char *tmp_3;
        if ((int)*p != 0) {
          if (! (p < & buf[ilen] - 1)) break;
        }
        else break;
        tmp_3 = p;
        p ++;
        pad_count += (size_t)((int)*tmp_3 != 0);
      }
      if ((int)*p == 0) 
        if (p < & buf[ilen] - 1) tmp_4 = 1; else tmp_4 = 0;
      else tmp_4 = 0;
      correct &= tmp_4;
      q = p;
      while (q < & buf[ilen] - 1) {
        unsigned char *tmp_5;
        tmp_5 = q;
        q ++;
        pad_count += (size_t)((int)*tmp_5 != 0);
      }
      correct = (int)((unsigned int)correct | (pad_count & (unsigned int)0x100000));
      p ++;
    }
    else {
      int tmp_7;
      while (1) {
        unsigned char *tmp_6;
        if ((int)*p == 0xFF) {
          if (! (p < & buf[ilen] - 1)) break;
        }
        else break;
        tmp_6 = p;
        p ++;
        pad_count += (size_t)((int)*tmp_6 == 0xFF);
      }
      if ((int)*p == 0) 
        if (p < & buf[ilen] - 1) tmp_7 = 1; else tmp_7 = 0;
      else tmp_7 = 0;
      correct &= tmp_7;
      q = p;
      while (q < & buf[ilen] - 1) {
        unsigned char *tmp_8;
        tmp_8 = q;
        q ++;
        pad_count += (size_t)((int)*tmp_8 != 0);
      }
      correct = (int)((unsigned int)correct | (pad_count & (unsigned int)0x100000));
      p ++;
    }
    if (correct == 0) {
      __retres = -0x4100;
      goto return_label;
    }
    break;
    case 1: { /* sequence */
              tmp_9 = p;
              p ++;
              ;
            }
    if ((int)*tmp_9 != 0) {
      __retres = -0x4100;
      goto return_label;
    }
    md_info = md_info_from_type((md_type_t)ctx->hash_id);
    if (md_info == (md_info_t const *)0) {
      __retres = -0x4080;
      goto return_label;
    }
    tmp_10 = md_get_size_2(md_info);
    hlen = (unsigned int)tmp_10;
    md_init_ctx(& md_ctx,md_info);
    md(md_info,(unsigned char const *)(lhash),(size_t)0,lhash);
    mgf_mask(& buf[1],hlen,& buf[hlen] + 1,(ilen - hlen) - (size_t)1,
             & md_ctx);
    mgf_mask(& buf[hlen] + 1,(ilen - hlen) - (size_t)1,& buf[1],hlen,
             & md_ctx);
    p += hlen;
    md_free_ctx(& md_ctx);
    tmp_11 = memcmp((void const *)(lhash),(void const *)p,hlen);
    if (tmp_11 != 0) {
      __retres = -0x4100;
      goto return_label;
    }
    p += hlen;
    while (1) {
      if ((int)*p == 0) {
        if (! (p < & buf[ilen])) break;
      }
      else break;
      p ++;
    }
    if (p == & buf[ilen]) {
      __retres = -0x4100;
      goto return_label;
    }
    tmp_12 = p;
    p ++;
    ;
    if ((int)*tmp_12 != 0x01) {
      __retres = -0x4100;
      goto return_label;
    }
    break;
    default: __retres = -0x4100;
    goto return_label;
  }
  if (ilen - (size_t)(p - buf) > output_max_len) {
    __retres = -0x4400;
    goto return_label;
  }
  *olen = ilen - (size_t)(p - buf);
  /*@ assert 0 ≤ *olen ≤ output_max_len; */ ;
  memcpy((void *)output,(void const *)p,*olen);
  __retres = 0;
  return_label: return __retres;
}

int rsa_pkcs1_sign(rsa_context *ctx,
                   int (*f_rng)(void *, unsigned char *, size_t ),
                   void *p_rng, int mode, int hash_id, unsigned int hashlen,
                   unsigned char const *hash, unsigned char *sig)
{
  int __retres;
  size_t nb_pad;
  size_t olen;
  unsigned char salt[64];
  unsigned int slen;
  unsigned int hlen;
  int ret;
  size_t msb;
  md_info_t const *md_info;
  md_context_t md_ctx;
  int tmp_10;
  unsigned char *p = sig;
  unsigned int offset = (unsigned int)0;
  olen = ctx->len;
  switch (ctx->padding) {
    unsigned char *tmp;
    unsigned char *tmp_0;
    unsigned char *tmp_1;
    unsigned char tmp_2;
    size_t tmp_3;
    size_t tmp_4;
    unsigned char *tmp_5;
    size_t tmp_6;
    unsigned char *tmp_7;
    case 0: ;
    switch (hash_id) {
      case 0: nb_pad = (olen - (size_t)3) - hashlen;
      break;
      case 2: case 3: case 4: nb_pad = (olen - (size_t)3) - (size_t)34;
      break;
      case 5: nb_pad = (olen - (size_t)3) - (size_t)35;
      break;
      case 14: nb_pad = (olen - (size_t)3) - (size_t)47;
      break;
      case 11: nb_pad = (olen - (size_t)3) - (size_t)51;
      break;
      case 12: nb_pad = (olen - (size_t)3) - (size_t)67;
      break;
      case 13: nb_pad = (olen - (size_t)3) - (size_t)83;
      break;
      default: __retres = -0x4080;
      goto return_label;
    }
    if (nb_pad < (size_t)8) {
      __retres = -0x4080;
      goto return_label;
    }
    else 
      if (nb_pad > olen) {
        __retres = -0x4080;
        goto return_label;
      }
    tmp = p;
    p ++;
    *tmp = (unsigned char)0;
    tmp_0 = p;
    p ++;
    *tmp_0 = (unsigned char)1;
    memset((void *)p,0xFF,nb_pad);
    p += nb_pad;
    tmp_1 = p;
    p ++;
    *tmp_1 = (unsigned char)0;
    switch (hash_id) {
      case 0: memcpy((void *)p,(void const *)hash,hashlen);
      break;
      case 2:
      memcpy((void *)p,
             (void const *)"0 0\f\006\b*\206H\206\367\r\002\000\005\000\004\020",
             (size_t)18);
      memcpy((void *)(p + 18),(void const *)hash,(size_t)16);
      *(p + 13) = (unsigned char)2;
      break;
      case 3:
      memcpy((void *)p,
             (void const *)"0 0\f\006\b*\206H\206\367\r\002\000\005\000\004\020",
             (size_t)18);
      memcpy((void *)(p + 18),(void const *)hash,(size_t)16);
      *(p + 13) = (unsigned char)4;
      break;
      case 4:
      memcpy((void *)p,
             (void const *)"0 0\f\006\b*\206H\206\367\r\002\000\005\000\004\020",
             (size_t)18);
      memcpy((void *)(p + 18),(void const *)hash,(size_t)16);
      *(p + 13) = (unsigned char)5;
      break;
      case 5:
      memcpy((void *)p,
             (void const *)"0!0\t\006\005+\016\003\002\032\005\000\004\024",
             (size_t)15);
      memcpy((void *)(p + 15),(void const *)hash,(size_t)20);
      break;
      case 14:
      memcpy((void *)p,
             (void const *)"0\0210\r\006\t`\206H\001e\003\004\002\000\005\000\004\000",
             (size_t)19);
      memcpy((void *)(p + 19),(void const *)hash,(size_t)28);
      *(p + 1) = (unsigned char)((int)*(p + 1) + 28);
      *(p + 14) = (unsigned char)4;
      *(p + 18) = (unsigned char)((int)*(p + 18) + 28);
      break;
      case 11:
      memcpy((void *)p,
             (void const *)"0\0210\r\006\t`\206H\001e\003\004\002\000\005\000\004\000",
             (size_t)19);
      memcpy((void *)(p + 19),(void const *)hash,(size_t)32);
      *(p + 1) = (unsigned char)((int)*(p + 1) + 32);
      *(p + 14) = (unsigned char)1;
      *(p + 18) = (unsigned char)((int)*(p + 18) + 32);
      break;
      case 12:
      memcpy((void *)p,
             (void const *)"0\0210\r\006\t`\206H\001e\003\004\002\000\005\000\004\000",
             (size_t)19);
      memcpy((void *)(p + 19),(void const *)hash,(size_t)48);
      *(p + 1) = (unsigned char)((int)*(p + 1) + 48);
      *(p + 14) = (unsigned char)2;
      *(p + 18) = (unsigned char)((int)*(p + 18) + 48);
      break;
      case 13:
      memcpy((void *)p,
             (void const *)"0\0210\r\006\t`\206H\001e\003\004\002\000\005\000\004\000",
             (size_t)19);
      memcpy((void *)(p + 19),(void const *)hash,(size_t)64);
      *(p + 1) = (unsigned char)((int)*(p + 1) + 64);
      *(p + 14) = (unsigned char)3;
      *(p + 18) = (unsigned char)((int)*(p + 18) + 64);
      break;
      default: __retres = -0x4080;
      goto return_label;
    }
    break;
    case 1: ;
    if (f_rng == (int (*)(void *, unsigned char *, size_t ))0) {
      __retres = -0x4080;
      goto return_label;
    }
    switch (hash_id) {
      case 2: case 3: case 4: hashlen = (unsigned int)16;
      break;
      case 5: hashlen = (unsigned int)20;
      break;
      case 14: hashlen = (unsigned int)28;
      break;
      case 11: hashlen = (unsigned int)32;
      break;
      case 12: hashlen = (unsigned int)48;
      break;
      case 13: hashlen = (unsigned int)64;
      break;
      default: __retres = -0x4080;
      goto return_label;
    }
    md_info = md_info_from_type((md_type_t)ctx->hash_id);
    if (md_info == (md_info_t const *)0) {
      __retres = -0x4080;
      goto return_label;
    }
    tmp_2 = md_get_size_2(md_info);
    hlen = (unsigned int)tmp_2;
    slen = hlen;
    if (olen < (hlen + slen) + (unsigned int)2) {
      __retres = -0x4080;
      goto return_label;
    }
    memset((void *)sig,0,olen);
    tmp_3 = mpi_msb((mpi const *)(& ctx->N));
    msb = tmp_3 - (size_t)1;
    ret = (*f_rng)(p_rng,salt,slen);
    if (ret != 0) {
      __retres = -0x4480 + ret;
      goto return_label;
    }
    tmp_4 = mpi_msb((mpi const *)(& ctx->N));
    msb = tmp_4 - (size_t)1;
    p += (olen - hlen * (unsigned int)2) - (size_t)2;
    tmp_5 = p;
    p ++;
    *tmp_5 = (unsigned char)0x01;
    memcpy((void *)p,(void const *)(salt),slen);
    p += slen;
    md_init_ctx(& md_ctx,md_info);
    md_starts(& md_ctx);
    md_update(& md_ctx,(unsigned char const *)p,(size_t)8);
    md_update(& md_ctx,hash,hashlen);
    md_update(& md_ctx,(unsigned char const *)(salt),slen);
    md_finish(& md_ctx,p);
    if (msb % (unsigned int)8 == (unsigned int)0) offset = (unsigned int)1;
    mgf_mask(sig + offset,((olen - hlen) - (size_t)1) - offset,p,hlen,
             & md_ctx);
    md_free_ctx(& md_ctx);
    tmp_6 = mpi_msb((mpi const *)(& ctx->N));
    msb = tmp_6 - (size_t)1;
    *(sig + 0) = (unsigned char)((int)*(sig + 0) & (0xFF >> (olen * (size_t)8 - msb)));
    p += hlen;
    tmp_7 = p;
    p ++;
    *tmp_7 = (unsigned char)0xBC;
    break;
    default: __retres = -0x4100;
    goto return_label;
  }
  if (mode == 0) tmp_10 = rsa_public(ctx,(unsigned char const *)sig,sig);
  else tmp_10 = rsa_private(ctx,(unsigned char const *)sig,sig);
  __retres = tmp_10;
  return_label: return __retres;
}

int rsa_pkcs1_verify(rsa_context *ctx, int mode, int hash_id,
                     unsigned int hashlen, unsigned char const *hash,
                     unsigned char *sig)
{
  int __retres;
  int ret;
  size_t len;
  size_t siglen;
  unsigned char *p;
  unsigned char c;
  unsigned char buf[1024];
  unsigned char result[64];
  unsigned char zeros[8];
  unsigned int hlen;
  size_t slen;
  size_t msb;
  md_info_t const *md_info;
  md_context_t md_ctx;
  siglen = ctx->len;
  if (siglen < (size_t)16) {
    __retres = -0x4080;
    goto return_label;
  }
  else 
    if (siglen > sizeof(buf)) {
      __retres = -0x4080;
      goto return_label;
    }
  if (mode == 0) ret = rsa_public(ctx,(unsigned char const *)sig,buf);
  else ret = rsa_private(ctx,(unsigned char const *)sig,buf);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  p = buf;
  switch (ctx->padding) {
    unsigned char *tmp_1;
    unsigned char tmp_10;
    size_t tmp_11;
    int tmp_13;
    case 0: { /* sequence */
              tmp_1 = p;
              p ++;
              ;
            }
    if ((int)*tmp_1 != 0) {
      __retres = -0x4100;
      goto return_label;
    }
    else {
      unsigned char *tmp_2;
      tmp_2 = p;
      p ++;
      ;
      if ((int)*tmp_2 != 1) {
        __retres = -0x4100;
        goto return_label;
      }
    }
    while ((int)*p != 0) {
      if (p >= & buf[siglen] - 1) {
        __retres = -0x4100;
        goto return_label;
      }
      else 
        if ((int)*p != 0xFF) {
          __retres = -0x4100;
          goto return_label;
        }
      p ++;
    }
    p ++;
    len = siglen - (size_t)(p - buf);
    if (len == (size_t)34) {
      int tmp_3;
      c = *(p + 13);
      *(p + 13) = (unsigned char)0;
      tmp_3 = memcmp((void const *)p,
                     (void const *)"0 0\f\006\b*\206H\206\367\r\002\000\005\000\004\020",
                     (size_t)18);
      if (tmp_3 != 0) {
        __retres = -0x4380;
        goto return_label;
      }
      if ((int)c == 2) {
        if (hash_id == 2) goto _LOR; else goto _LAND_0;
      }
      else {
        _LAND_0: ;
        if ((int)c == 4) {
          if (hash_id == 3) goto _LOR; else goto _LAND;
        }
        else {
          _LAND: ;
          if ((int)c == 5) 
            if (hash_id == 4) {
              _LOR:
              {
                int tmp_4;
                tmp_4 = memcmp((void const *)(p + 18),(void const *)hash,
                               (size_t)16);
                if (tmp_4 == 0) {
                  __retres = 0;
                  goto return_label;
                }
                else {
                  __retres = -0x4380;
                  goto return_label;
                }
              }
            }
        }
      }
    }
    if (len == (size_t)35) 
      if (hash_id == 5) {
        int tmp_5;
        tmp_5 = memcmp((void const *)p,
                       (void const *)"0!0\t\006\005+\016\003\002\032\005\000\004\024",
                       (size_t)15);
        if (tmp_5 == 0) {
          int tmp_6;
          tmp_6 = memcmp((void const *)(p + 15),(void const *)hash,
                         (size_t)20);
          if (tmp_6 == 0) {
            __retres = 0;
            goto return_label;
          }
          else {
            __retres = -0x4380;
            goto return_label;
          }
        }
        else {
          __retres = -0x4380;
          goto return_label;
        }
      }
    if (len == (size_t)(19 + 28)) {
      if ((int)*(p + 14) == 4) {
        if (hash_id == 14) goto _LOR_0; else goto _LAND_6;
      }
      else goto _LAND_6;
    }
    else {
      _LAND_6: ;
      if (len == (size_t)(19 + 32)) {
        if ((int)*(p + 14) == 1) {
          if (hash_id == 11) goto _LOR_0; else goto _LAND_4;
        }
        else goto _LAND_4;
      }
      else {
        _LAND_4: ;
        if (len == (size_t)(19 + 48)) {
          if ((int)*(p + 14) == 2) {
            if (hash_id == 12) goto _LOR_0; else goto _LAND_2;
          }
          else goto _LAND_2;
        }
        else {
          _LAND_2: ;
          if (len == (size_t)(19 + 64)) 
            if ((int)*(p + 14) == 3) 
              if (hash_id == 13) {
                _LOR_0:
                {
                  c = (unsigned char)((int)*(p + 1) - 17);
                  *(p + 1) = (unsigned char)17;
                  *(p + 14) = (unsigned char)0;
                  if ((int)*(p + 18) == (int)c) {
                    int tmp_7;
                    tmp_7 = memcmp((void const *)p,
                                   (void const *)"0\0210\r\006\t`\206H\001e\003\004\002\000\005\000\004\000",
                                   (size_t)18);
                    if (tmp_7 == 0) {
                      int tmp_8;
                      tmp_8 = memcmp((void const *)(p + 19),
                                     (void const *)hash,(size_t)c);
                      if (tmp_8 == 0) {
                        __retres = 0;
                        goto return_label;
                      }
                      else {
                        __retres = -0x4380;
                        goto return_label;
                      }
                    }
                    else {
                      __retres = -0x4380;
                      goto return_label;
                    }
                  }
                  else {
                    __retres = -0x4380;
                    goto return_label;
                  }
                }
              }
        }
      }
    }
    if (len == hashlen) 
      if (hash_id == 0) {
        int tmp_9;
        tmp_9 = memcmp((void const *)p,(void const *)hash,hashlen);
        if (tmp_9 == 0) {
          __retres = 0;
          goto return_label;
        }
        else {
          __retres = -0x4380;
          goto return_label;
        }
      }
    break;
    case 1: ;
    if ((int)buf[siglen - (size_t)1] != 0xBC) {
      __retres = -0x4100;
      goto return_label;
    }
    switch (hash_id) {
      case 2: case 3: case 4: hashlen = (unsigned int)16;
      break;
      case 5: hashlen = (unsigned int)20;
      break;
      case 14: hashlen = (unsigned int)28;
      break;
      case 11: hashlen = (unsigned int)32;
      break;
      case 12: hashlen = (unsigned int)48;
      break;
      case 13: hashlen = (unsigned int)64;
      break;
      default: __retres = -0x4080;
      goto return_label;
    }
    md_info = md_info_from_type((md_type_t)ctx->hash_id);
    if (md_info == (md_info_t const *)0) {
      __retres = -0x4080;
      goto return_label;
    }
    tmp_10 = md_get_size_2(md_info);
    hlen = (unsigned int)tmp_10;
    slen = (siglen - hlen) - (size_t)1;
    memset((void *)(zeros),0,(size_t)8);
    tmp_11 = mpi_msb((mpi const *)(& ctx->N));
    msb = tmp_11 - (size_t)1;
    if (msb % (unsigned int)8 == (unsigned int)0) {
      p ++;
      siglen -= (size_t)1;
    }
    if ((int)buf[0] >> (((size_t)8 - siglen * (size_t)8) + msb)) {
      __retres = -0x4080;
      goto return_label;
    }
    md_init_ctx(& md_ctx,md_info);
    mgf_mask(p,(siglen - hlen) - (size_t)1,((p + siglen) - hlen) - 1,hlen,
             & md_ctx);
    buf[0] = (unsigned char)((int)buf[0] & (0xFF >> (siglen * (size_t)8 - msb)));
    while (1) {
      if ((int)*p == 0) {
        if (! (p < & buf[siglen])) break;
      }
      else break;
      p ++;
    }
    if (p == & buf[siglen]) goto _LOR_1;
    else {
      unsigned char *tmp_12;
      tmp_12 = p;
      p ++;
      ;
      if ((int)*tmp_12 != 0x01) {
        _LOR_1:
        {
          md_free_ctx(& md_ctx);
          __retres = -0x4100;
          goto return_label;
        }
      }
    }
    slen -= (size_t)(p - buf);
    md_starts(& md_ctx);
    md_update(& md_ctx,(unsigned char const *)(zeros),(size_t)8);
    md_update(& md_ctx,hash,hashlen);
    md_update(& md_ctx,(unsigned char const *)p,slen);
    md_finish(& md_ctx,result);
    md_free_ctx(& md_ctx);
    tmp_13 = memcmp((void const *)(p + slen),(void const *)(result),hlen);
    if (tmp_13 == 0) {
      __retres = 0;
      goto return_label;
    }
    else {
      __retres = -0x4380;
      goto return_label;
    }
    default: __retres = -0x4100;
    goto return_label;
  }
  __retres = -0x4100;
  return_label: return __retres;
}

void rsa_free(rsa_context *ctx)
{
  mpi_free(& ctx->RQ);
  mpi_free(& ctx->RP);
  mpi_free(& ctx->RN);
  mpi_free(& ctx->QP);
  mpi_free(& ctx->DQ);
  mpi_free(& ctx->DP);
  mpi_free(& ctx->Q);
  mpi_free(& ctx->P);
  mpi_free(& ctx->D);
  mpi_free(& ctx->E);
  mpi_free(& ctx->N);
  return;
}

static int myrand(void *rng_state, unsigned char *output, size_t len)
{
  int __retres;
  size_t i;
  if (rng_state != (void *)0) rng_state = (void *)0;
  i = (size_t)0;
  while (i < len) {
    int tmp;
    tmp = rand();
    *(output + i) = (unsigned char)tmp;
    i ++;
  }
  __retres = 0;
  return __retres;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_91(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_92(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_93(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_94(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_95(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_96(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_97(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_98(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_99(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_100(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_101(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_102(char const * restrict format);

int rsa_self_test(int verbose)
{
  int __retres;
  size_t len;
  rsa_context rsa;
  unsigned char rsa_plaintext[24];
  unsigned char rsa_decrypted[24];
  unsigned char rsa_ciphertext[128];
  unsigned char sha1sum[20];
  int tmp;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  int tmp_4;
  int tmp_5;
  rsa_init(& rsa,0,0);
  rsa.len = (size_t)128;
  mpi_read_string(& rsa.N,16,
                  "9292758453063D803DD603D5E777D7888ED1D5BF35786190FA2F23EBC0848AEADDA92CA6C3D80B32C4D109BE0F36D6AE7130B9CED7ACDF54CFC7555AC14EEBAB93A89813FBF3C4F8066D2D800F7C38A81AE31942917403FF4946B0A83D3D3E05EE57C6F5F5606FB5D4BC6CD34EE0801A5E94BB77B07507233A0BC7BAC8F90F79");
  mpi_read_string(& rsa.E,16,"10001");
  mpi_read_string(& rsa.D,16,
                  "24BF6185468786FDD303083D25E64EFC66CA472BC44D253102F8B4A9D3BFA75091386C0077937FE33FA3252D28855837AE1B484A8A9A45F7EE8C0C634F99E8CDDF79C5CE07EE72C7F123142198164234CABB724CF78B8173B9F880FC86322407AF1FEDFDDE2BEB674CA15F3E81A1521E071513A1E85B5DFA031F21ECAE91A34D");
  mpi_read_string(& rsa.P,16,
                  "C36D0EB7FCD285223CFB5AABA5BDA3D82C01CAD19EA484A87EA4377637E75500FCB2005C5C7DD6EC4AC023CDA285D796C3D9E75E1EFC42488BB4F1D13AC30A57");
  mpi_read_string(& rsa.Q,16,
                  "C000DF51A7C77AE8D7C7370C1FF55B69E211C2B9E5DB1ED0BF61D0D9899620F4910E4168387E3C30AA1E00C339A795088452DD96A9A5EA5D9DCA68DA636032AF");
  mpi_read_string(& rsa.DP,16,
                  "C1ACF567564274FB07A0BBAD5D26E2983C94D22288ACD763FD8E5600ED4A702DF84198A5F06C2E72236AE490C93F07F83CC559CD27BC2D1CA488811730BB5725");
  mpi_read_string(& rsa.DQ,16,
                  "4959CBF6F8FEF750AEE6977C155579C7D8AAEA56749EA28623272E4F7D0592AF7C1F1313CAC9471B5C523BFE592F517B407A1BD76C164B93DA2D32A383E58357");
  mpi_read_string(& rsa.QP,16,
                  "9AE7FBC99546432DF71896FC239EADAEF38D18D2B2F0E2DD275AA977E2BF4411F5A3B2A5D33605AEBBCCBA7FEB9F2D2FA74206CEC169D74BF5A8C50D6F48EA08");
  if (verbose != 0) printf("  RSA key validation: "); /* printf_va_91 */
  tmp = rsa_check_pubkey((rsa_context const *)(& rsa));
  if (tmp != 0) goto _LOR;
  else {
    int tmp_0;
    tmp_0 = rsa_check_privkey((rsa_context const *)(& rsa));
    if (tmp_0 != 0) {
      _LOR:
      {
        if (verbose != 0) printf("failed\n"); /* printf_va_92 */
        __retres = 1;
        goto return_label;
      }
    }
  }
  if (verbose != 0) printf("passed\n  PKCS#1 encryption : "); /* printf_va_93 */
  memcpy((void *)(rsa_plaintext),
         (void const *)"\252\273\314\003\002\001\000\377\377\377\377\377\021\"3\n\v\f\314\335\335\335\335\335",
         (size_t)24);
  tmp_1 = rsa_pkcs1_encrypt(& rsa,& myrand,(void *)0,0,(size_t)24,
                            (unsigned char const *)(rsa_plaintext),
                            rsa_ciphertext);
  if (tmp_1 != 0) {
    if (verbose != 0) printf("failed\n"); /* printf_va_94 */
    __retres = 1;
    goto return_label;
  }
  if (verbose != 0) printf("passed\n  PKCS#1 decryption : "); /* printf_va_95 */
  tmp_2 = rsa_pkcs1_decrypt(& rsa,1,& len,
                            (unsigned char const *)(rsa_ciphertext),
                            rsa_decrypted,sizeof(rsa_decrypted));
  if (tmp_2 != 0) {
    if (verbose != 0) printf("failed\n"); /* printf_va_96 */
    __retres = 1;
    goto return_label;
  }
  tmp_3 = memcmp((void const *)(rsa_decrypted),(void const *)(rsa_plaintext),
                 len);
  if (tmp_3 != 0) {
    if (verbose != 0) printf("failed\n"); /* printf_va_97 */
    __retres = 1;
    goto return_label;
  }
  if (verbose != 0) printf("passed\n  PKCS#1 data sign  : "); /* printf_va_98 */
  sha1((unsigned char const *)(rsa_plaintext),(size_t)24,sha1sum);
  tmp_4 = rsa_pkcs1_sign(& rsa,(int (*)(void *, unsigned char *, size_t ))0,
                         (void *)0,1,5,(unsigned int)20,
                         (unsigned char const *)(sha1sum),rsa_ciphertext);
  if (tmp_4 != 0) {
    if (verbose != 0) printf("failed\n"); /* printf_va_99 */
    __retres = 1;
    goto return_label;
  }
  if (verbose != 0) printf("passed\n  PKCS#1 sig. verify: "); /* printf_va_100 */
  tmp_5 = rsa_pkcs1_verify(& rsa,0,5,(unsigned int)20,
                           (unsigned char const *)(sha1sum),rsa_ciphertext);
  if (tmp_5 != 0) {
    if (verbose != 0) printf("failed\n"); /* printf_va_101 */
    __retres = 1;
    goto return_label;
  }
  if (verbose != 0) printf("passed\n\n"); /* printf_va_102 */
  rsa_free(& rsa);
  __retres = 0;
  return_label: return __retres;
}

void sha1_starts(sha1_context *ctx)
{
  ctx->total[0] = (unsigned long)0;
  ctx->total[1] = (unsigned long)0;
  ctx->state[0] = (unsigned long)0x67452301;
  ctx->state[1] = (unsigned long)0xEFCDAB89;
  ctx->state[2] = (unsigned long)0x98BADCFE;
  ctx->state[3] = (unsigned long)0x10325476;
  ctx->state[4] = (unsigned long)0xC3D2E1F0;
  return;
}

/*@ requires \valid(ctx);
    requires \valid(&ctx->state[0 .. 4]);
    requires \initialized(&ctx->state[0 .. 4]);
    requires \valid_read(data + (0 .. 63));
    ensures \initialized(&\old(ctx)->state[0 .. 4]);
    assigns ctx->state[0 .. 4];
    assigns ctx->state[0 .. 4] \from _state;
 */
void sha1_process(sha1_context *ctx, unsigned char const data[64])
{
  unsigned long temp;
  unsigned long W[16];
  unsigned long A;
  unsigned long B;
  unsigned long C;
  unsigned long D;
  unsigned long E;
  W[0] = ((((unsigned long)*(data + 0) << 24) | ((unsigned long)*(data + (
                                                                  0 + 1)) << 16)) | (
          (unsigned long)*(data + (0 + 2)) << 8)) | (unsigned long)*(
         data + (0 + 3));
  W[1] = ((((unsigned long)*(data + 4) << 24) | ((unsigned long)*(data + (
                                                                  4 + 1)) << 16)) | (
          (unsigned long)*(data + (4 + 2)) << 8)) | (unsigned long)*(
         data + (4 + 3));
  W[2] = ((((unsigned long)*(data + 8) << 24) | ((unsigned long)*(data + (
                                                                  8 + 1)) << 16)) | (
          (unsigned long)*(data + (8 + 2)) << 8)) | (unsigned long)*(
         data + (8 + 3));
  W[3] = ((((unsigned long)*(data + 12) << 24) | ((unsigned long)*(data + (
                                                                   12 + 1)) << 16)) | (
          (unsigned long)*(data + (12 + 2)) << 8)) | (unsigned long)*(
         data + (12 + 3));
  W[4] = ((((unsigned long)*(data + 16) << 24) | ((unsigned long)*(data + (
                                                                   16 + 1)) << 16)) | (
          (unsigned long)*(data + (16 + 2)) << 8)) | (unsigned long)*(
         data + (16 + 3));
  W[5] = ((((unsigned long)*(data + 20) << 24) | ((unsigned long)*(data + (
                                                                   20 + 1)) << 16)) | (
          (unsigned long)*(data + (20 + 2)) << 8)) | (unsigned long)*(
         data + (20 + 3));
  W[6] = ((((unsigned long)*(data + 24) << 24) | ((unsigned long)*(data + (
                                                                   24 + 1)) << 16)) | (
          (unsigned long)*(data + (24 + 2)) << 8)) | (unsigned long)*(
         data + (24 + 3));
  W[7] = ((((unsigned long)*(data + 28) << 24) | ((unsigned long)*(data + (
                                                                   28 + 1)) << 16)) | (
          (unsigned long)*(data + (28 + 2)) << 8)) | (unsigned long)*(
         data + (28 + 3));
  W[8] = ((((unsigned long)*(data + 32) << 24) | ((unsigned long)*(data + (
                                                                   32 + 1)) << 16)) | (
          (unsigned long)*(data + (32 + 2)) << 8)) | (unsigned long)*(
         data + (32 + 3));
  W[9] = ((((unsigned long)*(data + 36) << 24) | ((unsigned long)*(data + (
                                                                   36 + 1)) << 16)) | (
          (unsigned long)*(data + (36 + 2)) << 8)) | (unsigned long)*(
         data + (36 + 3));
  W[10] = ((((unsigned long)*(data + 40) << 24) | ((unsigned long)*(data + (
                                                                    40 + 1)) << 16)) | (
           (unsigned long)*(data + (40 + 2)) << 8)) | (unsigned long)*(
          data + (40 + 3));
  W[11] = ((((unsigned long)*(data + 44) << 24) | ((unsigned long)*(data + (
                                                                    44 + 1)) << 16)) | (
           (unsigned long)*(data + (44 + 2)) << 8)) | (unsigned long)*(
          data + (44 + 3));
  W[12] = ((((unsigned long)*(data + 48) << 24) | ((unsigned long)*(data + (
                                                                    48 + 1)) << 16)) | (
           (unsigned long)*(data + (48 + 2)) << 8)) | (unsigned long)*(
          data + (48 + 3));
  W[13] = ((((unsigned long)*(data + 52) << 24) | ((unsigned long)*(data + (
                                                                    52 + 1)) << 16)) | (
           (unsigned long)*(data + (52 + 2)) << 8)) | (unsigned long)*(
          data + (52 + 3));
  W[14] = ((((unsigned long)*(data + 56) << 24) | ((unsigned long)*(data + (
                                                                    56 + 1)) << 16)) | (
           (unsigned long)*(data + (56 + 2)) << 8)) | (unsigned long)*(
          data + (56 + 3));
  W[15] = ((((unsigned long)*(data + 60) << 24) | ((unsigned long)*(data + (
                                                                    60 + 1)) << 16)) | (
           (unsigned long)*(data + (60 + 2)) << 8)) | (unsigned long)*(
          data + (60 + 3));
  A = ctx->state[0];
  B = ctx->state[1];
  C = ctx->state[2];
  D = ctx->state[3];
  E = ctx->state[4];
  E += ((((A << 5) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         D ^ (B & (C ^ D)))) + (unsigned long)0x5A827999) + W[0];
  B = (B << 30) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  D += ((((E << 5) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         C ^ (A & (B ^ C)))) + (unsigned long)0x5A827999) + W[1];
  A = (A << 30) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  C += ((((D << 5) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         B ^ (E & (A ^ B)))) + (unsigned long)0x5A827999) + W[2];
  E = (E << 30) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  B += ((((C << 5) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         A ^ (D & (E ^ A)))) + (unsigned long)0x5A827999) + W[3];
  D = (D << 30) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  A += ((((B << 5) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         E ^ (C & (D ^ E)))) + (unsigned long)0x5A827999) + W[4];
  C = (C << 30) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  E += ((((A << 5) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         D ^ (B & (C ^ D)))) + (unsigned long)0x5A827999) + W[5];
  B = (B << 30) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  D += ((((E << 5) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         C ^ (A & (B ^ C)))) + (unsigned long)0x5A827999) + W[6];
  A = (A << 30) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  C += ((((D << 5) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         B ^ (E & (A ^ B)))) + (unsigned long)0x5A827999) + W[7];
  E = (E << 30) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  B += ((((C << 5) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         A ^ (D & (E ^ A)))) + (unsigned long)0x5A827999) + W[8];
  D = (D << 30) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  A += ((((B << 5) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         E ^ (C & (D ^ E)))) + (unsigned long)0x5A827999) + W[9];
  C = (C << 30) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  E += ((((A << 5) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         D ^ (B & (C ^ D)))) + (unsigned long)0x5A827999) + W[10];
  B = (B << 30) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  D += ((((E << 5) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         C ^ (A & (B ^ C)))) + (unsigned long)0x5A827999) + W[11];
  A = (A << 30) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  C += ((((D << 5) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         B ^ (E & (A ^ B)))) + (unsigned long)0x5A827999) + W[12];
  E = (E << 30) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  B += ((((C << 5) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         A ^ (D & (E ^ A)))) + (unsigned long)0x5A827999) + W[13];
  D = (D << 30) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  A += ((((B << 5) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         E ^ (C & (D ^ E)))) + (unsigned long)0x5A827999) + W[14];
  C = (C << 30) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  E += ((((A << 5) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         D ^ (B & (C ^ D)))) + (unsigned long)0x5A827999) + W[15];
  B = (B << 30) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(16 - 3) & 0x0F] ^ W[(16 - 8) & 0x0F]) ^ W[(16 - 14) & 0x0F]) ^ W[
         16 & 0x0F];
  W[16 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  D += ((((E << 5) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         C ^ (A & (B ^ C)))) + (unsigned long)0x5A827999) + W[16 & 0x0F];
  A = (A << 30) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(17 - 3) & 0x0F] ^ W[(17 - 8) & 0x0F]) ^ W[(17 - 14) & 0x0F]) ^ W[
         17 & 0x0F];
  W[17 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  C += ((((D << 5) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         B ^ (E & (A ^ B)))) + (unsigned long)0x5A827999) + W[17 & 0x0F];
  E = (E << 30) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(18 - 3) & 0x0F] ^ W[(18 - 8) & 0x0F]) ^ W[(18 - 14) & 0x0F]) ^ W[
         18 & 0x0F];
  W[18 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  B += ((((C << 5) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         A ^ (D & (E ^ A)))) + (unsigned long)0x5A827999) + W[18 & 0x0F];
  D = (D << 30) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(19 - 3) & 0x0F] ^ W[(19 - 8) & 0x0F]) ^ W[(19 - 14) & 0x0F]) ^ W[
         19 & 0x0F];
  W[19 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  A += ((((B << 5) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         E ^ (C & (D ^ E)))) + (unsigned long)0x5A827999) + W[19 & 0x0F];
  C = (C << 30) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(20 - 3) & 0x0F] ^ W[(20 - 8) & 0x0F]) ^ W[(20 - 14) & 0x0F]) ^ W[
         20 & 0x0F];
  W[20 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  E += ((((A << 5) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (B ^ C) ^ D)) + (unsigned long)0x6ED9EBA1) + W[20 & 0x0F];
  B = (B << 30) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(21 - 3) & 0x0F] ^ W[(21 - 8) & 0x0F]) ^ W[(21 - 14) & 0x0F]) ^ W[
         21 & 0x0F];
  W[21 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  D += ((((E << 5) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (A ^ B) ^ C)) + (unsigned long)0x6ED9EBA1) + W[21 & 0x0F];
  A = (A << 30) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(22 - 3) & 0x0F] ^ W[(22 - 8) & 0x0F]) ^ W[(22 - 14) & 0x0F]) ^ W[
         22 & 0x0F];
  W[22 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  C += ((((D << 5) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (E ^ A) ^ B)) + (unsigned long)0x6ED9EBA1) + W[22 & 0x0F];
  E = (E << 30) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(23 - 3) & 0x0F] ^ W[(23 - 8) & 0x0F]) ^ W[(23 - 14) & 0x0F]) ^ W[
         23 & 0x0F];
  W[23 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  B += ((((C << 5) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (D ^ E) ^ A)) + (unsigned long)0x6ED9EBA1) + W[23 & 0x0F];
  D = (D << 30) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(24 - 3) & 0x0F] ^ W[(24 - 8) & 0x0F]) ^ W[(24 - 14) & 0x0F]) ^ W[
         24 & 0x0F];
  W[24 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  A += ((((B << 5) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (C ^ D) ^ E)) + (unsigned long)0x6ED9EBA1) + W[24 & 0x0F];
  C = (C << 30) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(25 - 3) & 0x0F] ^ W[(25 - 8) & 0x0F]) ^ W[(25 - 14) & 0x0F]) ^ W[
         25 & 0x0F];
  W[25 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  E += ((((A << 5) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (B ^ C) ^ D)) + (unsigned long)0x6ED9EBA1) + W[25 & 0x0F];
  B = (B << 30) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(26 - 3) & 0x0F] ^ W[(26 - 8) & 0x0F]) ^ W[(26 - 14) & 0x0F]) ^ W[
         26 & 0x0F];
  W[26 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  D += ((((E << 5) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (A ^ B) ^ C)) + (unsigned long)0x6ED9EBA1) + W[26 & 0x0F];
  A = (A << 30) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(27 - 3) & 0x0F] ^ W[(27 - 8) & 0x0F]) ^ W[(27 - 14) & 0x0F]) ^ W[
         27 & 0x0F];
  W[27 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  C += ((((D << 5) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (E ^ A) ^ B)) + (unsigned long)0x6ED9EBA1) + W[27 & 0x0F];
  E = (E << 30) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(28 - 3) & 0x0F] ^ W[(28 - 8) & 0x0F]) ^ W[(28 - 14) & 0x0F]) ^ W[
         28 & 0x0F];
  W[28 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  B += ((((C << 5) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (D ^ E) ^ A)) + (unsigned long)0x6ED9EBA1) + W[28 & 0x0F];
  D = (D << 30) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(29 - 3) & 0x0F] ^ W[(29 - 8) & 0x0F]) ^ W[(29 - 14) & 0x0F]) ^ W[
         29 & 0x0F];
  W[29 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  A += ((((B << 5) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (C ^ D) ^ E)) + (unsigned long)0x6ED9EBA1) + W[29 & 0x0F];
  C = (C << 30) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(30 - 3) & 0x0F] ^ W[(30 - 8) & 0x0F]) ^ W[(30 - 14) & 0x0F]) ^ W[
         30 & 0x0F];
  W[30 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  E += ((((A << 5) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (B ^ C) ^ D)) + (unsigned long)0x6ED9EBA1) + W[30 & 0x0F];
  B = (B << 30) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(31 - 3) & 0x0F] ^ W[(31 - 8) & 0x0F]) ^ W[(31 - 14) & 0x0F]) ^ W[
         31 & 0x0F];
  W[31 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  D += ((((E << 5) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (A ^ B) ^ C)) + (unsigned long)0x6ED9EBA1) + W[31 & 0x0F];
  A = (A << 30) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(32 - 3) & 0x0F] ^ W[(32 - 8) & 0x0F]) ^ W[(32 - 14) & 0x0F]) ^ W[
         32 & 0x0F];
  W[32 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  C += ((((D << 5) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (E ^ A) ^ B)) + (unsigned long)0x6ED9EBA1) + W[32 & 0x0F];
  E = (E << 30) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(33 - 3) & 0x0F] ^ W[(33 - 8) & 0x0F]) ^ W[(33 - 14) & 0x0F]) ^ W[
         33 & 0x0F];
  W[33 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  B += ((((C << 5) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (D ^ E) ^ A)) + (unsigned long)0x6ED9EBA1) + W[33 & 0x0F];
  D = (D << 30) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(34 - 3) & 0x0F] ^ W[(34 - 8) & 0x0F]) ^ W[(34 - 14) & 0x0F]) ^ W[
         34 & 0x0F];
  W[34 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  A += ((((B << 5) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (C ^ D) ^ E)) + (unsigned long)0x6ED9EBA1) + W[34 & 0x0F];
  C = (C << 30) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(35 - 3) & 0x0F] ^ W[(35 - 8) & 0x0F]) ^ W[(35 - 14) & 0x0F]) ^ W[
         35 & 0x0F];
  W[35 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  E += ((((A << 5) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (B ^ C) ^ D)) + (unsigned long)0x6ED9EBA1) + W[35 & 0x0F];
  B = (B << 30) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(36 - 3) & 0x0F] ^ W[(36 - 8) & 0x0F]) ^ W[(36 - 14) & 0x0F]) ^ W[
         36 & 0x0F];
  W[36 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  D += ((((E << 5) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (A ^ B) ^ C)) + (unsigned long)0x6ED9EBA1) + W[36 & 0x0F];
  A = (A << 30) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(37 - 3) & 0x0F] ^ W[(37 - 8) & 0x0F]) ^ W[(37 - 14) & 0x0F]) ^ W[
         37 & 0x0F];
  W[37 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  C += ((((D << 5) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (E ^ A) ^ B)) + (unsigned long)0x6ED9EBA1) + W[37 & 0x0F];
  E = (E << 30) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(38 - 3) & 0x0F] ^ W[(38 - 8) & 0x0F]) ^ W[(38 - 14) & 0x0F]) ^ W[
         38 & 0x0F];
  W[38 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  B += ((((C << 5) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (D ^ E) ^ A)) + (unsigned long)0x6ED9EBA1) + W[38 & 0x0F];
  D = (D << 30) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(39 - 3) & 0x0F] ^ W[(39 - 8) & 0x0F]) ^ W[(39 - 14) & 0x0F]) ^ W[
         39 & 0x0F];
  W[39 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  A += ((((B << 5) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (C ^ D) ^ E)) + (unsigned long)0x6ED9EBA1) + W[39 & 0x0F];
  C = (C << 30) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(40 - 3) & 0x0F] ^ W[(40 - 8) & 0x0F]) ^ W[(40 - 14) & 0x0F]) ^ W[
         40 & 0x0F];
  W[40 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  E += ((((A << 5) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (B & C) | (D & (B | C)))) + (unsigned long)0x8F1BBCDC) + W[40 & 0x0F];
  B = (B << 30) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(41 - 3) & 0x0F] ^ W[(41 - 8) & 0x0F]) ^ W[(41 - 14) & 0x0F]) ^ W[
         41 & 0x0F];
  W[41 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  D += ((((E << 5) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (A & B) | (C & (A | B)))) + (unsigned long)0x8F1BBCDC) + W[41 & 0x0F];
  A = (A << 30) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(42 - 3) & 0x0F] ^ W[(42 - 8) & 0x0F]) ^ W[(42 - 14) & 0x0F]) ^ W[
         42 & 0x0F];
  W[42 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  C += ((((D << 5) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (E & A) | (B & (E | A)))) + (unsigned long)0x8F1BBCDC) + W[42 & 0x0F];
  E = (E << 30) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(43 - 3) & 0x0F] ^ W[(43 - 8) & 0x0F]) ^ W[(43 - 14) & 0x0F]) ^ W[
         43 & 0x0F];
  W[43 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  B += ((((C << 5) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (D & E) | (A & (D | E)))) + (unsigned long)0x8F1BBCDC) + W[43 & 0x0F];
  D = (D << 30) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(44 - 3) & 0x0F] ^ W[(44 - 8) & 0x0F]) ^ W[(44 - 14) & 0x0F]) ^ W[
         44 & 0x0F];
  W[44 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  A += ((((B << 5) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (C & D) | (E & (C | D)))) + (unsigned long)0x8F1BBCDC) + W[44 & 0x0F];
  C = (C << 30) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(45 - 3) & 0x0F] ^ W[(45 - 8) & 0x0F]) ^ W[(45 - 14) & 0x0F]) ^ W[
         45 & 0x0F];
  W[45 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  E += ((((A << 5) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (B & C) | (D & (B | C)))) + (unsigned long)0x8F1BBCDC) + W[45 & 0x0F];
  B = (B << 30) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(46 - 3) & 0x0F] ^ W[(46 - 8) & 0x0F]) ^ W[(46 - 14) & 0x0F]) ^ W[
         46 & 0x0F];
  W[46 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  D += ((((E << 5) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (A & B) | (C & (A | B)))) + (unsigned long)0x8F1BBCDC) + W[46 & 0x0F];
  A = (A << 30) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(47 - 3) & 0x0F] ^ W[(47 - 8) & 0x0F]) ^ W[(47 - 14) & 0x0F]) ^ W[
         47 & 0x0F];
  W[47 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  C += ((((D << 5) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (E & A) | (B & (E | A)))) + (unsigned long)0x8F1BBCDC) + W[47 & 0x0F];
  E = (E << 30) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(48 - 3) & 0x0F] ^ W[(48 - 8) & 0x0F]) ^ W[(48 - 14) & 0x0F]) ^ W[
         48 & 0x0F];
  W[48 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  B += ((((C << 5) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (D & E) | (A & (D | E)))) + (unsigned long)0x8F1BBCDC) + W[48 & 0x0F];
  D = (D << 30) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(49 - 3) & 0x0F] ^ W[(49 - 8) & 0x0F]) ^ W[(49 - 14) & 0x0F]) ^ W[
         49 & 0x0F];
  W[49 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  A += ((((B << 5) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (C & D) | (E & (C | D)))) + (unsigned long)0x8F1BBCDC) + W[49 & 0x0F];
  C = (C << 30) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(50 - 3) & 0x0F] ^ W[(50 - 8) & 0x0F]) ^ W[(50 - 14) & 0x0F]) ^ W[
         50 & 0x0F];
  W[50 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  E += ((((A << 5) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (B & C) | (D & (B | C)))) + (unsigned long)0x8F1BBCDC) + W[50 & 0x0F];
  B = (B << 30) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(51 - 3) & 0x0F] ^ W[(51 - 8) & 0x0F]) ^ W[(51 - 14) & 0x0F]) ^ W[
         51 & 0x0F];
  W[51 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  D += ((((E << 5) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (A & B) | (C & (A | B)))) + (unsigned long)0x8F1BBCDC) + W[51 & 0x0F];
  A = (A << 30) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(52 - 3) & 0x0F] ^ W[(52 - 8) & 0x0F]) ^ W[(52 - 14) & 0x0F]) ^ W[
         52 & 0x0F];
  W[52 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  C += ((((D << 5) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (E & A) | (B & (E | A)))) + (unsigned long)0x8F1BBCDC) + W[52 & 0x0F];
  E = (E << 30) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(53 - 3) & 0x0F] ^ W[(53 - 8) & 0x0F]) ^ W[(53 - 14) & 0x0F]) ^ W[
         53 & 0x0F];
  W[53 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  B += ((((C << 5) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (D & E) | (A & (D | E)))) + (unsigned long)0x8F1BBCDC) + W[53 & 0x0F];
  D = (D << 30) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(54 - 3) & 0x0F] ^ W[(54 - 8) & 0x0F]) ^ W[(54 - 14) & 0x0F]) ^ W[
         54 & 0x0F];
  W[54 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  A += ((((B << 5) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (C & D) | (E & (C | D)))) + (unsigned long)0x8F1BBCDC) + W[54 & 0x0F];
  C = (C << 30) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(55 - 3) & 0x0F] ^ W[(55 - 8) & 0x0F]) ^ W[(55 - 14) & 0x0F]) ^ W[
         55 & 0x0F];
  W[55 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  E += ((((A << 5) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (B & C) | (D & (B | C)))) + (unsigned long)0x8F1BBCDC) + W[55 & 0x0F];
  B = (B << 30) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(56 - 3) & 0x0F] ^ W[(56 - 8) & 0x0F]) ^ W[(56 - 14) & 0x0F]) ^ W[
         56 & 0x0F];
  W[56 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  D += ((((E << 5) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (A & B) | (C & (A | B)))) + (unsigned long)0x8F1BBCDC) + W[56 & 0x0F];
  A = (A << 30) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(57 - 3) & 0x0F] ^ W[(57 - 8) & 0x0F]) ^ W[(57 - 14) & 0x0F]) ^ W[
         57 & 0x0F];
  W[57 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  C += ((((D << 5) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (E & A) | (B & (E | A)))) + (unsigned long)0x8F1BBCDC) + W[57 & 0x0F];
  E = (E << 30) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(58 - 3) & 0x0F] ^ W[(58 - 8) & 0x0F]) ^ W[(58 - 14) & 0x0F]) ^ W[
         58 & 0x0F];
  W[58 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  B += ((((C << 5) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (D & E) | (A & (D | E)))) + (unsigned long)0x8F1BBCDC) + W[58 & 0x0F];
  D = (D << 30) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(59 - 3) & 0x0F] ^ W[(59 - 8) & 0x0F]) ^ W[(59 - 14) & 0x0F]) ^ W[
         59 & 0x0F];
  W[59 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  A += ((((B << 5) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (C & D) | (E & (C | D)))) + (unsigned long)0x8F1BBCDC) + W[59 & 0x0F];
  C = (C << 30) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(60 - 3) & 0x0F] ^ W[(60 - 8) & 0x0F]) ^ W[(60 - 14) & 0x0F]) ^ W[
         60 & 0x0F];
  W[60 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  E += ((((A << 5) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (B ^ C) ^ D)) + (unsigned long)0xCA62C1D6) + W[60 & 0x0F];
  B = (B << 30) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(61 - 3) & 0x0F] ^ W[(61 - 8) & 0x0F]) ^ W[(61 - 14) & 0x0F]) ^ W[
         61 & 0x0F];
  W[61 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  D += ((((E << 5) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (A ^ B) ^ C)) + (unsigned long)0xCA62C1D6) + W[61 & 0x0F];
  A = (A << 30) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(62 - 3) & 0x0F] ^ W[(62 - 8) & 0x0F]) ^ W[(62 - 14) & 0x0F]) ^ W[
         62 & 0x0F];
  W[62 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  C += ((((D << 5) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (E ^ A) ^ B)) + (unsigned long)0xCA62C1D6) + W[62 & 0x0F];
  E = (E << 30) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(63 - 3) & 0x0F] ^ W[(63 - 8) & 0x0F]) ^ W[(63 - 14) & 0x0F]) ^ W[
         63 & 0x0F];
  W[63 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  B += ((((C << 5) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (D ^ E) ^ A)) + (unsigned long)0xCA62C1D6) + W[63 & 0x0F];
  D = (D << 30) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(64 - 3) & 0x0F] ^ W[(64 - 8) & 0x0F]) ^ W[(64 - 14) & 0x0F]) ^ W[
         64 & 0x0F];
  W[64 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  A += ((((B << 5) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (C ^ D) ^ E)) + (unsigned long)0xCA62C1D6) + W[64 & 0x0F];
  C = (C << 30) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(65 - 3) & 0x0F] ^ W[(65 - 8) & 0x0F]) ^ W[(65 - 14) & 0x0F]) ^ W[
         65 & 0x0F];
  W[65 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  E += ((((A << 5) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (B ^ C) ^ D)) + (unsigned long)0xCA62C1D6) + W[65 & 0x0F];
  B = (B << 30) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(66 - 3) & 0x0F] ^ W[(66 - 8) & 0x0F]) ^ W[(66 - 14) & 0x0F]) ^ W[
         66 & 0x0F];
  W[66 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  D += ((((E << 5) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (A ^ B) ^ C)) + (unsigned long)0xCA62C1D6) + W[66 & 0x0F];
  A = (A << 30) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(67 - 3) & 0x0F] ^ W[(67 - 8) & 0x0F]) ^ W[(67 - 14) & 0x0F]) ^ W[
         67 & 0x0F];
  W[67 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  C += ((((D << 5) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (E ^ A) ^ B)) + (unsigned long)0xCA62C1D6) + W[67 & 0x0F];
  E = (E << 30) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(68 - 3) & 0x0F] ^ W[(68 - 8) & 0x0F]) ^ W[(68 - 14) & 0x0F]) ^ W[
         68 & 0x0F];
  W[68 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  B += ((((C << 5) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (D ^ E) ^ A)) + (unsigned long)0xCA62C1D6) + W[68 & 0x0F];
  D = (D << 30) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(69 - 3) & 0x0F] ^ W[(69 - 8) & 0x0F]) ^ W[(69 - 14) & 0x0F]) ^ W[
         69 & 0x0F];
  W[69 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  A += ((((B << 5) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (C ^ D) ^ E)) + (unsigned long)0xCA62C1D6) + W[69 & 0x0F];
  C = (C << 30) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(70 - 3) & 0x0F] ^ W[(70 - 8) & 0x0F]) ^ W[(70 - 14) & 0x0F]) ^ W[
         70 & 0x0F];
  W[70 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  E += ((((A << 5) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (B ^ C) ^ D)) + (unsigned long)0xCA62C1D6) + W[70 & 0x0F];
  B = (B << 30) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(71 - 3) & 0x0F] ^ W[(71 - 8) & 0x0F]) ^ W[(71 - 14) & 0x0F]) ^ W[
         71 & 0x0F];
  W[71 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  D += ((((E << 5) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (A ^ B) ^ C)) + (unsigned long)0xCA62C1D6) + W[71 & 0x0F];
  A = (A << 30) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(72 - 3) & 0x0F] ^ W[(72 - 8) & 0x0F]) ^ W[(72 - 14) & 0x0F]) ^ W[
         72 & 0x0F];
  W[72 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  C += ((((D << 5) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (E ^ A) ^ B)) + (unsigned long)0xCA62C1D6) + W[72 & 0x0F];
  E = (E << 30) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(73 - 3) & 0x0F] ^ W[(73 - 8) & 0x0F]) ^ W[(73 - 14) & 0x0F]) ^ W[
         73 & 0x0F];
  W[73 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  B += ((((C << 5) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (D ^ E) ^ A)) + (unsigned long)0xCA62C1D6) + W[73 & 0x0F];
  D = (D << 30) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(74 - 3) & 0x0F] ^ W[(74 - 8) & 0x0F]) ^ W[(74 - 14) & 0x0F]) ^ W[
         74 & 0x0F];
  W[74 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  A += ((((B << 5) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (C ^ D) ^ E)) + (unsigned long)0xCA62C1D6) + W[74 & 0x0F];
  C = (C << 30) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(75 - 3) & 0x0F] ^ W[(75 - 8) & 0x0F]) ^ W[(75 - 14) & 0x0F]) ^ W[
         75 & 0x0F];
  W[75 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  E += ((((A << 5) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (B ^ C) ^ D)) + (unsigned long)0xCA62C1D6) + W[75 & 0x0F];
  B = (B << 30) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(76 - 3) & 0x0F] ^ W[(76 - 8) & 0x0F]) ^ W[(76 - 14) & 0x0F]) ^ W[
         76 & 0x0F];
  W[76 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  D += ((((E << 5) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (A ^ B) ^ C)) + (unsigned long)0xCA62C1D6) + W[76 & 0x0F];
  A = (A << 30) | ((A & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(77 - 3) & 0x0F] ^ W[(77 - 8) & 0x0F]) ^ W[(77 - 14) & 0x0F]) ^ W[
         77 & 0x0F];
  W[77 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  C += ((((D << 5) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (E ^ A) ^ B)) + (unsigned long)0xCA62C1D6) + W[77 & 0x0F];
  E = (E << 30) | ((E & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(78 - 3) & 0x0F] ^ W[(78 - 8) & 0x0F]) ^ W[(78 - 14) & 0x0F]) ^ W[
         78 & 0x0F];
  W[78 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  B += ((((C << 5) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (D ^ E) ^ A)) + (unsigned long)0xCA62C1D6) + W[78 & 0x0F];
  D = (D << 30) | ((D & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  temp = ((W[(79 - 3) & 0x0F] ^ W[(79 - 8) & 0x0F]) ^ W[(79 - 14) & 0x0F]) ^ W[
         79 & 0x0F];
  W[79 & 0x0F] = (temp << 1) | ((temp & (unsigned long)0xFFFFFFFF) >> (
                                32 - 1));
  A += ((((B << 5) | ((B & (unsigned long)0xFFFFFFFF) >> (32 - 5))) + (
         (C ^ D) ^ E)) + (unsigned long)0xCA62C1D6) + W[79 & 0x0F];
  C = (C << 30) | ((C & (unsigned long)0xFFFFFFFF) >> (32 - 30));
  ctx->state[0] += A;
  ctx->state[1] += B;
  ctx->state[2] += C;
  ctx->state[3] += D;
  ctx->state[4] += E;
  return;
}

void sha1_update(sha1_context *ctx, unsigned char const *input, size_t ilen)
{
  size_t fill;
  unsigned long left;
  if (ilen <= (size_t)0) goto return_label;
  left = ctx->total[0] & (unsigned long)0x3F;
  fill = (size_t)((unsigned long)64 - left);
  ctx->total[0] += (unsigned long)ilen;
  ctx->total[0] &= (unsigned long)0xFFFFFFFF;
  if (ctx->total[0] < (unsigned long)ilen) (ctx->total[1]) ++;
  if (left) 
    if (ilen >= fill) {
      memcpy((void *)(& ctx->buffer[left]),(void const *)input,fill);
      sha1_process(ctx,(unsigned char const *)(ctx->buffer));
      input += fill;
      ilen -= fill;
      left = (unsigned long)0;
    }
  while (ilen >= (size_t)64) {
    sha1_process(ctx,input);
    input += 64;
    ilen -= (size_t)64;
  }
  if (ilen > (size_t)0) memcpy((void *)(& ctx->buffer[left]),
                               (void const *)input,ilen);
  return_label: return;
}

static unsigned char const sha1_padding[64] =
  {(unsigned char)0x80,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0};
/*@ requires \valid(ctx);
    requires \initialized(&ctx->total[0 .. 1]);
    requires \initialized(&ctx->state[0 .. 4]);
    ensures \initialized(\old(output) + (0 .. 19));
    assigns ctx->total[0 .. 1], ctx->state[0 .. 4], ctx->buffer[0 .. 63],
            ctx->ipad[0 .. 62], *(output + (0 .. 19));
    assigns ctx->total[0 .. 1] \from _state;
    assigns ctx->state[0 .. 4] \from _state;
    assigns ctx->buffer[0 .. 63] \from _state;
    assigns ctx->ipad[0 .. 62] \from _state;
    assigns *(output + (0 .. 19)) \from _state;
 */
void sha1_finish(sha1_context *ctx, unsigned char output[20])
{
  unsigned long last;
  unsigned long padn;
  unsigned long high;
  unsigned long low;
  unsigned char msglen[8];
  high = (ctx->total[0] >> 29) | (ctx->total[1] << 3);
  low = ctx->total[0] << 3;
  msglen[0] = (unsigned char)(high >> 24);
  msglen[0 + 1] = (unsigned char)(high >> 16);
  msglen[0 + 2] = (unsigned char)(high >> 8);
  msglen[0 + 3] = (unsigned char)high;
  msglen[4] = (unsigned char)(low >> 24);
  msglen[4 + 1] = (unsigned char)(low >> 16);
  msglen[4 + 2] = (unsigned char)(low >> 8);
  msglen[4 + 3] = (unsigned char)low;
  last = ctx->total[0] & (unsigned long)0x3F;
  if (last < (unsigned long)56) padn = (unsigned long)56 - last;
  else padn = (unsigned long)120 - last;
  sha1_update(ctx,sha1_padding,(size_t)padn);
  sha1_update(ctx,(unsigned char const *)(msglen),(size_t)8);
  *(output + 0) = (unsigned char)(ctx->state[0] >> 24);
  *(output + (0 + 1)) = (unsigned char)(ctx->state[0] >> 16);
  *(output + (0 + 2)) = (unsigned char)(ctx->state[0] >> 8);
  *(output + (0 + 3)) = (unsigned char)ctx->state[0];
  *(output + 4) = (unsigned char)(ctx->state[1] >> 24);
  *(output + (4 + 1)) = (unsigned char)(ctx->state[1] >> 16);
  *(output + (4 + 2)) = (unsigned char)(ctx->state[1] >> 8);
  *(output + (4 + 3)) = (unsigned char)ctx->state[1];
  *(output + 8) = (unsigned char)(ctx->state[2] >> 24);
  *(output + (8 + 1)) = (unsigned char)(ctx->state[2] >> 16);
  *(output + (8 + 2)) = (unsigned char)(ctx->state[2] >> 8);
  *(output + (8 + 3)) = (unsigned char)ctx->state[2];
  *(output + 12) = (unsigned char)(ctx->state[3] >> 24);
  *(output + (12 + 1)) = (unsigned char)(ctx->state[3] >> 16);
  *(output + (12 + 2)) = (unsigned char)(ctx->state[3] >> 8);
  *(output + (12 + 3)) = (unsigned char)ctx->state[3];
  *(output + 16) = (unsigned char)(ctx->state[4] >> 24);
  *(output + (16 + 1)) = (unsigned char)(ctx->state[4] >> 16);
  *(output + (16 + 2)) = (unsigned char)(ctx->state[4] >> 8);
  *(output + (16 + 3)) = (unsigned char)ctx->state[4];
  return;
}

void sha1(unsigned char const *input, size_t ilen, unsigned char output[20])
{
  sha1_context ctx;
  sha1_starts(& ctx);
  sha1_update(& ctx,input,ilen);
  sha1_finish(& ctx,output);
  memset((void *)(& ctx),0,sizeof(sha1_context));
  return;
}

int sha1_file(char const *path, unsigned char output[20])
{
  int __retres;
  FILE *f;
  size_t n;
  sha1_context ctx;
  unsigned char buf[1024];
  int tmp;
  f = fopen(path,"rb");
  if (f == (FILE *)0) {
    __retres = -0x0076;
    goto return_label;
  }
  sha1_starts(& ctx);
  while (1) {
    n = fread((void *)(buf),(size_t)1,sizeof(buf),f);
    if (! (n > (size_t)0)) break;
    sha1_update(& ctx,(unsigned char const *)(buf),n);
  }
  sha1_finish(& ctx,output);
  memset((void *)(& ctx),0,sizeof(sha1_context));
  tmp = ferror(f);
  if (tmp != 0) {
    fclose(f);
    __retres = -0x0076;
    goto return_label;
  }
  fclose(f);
  __retres = 0;
  return_label: return __retres;
}

void sha1_hmac_starts(sha1_context *ctx, unsigned char const *key,
                      size_t keylen)
{
  size_t i;
  unsigned char sum[20];
  if (keylen > (size_t)64) {
    sha1(key,keylen,sum);
    keylen = (size_t)20;
    key = (unsigned char const *)(sum);
  }
  memset((void *)(ctx->ipad),0x36,(size_t)64);
  memset((void *)(ctx->opad),0x5C,(size_t)64);
  i = (size_t)0;
  /*@ loop unroll 64; */
  while (i < keylen) {
    ctx->ipad[i] = (unsigned char)((int)ctx->ipad[i] ^ (int)*(key + i));
    ctx->opad[i] = (unsigned char)((int)ctx->opad[i] ^ (int)*(key + i));
    i ++;
  }
  sha1_starts(ctx);
  sha1_update(ctx,(unsigned char const *)(ctx->ipad),(size_t)64);
  memset((void *)(sum),0,sizeof(sum));
  return;
}

void sha1_hmac_update(sha1_context *ctx, unsigned char const *input,
                      size_t ilen)
{
  sha1_update(ctx,input,ilen);
  return;
}

void sha1_hmac_finish(sha1_context *ctx, unsigned char output[20])
{
  unsigned char tmpbuf[20];
  sha1_finish(ctx,tmpbuf);
  sha1_starts(ctx);
  sha1_update(ctx,(unsigned char const *)(ctx->opad),(size_t)64);
  sha1_update(ctx,(unsigned char const *)(tmpbuf),(size_t)20);
  sha1_finish(ctx,output);
  memset((void *)(tmpbuf),0,sizeof(tmpbuf));
  return;
}

void sha1_hmac_reset(sha1_context *ctx)
{
  sha1_starts(ctx);
  sha1_update(ctx,(unsigned char const *)(ctx->ipad),(size_t)64);
  return;
}

void sha1_hmac(unsigned char const *key, size_t keylen,
               unsigned char const *input, size_t ilen,
               unsigned char output[20])
{
  sha1_context ctx;
  sha1_hmac_starts(& ctx,key,keylen);
  sha1_hmac_update(& ctx,input,ilen);
  sha1_hmac_finish(& ctx,output);
  memset((void *)(& ctx),0,sizeof(sha1_context));
  return;
}

static unsigned char sha1_test_buf[3][57] =
  {{(unsigned char)'a',
    (unsigned char)'b',
    (unsigned char)'c',
    (unsigned char)'\000'},
   {(unsigned char)'a',
    (unsigned char)'b',
    (unsigned char)'c',
    (unsigned char)'d',
    (unsigned char)'b',
    (unsigned char)'c',
    (unsigned char)'d',
    (unsigned char)'e',
    (unsigned char)'c',
    (unsigned char)'d',
    (unsigned char)'e',
    (unsigned char)'f',
    (unsigned char)'d',
    (unsigned char)'e',
    (unsigned char)'f',
    (unsigned char)'g',
    (unsigned char)'e',
    (unsigned char)'f',
    (unsigned char)'g',
    (unsigned char)'h',
    (unsigned char)'f',
    (unsigned char)'g',
    (unsigned char)'h',
    (unsigned char)'i',
    (unsigned char)'g',
    (unsigned char)'h',
    (unsigned char)'i',
    (unsigned char)'j',
    (unsigned char)'h',
    (unsigned char)'i',
    (unsigned char)'j',
    (unsigned char)'k',
    (unsigned char)'i',
    (unsigned char)'j',
    (unsigned char)'k',
    (unsigned char)'l',
    (unsigned char)'j',
    (unsigned char)'k',
    (unsigned char)'l',
    (unsigned char)'m',
    (unsigned char)'k',
    (unsigned char)'l',
    (unsigned char)'m',
    (unsigned char)'n',
    (unsigned char)'l',
    (unsigned char)'m',
    (unsigned char)'n',
    (unsigned char)'o',
    (unsigned char)'m',
    (unsigned char)'n',
    (unsigned char)'o',
    (unsigned char)'p',
    (unsigned char)'n',
    (unsigned char)'o',
    (unsigned char)'p',
    (unsigned char)'q',
    (unsigned char)'\000'},
   {(unsigned char)'\000'}};
static int const sha1_test_buflen[3] = {3, 56, 1000};
static unsigned char const sha1_test_sum[3][20] =
  {{(unsigned char)0xA9,
    (unsigned char)0x99,
    (unsigned char)0x3E,
    (unsigned char)0x36,
    (unsigned char)0x47,
    (unsigned char)0x06,
    (unsigned char)0x81,
    (unsigned char)0x6A,
    (unsigned char)0xBA,
    (unsigned char)0x3E,
    (unsigned char)0x25,
    (unsigned char)0x71,
    (unsigned char)0x78,
    (unsigned char)0x50,
    (unsigned char)0xC2,
    (unsigned char)0x6C,
    (unsigned char)0x9C,
    (unsigned char)0xD0,
    (unsigned char)0xD8,
    (unsigned char)0x9D},
   {(unsigned char)0x84,
    (unsigned char)0x98,
    (unsigned char)0x3E,
    (unsigned char)0x44,
    (unsigned char)0x1C,
    (unsigned char)0x3B,
    (unsigned char)0xD2,
    (unsigned char)0x6E,
    (unsigned char)0xBA,
    (unsigned char)0xAE,
    (unsigned char)0x4A,
    (unsigned char)0xA1,
    (unsigned char)0xF9,
    (unsigned char)0x51,
    (unsigned char)0x29,
    (unsigned char)0xE5,
    (unsigned char)0xE5,
    (unsigned char)0x46,
    (unsigned char)0x70,
    (unsigned char)0xF1},
   {(unsigned char)0x34,
    (unsigned char)0xAA,
    (unsigned char)0x97,
    (unsigned char)0x3C,
    (unsigned char)0xD4,
    (unsigned char)0xC4,
    (unsigned char)0xDA,
    (unsigned char)0xA4,
    (unsigned char)0xF6,
    (unsigned char)0x1E,
    (unsigned char)0xEB,
    (unsigned char)0x2B,
    (unsigned char)0xDB,
    (unsigned char)0xAD,
    (unsigned char)0x27,
    (unsigned char)0x31,
    (unsigned char)0x65,
    (unsigned char)0x34,
    (unsigned char)0x01,
    (unsigned char)0x6F}};
static unsigned char sha1_hmac_test_key[7][26] =
  {{(unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\000'},
   {(unsigned char)'J',
    (unsigned char)'e',
    (unsigned char)'f',
    (unsigned char)'e',
    (unsigned char)'\000'},
   {(unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\000'},
   {(unsigned char)'\001',
    (unsigned char)'\002',
    (unsigned char)'\003',
    (unsigned char)'\004',
    (unsigned char)'\005',
    (unsigned char)'\006',
    (unsigned char)'\a',
    (unsigned char)'\b',
    (unsigned char)'\t',
    (unsigned char)'\n',
    (unsigned char)'\v',
    (unsigned char)'\f',
    (unsigned char)'\r',
    (unsigned char)'\016',
    (unsigned char)'\017',
    (unsigned char)'\020',
    (unsigned char)'\021',
    (unsigned char)'\022',
    (unsigned char)'\023',
    (unsigned char)'\024',
    (unsigned char)'\025',
    (unsigned char)'\026',
    (unsigned char)'\027',
    (unsigned char)'\030',
    (unsigned char)'\031',
    (unsigned char)'\000'},
   {(unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\000'},
   {(unsigned char)'\000'},
   {(unsigned char)'\000'}};
static int const sha1_hmac_test_keylen[7] = {20, 4, 20, 25, 20, 80, 80};
static unsigned char sha1_hmac_test_buf[7][74] =
  {{(unsigned char)'H',
    (unsigned char)'i',
    (unsigned char)' ',
    (unsigned char)'T',
    (unsigned char)'h',
    (unsigned char)'e',
    (unsigned char)'r',
    (unsigned char)'e',
    (unsigned char)'\000'},
   {(unsigned char)'w',
    (unsigned char)'h',
    (unsigned char)'a',
    (unsigned char)'t',
    (unsigned char)' ',
    (unsigned char)'d',
    (unsigned char)'o',
    (unsigned char)' ',
    (unsigned char)'y',
    (unsigned char)'a',
    (unsigned char)' ',
    (unsigned char)'w',
    (unsigned char)'a',
    (unsigned char)'n',
    (unsigned char)'t',
    (unsigned char)' ',
    (unsigned char)'f',
    (unsigned char)'o',
    (unsigned char)'r',
    (unsigned char)' ',
    (unsigned char)'n',
    (unsigned char)'o',
    (unsigned char)'t',
    (unsigned char)'h',
    (unsigned char)'i',
    (unsigned char)'n',
    (unsigned char)'g',
    (unsigned char)'?',
    (unsigned char)'\000'},
   {(unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\000'},
   {(unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\000'},
   {(unsigned char)'T',
    (unsigned char)'e',
    (unsigned char)'s',
    (unsigned char)'t',
    (unsigned char)' ',
    (unsigned char)'W',
    (unsigned char)'i',
    (unsigned char)'t',
    (unsigned char)'h',
    (unsigned char)' ',
    (unsigned char)'T',
    (unsigned char)'r',
    (unsigned char)'u',
    (unsigned char)'n',
    (unsigned char)'c',
    (unsigned char)'a',
    (unsigned char)'t',
    (unsigned char)'i',
    (unsigned char)'o',
    (unsigned char)'n',
    (unsigned char)'\000'},
   {(unsigned char)'T',
    (unsigned char)'e',
    (unsigned char)'s',
    (unsigned char)'t',
    (unsigned char)' ',
    (unsigned char)'U',
    (unsigned char)'s',
    (unsigned char)'i',
    (unsigned char)'n',
    (unsigned char)'g',
    (unsigned char)' ',
    (unsigned char)'L',
    (unsigned char)'a',
    (unsigned char)'r',
    (unsigned char)'g',
    (unsigned char)'e',
    (unsigned char)'r',
    (unsigned char)' ',
    (unsigned char)'T',
    (unsigned char)'h',
    (unsigned char)'a',
    (unsigned char)'n',
    (unsigned char)' ',
    (unsigned char)'B',
    (unsigned char)'l',
    (unsigned char)'o',
    (unsigned char)'c',
    (unsigned char)'k',
    (unsigned char)'-',
    (unsigned char)'S',
    (unsigned char)'i',
    (unsigned char)'z',
    (unsigned char)'e',
    (unsigned char)' ',
    (unsigned char)'K',
    (unsigned char)'e',
    (unsigned char)'y',
    (unsigned char)' ',
    (unsigned char)'-',
    (unsigned char)' ',
    (unsigned char)'H',
    (unsigned char)'a',
    (unsigned char)'s',
    (unsigned char)'h',
    (unsigned char)' ',
    (unsigned char)'K',
    (unsigned char)'e',
    (unsigned char)'y',
    (unsigned char)' ',
    (unsigned char)'F',
    (unsigned char)'i',
    (unsigned char)'r',
    (unsigned char)'s',
    (unsigned char)'t',
    (unsigned char)'\000'},
   {(unsigned char)'T',
    (unsigned char)'e',
    (unsigned char)'s',
    (unsigned char)'t',
    (unsigned char)' ',
    (unsigned char)'U',
    (unsigned char)'s',
    (unsigned char)'i',
    (unsigned char)'n',
    (unsigned char)'g',
    (unsigned char)' ',
    (unsigned char)'L',
    (unsigned char)'a',
    (unsigned char)'r',
    (unsigned char)'g',
    (unsigned char)'e',
    (unsigned char)'r',
    (unsigned char)' ',
    (unsigned char)'T',
    (unsigned char)'h',
    (unsigned char)'a',
    (unsigned char)'n',
    (unsigned char)' ',
    (unsigned char)'B',
    (unsigned char)'l',
    (unsigned char)'o',
    (unsigned char)'c',
    (unsigned char)'k',
    (unsigned char)'-',
    (unsigned char)'S',
    (unsigned char)'i',
    (unsigned char)'z',
    (unsigned char)'e',
    (unsigned char)' ',
    (unsigned char)'K',
    (unsigned char)'e',
    (unsigned char)'y',
    (unsigned char)' ',
    (unsigned char)'a',
    (unsigned char)'n',
    (unsigned char)'d',
    (unsigned char)' ',
    (unsigned char)'L',
    (unsigned char)'a',
    (unsigned char)'r',
    (unsigned char)'g',
    (unsigned char)'e',
    (unsigned char)'r',
    (unsigned char)' ',
    (unsigned char)'T',
    (unsigned char)'h',
    (unsigned char)'a',
    (unsigned char)'n',
    (unsigned char)' ',
    (unsigned char)'O',
    (unsigned char)'n',
    (unsigned char)'e',
    (unsigned char)' ',
    (unsigned char)'B',
    (unsigned char)'l',
    (unsigned char)'o',
    (unsigned char)'c',
    (unsigned char)'k',
    (unsigned char)'-',
    (unsigned char)'S',
    (unsigned char)'i',
    (unsigned char)'z',
    (unsigned char)'e',
    (unsigned char)' ',
    (unsigned char)'D',
    (unsigned char)'a',
    (unsigned char)'t',
    (unsigned char)'a',
    (unsigned char)'\000'}};
static int const sha1_hmac_test_buflen[7] = {8, 28, 50, 50, 20, 54, 73};
static unsigned char const sha1_hmac_test_sum[7][20] =
  {{(unsigned char)0xB6,
    (unsigned char)0x17,
    (unsigned char)0x31,
    (unsigned char)0x86,
    (unsigned char)0x55,
    (unsigned char)0x05,
    (unsigned char)0x72,
    (unsigned char)0x64,
    (unsigned char)0xE2,
    (unsigned char)0x8B,
    (unsigned char)0xC0,
    (unsigned char)0xB6,
    (unsigned char)0xFB,
    (unsigned char)0x37,
    (unsigned char)0x8C,
    (unsigned char)0x8E,
    (unsigned char)0xF1,
    (unsigned char)0x46,
    (unsigned char)0xBE,
    (unsigned char)0x00},
   {(unsigned char)0xEF,
    (unsigned char)0xFC,
    (unsigned char)0xDF,
    (unsigned char)0x6A,
    (unsigned char)0xE5,
    (unsigned char)0xEB,
    (unsigned char)0x2F,
    (unsigned char)0xA2,
    (unsigned char)0xD2,
    (unsigned char)0x74,
    (unsigned char)0x16,
    (unsigned char)0xD5,
    (unsigned char)0xF1,
    (unsigned char)0x84,
    (unsigned char)0xDF,
    (unsigned char)0x9C,
    (unsigned char)0x25,
    (unsigned char)0x9A,
    (unsigned char)0x7C,
    (unsigned char)0x79},
   {(unsigned char)0x12,
    (unsigned char)0x5D,
    (unsigned char)0x73,
    (unsigned char)0x42,
    (unsigned char)0xB9,
    (unsigned char)0xAC,
    (unsigned char)0x11,
    (unsigned char)0xCD,
    (unsigned char)0x91,
    (unsigned char)0xA3,
    (unsigned char)0x9A,
    (unsigned char)0xF4,
    (unsigned char)0x8A,
    (unsigned char)0xA1,
    (unsigned char)0x7B,
    (unsigned char)0x4F,
    (unsigned char)0x63,
    (unsigned char)0xF1,
    (unsigned char)0x75,
    (unsigned char)0xD3},
   {(unsigned char)0x4C,
    (unsigned char)0x90,
    (unsigned char)0x07,
    (unsigned char)0xF4,
    (unsigned char)0x02,
    (unsigned char)0x62,
    (unsigned char)0x50,
    (unsigned char)0xC6,
    (unsigned char)0xBC,
    (unsigned char)0x84,
    (unsigned char)0x14,
    (unsigned char)0xF9,
    (unsigned char)0xBF,
    (unsigned char)0x50,
    (unsigned char)0xC8,
    (unsigned char)0x6C,
    (unsigned char)0x2D,
    (unsigned char)0x72,
    (unsigned char)0x35,
    (unsigned char)0xDA},
   {(unsigned char)0x4C,
    (unsigned char)0x1A,
    (unsigned char)0x03,
    (unsigned char)0x42,
    (unsigned char)0x4B,
    (unsigned char)0x55,
    (unsigned char)0xE0,
    (unsigned char)0x7F,
    (unsigned char)0xE7,
    (unsigned char)0xF2,
    (unsigned char)0x7B,
    (unsigned char)0xE1},
   {(unsigned char)0xAA,
    (unsigned char)0x4A,
    (unsigned char)0xE5,
    (unsigned char)0xE1,
    (unsigned char)0x52,
    (unsigned char)0x72,
    (unsigned char)0xD0,
    (unsigned char)0x0E,
    (unsigned char)0x95,
    (unsigned char)0x70,
    (unsigned char)0x56,
    (unsigned char)0x37,
    (unsigned char)0xCE,
    (unsigned char)0x8A,
    (unsigned char)0x3B,
    (unsigned char)0x55,
    (unsigned char)0xED,
    (unsigned char)0x40,
    (unsigned char)0x21,
    (unsigned char)0x12},
   {(unsigned char)0xE8,
    (unsigned char)0xE9,
    (unsigned char)0x9D,
    (unsigned char)0x0F,
    (unsigned char)0x45,
    (unsigned char)0x23,
    (unsigned char)0x7D,
    (unsigned char)0x78,
    (unsigned char)0x6D,
    (unsigned char)0x6B,
    (unsigned char)0xBA,
    (unsigned char)0xA7,
    (unsigned char)0x96,
    (unsigned char)0x5C,
    (unsigned char)0x78,
    (unsigned char)0x08,
    (unsigned char)0xBB,
    (unsigned char)0xFF,
    (unsigned char)0x1A,
    (unsigned char)0x91}};
/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_103(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_104(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_105(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_106(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_107(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_108(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_109(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_110(char const * restrict format);

int sha1_self_test(int verbose)
{
  int __retres;
  int i;
  int j;
  int buflen;
  unsigned char buf[1024];
  unsigned char sha1sum[20];
  sha1_context ctx;
  i = 0;
  while (i < 3) {
    {
      int tmp;
      if (verbose != 0) printf("  SHA-1 test #%d: ",i + 1); /* printf_va_103 */
      sha1_starts(& ctx);
      if (i == 2) {
        buflen = 1000;
        memset((void *)(buf),'a',(size_t)buflen);
        j = 0;
        while (j < 1000) {
          sha1_update(& ctx,(unsigned char const *)(buf),(size_t)buflen);
          j ++;
        }
      }
      else sha1_update(& ctx,(unsigned char const *)(sha1_test_buf[i]),
                       (size_t)sha1_test_buflen[i]);
      sha1_finish(& ctx,sha1sum);
      tmp = memcmp((void const *)(sha1sum),(void const *)(sha1_test_sum[i]),
                   (size_t)20);
      if (tmp != 0) {
        if (verbose != 0) printf("failed\n"); /* printf_va_104 */
        __retres = 1;
        goto return_label;
      }
      if (verbose != 0) printf("passed\n"); /* printf_va_105 */
    }
    i ++;
  }
  if (verbose != 0) printf("\n"); /* printf_va_106 */
  i = 0;
  while (i < 7) {
    {
      int tmp_0;
      if (verbose != 0) printf("  HMAC-SHA-1 test #%d: ",i + 1); /* printf_va_107 */
      if (i == 5) goto _LOR;
      else 
        if (i == 6) {
          _LOR:
          {
            buflen = 80;
            memset((void *)(buf),'\252',(size_t)buflen);
            sha1_hmac_starts(& ctx,(unsigned char const *)(buf),
                             (size_t)buflen);
          }
        }
        else sha1_hmac_starts(& ctx,
                              (unsigned char const *)(sha1_hmac_test_key[i]),
                              (size_t)sha1_hmac_test_keylen[i]);
      sha1_hmac_update(& ctx,(unsigned char const *)(sha1_hmac_test_buf[i]),
                       (size_t)sha1_hmac_test_buflen[i]);
      sha1_hmac_finish(& ctx,sha1sum);
      if (i == 4) buflen = 12; else buflen = 20;
      tmp_0 = memcmp((void const *)(sha1sum),
                     (void const *)(sha1_hmac_test_sum[i]),(size_t)buflen);
      if (tmp_0 != 0) {
        if (verbose != 0) printf("failed\n"); /* printf_va_108 */
        __retres = 1;
        goto return_label;
      }
      if (verbose != 0) printf("passed\n"); /* printf_va_109 */
    }
    i ++;
  }
  if (verbose != 0) printf("\n"); /* printf_va_110 */
  __retres = 0;
  return_label: return __retres;
}

void sha2_starts(sha2_context *ctx, int is224)
{
  ctx->total[0] = (unsigned long)0;
  ctx->total[1] = (unsigned long)0;
  if (is224 == 0) {
    ctx->state[0] = (unsigned long)0x6A09E667;
    ctx->state[1] = (unsigned long)0xBB67AE85;
    ctx->state[2] = (unsigned long)0x3C6EF372;
    ctx->state[3] = (unsigned long)0xA54FF53A;
    ctx->state[4] = (unsigned long)0x510E527F;
    ctx->state[5] = (unsigned long)0x9B05688C;
    ctx->state[6] = (unsigned long)0x1F83D9AB;
    ctx->state[7] = (unsigned long)0x5BE0CD19;
  }
  else {
    ctx->state[0] = (unsigned long)0xC1059ED8;
    ctx->state[1] = (unsigned long)0x367CD507;
    ctx->state[2] = (unsigned long)0x3070DD17;
    ctx->state[3] = (unsigned long)0xF70E5939;
    ctx->state[4] = (unsigned long)0xFFC00B31;
    ctx->state[5] = (unsigned long)0x68581511;
    ctx->state[6] = (unsigned long)0x64F98FA7;
    ctx->state[7] = (unsigned long)0xBEFA4FA4;
  }
  ctx->is224 = is224;
  return;
}

void sha2_process(sha2_context *ctx, unsigned char const data[64])
{
  unsigned long temp1;
  unsigned long temp2;
  unsigned long W[64];
  unsigned long A;
  unsigned long B;
  unsigned long C;
  unsigned long D;
  unsigned long E;
  unsigned long F;
  unsigned long G;
  unsigned long H;
  W[0] = ((((unsigned long)*(data + 0) << 24) | ((unsigned long)*(data + (
                                                                  0 + 1)) << 16)) | (
          (unsigned long)*(data + (0 + 2)) << 8)) | (unsigned long)*(
         data + (0 + 3));
  W[1] = ((((unsigned long)*(data + 4) << 24) | ((unsigned long)*(data + (
                                                                  4 + 1)) << 16)) | (
          (unsigned long)*(data + (4 + 2)) << 8)) | (unsigned long)*(
         data + (4 + 3));
  W[2] = ((((unsigned long)*(data + 8) << 24) | ((unsigned long)*(data + (
                                                                  8 + 1)) << 16)) | (
          (unsigned long)*(data + (8 + 2)) << 8)) | (unsigned long)*(
         data + (8 + 3));
  W[3] = ((((unsigned long)*(data + 12) << 24) | ((unsigned long)*(data + (
                                                                   12 + 1)) << 16)) | (
          (unsigned long)*(data + (12 + 2)) << 8)) | (unsigned long)*(
         data + (12 + 3));
  W[4] = ((((unsigned long)*(data + 16) << 24) | ((unsigned long)*(data + (
                                                                   16 + 1)) << 16)) | (
          (unsigned long)*(data + (16 + 2)) << 8)) | (unsigned long)*(
         data + (16 + 3));
  W[5] = ((((unsigned long)*(data + 20) << 24) | ((unsigned long)*(data + (
                                                                   20 + 1)) << 16)) | (
          (unsigned long)*(data + (20 + 2)) << 8)) | (unsigned long)*(
         data + (20 + 3));
  W[6] = ((((unsigned long)*(data + 24) << 24) | ((unsigned long)*(data + (
                                                                   24 + 1)) << 16)) | (
          (unsigned long)*(data + (24 + 2)) << 8)) | (unsigned long)*(
         data + (24 + 3));
  W[7] = ((((unsigned long)*(data + 28) << 24) | ((unsigned long)*(data + (
                                                                   28 + 1)) << 16)) | (
          (unsigned long)*(data + (28 + 2)) << 8)) | (unsigned long)*(
         data + (28 + 3));
  W[8] = ((((unsigned long)*(data + 32) << 24) | ((unsigned long)*(data + (
                                                                   32 + 1)) << 16)) | (
          (unsigned long)*(data + (32 + 2)) << 8)) | (unsigned long)*(
         data + (32 + 3));
  W[9] = ((((unsigned long)*(data + 36) << 24) | ((unsigned long)*(data + (
                                                                   36 + 1)) << 16)) | (
          (unsigned long)*(data + (36 + 2)) << 8)) | (unsigned long)*(
         data + (36 + 3));
  W[10] = ((((unsigned long)*(data + 40) << 24) | ((unsigned long)*(data + (
                                                                    40 + 1)) << 16)) | (
           (unsigned long)*(data + (40 + 2)) << 8)) | (unsigned long)*(
          data + (40 + 3));
  W[11] = ((((unsigned long)*(data + 44) << 24) | ((unsigned long)*(data + (
                                                                    44 + 1)) << 16)) | (
           (unsigned long)*(data + (44 + 2)) << 8)) | (unsigned long)*(
          data + (44 + 3));
  W[12] = ((((unsigned long)*(data + 48) << 24) | ((unsigned long)*(data + (
                                                                    48 + 1)) << 16)) | (
           (unsigned long)*(data + (48 + 2)) << 8)) | (unsigned long)*(
          data + (48 + 3));
  W[13] = ((((unsigned long)*(data + 52) << 24) | ((unsigned long)*(data + (
                                                                    52 + 1)) << 16)) | (
           (unsigned long)*(data + (52 + 2)) << 8)) | (unsigned long)*(
          data + (52 + 3));
  W[14] = ((((unsigned long)*(data + 56) << 24) | ((unsigned long)*(data + (
                                                                    56 + 1)) << 16)) | (
           (unsigned long)*(data + (56 + 2)) << 8)) | (unsigned long)*(
          data + (56 + 3));
  W[15] = ((((unsigned long)*(data + 60) << 24) | ((unsigned long)*(data + (
                                                                    60 + 1)) << 16)) | (
           (unsigned long)*(data + (60 + 2)) << 8)) | (unsigned long)*(
          data + (60 + 3));
  A = ctx->state[0];
  B = ctx->state[1];
  C = ctx->state[2];
  D = ctx->state[3];
  E = ctx->state[4];
  F = ctx->state[5];
  G = ctx->state[6];
  H = ctx->state[7];
  temp1 = (((H + (((((E & (unsigned long)0xFFFFFFFF) >> 6) | (E << (32 - 6))) ^ (
                   ((E & (unsigned long)0xFFFFFFFF) >> 11) | (E << (32 - 11)))) ^ (
                  ((E & (unsigned long)0xFFFFFFFF) >> 25) | (E << (32 - 25))))) + (
            G ^ (E & (F ^ G)))) + (unsigned long)0x428A2F98) + W[0];
  temp2 = (((((A & (unsigned long)0xFFFFFFFF) >> 2) | (A << (32 - 2))) ^ (
            ((A & (unsigned long)0xFFFFFFFF) >> 13) | (A << (32 - 13)))) ^ (
           ((A & (unsigned long)0xFFFFFFFF) >> 22) | (A << (32 - 22)))) + (
          (A & B) | (C & (A | B)));
  D += temp1;
  H = temp1 + temp2;
  temp1 = (((G + (((((D & (unsigned long)0xFFFFFFFF) >> 6) | (D << (32 - 6))) ^ (
                   ((D & (unsigned long)0xFFFFFFFF) >> 11) | (D << (32 - 11)))) ^ (
                  ((D & (unsigned long)0xFFFFFFFF) >> 25) | (D << (32 - 25))))) + (
            F ^ (D & (E ^ F)))) + (unsigned long)0x71374491) + W[1];
  temp2 = (((((H & (unsigned long)0xFFFFFFFF) >> 2) | (H << (32 - 2))) ^ (
            ((H & (unsigned long)0xFFFFFFFF) >> 13) | (H << (32 - 13)))) ^ (
           ((H & (unsigned long)0xFFFFFFFF) >> 22) | (H << (32 - 22)))) + (
          (H & A) | (B & (H | A)));
  C += temp1;
  G = temp1 + temp2;
  temp1 = (((F + (((((C & (unsigned long)0xFFFFFFFF) >> 6) | (C << (32 - 6))) ^ (
                   ((C & (unsigned long)0xFFFFFFFF) >> 11) | (C << (32 - 11)))) ^ (
                  ((C & (unsigned long)0xFFFFFFFF) >> 25) | (C << (32 - 25))))) + (
            E ^ (C & (D ^ E)))) + (unsigned long)0xB5C0FBCF) + W[2];
  temp2 = (((((G & (unsigned long)0xFFFFFFFF) >> 2) | (G << (32 - 2))) ^ (
            ((G & (unsigned long)0xFFFFFFFF) >> 13) | (G << (32 - 13)))) ^ (
           ((G & (unsigned long)0xFFFFFFFF) >> 22) | (G << (32 - 22)))) + (
          (G & H) | (A & (G | H)));
  B += temp1;
  F = temp1 + temp2;
  temp1 = (((E + (((((B & (unsigned long)0xFFFFFFFF) >> 6) | (B << (32 - 6))) ^ (
                   ((B & (unsigned long)0xFFFFFFFF) >> 11) | (B << (32 - 11)))) ^ (
                  ((B & (unsigned long)0xFFFFFFFF) >> 25) | (B << (32 - 25))))) + (
            D ^ (B & (C ^ D)))) + (unsigned long)0xE9B5DBA5) + W[3];
  temp2 = (((((F & (unsigned long)0xFFFFFFFF) >> 2) | (F << (32 - 2))) ^ (
            ((F & (unsigned long)0xFFFFFFFF) >> 13) | (F << (32 - 13)))) ^ (
           ((F & (unsigned long)0xFFFFFFFF) >> 22) | (F << (32 - 22)))) + (
          (F & G) | (H & (F | G)));
  A += temp1;
  E = temp1 + temp2;
  temp1 = (((D + (((((A & (unsigned long)0xFFFFFFFF) >> 6) | (A << (32 - 6))) ^ (
                   ((A & (unsigned long)0xFFFFFFFF) >> 11) | (A << (32 - 11)))) ^ (
                  ((A & (unsigned long)0xFFFFFFFF) >> 25) | (A << (32 - 25))))) + (
            C ^ (A & (B ^ C)))) + (unsigned long)0x3956C25B) + W[4];
  temp2 = (((((E & (unsigned long)0xFFFFFFFF) >> 2) | (E << (32 - 2))) ^ (
            ((E & (unsigned long)0xFFFFFFFF) >> 13) | (E << (32 - 13)))) ^ (
           ((E & (unsigned long)0xFFFFFFFF) >> 22) | (E << (32 - 22)))) + (
          (E & F) | (G & (E | F)));
  H += temp1;
  D = temp1 + temp2;
  temp1 = (((C + (((((H & (unsigned long)0xFFFFFFFF) >> 6) | (H << (32 - 6))) ^ (
                   ((H & (unsigned long)0xFFFFFFFF) >> 11) | (H << (32 - 11)))) ^ (
                  ((H & (unsigned long)0xFFFFFFFF) >> 25) | (H << (32 - 25))))) + (
            B ^ (H & (A ^ B)))) + (unsigned long)0x59F111F1) + W[5];
  temp2 = (((((D & (unsigned long)0xFFFFFFFF) >> 2) | (D << (32 - 2))) ^ (
            ((D & (unsigned long)0xFFFFFFFF) >> 13) | (D << (32 - 13)))) ^ (
           ((D & (unsigned long)0xFFFFFFFF) >> 22) | (D << (32 - 22)))) + (
          (D & E) | (F & (D | E)));
  G += temp1;
  C = temp1 + temp2;
  temp1 = (((B + (((((G & (unsigned long)0xFFFFFFFF) >> 6) | (G << (32 - 6))) ^ (
                   ((G & (unsigned long)0xFFFFFFFF) >> 11) | (G << (32 - 11)))) ^ (
                  ((G & (unsigned long)0xFFFFFFFF) >> 25) | (G << (32 - 25))))) + (
            A ^ (G & (H ^ A)))) + (unsigned long)0x923F82A4) + W[6];
  temp2 = (((((C & (unsigned long)0xFFFFFFFF) >> 2) | (C << (32 - 2))) ^ (
            ((C & (unsigned long)0xFFFFFFFF) >> 13) | (C << (32 - 13)))) ^ (
           ((C & (unsigned long)0xFFFFFFFF) >> 22) | (C << (32 - 22)))) + (
          (C & D) | (E & (C | D)));
  F += temp1;
  B = temp1 + temp2;
  temp1 = (((A + (((((F & (unsigned long)0xFFFFFFFF) >> 6) | (F << (32 - 6))) ^ (
                   ((F & (unsigned long)0xFFFFFFFF) >> 11) | (F << (32 - 11)))) ^ (
                  ((F & (unsigned long)0xFFFFFFFF) >> 25) | (F << (32 - 25))))) + (
            H ^ (F & (G ^ H)))) + (unsigned long)0xAB1C5ED5) + W[7];
  temp2 = (((((B & (unsigned long)0xFFFFFFFF) >> 2) | (B << (32 - 2))) ^ (
            ((B & (unsigned long)0xFFFFFFFF) >> 13) | (B << (32 - 13)))) ^ (
           ((B & (unsigned long)0xFFFFFFFF) >> 22) | (B << (32 - 22)))) + (
          (B & C) | (D & (B | C)));
  E += temp1;
  A = temp1 + temp2;
  temp1 = (((H + (((((E & (unsigned long)0xFFFFFFFF) >> 6) | (E << (32 - 6))) ^ (
                   ((E & (unsigned long)0xFFFFFFFF) >> 11) | (E << (32 - 11)))) ^ (
                  ((E & (unsigned long)0xFFFFFFFF) >> 25) | (E << (32 - 25))))) + (
            G ^ (E & (F ^ G)))) + (unsigned long)0xD807AA98) + W[8];
  temp2 = (((((A & (unsigned long)0xFFFFFFFF) >> 2) | (A << (32 - 2))) ^ (
            ((A & (unsigned long)0xFFFFFFFF) >> 13) | (A << (32 - 13)))) ^ (
           ((A & (unsigned long)0xFFFFFFFF) >> 22) | (A << (32 - 22)))) + (
          (A & B) | (C & (A | B)));
  D += temp1;
  H = temp1 + temp2;
  temp1 = (((G + (((((D & (unsigned long)0xFFFFFFFF) >> 6) | (D << (32 - 6))) ^ (
                   ((D & (unsigned long)0xFFFFFFFF) >> 11) | (D << (32 - 11)))) ^ (
                  ((D & (unsigned long)0xFFFFFFFF) >> 25) | (D << (32 - 25))))) + (
            F ^ (D & (E ^ F)))) + (unsigned long)0x12835B01) + W[9];
  temp2 = (((((H & (unsigned long)0xFFFFFFFF) >> 2) | (H << (32 - 2))) ^ (
            ((H & (unsigned long)0xFFFFFFFF) >> 13) | (H << (32 - 13)))) ^ (
           ((H & (unsigned long)0xFFFFFFFF) >> 22) | (H << (32 - 22)))) + (
          (H & A) | (B & (H | A)));
  C += temp1;
  G = temp1 + temp2;
  temp1 = (((F + (((((C & (unsigned long)0xFFFFFFFF) >> 6) | (C << (32 - 6))) ^ (
                   ((C & (unsigned long)0xFFFFFFFF) >> 11) | (C << (32 - 11)))) ^ (
                  ((C & (unsigned long)0xFFFFFFFF) >> 25) | (C << (32 - 25))))) + (
            E ^ (C & (D ^ E)))) + (unsigned long)0x243185BE) + W[10];
  temp2 = (((((G & (unsigned long)0xFFFFFFFF) >> 2) | (G << (32 - 2))) ^ (
            ((G & (unsigned long)0xFFFFFFFF) >> 13) | (G << (32 - 13)))) ^ (
           ((G & (unsigned long)0xFFFFFFFF) >> 22) | (G << (32 - 22)))) + (
          (G & H) | (A & (G | H)));
  B += temp1;
  F = temp1 + temp2;
  temp1 = (((E + (((((B & (unsigned long)0xFFFFFFFF) >> 6) | (B << (32 - 6))) ^ (
                   ((B & (unsigned long)0xFFFFFFFF) >> 11) | (B << (32 - 11)))) ^ (
                  ((B & (unsigned long)0xFFFFFFFF) >> 25) | (B << (32 - 25))))) + (
            D ^ (B & (C ^ D)))) + (unsigned long)0x550C7DC3) + W[11];
  temp2 = (((((F & (unsigned long)0xFFFFFFFF) >> 2) | (F << (32 - 2))) ^ (
            ((F & (unsigned long)0xFFFFFFFF) >> 13) | (F << (32 - 13)))) ^ (
           ((F & (unsigned long)0xFFFFFFFF) >> 22) | (F << (32 - 22)))) + (
          (F & G) | (H & (F | G)));
  A += temp1;
  E = temp1 + temp2;
  temp1 = (((D + (((((A & (unsigned long)0xFFFFFFFF) >> 6) | (A << (32 - 6))) ^ (
                   ((A & (unsigned long)0xFFFFFFFF) >> 11) | (A << (32 - 11)))) ^ (
                  ((A & (unsigned long)0xFFFFFFFF) >> 25) | (A << (32 - 25))))) + (
            C ^ (A & (B ^ C)))) + (unsigned long)0x72BE5D74) + W[12];
  temp2 = (((((E & (unsigned long)0xFFFFFFFF) >> 2) | (E << (32 - 2))) ^ (
            ((E & (unsigned long)0xFFFFFFFF) >> 13) | (E << (32 - 13)))) ^ (
           ((E & (unsigned long)0xFFFFFFFF) >> 22) | (E << (32 - 22)))) + (
          (E & F) | (G & (E | F)));
  H += temp1;
  D = temp1 + temp2;
  temp1 = (((C + (((((H & (unsigned long)0xFFFFFFFF) >> 6) | (H << (32 - 6))) ^ (
                   ((H & (unsigned long)0xFFFFFFFF) >> 11) | (H << (32 - 11)))) ^ (
                  ((H & (unsigned long)0xFFFFFFFF) >> 25) | (H << (32 - 25))))) + (
            B ^ (H & (A ^ B)))) + (unsigned long)0x80DEB1FE) + W[13];
  temp2 = (((((D & (unsigned long)0xFFFFFFFF) >> 2) | (D << (32 - 2))) ^ (
            ((D & (unsigned long)0xFFFFFFFF) >> 13) | (D << (32 - 13)))) ^ (
           ((D & (unsigned long)0xFFFFFFFF) >> 22) | (D << (32 - 22)))) + (
          (D & E) | (F & (D | E)));
  G += temp1;
  C = temp1 + temp2;
  temp1 = (((B + (((((G & (unsigned long)0xFFFFFFFF) >> 6) | (G << (32 - 6))) ^ (
                   ((G & (unsigned long)0xFFFFFFFF) >> 11) | (G << (32 - 11)))) ^ (
                  ((G & (unsigned long)0xFFFFFFFF) >> 25) | (G << (32 - 25))))) + (
            A ^ (G & (H ^ A)))) + (unsigned long)0x9BDC06A7) + W[14];
  temp2 = (((((C & (unsigned long)0xFFFFFFFF) >> 2) | (C << (32 - 2))) ^ (
            ((C & (unsigned long)0xFFFFFFFF) >> 13) | (C << (32 - 13)))) ^ (
           ((C & (unsigned long)0xFFFFFFFF) >> 22) | (C << (32 - 22)))) + (
          (C & D) | (E & (C | D)));
  F += temp1;
  B = temp1 + temp2;
  temp1 = (((A + (((((F & (unsigned long)0xFFFFFFFF) >> 6) | (F << (32 - 6))) ^ (
                   ((F & (unsigned long)0xFFFFFFFF) >> 11) | (F << (32 - 11)))) ^ (
                  ((F & (unsigned long)0xFFFFFFFF) >> 25) | (F << (32 - 25))))) + (
            H ^ (F & (G ^ H)))) + (unsigned long)0xC19BF174) + W[15];
  temp2 = (((((B & (unsigned long)0xFFFFFFFF) >> 2) | (B << (32 - 2))) ^ (
            ((B & (unsigned long)0xFFFFFFFF) >> 13) | (B << (32 - 13)))) ^ (
           ((B & (unsigned long)0xFFFFFFFF) >> 22) | (B << (32 - 22)))) + (
          (B & C) | (D & (B | C)));
  E += temp1;
  A = temp1 + temp2;
  W[16] = (((((((W[16 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[16 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[16 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[16 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[16 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[16 - 7]) + (
           ((((W[16 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[16 - 15] << (
                                                                32 - 7))) ^ (
            ((W[16 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[16 - 15] << (
                                                                32 - 18)))) ^ (
           (W[16 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[16 - 16];
  temp1 = (((H + (((((E & (unsigned long)0xFFFFFFFF) >> 6) | (E << (32 - 6))) ^ (
                   ((E & (unsigned long)0xFFFFFFFF) >> 11) | (E << (32 - 11)))) ^ (
                  ((E & (unsigned long)0xFFFFFFFF) >> 25) | (E << (32 - 25))))) + (
            G ^ (E & (F ^ G)))) + (unsigned long)0xE49B69C1) + W[16];
  temp2 = (((((A & (unsigned long)0xFFFFFFFF) >> 2) | (A << (32 - 2))) ^ (
            ((A & (unsigned long)0xFFFFFFFF) >> 13) | (A << (32 - 13)))) ^ (
           ((A & (unsigned long)0xFFFFFFFF) >> 22) | (A << (32 - 22)))) + (
          (A & B) | (C & (A | B)));
  D += temp1;
  H = temp1 + temp2;
  W[17] = (((((((W[17 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[17 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[17 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[17 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[17 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[17 - 7]) + (
           ((((W[17 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[17 - 15] << (
                                                                32 - 7))) ^ (
            ((W[17 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[17 - 15] << (
                                                                32 - 18)))) ^ (
           (W[17 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[17 - 16];
  temp1 = (((G + (((((D & (unsigned long)0xFFFFFFFF) >> 6) | (D << (32 - 6))) ^ (
                   ((D & (unsigned long)0xFFFFFFFF) >> 11) | (D << (32 - 11)))) ^ (
                  ((D & (unsigned long)0xFFFFFFFF) >> 25) | (D << (32 - 25))))) + (
            F ^ (D & (E ^ F)))) + (unsigned long)0xEFBE4786) + W[17];
  temp2 = (((((H & (unsigned long)0xFFFFFFFF) >> 2) | (H << (32 - 2))) ^ (
            ((H & (unsigned long)0xFFFFFFFF) >> 13) | (H << (32 - 13)))) ^ (
           ((H & (unsigned long)0xFFFFFFFF) >> 22) | (H << (32 - 22)))) + (
          (H & A) | (B & (H | A)));
  C += temp1;
  G = temp1 + temp2;
  W[18] = (((((((W[18 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[18 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[18 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[18 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[18 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[18 - 7]) + (
           ((((W[18 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[18 - 15] << (
                                                                32 - 7))) ^ (
            ((W[18 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[18 - 15] << (
                                                                32 - 18)))) ^ (
           (W[18 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[18 - 16];
  temp1 = (((F + (((((C & (unsigned long)0xFFFFFFFF) >> 6) | (C << (32 - 6))) ^ (
                   ((C & (unsigned long)0xFFFFFFFF) >> 11) | (C << (32 - 11)))) ^ (
                  ((C & (unsigned long)0xFFFFFFFF) >> 25) | (C << (32 - 25))))) + (
            E ^ (C & (D ^ E)))) + (unsigned long)0x0FC19DC6) + W[18];
  temp2 = (((((G & (unsigned long)0xFFFFFFFF) >> 2) | (G << (32 - 2))) ^ (
            ((G & (unsigned long)0xFFFFFFFF) >> 13) | (G << (32 - 13)))) ^ (
           ((G & (unsigned long)0xFFFFFFFF) >> 22) | (G << (32 - 22)))) + (
          (G & H) | (A & (G | H)));
  B += temp1;
  F = temp1 + temp2;
  W[19] = (((((((W[19 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[19 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[19 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[19 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[19 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[19 - 7]) + (
           ((((W[19 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[19 - 15] << (
                                                                32 - 7))) ^ (
            ((W[19 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[19 - 15] << (
                                                                32 - 18)))) ^ (
           (W[19 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[19 - 16];
  temp1 = (((E + (((((B & (unsigned long)0xFFFFFFFF) >> 6) | (B << (32 - 6))) ^ (
                   ((B & (unsigned long)0xFFFFFFFF) >> 11) | (B << (32 - 11)))) ^ (
                  ((B & (unsigned long)0xFFFFFFFF) >> 25) | (B << (32 - 25))))) + (
            D ^ (B & (C ^ D)))) + (unsigned long)0x240CA1CC) + W[19];
  temp2 = (((((F & (unsigned long)0xFFFFFFFF) >> 2) | (F << (32 - 2))) ^ (
            ((F & (unsigned long)0xFFFFFFFF) >> 13) | (F << (32 - 13)))) ^ (
           ((F & (unsigned long)0xFFFFFFFF) >> 22) | (F << (32 - 22)))) + (
          (F & G) | (H & (F | G)));
  A += temp1;
  E = temp1 + temp2;
  W[20] = (((((((W[20 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[20 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[20 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[20 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[20 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[20 - 7]) + (
           ((((W[20 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[20 - 15] << (
                                                                32 - 7))) ^ (
            ((W[20 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[20 - 15] << (
                                                                32 - 18)))) ^ (
           (W[20 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[20 - 16];
  temp1 = (((D + (((((A & (unsigned long)0xFFFFFFFF) >> 6) | (A << (32 - 6))) ^ (
                   ((A & (unsigned long)0xFFFFFFFF) >> 11) | (A << (32 - 11)))) ^ (
                  ((A & (unsigned long)0xFFFFFFFF) >> 25) | (A << (32 - 25))))) + (
            C ^ (A & (B ^ C)))) + (unsigned long)0x2DE92C6F) + W[20];
  temp2 = (((((E & (unsigned long)0xFFFFFFFF) >> 2) | (E << (32 - 2))) ^ (
            ((E & (unsigned long)0xFFFFFFFF) >> 13) | (E << (32 - 13)))) ^ (
           ((E & (unsigned long)0xFFFFFFFF) >> 22) | (E << (32 - 22)))) + (
          (E & F) | (G & (E | F)));
  H += temp1;
  D = temp1 + temp2;
  W[21] = (((((((W[21 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[21 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[21 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[21 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[21 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[21 - 7]) + (
           ((((W[21 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[21 - 15] << (
                                                                32 - 7))) ^ (
            ((W[21 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[21 - 15] << (
                                                                32 - 18)))) ^ (
           (W[21 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[21 - 16];
  temp1 = (((C + (((((H & (unsigned long)0xFFFFFFFF) >> 6) | (H << (32 - 6))) ^ (
                   ((H & (unsigned long)0xFFFFFFFF) >> 11) | (H << (32 - 11)))) ^ (
                  ((H & (unsigned long)0xFFFFFFFF) >> 25) | (H << (32 - 25))))) + (
            B ^ (H & (A ^ B)))) + (unsigned long)0x4A7484AA) + W[21];
  temp2 = (((((D & (unsigned long)0xFFFFFFFF) >> 2) | (D << (32 - 2))) ^ (
            ((D & (unsigned long)0xFFFFFFFF) >> 13) | (D << (32 - 13)))) ^ (
           ((D & (unsigned long)0xFFFFFFFF) >> 22) | (D << (32 - 22)))) + (
          (D & E) | (F & (D | E)));
  G += temp1;
  C = temp1 + temp2;
  W[22] = (((((((W[22 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[22 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[22 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[22 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[22 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[22 - 7]) + (
           ((((W[22 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[22 - 15] << (
                                                                32 - 7))) ^ (
            ((W[22 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[22 - 15] << (
                                                                32 - 18)))) ^ (
           (W[22 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[22 - 16];
  temp1 = (((B + (((((G & (unsigned long)0xFFFFFFFF) >> 6) | (G << (32 - 6))) ^ (
                   ((G & (unsigned long)0xFFFFFFFF) >> 11) | (G << (32 - 11)))) ^ (
                  ((G & (unsigned long)0xFFFFFFFF) >> 25) | (G << (32 - 25))))) + (
            A ^ (G & (H ^ A)))) + (unsigned long)0x5CB0A9DC) + W[22];
  temp2 = (((((C & (unsigned long)0xFFFFFFFF) >> 2) | (C << (32 - 2))) ^ (
            ((C & (unsigned long)0xFFFFFFFF) >> 13) | (C << (32 - 13)))) ^ (
           ((C & (unsigned long)0xFFFFFFFF) >> 22) | (C << (32 - 22)))) + (
          (C & D) | (E & (C | D)));
  F += temp1;
  B = temp1 + temp2;
  W[23] = (((((((W[23 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[23 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[23 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[23 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[23 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[23 - 7]) + (
           ((((W[23 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[23 - 15] << (
                                                                32 - 7))) ^ (
            ((W[23 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[23 - 15] << (
                                                                32 - 18)))) ^ (
           (W[23 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[23 - 16];
  temp1 = (((A + (((((F & (unsigned long)0xFFFFFFFF) >> 6) | (F << (32 - 6))) ^ (
                   ((F & (unsigned long)0xFFFFFFFF) >> 11) | (F << (32 - 11)))) ^ (
                  ((F & (unsigned long)0xFFFFFFFF) >> 25) | (F << (32 - 25))))) + (
            H ^ (F & (G ^ H)))) + (unsigned long)0x76F988DA) + W[23];
  temp2 = (((((B & (unsigned long)0xFFFFFFFF) >> 2) | (B << (32 - 2))) ^ (
            ((B & (unsigned long)0xFFFFFFFF) >> 13) | (B << (32 - 13)))) ^ (
           ((B & (unsigned long)0xFFFFFFFF) >> 22) | (B << (32 - 22)))) + (
          (B & C) | (D & (B | C)));
  E += temp1;
  A = temp1 + temp2;
  W[24] = (((((((W[24 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[24 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[24 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[24 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[24 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[24 - 7]) + (
           ((((W[24 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[24 - 15] << (
                                                                32 - 7))) ^ (
            ((W[24 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[24 - 15] << (
                                                                32 - 18)))) ^ (
           (W[24 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[24 - 16];
  temp1 = (((H + (((((E & (unsigned long)0xFFFFFFFF) >> 6) | (E << (32 - 6))) ^ (
                   ((E & (unsigned long)0xFFFFFFFF) >> 11) | (E << (32 - 11)))) ^ (
                  ((E & (unsigned long)0xFFFFFFFF) >> 25) | (E << (32 - 25))))) + (
            G ^ (E & (F ^ G)))) + (unsigned long)0x983E5152) + W[24];
  temp2 = (((((A & (unsigned long)0xFFFFFFFF) >> 2) | (A << (32 - 2))) ^ (
            ((A & (unsigned long)0xFFFFFFFF) >> 13) | (A << (32 - 13)))) ^ (
           ((A & (unsigned long)0xFFFFFFFF) >> 22) | (A << (32 - 22)))) + (
          (A & B) | (C & (A | B)));
  D += temp1;
  H = temp1 + temp2;
  W[25] = (((((((W[25 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[25 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[25 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[25 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[25 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[25 - 7]) + (
           ((((W[25 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[25 - 15] << (
                                                                32 - 7))) ^ (
            ((W[25 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[25 - 15] << (
                                                                32 - 18)))) ^ (
           (W[25 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[25 - 16];
  temp1 = (((G + (((((D & (unsigned long)0xFFFFFFFF) >> 6) | (D << (32 - 6))) ^ (
                   ((D & (unsigned long)0xFFFFFFFF) >> 11) | (D << (32 - 11)))) ^ (
                  ((D & (unsigned long)0xFFFFFFFF) >> 25) | (D << (32 - 25))))) + (
            F ^ (D & (E ^ F)))) + (unsigned long)0xA831C66D) + W[25];
  temp2 = (((((H & (unsigned long)0xFFFFFFFF) >> 2) | (H << (32 - 2))) ^ (
            ((H & (unsigned long)0xFFFFFFFF) >> 13) | (H << (32 - 13)))) ^ (
           ((H & (unsigned long)0xFFFFFFFF) >> 22) | (H << (32 - 22)))) + (
          (H & A) | (B & (H | A)));
  C += temp1;
  G = temp1 + temp2;
  W[26] = (((((((W[26 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[26 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[26 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[26 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[26 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[26 - 7]) + (
           ((((W[26 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[26 - 15] << (
                                                                32 - 7))) ^ (
            ((W[26 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[26 - 15] << (
                                                                32 - 18)))) ^ (
           (W[26 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[26 - 16];
  temp1 = (((F + (((((C & (unsigned long)0xFFFFFFFF) >> 6) | (C << (32 - 6))) ^ (
                   ((C & (unsigned long)0xFFFFFFFF) >> 11) | (C << (32 - 11)))) ^ (
                  ((C & (unsigned long)0xFFFFFFFF) >> 25) | (C << (32 - 25))))) + (
            E ^ (C & (D ^ E)))) + (unsigned long)0xB00327C8) + W[26];
  temp2 = (((((G & (unsigned long)0xFFFFFFFF) >> 2) | (G << (32 - 2))) ^ (
            ((G & (unsigned long)0xFFFFFFFF) >> 13) | (G << (32 - 13)))) ^ (
           ((G & (unsigned long)0xFFFFFFFF) >> 22) | (G << (32 - 22)))) + (
          (G & H) | (A & (G | H)));
  B += temp1;
  F = temp1 + temp2;
  W[27] = (((((((W[27 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[27 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[27 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[27 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[27 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[27 - 7]) + (
           ((((W[27 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[27 - 15] << (
                                                                32 - 7))) ^ (
            ((W[27 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[27 - 15] << (
                                                                32 - 18)))) ^ (
           (W[27 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[27 - 16];
  temp1 = (((E + (((((B & (unsigned long)0xFFFFFFFF) >> 6) | (B << (32 - 6))) ^ (
                   ((B & (unsigned long)0xFFFFFFFF) >> 11) | (B << (32 - 11)))) ^ (
                  ((B & (unsigned long)0xFFFFFFFF) >> 25) | (B << (32 - 25))))) + (
            D ^ (B & (C ^ D)))) + (unsigned long)0xBF597FC7) + W[27];
  temp2 = (((((F & (unsigned long)0xFFFFFFFF) >> 2) | (F << (32 - 2))) ^ (
            ((F & (unsigned long)0xFFFFFFFF) >> 13) | (F << (32 - 13)))) ^ (
           ((F & (unsigned long)0xFFFFFFFF) >> 22) | (F << (32 - 22)))) + (
          (F & G) | (H & (F | G)));
  A += temp1;
  E = temp1 + temp2;
  W[28] = (((((((W[28 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[28 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[28 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[28 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[28 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[28 - 7]) + (
           ((((W[28 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[28 - 15] << (
                                                                32 - 7))) ^ (
            ((W[28 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[28 - 15] << (
                                                                32 - 18)))) ^ (
           (W[28 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[28 - 16];
  temp1 = (((D + (((((A & (unsigned long)0xFFFFFFFF) >> 6) | (A << (32 - 6))) ^ (
                   ((A & (unsigned long)0xFFFFFFFF) >> 11) | (A << (32 - 11)))) ^ (
                  ((A & (unsigned long)0xFFFFFFFF) >> 25) | (A << (32 - 25))))) + (
            C ^ (A & (B ^ C)))) + (unsigned long)0xC6E00BF3) + W[28];
  temp2 = (((((E & (unsigned long)0xFFFFFFFF) >> 2) | (E << (32 - 2))) ^ (
            ((E & (unsigned long)0xFFFFFFFF) >> 13) | (E << (32 - 13)))) ^ (
           ((E & (unsigned long)0xFFFFFFFF) >> 22) | (E << (32 - 22)))) + (
          (E & F) | (G & (E | F)));
  H += temp1;
  D = temp1 + temp2;
  W[29] = (((((((W[29 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[29 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[29 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[29 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[29 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[29 - 7]) + (
           ((((W[29 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[29 - 15] << (
                                                                32 - 7))) ^ (
            ((W[29 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[29 - 15] << (
                                                                32 - 18)))) ^ (
           (W[29 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[29 - 16];
  temp1 = (((C + (((((H & (unsigned long)0xFFFFFFFF) >> 6) | (H << (32 - 6))) ^ (
                   ((H & (unsigned long)0xFFFFFFFF) >> 11) | (H << (32 - 11)))) ^ (
                  ((H & (unsigned long)0xFFFFFFFF) >> 25) | (H << (32 - 25))))) + (
            B ^ (H & (A ^ B)))) + (unsigned long)0xD5A79147) + W[29];
  temp2 = (((((D & (unsigned long)0xFFFFFFFF) >> 2) | (D << (32 - 2))) ^ (
            ((D & (unsigned long)0xFFFFFFFF) >> 13) | (D << (32 - 13)))) ^ (
           ((D & (unsigned long)0xFFFFFFFF) >> 22) | (D << (32 - 22)))) + (
          (D & E) | (F & (D | E)));
  G += temp1;
  C = temp1 + temp2;
  W[30] = (((((((W[30 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[30 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[30 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[30 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[30 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[30 - 7]) + (
           ((((W[30 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[30 - 15] << (
                                                                32 - 7))) ^ (
            ((W[30 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[30 - 15] << (
                                                                32 - 18)))) ^ (
           (W[30 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[30 - 16];
  temp1 = (((B + (((((G & (unsigned long)0xFFFFFFFF) >> 6) | (G << (32 - 6))) ^ (
                   ((G & (unsigned long)0xFFFFFFFF) >> 11) | (G << (32 - 11)))) ^ (
                  ((G & (unsigned long)0xFFFFFFFF) >> 25) | (G << (32 - 25))))) + (
            A ^ (G & (H ^ A)))) + (unsigned long)0x06CA6351) + W[30];
  temp2 = (((((C & (unsigned long)0xFFFFFFFF) >> 2) | (C << (32 - 2))) ^ (
            ((C & (unsigned long)0xFFFFFFFF) >> 13) | (C << (32 - 13)))) ^ (
           ((C & (unsigned long)0xFFFFFFFF) >> 22) | (C << (32 - 22)))) + (
          (C & D) | (E & (C | D)));
  F += temp1;
  B = temp1 + temp2;
  W[31] = (((((((W[31 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[31 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[31 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[31 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[31 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[31 - 7]) + (
           ((((W[31 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[31 - 15] << (
                                                                32 - 7))) ^ (
            ((W[31 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[31 - 15] << (
                                                                32 - 18)))) ^ (
           (W[31 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[31 - 16];
  temp1 = (((A + (((((F & (unsigned long)0xFFFFFFFF) >> 6) | (F << (32 - 6))) ^ (
                   ((F & (unsigned long)0xFFFFFFFF) >> 11) | (F << (32 - 11)))) ^ (
                  ((F & (unsigned long)0xFFFFFFFF) >> 25) | (F << (32 - 25))))) + (
            H ^ (F & (G ^ H)))) + (unsigned long)0x14292967) + W[31];
  temp2 = (((((B & (unsigned long)0xFFFFFFFF) >> 2) | (B << (32 - 2))) ^ (
            ((B & (unsigned long)0xFFFFFFFF) >> 13) | (B << (32 - 13)))) ^ (
           ((B & (unsigned long)0xFFFFFFFF) >> 22) | (B << (32 - 22)))) + (
          (B & C) | (D & (B | C)));
  E += temp1;
  A = temp1 + temp2;
  W[32] = (((((((W[32 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[32 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[32 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[32 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[32 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[32 - 7]) + (
           ((((W[32 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[32 - 15] << (
                                                                32 - 7))) ^ (
            ((W[32 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[32 - 15] << (
                                                                32 - 18)))) ^ (
           (W[32 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[32 - 16];
  temp1 = (((H + (((((E & (unsigned long)0xFFFFFFFF) >> 6) | (E << (32 - 6))) ^ (
                   ((E & (unsigned long)0xFFFFFFFF) >> 11) | (E << (32 - 11)))) ^ (
                  ((E & (unsigned long)0xFFFFFFFF) >> 25) | (E << (32 - 25))))) + (
            G ^ (E & (F ^ G)))) + (unsigned long)0x27B70A85) + W[32];
  temp2 = (((((A & (unsigned long)0xFFFFFFFF) >> 2) | (A << (32 - 2))) ^ (
            ((A & (unsigned long)0xFFFFFFFF) >> 13) | (A << (32 - 13)))) ^ (
           ((A & (unsigned long)0xFFFFFFFF) >> 22) | (A << (32 - 22)))) + (
          (A & B) | (C & (A | B)));
  D += temp1;
  H = temp1 + temp2;
  W[33] = (((((((W[33 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[33 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[33 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[33 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[33 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[33 - 7]) + (
           ((((W[33 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[33 - 15] << (
                                                                32 - 7))) ^ (
            ((W[33 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[33 - 15] << (
                                                                32 - 18)))) ^ (
           (W[33 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[33 - 16];
  temp1 = (((G + (((((D & (unsigned long)0xFFFFFFFF) >> 6) | (D << (32 - 6))) ^ (
                   ((D & (unsigned long)0xFFFFFFFF) >> 11) | (D << (32 - 11)))) ^ (
                  ((D & (unsigned long)0xFFFFFFFF) >> 25) | (D << (32 - 25))))) + (
            F ^ (D & (E ^ F)))) + (unsigned long)0x2E1B2138) + W[33];
  temp2 = (((((H & (unsigned long)0xFFFFFFFF) >> 2) | (H << (32 - 2))) ^ (
            ((H & (unsigned long)0xFFFFFFFF) >> 13) | (H << (32 - 13)))) ^ (
           ((H & (unsigned long)0xFFFFFFFF) >> 22) | (H << (32 - 22)))) + (
          (H & A) | (B & (H | A)));
  C += temp1;
  G = temp1 + temp2;
  W[34] = (((((((W[34 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[34 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[34 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[34 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[34 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[34 - 7]) + (
           ((((W[34 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[34 - 15] << (
                                                                32 - 7))) ^ (
            ((W[34 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[34 - 15] << (
                                                                32 - 18)))) ^ (
           (W[34 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[34 - 16];
  temp1 = (((F + (((((C & (unsigned long)0xFFFFFFFF) >> 6) | (C << (32 - 6))) ^ (
                   ((C & (unsigned long)0xFFFFFFFF) >> 11) | (C << (32 - 11)))) ^ (
                  ((C & (unsigned long)0xFFFFFFFF) >> 25) | (C << (32 - 25))))) + (
            E ^ (C & (D ^ E)))) + (unsigned long)0x4D2C6DFC) + W[34];
  temp2 = (((((G & (unsigned long)0xFFFFFFFF) >> 2) | (G << (32 - 2))) ^ (
            ((G & (unsigned long)0xFFFFFFFF) >> 13) | (G << (32 - 13)))) ^ (
           ((G & (unsigned long)0xFFFFFFFF) >> 22) | (G << (32 - 22)))) + (
          (G & H) | (A & (G | H)));
  B += temp1;
  F = temp1 + temp2;
  W[35] = (((((((W[35 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[35 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[35 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[35 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[35 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[35 - 7]) + (
           ((((W[35 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[35 - 15] << (
                                                                32 - 7))) ^ (
            ((W[35 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[35 - 15] << (
                                                                32 - 18)))) ^ (
           (W[35 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[35 - 16];
  temp1 = (((E + (((((B & (unsigned long)0xFFFFFFFF) >> 6) | (B << (32 - 6))) ^ (
                   ((B & (unsigned long)0xFFFFFFFF) >> 11) | (B << (32 - 11)))) ^ (
                  ((B & (unsigned long)0xFFFFFFFF) >> 25) | (B << (32 - 25))))) + (
            D ^ (B & (C ^ D)))) + (unsigned long)0x53380D13) + W[35];
  temp2 = (((((F & (unsigned long)0xFFFFFFFF) >> 2) | (F << (32 - 2))) ^ (
            ((F & (unsigned long)0xFFFFFFFF) >> 13) | (F << (32 - 13)))) ^ (
           ((F & (unsigned long)0xFFFFFFFF) >> 22) | (F << (32 - 22)))) + (
          (F & G) | (H & (F | G)));
  A += temp1;
  E = temp1 + temp2;
  W[36] = (((((((W[36 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[36 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[36 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[36 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[36 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[36 - 7]) + (
           ((((W[36 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[36 - 15] << (
                                                                32 - 7))) ^ (
            ((W[36 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[36 - 15] << (
                                                                32 - 18)))) ^ (
           (W[36 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[36 - 16];
  temp1 = (((D + (((((A & (unsigned long)0xFFFFFFFF) >> 6) | (A << (32 - 6))) ^ (
                   ((A & (unsigned long)0xFFFFFFFF) >> 11) | (A << (32 - 11)))) ^ (
                  ((A & (unsigned long)0xFFFFFFFF) >> 25) | (A << (32 - 25))))) + (
            C ^ (A & (B ^ C)))) + (unsigned long)0x650A7354) + W[36];
  temp2 = (((((E & (unsigned long)0xFFFFFFFF) >> 2) | (E << (32 - 2))) ^ (
            ((E & (unsigned long)0xFFFFFFFF) >> 13) | (E << (32 - 13)))) ^ (
           ((E & (unsigned long)0xFFFFFFFF) >> 22) | (E << (32 - 22)))) + (
          (E & F) | (G & (E | F)));
  H += temp1;
  D = temp1 + temp2;
  W[37] = (((((((W[37 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[37 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[37 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[37 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[37 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[37 - 7]) + (
           ((((W[37 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[37 - 15] << (
                                                                32 - 7))) ^ (
            ((W[37 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[37 - 15] << (
                                                                32 - 18)))) ^ (
           (W[37 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[37 - 16];
  temp1 = (((C + (((((H & (unsigned long)0xFFFFFFFF) >> 6) | (H << (32 - 6))) ^ (
                   ((H & (unsigned long)0xFFFFFFFF) >> 11) | (H << (32 - 11)))) ^ (
                  ((H & (unsigned long)0xFFFFFFFF) >> 25) | (H << (32 - 25))))) + (
            B ^ (H & (A ^ B)))) + (unsigned long)0x766A0ABB) + W[37];
  temp2 = (((((D & (unsigned long)0xFFFFFFFF) >> 2) | (D << (32 - 2))) ^ (
            ((D & (unsigned long)0xFFFFFFFF) >> 13) | (D << (32 - 13)))) ^ (
           ((D & (unsigned long)0xFFFFFFFF) >> 22) | (D << (32 - 22)))) + (
          (D & E) | (F & (D | E)));
  G += temp1;
  C = temp1 + temp2;
  W[38] = (((((((W[38 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[38 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[38 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[38 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[38 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[38 - 7]) + (
           ((((W[38 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[38 - 15] << (
                                                                32 - 7))) ^ (
            ((W[38 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[38 - 15] << (
                                                                32 - 18)))) ^ (
           (W[38 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[38 - 16];
  temp1 = (((B + (((((G & (unsigned long)0xFFFFFFFF) >> 6) | (G << (32 - 6))) ^ (
                   ((G & (unsigned long)0xFFFFFFFF) >> 11) | (G << (32 - 11)))) ^ (
                  ((G & (unsigned long)0xFFFFFFFF) >> 25) | (G << (32 - 25))))) + (
            A ^ (G & (H ^ A)))) + (unsigned long)0x81C2C92E) + W[38];
  temp2 = (((((C & (unsigned long)0xFFFFFFFF) >> 2) | (C << (32 - 2))) ^ (
            ((C & (unsigned long)0xFFFFFFFF) >> 13) | (C << (32 - 13)))) ^ (
           ((C & (unsigned long)0xFFFFFFFF) >> 22) | (C << (32 - 22)))) + (
          (C & D) | (E & (C | D)));
  F += temp1;
  B = temp1 + temp2;
  W[39] = (((((((W[39 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[39 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[39 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[39 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[39 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[39 - 7]) + (
           ((((W[39 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[39 - 15] << (
                                                                32 - 7))) ^ (
            ((W[39 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[39 - 15] << (
                                                                32 - 18)))) ^ (
           (W[39 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[39 - 16];
  temp1 = (((A + (((((F & (unsigned long)0xFFFFFFFF) >> 6) | (F << (32 - 6))) ^ (
                   ((F & (unsigned long)0xFFFFFFFF) >> 11) | (F << (32 - 11)))) ^ (
                  ((F & (unsigned long)0xFFFFFFFF) >> 25) | (F << (32 - 25))))) + (
            H ^ (F & (G ^ H)))) + (unsigned long)0x92722C85) + W[39];
  temp2 = (((((B & (unsigned long)0xFFFFFFFF) >> 2) | (B << (32 - 2))) ^ (
            ((B & (unsigned long)0xFFFFFFFF) >> 13) | (B << (32 - 13)))) ^ (
           ((B & (unsigned long)0xFFFFFFFF) >> 22) | (B << (32 - 22)))) + (
          (B & C) | (D & (B | C)));
  E += temp1;
  A = temp1 + temp2;
  W[40] = (((((((W[40 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[40 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[40 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[40 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[40 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[40 - 7]) + (
           ((((W[40 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[40 - 15] << (
                                                                32 - 7))) ^ (
            ((W[40 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[40 - 15] << (
                                                                32 - 18)))) ^ (
           (W[40 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[40 - 16];
  temp1 = (((H + (((((E & (unsigned long)0xFFFFFFFF) >> 6) | (E << (32 - 6))) ^ (
                   ((E & (unsigned long)0xFFFFFFFF) >> 11) | (E << (32 - 11)))) ^ (
                  ((E & (unsigned long)0xFFFFFFFF) >> 25) | (E << (32 - 25))))) + (
            G ^ (E & (F ^ G)))) + (unsigned long)0xA2BFE8A1) + W[40];
  temp2 = (((((A & (unsigned long)0xFFFFFFFF) >> 2) | (A << (32 - 2))) ^ (
            ((A & (unsigned long)0xFFFFFFFF) >> 13) | (A << (32 - 13)))) ^ (
           ((A & (unsigned long)0xFFFFFFFF) >> 22) | (A << (32 - 22)))) + (
          (A & B) | (C & (A | B)));
  D += temp1;
  H = temp1 + temp2;
  W[41] = (((((((W[41 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[41 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[41 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[41 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[41 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[41 - 7]) + (
           ((((W[41 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[41 - 15] << (
                                                                32 - 7))) ^ (
            ((W[41 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[41 - 15] << (
                                                                32 - 18)))) ^ (
           (W[41 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[41 - 16];
  temp1 = (((G + (((((D & (unsigned long)0xFFFFFFFF) >> 6) | (D << (32 - 6))) ^ (
                   ((D & (unsigned long)0xFFFFFFFF) >> 11) | (D << (32 - 11)))) ^ (
                  ((D & (unsigned long)0xFFFFFFFF) >> 25) | (D << (32 - 25))))) + (
            F ^ (D & (E ^ F)))) + (unsigned long)0xA81A664B) + W[41];
  temp2 = (((((H & (unsigned long)0xFFFFFFFF) >> 2) | (H << (32 - 2))) ^ (
            ((H & (unsigned long)0xFFFFFFFF) >> 13) | (H << (32 - 13)))) ^ (
           ((H & (unsigned long)0xFFFFFFFF) >> 22) | (H << (32 - 22)))) + (
          (H & A) | (B & (H | A)));
  C += temp1;
  G = temp1 + temp2;
  W[42] = (((((((W[42 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[42 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[42 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[42 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[42 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[42 - 7]) + (
           ((((W[42 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[42 - 15] << (
                                                                32 - 7))) ^ (
            ((W[42 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[42 - 15] << (
                                                                32 - 18)))) ^ (
           (W[42 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[42 - 16];
  temp1 = (((F + (((((C & (unsigned long)0xFFFFFFFF) >> 6) | (C << (32 - 6))) ^ (
                   ((C & (unsigned long)0xFFFFFFFF) >> 11) | (C << (32 - 11)))) ^ (
                  ((C & (unsigned long)0xFFFFFFFF) >> 25) | (C << (32 - 25))))) + (
            E ^ (C & (D ^ E)))) + (unsigned long)0xC24B8B70) + W[42];
  temp2 = (((((G & (unsigned long)0xFFFFFFFF) >> 2) | (G << (32 - 2))) ^ (
            ((G & (unsigned long)0xFFFFFFFF) >> 13) | (G << (32 - 13)))) ^ (
           ((G & (unsigned long)0xFFFFFFFF) >> 22) | (G << (32 - 22)))) + (
          (G & H) | (A & (G | H)));
  B += temp1;
  F = temp1 + temp2;
  W[43] = (((((((W[43 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[43 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[43 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[43 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[43 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[43 - 7]) + (
           ((((W[43 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[43 - 15] << (
                                                                32 - 7))) ^ (
            ((W[43 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[43 - 15] << (
                                                                32 - 18)))) ^ (
           (W[43 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[43 - 16];
  temp1 = (((E + (((((B & (unsigned long)0xFFFFFFFF) >> 6) | (B << (32 - 6))) ^ (
                   ((B & (unsigned long)0xFFFFFFFF) >> 11) | (B << (32 - 11)))) ^ (
                  ((B & (unsigned long)0xFFFFFFFF) >> 25) | (B << (32 - 25))))) + (
            D ^ (B & (C ^ D)))) + (unsigned long)0xC76C51A3) + W[43];
  temp2 = (((((F & (unsigned long)0xFFFFFFFF) >> 2) | (F << (32 - 2))) ^ (
            ((F & (unsigned long)0xFFFFFFFF) >> 13) | (F << (32 - 13)))) ^ (
           ((F & (unsigned long)0xFFFFFFFF) >> 22) | (F << (32 - 22)))) + (
          (F & G) | (H & (F | G)));
  A += temp1;
  E = temp1 + temp2;
  W[44] = (((((((W[44 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[44 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[44 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[44 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[44 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[44 - 7]) + (
           ((((W[44 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[44 - 15] << (
                                                                32 - 7))) ^ (
            ((W[44 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[44 - 15] << (
                                                                32 - 18)))) ^ (
           (W[44 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[44 - 16];
  temp1 = (((D + (((((A & (unsigned long)0xFFFFFFFF) >> 6) | (A << (32 - 6))) ^ (
                   ((A & (unsigned long)0xFFFFFFFF) >> 11) | (A << (32 - 11)))) ^ (
                  ((A & (unsigned long)0xFFFFFFFF) >> 25) | (A << (32 - 25))))) + (
            C ^ (A & (B ^ C)))) + (unsigned long)0xD192E819) + W[44];
  temp2 = (((((E & (unsigned long)0xFFFFFFFF) >> 2) | (E << (32 - 2))) ^ (
            ((E & (unsigned long)0xFFFFFFFF) >> 13) | (E << (32 - 13)))) ^ (
           ((E & (unsigned long)0xFFFFFFFF) >> 22) | (E << (32 - 22)))) + (
          (E & F) | (G & (E | F)));
  H += temp1;
  D = temp1 + temp2;
  W[45] = (((((((W[45 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[45 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[45 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[45 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[45 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[45 - 7]) + (
           ((((W[45 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[45 - 15] << (
                                                                32 - 7))) ^ (
            ((W[45 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[45 - 15] << (
                                                                32 - 18)))) ^ (
           (W[45 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[45 - 16];
  temp1 = (((C + (((((H & (unsigned long)0xFFFFFFFF) >> 6) | (H << (32 - 6))) ^ (
                   ((H & (unsigned long)0xFFFFFFFF) >> 11) | (H << (32 - 11)))) ^ (
                  ((H & (unsigned long)0xFFFFFFFF) >> 25) | (H << (32 - 25))))) + (
            B ^ (H & (A ^ B)))) + (unsigned long)0xD6990624) + W[45];
  temp2 = (((((D & (unsigned long)0xFFFFFFFF) >> 2) | (D << (32 - 2))) ^ (
            ((D & (unsigned long)0xFFFFFFFF) >> 13) | (D << (32 - 13)))) ^ (
           ((D & (unsigned long)0xFFFFFFFF) >> 22) | (D << (32 - 22)))) + (
          (D & E) | (F & (D | E)));
  G += temp1;
  C = temp1 + temp2;
  W[46] = (((((((W[46 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[46 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[46 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[46 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[46 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[46 - 7]) + (
           ((((W[46 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[46 - 15] << (
                                                                32 - 7))) ^ (
            ((W[46 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[46 - 15] << (
                                                                32 - 18)))) ^ (
           (W[46 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[46 - 16];
  temp1 = (((B + (((((G & (unsigned long)0xFFFFFFFF) >> 6) | (G << (32 - 6))) ^ (
                   ((G & (unsigned long)0xFFFFFFFF) >> 11) | (G << (32 - 11)))) ^ (
                  ((G & (unsigned long)0xFFFFFFFF) >> 25) | (G << (32 - 25))))) + (
            A ^ (G & (H ^ A)))) + (unsigned long)0xF40E3585) + W[46];
  temp2 = (((((C & (unsigned long)0xFFFFFFFF) >> 2) | (C << (32 - 2))) ^ (
            ((C & (unsigned long)0xFFFFFFFF) >> 13) | (C << (32 - 13)))) ^ (
           ((C & (unsigned long)0xFFFFFFFF) >> 22) | (C << (32 - 22)))) + (
          (C & D) | (E & (C | D)));
  F += temp1;
  B = temp1 + temp2;
  W[47] = (((((((W[47 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[47 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[47 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[47 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[47 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[47 - 7]) + (
           ((((W[47 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[47 - 15] << (
                                                                32 - 7))) ^ (
            ((W[47 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[47 - 15] << (
                                                                32 - 18)))) ^ (
           (W[47 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[47 - 16];
  temp1 = (((A + (((((F & (unsigned long)0xFFFFFFFF) >> 6) | (F << (32 - 6))) ^ (
                   ((F & (unsigned long)0xFFFFFFFF) >> 11) | (F << (32 - 11)))) ^ (
                  ((F & (unsigned long)0xFFFFFFFF) >> 25) | (F << (32 - 25))))) + (
            H ^ (F & (G ^ H)))) + (unsigned long)0x106AA070) + W[47];
  temp2 = (((((B & (unsigned long)0xFFFFFFFF) >> 2) | (B << (32 - 2))) ^ (
            ((B & (unsigned long)0xFFFFFFFF) >> 13) | (B << (32 - 13)))) ^ (
           ((B & (unsigned long)0xFFFFFFFF) >> 22) | (B << (32 - 22)))) + (
          (B & C) | (D & (B | C)));
  E += temp1;
  A = temp1 + temp2;
  W[48] = (((((((W[48 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[48 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[48 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[48 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[48 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[48 - 7]) + (
           ((((W[48 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[48 - 15] << (
                                                                32 - 7))) ^ (
            ((W[48 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[48 - 15] << (
                                                                32 - 18)))) ^ (
           (W[48 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[48 - 16];
  temp1 = (((H + (((((E & (unsigned long)0xFFFFFFFF) >> 6) | (E << (32 - 6))) ^ (
                   ((E & (unsigned long)0xFFFFFFFF) >> 11) | (E << (32 - 11)))) ^ (
                  ((E & (unsigned long)0xFFFFFFFF) >> 25) | (E << (32 - 25))))) + (
            G ^ (E & (F ^ G)))) + (unsigned long)0x19A4C116) + W[48];
  temp2 = (((((A & (unsigned long)0xFFFFFFFF) >> 2) | (A << (32 - 2))) ^ (
            ((A & (unsigned long)0xFFFFFFFF) >> 13) | (A << (32 - 13)))) ^ (
           ((A & (unsigned long)0xFFFFFFFF) >> 22) | (A << (32 - 22)))) + (
          (A & B) | (C & (A | B)));
  D += temp1;
  H = temp1 + temp2;
  W[49] = (((((((W[49 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[49 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[49 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[49 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[49 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[49 - 7]) + (
           ((((W[49 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[49 - 15] << (
                                                                32 - 7))) ^ (
            ((W[49 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[49 - 15] << (
                                                                32 - 18)))) ^ (
           (W[49 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[49 - 16];
  temp1 = (((G + (((((D & (unsigned long)0xFFFFFFFF) >> 6) | (D << (32 - 6))) ^ (
                   ((D & (unsigned long)0xFFFFFFFF) >> 11) | (D << (32 - 11)))) ^ (
                  ((D & (unsigned long)0xFFFFFFFF) >> 25) | (D << (32 - 25))))) + (
            F ^ (D & (E ^ F)))) + (unsigned long)0x1E376C08) + W[49];
  temp2 = (((((H & (unsigned long)0xFFFFFFFF) >> 2) | (H << (32 - 2))) ^ (
            ((H & (unsigned long)0xFFFFFFFF) >> 13) | (H << (32 - 13)))) ^ (
           ((H & (unsigned long)0xFFFFFFFF) >> 22) | (H << (32 - 22)))) + (
          (H & A) | (B & (H | A)));
  C += temp1;
  G = temp1 + temp2;
  W[50] = (((((((W[50 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[50 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[50 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[50 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[50 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[50 - 7]) + (
           ((((W[50 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[50 - 15] << (
                                                                32 - 7))) ^ (
            ((W[50 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[50 - 15] << (
                                                                32 - 18)))) ^ (
           (W[50 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[50 - 16];
  temp1 = (((F + (((((C & (unsigned long)0xFFFFFFFF) >> 6) | (C << (32 - 6))) ^ (
                   ((C & (unsigned long)0xFFFFFFFF) >> 11) | (C << (32 - 11)))) ^ (
                  ((C & (unsigned long)0xFFFFFFFF) >> 25) | (C << (32 - 25))))) + (
            E ^ (C & (D ^ E)))) + (unsigned long)0x2748774C) + W[50];
  temp2 = (((((G & (unsigned long)0xFFFFFFFF) >> 2) | (G << (32 - 2))) ^ (
            ((G & (unsigned long)0xFFFFFFFF) >> 13) | (G << (32 - 13)))) ^ (
           ((G & (unsigned long)0xFFFFFFFF) >> 22) | (G << (32 - 22)))) + (
          (G & H) | (A & (G | H)));
  B += temp1;
  F = temp1 + temp2;
  W[51] = (((((((W[51 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[51 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[51 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[51 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[51 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[51 - 7]) + (
           ((((W[51 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[51 - 15] << (
                                                                32 - 7))) ^ (
            ((W[51 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[51 - 15] << (
                                                                32 - 18)))) ^ (
           (W[51 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[51 - 16];
  temp1 = (((E + (((((B & (unsigned long)0xFFFFFFFF) >> 6) | (B << (32 - 6))) ^ (
                   ((B & (unsigned long)0xFFFFFFFF) >> 11) | (B << (32 - 11)))) ^ (
                  ((B & (unsigned long)0xFFFFFFFF) >> 25) | (B << (32 - 25))))) + (
            D ^ (B & (C ^ D)))) + (unsigned long)0x34B0BCB5) + W[51];
  temp2 = (((((F & (unsigned long)0xFFFFFFFF) >> 2) | (F << (32 - 2))) ^ (
            ((F & (unsigned long)0xFFFFFFFF) >> 13) | (F << (32 - 13)))) ^ (
           ((F & (unsigned long)0xFFFFFFFF) >> 22) | (F << (32 - 22)))) + (
          (F & G) | (H & (F | G)));
  A += temp1;
  E = temp1 + temp2;
  W[52] = (((((((W[52 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[52 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[52 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[52 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[52 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[52 - 7]) + (
           ((((W[52 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[52 - 15] << (
                                                                32 - 7))) ^ (
            ((W[52 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[52 - 15] << (
                                                                32 - 18)))) ^ (
           (W[52 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[52 - 16];
  temp1 = (((D + (((((A & (unsigned long)0xFFFFFFFF) >> 6) | (A << (32 - 6))) ^ (
                   ((A & (unsigned long)0xFFFFFFFF) >> 11) | (A << (32 - 11)))) ^ (
                  ((A & (unsigned long)0xFFFFFFFF) >> 25) | (A << (32 - 25))))) + (
            C ^ (A & (B ^ C)))) + (unsigned long)0x391C0CB3) + W[52];
  temp2 = (((((E & (unsigned long)0xFFFFFFFF) >> 2) | (E << (32 - 2))) ^ (
            ((E & (unsigned long)0xFFFFFFFF) >> 13) | (E << (32 - 13)))) ^ (
           ((E & (unsigned long)0xFFFFFFFF) >> 22) | (E << (32 - 22)))) + (
          (E & F) | (G & (E | F)));
  H += temp1;
  D = temp1 + temp2;
  W[53] = (((((((W[53 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[53 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[53 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[53 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[53 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[53 - 7]) + (
           ((((W[53 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[53 - 15] << (
                                                                32 - 7))) ^ (
            ((W[53 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[53 - 15] << (
                                                                32 - 18)))) ^ (
           (W[53 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[53 - 16];
  temp1 = (((C + (((((H & (unsigned long)0xFFFFFFFF) >> 6) | (H << (32 - 6))) ^ (
                   ((H & (unsigned long)0xFFFFFFFF) >> 11) | (H << (32 - 11)))) ^ (
                  ((H & (unsigned long)0xFFFFFFFF) >> 25) | (H << (32 - 25))))) + (
            B ^ (H & (A ^ B)))) + (unsigned long)0x4ED8AA4A) + W[53];
  temp2 = (((((D & (unsigned long)0xFFFFFFFF) >> 2) | (D << (32 - 2))) ^ (
            ((D & (unsigned long)0xFFFFFFFF) >> 13) | (D << (32 - 13)))) ^ (
           ((D & (unsigned long)0xFFFFFFFF) >> 22) | (D << (32 - 22)))) + (
          (D & E) | (F & (D | E)));
  G += temp1;
  C = temp1 + temp2;
  W[54] = (((((((W[54 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[54 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[54 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[54 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[54 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[54 - 7]) + (
           ((((W[54 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[54 - 15] << (
                                                                32 - 7))) ^ (
            ((W[54 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[54 - 15] << (
                                                                32 - 18)))) ^ (
           (W[54 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[54 - 16];
  temp1 = (((B + (((((G & (unsigned long)0xFFFFFFFF) >> 6) | (G << (32 - 6))) ^ (
                   ((G & (unsigned long)0xFFFFFFFF) >> 11) | (G << (32 - 11)))) ^ (
                  ((G & (unsigned long)0xFFFFFFFF) >> 25) | (G << (32 - 25))))) + (
            A ^ (G & (H ^ A)))) + (unsigned long)0x5B9CCA4F) + W[54];
  temp2 = (((((C & (unsigned long)0xFFFFFFFF) >> 2) | (C << (32 - 2))) ^ (
            ((C & (unsigned long)0xFFFFFFFF) >> 13) | (C << (32 - 13)))) ^ (
           ((C & (unsigned long)0xFFFFFFFF) >> 22) | (C << (32 - 22)))) + (
          (C & D) | (E & (C | D)));
  F += temp1;
  B = temp1 + temp2;
  W[55] = (((((((W[55 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[55 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[55 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[55 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[55 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[55 - 7]) + (
           ((((W[55 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[55 - 15] << (
                                                                32 - 7))) ^ (
            ((W[55 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[55 - 15] << (
                                                                32 - 18)))) ^ (
           (W[55 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[55 - 16];
  temp1 = (((A + (((((F & (unsigned long)0xFFFFFFFF) >> 6) | (F << (32 - 6))) ^ (
                   ((F & (unsigned long)0xFFFFFFFF) >> 11) | (F << (32 - 11)))) ^ (
                  ((F & (unsigned long)0xFFFFFFFF) >> 25) | (F << (32 - 25))))) + (
            H ^ (F & (G ^ H)))) + (unsigned long)0x682E6FF3) + W[55];
  temp2 = (((((B & (unsigned long)0xFFFFFFFF) >> 2) | (B << (32 - 2))) ^ (
            ((B & (unsigned long)0xFFFFFFFF) >> 13) | (B << (32 - 13)))) ^ (
           ((B & (unsigned long)0xFFFFFFFF) >> 22) | (B << (32 - 22)))) + (
          (B & C) | (D & (B | C)));
  E += temp1;
  A = temp1 + temp2;
  W[56] = (((((((W[56 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[56 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[56 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[56 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[56 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[56 - 7]) + (
           ((((W[56 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[56 - 15] << (
                                                                32 - 7))) ^ (
            ((W[56 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[56 - 15] << (
                                                                32 - 18)))) ^ (
           (W[56 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[56 - 16];
  temp1 = (((H + (((((E & (unsigned long)0xFFFFFFFF) >> 6) | (E << (32 - 6))) ^ (
                   ((E & (unsigned long)0xFFFFFFFF) >> 11) | (E << (32 - 11)))) ^ (
                  ((E & (unsigned long)0xFFFFFFFF) >> 25) | (E << (32 - 25))))) + (
            G ^ (E & (F ^ G)))) + (unsigned long)0x748F82EE) + W[56];
  temp2 = (((((A & (unsigned long)0xFFFFFFFF) >> 2) | (A << (32 - 2))) ^ (
            ((A & (unsigned long)0xFFFFFFFF) >> 13) | (A << (32 - 13)))) ^ (
           ((A & (unsigned long)0xFFFFFFFF) >> 22) | (A << (32 - 22)))) + (
          (A & B) | (C & (A | B)));
  D += temp1;
  H = temp1 + temp2;
  W[57] = (((((((W[57 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[57 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[57 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[57 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[57 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[57 - 7]) + (
           ((((W[57 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[57 - 15] << (
                                                                32 - 7))) ^ (
            ((W[57 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[57 - 15] << (
                                                                32 - 18)))) ^ (
           (W[57 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[57 - 16];
  temp1 = (((G + (((((D & (unsigned long)0xFFFFFFFF) >> 6) | (D << (32 - 6))) ^ (
                   ((D & (unsigned long)0xFFFFFFFF) >> 11) | (D << (32 - 11)))) ^ (
                  ((D & (unsigned long)0xFFFFFFFF) >> 25) | (D << (32 - 25))))) + (
            F ^ (D & (E ^ F)))) + (unsigned long)0x78A5636F) + W[57];
  temp2 = (((((H & (unsigned long)0xFFFFFFFF) >> 2) | (H << (32 - 2))) ^ (
            ((H & (unsigned long)0xFFFFFFFF) >> 13) | (H << (32 - 13)))) ^ (
           ((H & (unsigned long)0xFFFFFFFF) >> 22) | (H << (32 - 22)))) + (
          (H & A) | (B & (H | A)));
  C += temp1;
  G = temp1 + temp2;
  W[58] = (((((((W[58 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[58 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[58 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[58 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[58 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[58 - 7]) + (
           ((((W[58 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[58 - 15] << (
                                                                32 - 7))) ^ (
            ((W[58 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[58 - 15] << (
                                                                32 - 18)))) ^ (
           (W[58 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[58 - 16];
  temp1 = (((F + (((((C & (unsigned long)0xFFFFFFFF) >> 6) | (C << (32 - 6))) ^ (
                   ((C & (unsigned long)0xFFFFFFFF) >> 11) | (C << (32 - 11)))) ^ (
                  ((C & (unsigned long)0xFFFFFFFF) >> 25) | (C << (32 - 25))))) + (
            E ^ (C & (D ^ E)))) + (unsigned long)0x84C87814) + W[58];
  temp2 = (((((G & (unsigned long)0xFFFFFFFF) >> 2) | (G << (32 - 2))) ^ (
            ((G & (unsigned long)0xFFFFFFFF) >> 13) | (G << (32 - 13)))) ^ (
           ((G & (unsigned long)0xFFFFFFFF) >> 22) | (G << (32 - 22)))) + (
          (G & H) | (A & (G | H)));
  B += temp1;
  F = temp1 + temp2;
  W[59] = (((((((W[59 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[59 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[59 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[59 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[59 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[59 - 7]) + (
           ((((W[59 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[59 - 15] << (
                                                                32 - 7))) ^ (
            ((W[59 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[59 - 15] << (
                                                                32 - 18)))) ^ (
           (W[59 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[59 - 16];
  temp1 = (((E + (((((B & (unsigned long)0xFFFFFFFF) >> 6) | (B << (32 - 6))) ^ (
                   ((B & (unsigned long)0xFFFFFFFF) >> 11) | (B << (32 - 11)))) ^ (
                  ((B & (unsigned long)0xFFFFFFFF) >> 25) | (B << (32 - 25))))) + (
            D ^ (B & (C ^ D)))) + (unsigned long)0x8CC70208) + W[59];
  temp2 = (((((F & (unsigned long)0xFFFFFFFF) >> 2) | (F << (32 - 2))) ^ (
            ((F & (unsigned long)0xFFFFFFFF) >> 13) | (F << (32 - 13)))) ^ (
           ((F & (unsigned long)0xFFFFFFFF) >> 22) | (F << (32 - 22)))) + (
          (F & G) | (H & (F | G)));
  A += temp1;
  E = temp1 + temp2;
  W[60] = (((((((W[60 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[60 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[60 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[60 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[60 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[60 - 7]) + (
           ((((W[60 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[60 - 15] << (
                                                                32 - 7))) ^ (
            ((W[60 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[60 - 15] << (
                                                                32 - 18)))) ^ (
           (W[60 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[60 - 16];
  temp1 = (((D + (((((A & (unsigned long)0xFFFFFFFF) >> 6) | (A << (32 - 6))) ^ (
                   ((A & (unsigned long)0xFFFFFFFF) >> 11) | (A << (32 - 11)))) ^ (
                  ((A & (unsigned long)0xFFFFFFFF) >> 25) | (A << (32 - 25))))) + (
            C ^ (A & (B ^ C)))) + (unsigned long)0x90BEFFFA) + W[60];
  temp2 = (((((E & (unsigned long)0xFFFFFFFF) >> 2) | (E << (32 - 2))) ^ (
            ((E & (unsigned long)0xFFFFFFFF) >> 13) | (E << (32 - 13)))) ^ (
           ((E & (unsigned long)0xFFFFFFFF) >> 22) | (E << (32 - 22)))) + (
          (E & F) | (G & (E | F)));
  H += temp1;
  D = temp1 + temp2;
  W[61] = (((((((W[61 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[61 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[61 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[61 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[61 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[61 - 7]) + (
           ((((W[61 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[61 - 15] << (
                                                                32 - 7))) ^ (
            ((W[61 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[61 - 15] << (
                                                                32 - 18)))) ^ (
           (W[61 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[61 - 16];
  temp1 = (((C + (((((H & (unsigned long)0xFFFFFFFF) >> 6) | (H << (32 - 6))) ^ (
                   ((H & (unsigned long)0xFFFFFFFF) >> 11) | (H << (32 - 11)))) ^ (
                  ((H & (unsigned long)0xFFFFFFFF) >> 25) | (H << (32 - 25))))) + (
            B ^ (H & (A ^ B)))) + (unsigned long)0xA4506CEB) + W[61];
  temp2 = (((((D & (unsigned long)0xFFFFFFFF) >> 2) | (D << (32 - 2))) ^ (
            ((D & (unsigned long)0xFFFFFFFF) >> 13) | (D << (32 - 13)))) ^ (
           ((D & (unsigned long)0xFFFFFFFF) >> 22) | (D << (32 - 22)))) + (
          (D & E) | (F & (D | E)));
  G += temp1;
  C = temp1 + temp2;
  W[62] = (((((((W[62 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[62 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[62 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[62 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[62 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[62 - 7]) + (
           ((((W[62 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[62 - 15] << (
                                                                32 - 7))) ^ (
            ((W[62 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[62 - 15] << (
                                                                32 - 18)))) ^ (
           (W[62 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[62 - 16];
  temp1 = (((B + (((((G & (unsigned long)0xFFFFFFFF) >> 6) | (G << (32 - 6))) ^ (
                   ((G & (unsigned long)0xFFFFFFFF) >> 11) | (G << (32 - 11)))) ^ (
                  ((G & (unsigned long)0xFFFFFFFF) >> 25) | (G << (32 - 25))))) + (
            A ^ (G & (H ^ A)))) + (unsigned long)0xBEF9A3F7) + W[62];
  temp2 = (((((C & (unsigned long)0xFFFFFFFF) >> 2) | (C << (32 - 2))) ^ (
            ((C & (unsigned long)0xFFFFFFFF) >> 13) | (C << (32 - 13)))) ^ (
           ((C & (unsigned long)0xFFFFFFFF) >> 22) | (C << (32 - 22)))) + (
          (C & D) | (E & (C | D)));
  F += temp1;
  B = temp1 + temp2;
  W[63] = (((((((W[63 - 2] & (unsigned long)0xFFFFFFFF) >> 17) | (W[63 - 2] << (
                                                                  32 - 17))) ^ (
              ((W[63 - 2] & (unsigned long)0xFFFFFFFF) >> 19) | (W[63 - 2] << (
                                                                 32 - 19)))) ^ (
             (W[63 - 2] & (unsigned long)0xFFFFFFFF) >> 10)) + W[63 - 7]) + (
           ((((W[63 - 15] & (unsigned long)0xFFFFFFFF) >> 7) | (W[63 - 15] << (
                                                                32 - 7))) ^ (
            ((W[63 - 15] & (unsigned long)0xFFFFFFFF) >> 18) | (W[63 - 15] << (
                                                                32 - 18)))) ^ (
           (W[63 - 15] & (unsigned long)0xFFFFFFFF) >> 3))) + W[63 - 16];
  temp1 = (((A + (((((F & (unsigned long)0xFFFFFFFF) >> 6) | (F << (32 - 6))) ^ (
                   ((F & (unsigned long)0xFFFFFFFF) >> 11) | (F << (32 - 11)))) ^ (
                  ((F & (unsigned long)0xFFFFFFFF) >> 25) | (F << (32 - 25))))) + (
            H ^ (F & (G ^ H)))) + (unsigned long)0xC67178F2) + W[63];
  temp2 = (((((B & (unsigned long)0xFFFFFFFF) >> 2) | (B << (32 - 2))) ^ (
            ((B & (unsigned long)0xFFFFFFFF) >> 13) | (B << (32 - 13)))) ^ (
           ((B & (unsigned long)0xFFFFFFFF) >> 22) | (B << (32 - 22)))) + (
          (B & C) | (D & (B | C)));
  E += temp1;
  A = temp1 + temp2;
  ctx->state[0] += A;
  ctx->state[1] += B;
  ctx->state[2] += C;
  ctx->state[3] += D;
  ctx->state[4] += E;
  ctx->state[5] += F;
  ctx->state[6] += G;
  ctx->state[7] += H;
  return;
}

void sha2_update(sha2_context *ctx, unsigned char const *input, size_t ilen)
{
  size_t fill;
  unsigned long left;
  if (ilen <= (size_t)0) goto return_label;
  left = ctx->total[0] & (unsigned long)0x3F;
  fill = (size_t)((unsigned long)64 - left);
  ctx->total[0] += (unsigned long)ilen;
  ctx->total[0] &= (unsigned long)0xFFFFFFFF;
  if (ctx->total[0] < (unsigned long)ilen) (ctx->total[1]) ++;
  if (left) 
    if (ilen >= fill) {
      memcpy((void *)(& ctx->buffer[left]),(void const *)input,fill);
      sha2_process(ctx,(unsigned char const *)(ctx->buffer));
      input += fill;
      ilen -= fill;
      left = (unsigned long)0;
    }
  while (ilen >= (size_t)64) {
    sha2_process(ctx,input);
    input += 64;
    ilen -= (size_t)64;
  }
  if (ilen > (size_t)0) memcpy((void *)(& ctx->buffer[left]),
                               (void const *)input,ilen);
  return_label: return;
}

static unsigned char const sha2_padding[64] =
  {(unsigned char)0x80,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0};
void sha2_finish(sha2_context *ctx, unsigned char output[32])
{
  unsigned long last;
  unsigned long padn;
  unsigned long high;
  unsigned long low;
  unsigned char msglen[8];
  high = (ctx->total[0] >> 29) | (ctx->total[1] << 3);
  low = ctx->total[0] << 3;
  msglen[0] = (unsigned char)(high >> 24);
  msglen[0 + 1] = (unsigned char)(high >> 16);
  msglen[0 + 2] = (unsigned char)(high >> 8);
  msglen[0 + 3] = (unsigned char)high;
  msglen[4] = (unsigned char)(low >> 24);
  msglen[4 + 1] = (unsigned char)(low >> 16);
  msglen[4 + 2] = (unsigned char)(low >> 8);
  msglen[4 + 3] = (unsigned char)low;
  last = ctx->total[0] & (unsigned long)0x3F;
  if (last < (unsigned long)56) padn = (unsigned long)56 - last;
  else padn = (unsigned long)120 - last;
  sha2_update(ctx,sha2_padding,(size_t)padn);
  sha2_update(ctx,(unsigned char const *)(msglen),(size_t)8);
  *(output + 0) = (unsigned char)(ctx->state[0] >> 24);
  *(output + (0 + 1)) = (unsigned char)(ctx->state[0] >> 16);
  *(output + (0 + 2)) = (unsigned char)(ctx->state[0] >> 8);
  *(output + (0 + 3)) = (unsigned char)ctx->state[0];
  *(output + 4) = (unsigned char)(ctx->state[1] >> 24);
  *(output + (4 + 1)) = (unsigned char)(ctx->state[1] >> 16);
  *(output + (4 + 2)) = (unsigned char)(ctx->state[1] >> 8);
  *(output + (4 + 3)) = (unsigned char)ctx->state[1];
  *(output + 8) = (unsigned char)(ctx->state[2] >> 24);
  *(output + (8 + 1)) = (unsigned char)(ctx->state[2] >> 16);
  *(output + (8 + 2)) = (unsigned char)(ctx->state[2] >> 8);
  *(output + (8 + 3)) = (unsigned char)ctx->state[2];
  *(output + 12) = (unsigned char)(ctx->state[3] >> 24);
  *(output + (12 + 1)) = (unsigned char)(ctx->state[3] >> 16);
  *(output + (12 + 2)) = (unsigned char)(ctx->state[3] >> 8);
  *(output + (12 + 3)) = (unsigned char)ctx->state[3];
  *(output + 16) = (unsigned char)(ctx->state[4] >> 24);
  *(output + (16 + 1)) = (unsigned char)(ctx->state[4] >> 16);
  *(output + (16 + 2)) = (unsigned char)(ctx->state[4] >> 8);
  *(output + (16 + 3)) = (unsigned char)ctx->state[4];
  *(output + 20) = (unsigned char)(ctx->state[5] >> 24);
  *(output + (20 + 1)) = (unsigned char)(ctx->state[5] >> 16);
  *(output + (20 + 2)) = (unsigned char)(ctx->state[5] >> 8);
  *(output + (20 + 3)) = (unsigned char)ctx->state[5];
  *(output + 24) = (unsigned char)(ctx->state[6] >> 24);
  *(output + (24 + 1)) = (unsigned char)(ctx->state[6] >> 16);
  *(output + (24 + 2)) = (unsigned char)(ctx->state[6] >> 8);
  *(output + (24 + 3)) = (unsigned char)ctx->state[6];
  if (ctx->is224 == 0) {
    *(output + 28) = (unsigned char)(ctx->state[7] >> 24);
    *(output + (28 + 1)) = (unsigned char)(ctx->state[7] >> 16);
    *(output + (28 + 2)) = (unsigned char)(ctx->state[7] >> 8);
    *(output + (28 + 3)) = (unsigned char)ctx->state[7];
  }
  return;
}

void sha2(unsigned char const *input, size_t ilen, unsigned char output[32],
          int is224)
{
  sha2_context ctx;
  sha2_starts(& ctx,is224);
  sha2_update(& ctx,input,ilen);
  sha2_finish(& ctx,output);
  memset((void *)(& ctx),0,sizeof(sha2_context));
  return;
}

int sha2_file(char const *path, unsigned char output[32], int is224)
{
  int __retres;
  FILE *f;
  size_t n;
  sha2_context ctx;
  unsigned char buf[1024];
  int tmp;
  f = fopen(path,"rb");
  if (f == (FILE *)0) {
    __retres = -0x0078;
    goto return_label;
  }
  sha2_starts(& ctx,is224);
  while (1) {
    n = fread((void *)(buf),(size_t)1,sizeof(buf),f);
    if (! (n > (size_t)0)) break;
    sha2_update(& ctx,(unsigned char const *)(buf),n);
  }
  sha2_finish(& ctx,output);
  memset((void *)(& ctx),0,sizeof(sha2_context));
  tmp = ferror(f);
  if (tmp != 0) {
    fclose(f);
    __retres = -0x0078;
    goto return_label;
  }
  fclose(f);
  __retres = 0;
  return_label: return __retres;
}

void sha2_hmac_starts(sha2_context *ctx, unsigned char const *key,
                      size_t keylen, int is224)
{
  size_t i;
  unsigned char sum[32];
  if (keylen > (size_t)64) {
    sha2(key,keylen,sum,is224);
    if (is224) keylen = (size_t)28; else keylen = (size_t)32;
    key = (unsigned char const *)(sum);
  }
  memset((void *)(ctx->ipad),0x36,(size_t)64);
  memset((void *)(ctx->opad),0x5C,(size_t)64);
  i = (size_t)0;
  while (i < keylen) {
    ctx->ipad[i] = (unsigned char)((int)ctx->ipad[i] ^ (int)*(key + i));
    ctx->opad[i] = (unsigned char)((int)ctx->opad[i] ^ (int)*(key + i));
    i ++;
  }
  sha2_starts(ctx,is224);
  sha2_update(ctx,(unsigned char const *)(ctx->ipad),(size_t)64);
  memset((void *)(sum),0,sizeof(sum));
  return;
}

void sha2_hmac_update(sha2_context *ctx, unsigned char const *input,
                      size_t ilen)
{
  sha2_update(ctx,input,ilen);
  return;
}

void sha2_hmac_finish(sha2_context *ctx, unsigned char output[32])
{
  int is224;
  int hlen;
  unsigned char tmpbuf[32];
  is224 = ctx->is224;
  if (is224 == 0) hlen = 32; else hlen = 28;
  sha2_finish(ctx,tmpbuf);
  sha2_starts(ctx,is224);
  sha2_update(ctx,(unsigned char const *)(ctx->opad),(size_t)64);
  sha2_update(ctx,(unsigned char const *)(tmpbuf),(size_t)hlen);
  sha2_finish(ctx,output);
  memset((void *)(tmpbuf),0,sizeof(tmpbuf));
  return;
}

void sha2_hmac_reset(sha2_context *ctx)
{
  sha2_starts(ctx,ctx->is224);
  sha2_update(ctx,(unsigned char const *)(ctx->ipad),(size_t)64);
  return;
}

void sha2_hmac(unsigned char const *key, size_t keylen,
               unsigned char const *input, size_t ilen,
               unsigned char output[32], int is224)
{
  sha2_context ctx;
  sha2_hmac_starts(& ctx,key,keylen,is224);
  sha2_hmac_update(& ctx,input,ilen);
  sha2_hmac_finish(& ctx,output);
  memset((void *)(& ctx),0,sizeof(sha2_context));
  return;
}

static unsigned char sha2_test_buf[3][57] =
  {{(unsigned char)'a',
    (unsigned char)'b',
    (unsigned char)'c',
    (unsigned char)'\000'},
   {(unsigned char)'a',
    (unsigned char)'b',
    (unsigned char)'c',
    (unsigned char)'d',
    (unsigned char)'b',
    (unsigned char)'c',
    (unsigned char)'d',
    (unsigned char)'e',
    (unsigned char)'c',
    (unsigned char)'d',
    (unsigned char)'e',
    (unsigned char)'f',
    (unsigned char)'d',
    (unsigned char)'e',
    (unsigned char)'f',
    (unsigned char)'g',
    (unsigned char)'e',
    (unsigned char)'f',
    (unsigned char)'g',
    (unsigned char)'h',
    (unsigned char)'f',
    (unsigned char)'g',
    (unsigned char)'h',
    (unsigned char)'i',
    (unsigned char)'g',
    (unsigned char)'h',
    (unsigned char)'i',
    (unsigned char)'j',
    (unsigned char)'h',
    (unsigned char)'i',
    (unsigned char)'j',
    (unsigned char)'k',
    (unsigned char)'i',
    (unsigned char)'j',
    (unsigned char)'k',
    (unsigned char)'l',
    (unsigned char)'j',
    (unsigned char)'k',
    (unsigned char)'l',
    (unsigned char)'m',
    (unsigned char)'k',
    (unsigned char)'l',
    (unsigned char)'m',
    (unsigned char)'n',
    (unsigned char)'l',
    (unsigned char)'m',
    (unsigned char)'n',
    (unsigned char)'o',
    (unsigned char)'m',
    (unsigned char)'n',
    (unsigned char)'o',
    (unsigned char)'p',
    (unsigned char)'n',
    (unsigned char)'o',
    (unsigned char)'p',
    (unsigned char)'q',
    (unsigned char)'\000'},
   {(unsigned char)'\000'}};
static int const sha2_test_buflen[3] = {3, 56, 1000};
static unsigned char const sha2_test_sum[6][32] =
  {{(unsigned char)0x23,
    (unsigned char)0x09,
    (unsigned char)0x7D,
    (unsigned char)0x22,
    (unsigned char)0x34,
    (unsigned char)0x05,
    (unsigned char)0xD8,
    (unsigned char)0x22,
    (unsigned char)0x86,
    (unsigned char)0x42,
    (unsigned char)0xA4,
    (unsigned char)0x77,
    (unsigned char)0xBD,
    (unsigned char)0xA2,
    (unsigned char)0x55,
    (unsigned char)0xB3,
    (unsigned char)0x2A,
    (unsigned char)0xAD,
    (unsigned char)0xBC,
    (unsigned char)0xE4,
    (unsigned char)0xBD,
    (unsigned char)0xA0,
    (unsigned char)0xB3,
    (unsigned char)0xF7,
    (unsigned char)0xE3,
    (unsigned char)0x6C,
    (unsigned char)0x9D,
    (unsigned char)0xA7},
   {(unsigned char)0x75,
    (unsigned char)0x38,
    (unsigned char)0x8B,
    (unsigned char)0x16,
    (unsigned char)0x51,
    (unsigned char)0x27,
    (unsigned char)0x76,
    (unsigned char)0xCC,
    (unsigned char)0x5D,
    (unsigned char)0xBA,
    (unsigned char)0x5D,
    (unsigned char)0xA1,
    (unsigned char)0xFD,
    (unsigned char)0x89,
    (unsigned char)0x01,
    (unsigned char)0x50,
    (unsigned char)0xB0,
    (unsigned char)0xC6,
    (unsigned char)0x45,
    (unsigned char)0x5C,
    (unsigned char)0xB4,
    (unsigned char)0xF5,
    (unsigned char)0x8B,
    (unsigned char)0x19,
    (unsigned char)0x52,
    (unsigned char)0x52,
    (unsigned char)0x25,
    (unsigned char)0x25},
   {(unsigned char)0x20,
    (unsigned char)0x79,
    (unsigned char)0x46,
    (unsigned char)0x55,
    (unsigned char)0x98,
    (unsigned char)0x0C,
    (unsigned char)0x91,
    (unsigned char)0xD8,
    (unsigned char)0xBB,
    (unsigned char)0xB4,
    (unsigned char)0xC1,
    (unsigned char)0xEA,
    (unsigned char)0x97,
    (unsigned char)0x61,
    (unsigned char)0x8A,
    (unsigned char)0x4B,
    (unsigned char)0xF0,
    (unsigned char)0x3F,
    (unsigned char)0x42,
    (unsigned char)0x58,
    (unsigned char)0x19,
    (unsigned char)0x48,
    (unsigned char)0xB2,
    (unsigned char)0xEE,
    (unsigned char)0x4E,
    (unsigned char)0xE7,
    (unsigned char)0xAD,
    (unsigned char)0x67},
   {(unsigned char)0xBA,
    (unsigned char)0x78,
    (unsigned char)0x16,
    (unsigned char)0xBF,
    (unsigned char)0x8F,
    (unsigned char)0x01,
    (unsigned char)0xCF,
    (unsigned char)0xEA,
    (unsigned char)0x41,
    (unsigned char)0x41,
    (unsigned char)0x40,
    (unsigned char)0xDE,
    (unsigned char)0x5D,
    (unsigned char)0xAE,
    (unsigned char)0x22,
    (unsigned char)0x23,
    (unsigned char)0xB0,
    (unsigned char)0x03,
    (unsigned char)0x61,
    (unsigned char)0xA3,
    (unsigned char)0x96,
    (unsigned char)0x17,
    (unsigned char)0x7A,
    (unsigned char)0x9C,
    (unsigned char)0xB4,
    (unsigned char)0x10,
    (unsigned char)0xFF,
    (unsigned char)0x61,
    (unsigned char)0xF2,
    (unsigned char)0x00,
    (unsigned char)0x15,
    (unsigned char)0xAD},
   {(unsigned char)0x24,
    (unsigned char)0x8D,
    (unsigned char)0x6A,
    (unsigned char)0x61,
    (unsigned char)0xD2,
    (unsigned char)0x06,
    (unsigned char)0x38,
    (unsigned char)0xB8,
    (unsigned char)0xE5,
    (unsigned char)0xC0,
    (unsigned char)0x26,
    (unsigned char)0x93,
    (unsigned char)0x0C,
    (unsigned char)0x3E,
    (unsigned char)0x60,
    (unsigned char)0x39,
    (unsigned char)0xA3,
    (unsigned char)0x3C,
    (unsigned char)0xE4,
    (unsigned char)0x59,
    (unsigned char)0x64,
    (unsigned char)0xFF,
    (unsigned char)0x21,
    (unsigned char)0x67,
    (unsigned char)0xF6,
    (unsigned char)0xEC,
    (unsigned char)0xED,
    (unsigned char)0xD4,
    (unsigned char)0x19,
    (unsigned char)0xDB,
    (unsigned char)0x06,
    (unsigned char)0xC1},
   {(unsigned char)0xCD,
    (unsigned char)0xC7,
    (unsigned char)0x6E,
    (unsigned char)0x5C,
    (unsigned char)0x99,
    (unsigned char)0x14,
    (unsigned char)0xFB,
    (unsigned char)0x92,
    (unsigned char)0x81,
    (unsigned char)0xA1,
    (unsigned char)0xC7,
    (unsigned char)0xE2,
    (unsigned char)0x84,
    (unsigned char)0xD7,
    (unsigned char)0x3E,
    (unsigned char)0x67,
    (unsigned char)0xF1,
    (unsigned char)0x80,
    (unsigned char)0x9A,
    (unsigned char)0x48,
    (unsigned char)0xA4,
    (unsigned char)0x97,
    (unsigned char)0x20,
    (unsigned char)0x0E,
    (unsigned char)0x04,
    (unsigned char)0x6D,
    (unsigned char)0x39,
    (unsigned char)0xCC,
    (unsigned char)0xC7,
    (unsigned char)0x11,
    (unsigned char)0x2C,
    (unsigned char)0xD0}};
static unsigned char sha2_hmac_test_key[7][26] =
  {{(unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\000'},
   {(unsigned char)'J',
    (unsigned char)'e',
    (unsigned char)'f',
    (unsigned char)'e',
    (unsigned char)'\000'},
   {(unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\000'},
   {(unsigned char)'\001',
    (unsigned char)'\002',
    (unsigned char)'\003',
    (unsigned char)'\004',
    (unsigned char)'\005',
    (unsigned char)'\006',
    (unsigned char)'\a',
    (unsigned char)'\b',
    (unsigned char)'\t',
    (unsigned char)'\n',
    (unsigned char)'\v',
    (unsigned char)'\f',
    (unsigned char)'\r',
    (unsigned char)'\016',
    (unsigned char)'\017',
    (unsigned char)'\020',
    (unsigned char)'\021',
    (unsigned char)'\022',
    (unsigned char)'\023',
    (unsigned char)'\024',
    (unsigned char)'\025',
    (unsigned char)'\026',
    (unsigned char)'\027',
    (unsigned char)'\030',
    (unsigned char)'\031',
    (unsigned char)'\000'},
   {(unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\000'},
   {(unsigned char)'\000'},
   {(unsigned char)'\000'}};
static int const sha2_hmac_test_keylen[7] = {20, 4, 20, 25, 20, 131, 131};
static unsigned char sha2_hmac_test_buf[7][153] =
  {{(unsigned char)'H',
    (unsigned char)'i',
    (unsigned char)' ',
    (unsigned char)'T',
    (unsigned char)'h',
    (unsigned char)'e',
    (unsigned char)'r',
    (unsigned char)'e',
    (unsigned char)'\000'},
   {(unsigned char)'w',
    (unsigned char)'h',
    (unsigned char)'a',
    (unsigned char)'t',
    (unsigned char)' ',
    (unsigned char)'d',
    (unsigned char)'o',
    (unsigned char)' ',
    (unsigned char)'y',
    (unsigned char)'a',
    (unsigned char)' ',
    (unsigned char)'w',
    (unsigned char)'a',
    (unsigned char)'n',
    (unsigned char)'t',
    (unsigned char)' ',
    (unsigned char)'f',
    (unsigned char)'o',
    (unsigned char)'r',
    (unsigned char)' ',
    (unsigned char)'n',
    (unsigned char)'o',
    (unsigned char)'t',
    (unsigned char)'h',
    (unsigned char)'i',
    (unsigned char)'n',
    (unsigned char)'g',
    (unsigned char)'?',
    (unsigned char)'\000'},
   {(unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\000'},
   {(unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\000'},
   {(unsigned char)'T',
    (unsigned char)'e',
    (unsigned char)'s',
    (unsigned char)'t',
    (unsigned char)' ',
    (unsigned char)'W',
    (unsigned char)'i',
    (unsigned char)'t',
    (unsigned char)'h',
    (unsigned char)' ',
    (unsigned char)'T',
    (unsigned char)'r',
    (unsigned char)'u',
    (unsigned char)'n',
    (unsigned char)'c',
    (unsigned char)'a',
    (unsigned char)'t',
    (unsigned char)'i',
    (unsigned char)'o',
    (unsigned char)'n',
    (unsigned char)'\000'},
   {(unsigned char)'T',
    (unsigned char)'e',
    (unsigned char)'s',
    (unsigned char)'t',
    (unsigned char)' ',
    (unsigned char)'U',
    (unsigned char)'s',
    (unsigned char)'i',
    (unsigned char)'n',
    (unsigned char)'g',
    (unsigned char)' ',
    (unsigned char)'L',
    (unsigned char)'a',
    (unsigned char)'r',
    (unsigned char)'g',
    (unsigned char)'e',
    (unsigned char)'r',
    (unsigned char)' ',
    (unsigned char)'T',
    (unsigned char)'h',
    (unsigned char)'a',
    (unsigned char)'n',
    (unsigned char)' ',
    (unsigned char)'B',
    (unsigned char)'l',
    (unsigned char)'o',
    (unsigned char)'c',
    (unsigned char)'k',
    (unsigned char)'-',
    (unsigned char)'S',
    (unsigned char)'i',
    (unsigned char)'z',
    (unsigned char)'e',
    (unsigned char)' ',
    (unsigned char)'K',
    (unsigned char)'e',
    (unsigned char)'y',
    (unsigned char)' ',
    (unsigned char)'-',
    (unsigned char)' ',
    (unsigned char)'H',
    (unsigned char)'a',
    (unsigned char)'s',
    (unsigned char)'h',
    (unsigned char)' ',
    (unsigned char)'K',
    (unsigned char)'e',
    (unsigned char)'y',
    (unsigned char)' ',
    (unsigned char)'F',
    (unsigned char)'i',
    (unsigned char)'r',
    (unsigned char)'s',
    (unsigned char)'t',
    (unsigned char)'\000'},
   {(unsigned char)'T',
    (unsigned char)'h',
    (unsigned char)'i',
    (unsigned char)'s',
    (unsigned char)' ',
    (unsigned char)'i',
    (unsigned char)'s',
    (unsigned char)' ',
    (unsigned char)'a',
    (unsigned char)' ',
    (unsigned char)'t',
    (unsigned char)'e',
    (unsigned char)'s',
    (unsigned char)'t',
    (unsigned char)' ',
    (unsigned char)'u',
    (unsigned char)'s',
    (unsigned char)'i',
    (unsigned char)'n',
    (unsigned char)'g',
    (unsigned char)' ',
    (unsigned char)'a',
    (unsigned char)' ',
    (unsigned char)'l',
    (unsigned char)'a',
    (unsigned char)'r',
    (unsigned char)'g',
    (unsigned char)'e',
    (unsigned char)'r',
    (unsigned char)' ',
    (unsigned char)'t',
    (unsigned char)'h',
    (unsigned char)'a',
    (unsigned char)'n',
    (unsigned char)' ',
    (unsigned char)'b',
    (unsigned char)'l',
    (unsigned char)'o',
    (unsigned char)'c',
    (unsigned char)'k',
    (unsigned char)'-',
    (unsigned char)'s',
    (unsigned char)'i',
    (unsigned char)'z',
    (unsigned char)'e',
    (unsigned char)' ',
    (unsigned char)'k',
    (unsigned char)'e',
    (unsigned char)'y',
    (unsigned char)' ',
    (unsigned char)'a',
    (unsigned char)'n',
    (unsigned char)'d',
    (unsigned char)' ',
    (unsigned char)'a',
    (unsigned char)' ',
    (unsigned char)'l',
    (unsigned char)'a',
    (unsigned char)'r',
    (unsigned char)'g',
    (unsigned char)'e',
    (unsigned char)'r',
    (unsigned char)' ',
    (unsigned char)'t',
    (unsigned char)'h',
    (unsigned char)'a',
    (unsigned char)'n',
    (unsigned char)' ',
    (unsigned char)'b',
    (unsigned char)'l',
    (unsigned char)'o',
    (unsigned char)'c',
    (unsigned char)'k',
    (unsigned char)'-',
    (unsigned char)'s',
    (unsigned char)'i',
    (unsigned char)'z',
    (unsigned char)'e',
    (unsigned char)' ',
    (unsigned char)'d',
    (unsigned char)'a',
    (unsigned char)'t',
    (unsigned char)'a',
    (unsigned char)'.',
    (unsigned char)' ',
    (unsigned char)'T',
    (unsigned char)'h',
    (unsigned char)'e',
    (unsigned char)' ',
    (unsigned char)'k',
    (unsigned char)'e',
    (unsigned char)'y',
    (unsigned char)' ',
    (unsigned char)'n',
    (unsigned char)'e',
    (unsigned char)'e',
    (unsigned char)'d',
    (unsigned char)'s',
    (unsigned char)' ',
    (unsigned char)'t',
    (unsigned char)'o',
    (unsigned char)' ',
    (unsigned char)'b',
    (unsigned char)'e',
    (unsigned char)' ',
    (unsigned char)'h',
    (unsigned char)'a',
    (unsigned char)'s',
    (unsigned char)'h',
    (unsigned char)'e',
    (unsigned char)'d',
    (unsigned char)' ',
    (unsigned char)'b',
    (unsigned char)'e',
    (unsigned char)'f',
    (unsigned char)'o',
    (unsigned char)'r',
    (unsigned char)'e',
    (unsigned char)' ',
    (unsigned char)'b',
    (unsigned char)'e',
    (unsigned char)'i',
    (unsigned char)'n',
    (unsigned char)'g',
    (unsigned char)' ',
    (unsigned char)'u',
    (unsigned char)'s',
    (unsigned char)'e',
    (unsigned char)'d',
    (unsigned char)' ',
    (unsigned char)'b',
    (unsigned char)'y',
    (unsigned char)' ',
    (unsigned char)'t',
    (unsigned char)'h',
    (unsigned char)'e',
    (unsigned char)' ',
    (unsigned char)'H',
    (unsigned char)'M',
    (unsigned char)'A',
    (unsigned char)'C',
    (unsigned char)' ',
    (unsigned char)'a',
    (unsigned char)'l',
    (unsigned char)'g',
    (unsigned char)'o',
    (unsigned char)'r',
    (unsigned char)'i',
    (unsigned char)'t',
    (unsigned char)'h',
    (unsigned char)'m',
    (unsigned char)'.',
    (unsigned char)'\000'}};
static int const sha2_hmac_test_buflen[7] = {8, 28, 50, 50, 20, 54, 152};
static unsigned char const sha2_hmac_test_sum[14][32] =
  {{(unsigned char)0x89,
    (unsigned char)0x6F,
    (unsigned char)0xB1,
    (unsigned char)0x12,
    (unsigned char)0x8A,
    (unsigned char)0xBB,
    (unsigned char)0xDF,
    (unsigned char)0x19,
    (unsigned char)0x68,
    (unsigned char)0x32,
    (unsigned char)0x10,
    (unsigned char)0x7C,
    (unsigned char)0xD4,
    (unsigned char)0x9D,
    (unsigned char)0xF3,
    (unsigned char)0x3F,
    (unsigned char)0x47,
    (unsigned char)0xB4,
    (unsigned char)0xB1,
    (unsigned char)0x16,
    (unsigned char)0x99,
    (unsigned char)0x12,
    (unsigned char)0xBA,
    (unsigned char)0x4F,
    (unsigned char)0x53,
    (unsigned char)0x68,
    (unsigned char)0x4B,
    (unsigned char)0x22},
   {(unsigned char)0xA3,
    (unsigned char)0x0E,
    (unsigned char)0x01,
    (unsigned char)0x09,
    (unsigned char)0x8B,
    (unsigned char)0xC6,
    (unsigned char)0xDB,
    (unsigned char)0xBF,
    (unsigned char)0x45,
    (unsigned char)0x69,
    (unsigned char)0x0F,
    (unsigned char)0x3A,
    (unsigned char)0x7E,
    (unsigned char)0x9E,
    (unsigned char)0x6D,
    (unsigned char)0x0F,
    (unsigned char)0x8B,
    (unsigned char)0xBE,
    (unsigned char)0xA2,
    (unsigned char)0xA3,
    (unsigned char)0x9E,
    (unsigned char)0x61,
    (unsigned char)0x48,
    (unsigned char)0x00,
    (unsigned char)0x8F,
    (unsigned char)0xD0,
    (unsigned char)0x5E,
    (unsigned char)0x44},
   {(unsigned char)0x7F,
    (unsigned char)0xB3,
    (unsigned char)0xCB,
    (unsigned char)0x35,
    (unsigned char)0x88,
    (unsigned char)0xC6,
    (unsigned char)0xC1,
    (unsigned char)0xF6,
    (unsigned char)0xFF,
    (unsigned char)0xA9,
    (unsigned char)0x69,
    (unsigned char)0x4D,
    (unsigned char)0x7D,
    (unsigned char)0x6A,
    (unsigned char)0xD2,
    (unsigned char)0x64,
    (unsigned char)0x93,
    (unsigned char)0x65,
    (unsigned char)0xB0,
    (unsigned char)0xC1,
    (unsigned char)0xF6,
    (unsigned char)0x5D,
    (unsigned char)0x69,
    (unsigned char)0xD1,
    (unsigned char)0xEC,
    (unsigned char)0x83,
    (unsigned char)0x33,
    (unsigned char)0xEA},
   {(unsigned char)0x6C,
    (unsigned char)0x11,
    (unsigned char)0x50,
    (unsigned char)0x68,
    (unsigned char)0x74,
    (unsigned char)0x01,
    (unsigned char)0x3C,
    (unsigned char)0xAC,
    (unsigned char)0x6A,
    (unsigned char)0x2A,
    (unsigned char)0xBC,
    (unsigned char)0x1B,
    (unsigned char)0xB3,
    (unsigned char)0x82,
    (unsigned char)0x62,
    (unsigned char)0x7C,
    (unsigned char)0xEC,
    (unsigned char)0x6A,
    (unsigned char)0x90,
    (unsigned char)0xD8,
    (unsigned char)0x6E,
    (unsigned char)0xFC,
    (unsigned char)0x01,
    (unsigned char)0x2D,
    (unsigned char)0xE7,
    (unsigned char)0xAF,
    (unsigned char)0xEC,
    (unsigned char)0x5A},
   {(unsigned char)0x0E,
    (unsigned char)0x2A,
    (unsigned char)0xEA,
    (unsigned char)0x68,
    (unsigned char)0xA9,
    (unsigned char)0x0C,
    (unsigned char)0x8D,
    (unsigned char)0x37,
    (unsigned char)0xC9,
    (unsigned char)0x88,
    (unsigned char)0xBC,
    (unsigned char)0xDB,
    (unsigned char)0x9F,
    (unsigned char)0xCA,
    (unsigned char)0x6F,
    (unsigned char)0xA8},
   {(unsigned char)0x95,
    (unsigned char)0xE9,
    (unsigned char)0xA0,
    (unsigned char)0xDB,
    (unsigned char)0x96,
    (unsigned char)0x20,
    (unsigned char)0x95,
    (unsigned char)0xAD,
    (unsigned char)0xAE,
    (unsigned char)0xBE,
    (unsigned char)0x9B,
    (unsigned char)0x2D,
    (unsigned char)0x6F,
    (unsigned char)0x0D,
    (unsigned char)0xBC,
    (unsigned char)0xE2,
    (unsigned char)0xD4,
    (unsigned char)0x99,
    (unsigned char)0xF1,
    (unsigned char)0x12,
    (unsigned char)0xF2,
    (unsigned char)0xD2,
    (unsigned char)0xB7,
    (unsigned char)0x27,
    (unsigned char)0x3F,
    (unsigned char)0xA6,
    (unsigned char)0x87,
    (unsigned char)0x0E},
   {(unsigned char)0x3A,
    (unsigned char)0x85,
    (unsigned char)0x41,
    (unsigned char)0x66,
    (unsigned char)0xAC,
    (unsigned char)0x5D,
    (unsigned char)0x9F,
    (unsigned char)0x02,
    (unsigned char)0x3F,
    (unsigned char)0x54,
    (unsigned char)0xD5,
    (unsigned char)0x17,
    (unsigned char)0xD0,
    (unsigned char)0xB3,
    (unsigned char)0x9D,
    (unsigned char)0xBD,
    (unsigned char)0x94,
    (unsigned char)0x67,
    (unsigned char)0x70,
    (unsigned char)0xDB,
    (unsigned char)0x9C,
    (unsigned char)0x2B,
    (unsigned char)0x95,
    (unsigned char)0xC9,
    (unsigned char)0xF6,
    (unsigned char)0xF5,
    (unsigned char)0x65,
    (unsigned char)0xD1},
   {(unsigned char)0xB0,
    (unsigned char)0x34,
    (unsigned char)0x4C,
    (unsigned char)0x61,
    (unsigned char)0xD8,
    (unsigned char)0xDB,
    (unsigned char)0x38,
    (unsigned char)0x53,
    (unsigned char)0x5C,
    (unsigned char)0xA8,
    (unsigned char)0xAF,
    (unsigned char)0xCE,
    (unsigned char)0xAF,
    (unsigned char)0x0B,
    (unsigned char)0xF1,
    (unsigned char)0x2B,
    (unsigned char)0x88,
    (unsigned char)0x1D,
    (unsigned char)0xC2,
    (unsigned char)0x00,
    (unsigned char)0xC9,
    (unsigned char)0x83,
    (unsigned char)0x3D,
    (unsigned char)0xA7,
    (unsigned char)0x26,
    (unsigned char)0xE9,
    (unsigned char)0x37,
    (unsigned char)0x6C,
    (unsigned char)0x2E,
    (unsigned char)0x32,
    (unsigned char)0xCF,
    (unsigned char)0xF7},
   {(unsigned char)0x5B,
    (unsigned char)0xDC,
    (unsigned char)0xC1,
    (unsigned char)0x46,
    (unsigned char)0xBF,
    (unsigned char)0x60,
    (unsigned char)0x75,
    (unsigned char)0x4E,
    (unsigned char)0x6A,
    (unsigned char)0x04,
    (unsigned char)0x24,
    (unsigned char)0x26,
    (unsigned char)0x08,
    (unsigned char)0x95,
    (unsigned char)0x75,
    (unsigned char)0xC7,
    (unsigned char)0x5A,
    (unsigned char)0x00,
    (unsigned char)0x3F,
    (unsigned char)0x08,
    (unsigned char)0x9D,
    (unsigned char)0x27,
    (unsigned char)0x39,
    (unsigned char)0x83,
    (unsigned char)0x9D,
    (unsigned char)0xEC,
    (unsigned char)0x58,
    (unsigned char)0xB9,
    (unsigned char)0x64,
    (unsigned char)0xEC,
    (unsigned char)0x38,
    (unsigned char)0x43},
   {(unsigned char)0x77,
    (unsigned char)0x3E,
    (unsigned char)0xA9,
    (unsigned char)0x1E,
    (unsigned char)0x36,
    (unsigned char)0x80,
    (unsigned char)0x0E,
    (unsigned char)0x46,
    (unsigned char)0x85,
    (unsigned char)0x4D,
    (unsigned char)0xB8,
    (unsigned char)0xEB,
    (unsigned char)0xD0,
    (unsigned char)0x91,
    (unsigned char)0x81,
    (unsigned char)0xA7,
    (unsigned char)0x29,
    (unsigned char)0x59,
    (unsigned char)0x09,
    (unsigned char)0x8B,
    (unsigned char)0x3E,
    (unsigned char)0xF8,
    (unsigned char)0xC1,
    (unsigned char)0x22,
    (unsigned char)0xD9,
    (unsigned char)0x63,
    (unsigned char)0x55,
    (unsigned char)0x14,
    (unsigned char)0xCE,
    (unsigned char)0xD5,
    (unsigned char)0x65,
    (unsigned char)0xFE},
   {(unsigned char)0x82,
    (unsigned char)0x55,
    (unsigned char)0x8A,
    (unsigned char)0x38,
    (unsigned char)0x9A,
    (unsigned char)0x44,
    (unsigned char)0x3C,
    (unsigned char)0x0E,
    (unsigned char)0xA4,
    (unsigned char)0xCC,
    (unsigned char)0x81,
    (unsigned char)0x98,
    (unsigned char)0x99,
    (unsigned char)0xF2,
    (unsigned char)0x08,
    (unsigned char)0x3A,
    (unsigned char)0x85,
    (unsigned char)0xF0,
    (unsigned char)0xFA,
    (unsigned char)0xA3,
    (unsigned char)0xE5,
    (unsigned char)0x78,
    (unsigned char)0xF8,
    (unsigned char)0x07,
    (unsigned char)0x7A,
    (unsigned char)0x2E,
    (unsigned char)0x3F,
    (unsigned char)0xF4,
    (unsigned char)0x67,
    (unsigned char)0x29,
    (unsigned char)0x66,
    (unsigned char)0x5B},
   {(unsigned char)0xA3,
    (unsigned char)0xB6,
    (unsigned char)0x16,
    (unsigned char)0x74,
    (unsigned char)0x73,
    (unsigned char)0x10,
    (unsigned char)0x0E,
    (unsigned char)0xE0,
    (unsigned char)0x6E,
    (unsigned char)0x0C,
    (unsigned char)0x79,
    (unsigned char)0x6C,
    (unsigned char)0x29,
    (unsigned char)0x55,
    (unsigned char)0x55,
    (unsigned char)0x2B},
   {(unsigned char)0x60,
    (unsigned char)0xE4,
    (unsigned char)0x31,
    (unsigned char)0x59,
    (unsigned char)0x1E,
    (unsigned char)0xE0,
    (unsigned char)0xB6,
    (unsigned char)0x7F,
    (unsigned char)0x0D,
    (unsigned char)0x8A,
    (unsigned char)0x26,
    (unsigned char)0xAA,
    (unsigned char)0xCB,
    (unsigned char)0xF5,
    (unsigned char)0xB7,
    (unsigned char)0x7F,
    (unsigned char)0x8E,
    (unsigned char)0x0B,
    (unsigned char)0xC6,
    (unsigned char)0x21,
    (unsigned char)0x37,
    (unsigned char)0x28,
    (unsigned char)0xC5,
    (unsigned char)0x14,
    (unsigned char)0x05,
    (unsigned char)0x46,
    (unsigned char)0x04,
    (unsigned char)0x0F,
    (unsigned char)0x0E,
    (unsigned char)0xE3,
    (unsigned char)0x7F,
    (unsigned char)0x54},
   {(unsigned char)0x9B,
    (unsigned char)0x09,
    (unsigned char)0xFF,
    (unsigned char)0xA7,
    (unsigned char)0x1B,
    (unsigned char)0x94,
    (unsigned char)0x2F,
    (unsigned char)0xCB,
    (unsigned char)0x27,
    (unsigned char)0x63,
    (unsigned char)0x5F,
    (unsigned char)0xBC,
    (unsigned char)0xD5,
    (unsigned char)0xB0,
    (unsigned char)0xE9,
    (unsigned char)0x44,
    (unsigned char)0xBF,
    (unsigned char)0xDC,
    (unsigned char)0x63,
    (unsigned char)0x64,
    (unsigned char)0x4F,
    (unsigned char)0x07,
    (unsigned char)0x13,
    (unsigned char)0x93,
    (unsigned char)0x8A,
    (unsigned char)0x7F,
    (unsigned char)0x51,
    (unsigned char)0x53,
    (unsigned char)0x5C,
    (unsigned char)0x3A,
    (unsigned char)0x35,
    (unsigned char)0xE2}};
/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_111(char const * restrict format, int param0, int param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_112(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_113(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_114(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_115(char const * restrict format, int param0, int param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_116(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_117(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_118(char const * restrict format);

int sha2_self_test(int verbose)
{
  int __retres;
  int i;
  int j;
  int k;
  int buflen;
  unsigned char buf[1024];
  unsigned char sha2sum[32];
  sha2_context ctx;
  i = 0;
  while (i < 6) {
    {
      int tmp;
      j = i % 3;
      k = i < 3;
      if (verbose != 0) printf("  SHA-%d test #%d: ",256 - k * 32,j + 1); /* printf_va_111 */
      sha2_starts(& ctx,k);
      if (j == 2) {
        buflen = 1000;
        memset((void *)(buf),'a',(size_t)buflen);
        j = 0;
        while (j < 1000) {
          sha2_update(& ctx,(unsigned char const *)(buf),(size_t)buflen);
          j ++;
        }
      }
      else sha2_update(& ctx,(unsigned char const *)(sha2_test_buf[j]),
                       (size_t)sha2_test_buflen[j]);
      sha2_finish(& ctx,sha2sum);
      tmp = memcmp((void const *)(sha2sum),(void const *)(sha2_test_sum[i]),
                   (size_t)(32 - k * 4));
      if (tmp != 0) {
        if (verbose != 0) printf("failed\n"); /* printf_va_112 */
        __retres = 1;
        goto return_label;
      }
      if (verbose != 0) printf("passed\n"); /* printf_va_113 */
    }
    i ++;
  }
  if (verbose != 0) printf("\n"); /* printf_va_114 */
  i = 0;
  while (i < 14) {
    {
      int tmp_0;
      j = i % 7;
      k = i < 7;
      if (verbose != 0) printf("  HMAC-SHA-%d test #%d: ",256 - k * 32,j + 1); /* printf_va_115 */
      if (j == 5) goto _LOR;
      else 
        if (j == 6) {
          _LOR:
          {
            buflen = 131;
            memset((void *)(buf),'\252',(size_t)buflen);
            sha2_hmac_starts(& ctx,(unsigned char const *)(buf),
                             (size_t)buflen,k);
          }
        }
        else sha2_hmac_starts(& ctx,
                              (unsigned char const *)(sha2_hmac_test_key[j]),
                              (size_t)sha2_hmac_test_keylen[j],k);
      sha2_hmac_update(& ctx,(unsigned char const *)(sha2_hmac_test_buf[j]),
                       (size_t)sha2_hmac_test_buflen[j]);
      sha2_hmac_finish(& ctx,sha2sum);
      if (j == 4) buflen = 16; else buflen = 32 - k * 4;
      tmp_0 = memcmp((void const *)(sha2sum),
                     (void const *)(sha2_hmac_test_sum[i]),(size_t)buflen);
      if (tmp_0 != 0) {
        if (verbose != 0) printf("failed\n"); /* printf_va_116 */
        __retres = 1;
        goto return_label;
      }
      if (verbose != 0) printf("passed\n"); /* printf_va_117 */
    }
    i ++;
  }
  if (verbose != 0) printf("\n"); /* printf_va_118 */
  __retres = 0;
  return_label: return __retres;
}

static unsigned long long const K[80] =
  {0x428A2F98D728AE22ULL,
   0x7137449123EF65CDULL,
   0xB5C0FBCFEC4D3B2FULL,
   0xE9B5DBA58189DBBCULL,
   0x3956C25BF348B538ULL,
   0x59F111F1B605D019ULL,
   0x923F82A4AF194F9BULL,
   0xAB1C5ED5DA6D8118ULL,
   0xD807AA98A3030242ULL,
   0x12835B0145706FBEULL,
   0x243185BE4EE4B28CULL,
   0x550C7DC3D5FFB4E2ULL,
   0x72BE5D74F27B896FULL,
   0x80DEB1FE3B1696B1ULL,
   0x9BDC06A725C71235ULL,
   0xC19BF174CF692694ULL,
   0xE49B69C19EF14AD2ULL,
   0xEFBE4786384F25E3ULL,
   0x0FC19DC68B8CD5B5ULL,
   0x240CA1CC77AC9C65ULL,
   0x2DE92C6F592B0275ULL,
   0x4A7484AA6EA6E483ULL,
   0x5CB0A9DCBD41FBD4ULL,
   0x76F988DA831153B5ULL,
   0x983E5152EE66DFABULL,
   0xA831C66D2DB43210ULL,
   0xB00327C898FB213FULL,
   0xBF597FC7BEEF0EE4ULL,
   0xC6E00BF33DA88FC2ULL,
   0xD5A79147930AA725ULL,
   0x06CA6351E003826FULL,
   0x142929670A0E6E70ULL,
   0x27B70A8546D22FFCULL,
   0x2E1B21385C26C926ULL,
   0x4D2C6DFC5AC42AEDULL,
   0x53380D139D95B3DFULL,
   0x650A73548BAF63DEULL,
   0x766A0ABB3C77B2A8ULL,
   0x81C2C92E47EDAEE6ULL,
   0x92722C851482353BULL,
   0xA2BFE8A14CF10364ULL,
   0xA81A664BBC423001ULL,
   0xC24B8B70D0F89791ULL,
   0xC76C51A30654BE30ULL,
   0xD192E819D6EF5218ULL,
   0xD69906245565A910ULL,
   0xF40E35855771202AULL,
   0x106AA07032BBD1B8ULL,
   0x19A4C116B8D2D0C8ULL,
   0x1E376C085141AB53ULL,
   0x2748774CDF8EEB99ULL,
   0x34B0BCB5E19B48A8ULL,
   0x391C0CB3C5C95A63ULL,
   0x4ED8AA4AE3418ACBULL,
   0x5B9CCA4F7763E373ULL,
   0x682E6FF3D6B2B8A3ULL,
   0x748F82EE5DEFB2FCULL,
   0x78A5636F43172F60ULL,
   0x84C87814A1F0AB72ULL,
   0x8CC702081A6439ECULL,
   0x90BEFFFA23631E28ULL,
   0xA4506CEBDE82BDE9ULL,
   0xBEF9A3F7B2C67915ULL,
   0xC67178F2E372532BULL,
   0xCA273ECEEA26619CULL,
   0xD186B8C721C0C207ULL,
   0xEADA7DD6CDE0EB1EULL,
   0xF57D4F7FEE6ED178ULL,
   0x06F067AA72176FBAULL,
   0x0A637DC5A2C898A6ULL,
   0x113F9804BEF90DAEULL,
   0x1B710B35131C471BULL,
   0x28DB77F523047D84ULL,
   0x32CAAB7B40C72493ULL,
   0x3C9EBE0A15C9BEBCULL,
   0x431D67C49C100D4CULL,
   0x4CC5D4BECB3E42B6ULL,
   0x597F299CFC657E2AULL,
   0x5FCB6FAB3AD6FAECULL,
   0x6C44198C4A475817ULL};
void sha4_starts(sha4_context *ctx, int is384)
{
  ctx->total[0] = (unsigned long long)0;
  ctx->total[1] = (unsigned long long)0;
  if (is384 == 0) {
    ctx->state[0] = 0x6A09E667F3BCC908ULL;
    ctx->state[1] = 0xBB67AE8584CAA73BULL;
    ctx->state[2] = 0x3C6EF372FE94F82BULL;
    ctx->state[3] = 0xA54FF53A5F1D36F1ULL;
    ctx->state[4] = 0x510E527FADE682D1ULL;
    ctx->state[5] = 0x9B05688C2B3E6C1FULL;
    ctx->state[6] = 0x1F83D9ABFB41BD6BULL;
    ctx->state[7] = 0x5BE0CD19137E2179ULL;
  }
  else {
    ctx->state[0] = 0xCBBB9D5DC1059ED8ULL;
    ctx->state[1] = 0x629A292A367CD507ULL;
    ctx->state[2] = 0x9159015A3070DD17ULL;
    ctx->state[3] = 0x152FECD8F70E5939ULL;
    ctx->state[4] = 0x67332667FFC00B31ULL;
    ctx->state[5] = 0x8EB44A8768581511ULL;
    ctx->state[6] = 0xDB0C2E0D64F98FA7ULL;
    ctx->state[7] = 0x47B5481DBEFA4FA4ULL;
  }
  ctx->is384 = is384;
  return;
}

/*@ requires \valid(ctx);
    requires \valid(&ctx->state[0 .. 7]);
    requires \initialized(data);
    assigns ctx->state[0 .. 7];
    assigns ctx->state[0 .. 7]
      \from ctx->state[0 .. 7], *(data + (0 .. 127));
 */
static void sha4_process(sha4_context *ctx, unsigned char const data[128])
{
  int i;
  unsigned long long temp1;
  unsigned long long temp2;
  unsigned long long W[80];
  unsigned long long A;
  unsigned long long B;
  unsigned long long C;
  unsigned long long D;
  unsigned long long E;
  unsigned long long F;
  unsigned long long G;
  unsigned long long H;
  i = 0;
  while (i < 16) {
    W[i] = ((((((((unsigned long long)*(data + (i << 3)) << 56) | ((unsigned long long)*(
                                                                   data + (
                                                                   (i << 3) + 1)) << 48)) | (
                (unsigned long long)*(data + ((i << 3) + 2)) << 40)) | (
               (unsigned long long)*(data + ((i << 3) + 3)) << 32)) | (
              (unsigned long long)*(data + ((i << 3) + 4)) << 24)) | (
             (unsigned long long)*(data + ((i << 3) + 5)) << 16)) | (
            (unsigned long long)*(data + ((i << 3) + 6)) << 8)) | (unsigned long long)*(
           data + ((i << 3) + 7));
    i ++;
  }
  while (i < 80) {
    W[i] = ((((((W[i - 2] >> 19) | (W[i - 2] << (64 - 19))) ^ ((W[i - 2] >> 61) | (
                                                               W[i - 2] << (
                                                               64 - 61)))) ^ (
              W[i - 2] >> 6)) + W[i - 7]) + ((((W[i - 15] >> 1) | (W[
                                                                   i - 15] << (
                                                                   64 - 1))) ^ (
                                              (W[i - 15] >> 8) | (W[i - 15] << (
                                                                  64 - 8)))) ^ (
                                             W[i - 15] >> 7))) + W[i - 16];
    i ++;
  }
  A = ctx->state[0];
  B = ctx->state[1];
  C = ctx->state[2];
  D = ctx->state[3];
  E = ctx->state[4];
  F = ctx->state[5];
  G = ctx->state[6];
  H = ctx->state[7];
  i = 0;
  while (1) {
    temp1 = (((H + ((((E >> 14) | (E << (64 - 14))) ^ ((E >> 18) | (E << (
                                                                    64 - 18)))) ^ (
                    (E >> 41) | (E << (64 - 41))))) + (G ^ (E & (F ^ G)))) + K[i]) + W[i];
    temp2 = ((((A >> 28) | (A << (64 - 28))) ^ ((A >> 34) | (A << (64 - 34)))) ^ (
             (A >> 39) | (A << (64 - 39)))) + ((A & B) | (C & (A | B)));
    D += temp1;
    H = temp1 + temp2;
    i ++;
    temp1 = (((G + ((((D >> 14) | (D << (64 - 14))) ^ ((D >> 18) | (D << (
                                                                    64 - 18)))) ^ (
                    (D >> 41) | (D << (64 - 41))))) + (F ^ (D & (E ^ F)))) + K[i]) + W[i];
    temp2 = ((((H >> 28) | (H << (64 - 28))) ^ ((H >> 34) | (H << (64 - 34)))) ^ (
             (H >> 39) | (H << (64 - 39)))) + ((H & A) | (B & (H | A)));
    C += temp1;
    G = temp1 + temp2;
    i ++;
    temp1 = (((F + ((((C >> 14) | (C << (64 - 14))) ^ ((C >> 18) | (C << (
                                                                    64 - 18)))) ^ (
                    (C >> 41) | (C << (64 - 41))))) + (E ^ (C & (D ^ E)))) + K[i]) + W[i];
    temp2 = ((((G >> 28) | (G << (64 - 28))) ^ ((G >> 34) | (G << (64 - 34)))) ^ (
             (G >> 39) | (G << (64 - 39)))) + ((G & H) | (A & (G | H)));
    B += temp1;
    F = temp1 + temp2;
    i ++;
    temp1 = (((E + ((((B >> 14) | (B << (64 - 14))) ^ ((B >> 18) | (B << (
                                                                    64 - 18)))) ^ (
                    (B >> 41) | (B << (64 - 41))))) + (D ^ (B & (C ^ D)))) + K[i]) + W[i];
    temp2 = ((((F >> 28) | (F << (64 - 28))) ^ ((F >> 34) | (F << (64 - 34)))) ^ (
             (F >> 39) | (F << (64 - 39)))) + ((F & G) | (H & (F | G)));
    A += temp1;
    E = temp1 + temp2;
    i ++;
    temp1 = (((D + ((((A >> 14) | (A << (64 - 14))) ^ ((A >> 18) | (A << (
                                                                    64 - 18)))) ^ (
                    (A >> 41) | (A << (64 - 41))))) + (C ^ (A & (B ^ C)))) + K[i]) + W[i];
    temp2 = ((((E >> 28) | (E << (64 - 28))) ^ ((E >> 34) | (E << (64 - 34)))) ^ (
             (E >> 39) | (E << (64 - 39)))) + ((E & F) | (G & (E | F)));
    H += temp1;
    D = temp1 + temp2;
    i ++;
    temp1 = (((C + ((((H >> 14) | (H << (64 - 14))) ^ ((H >> 18) | (H << (
                                                                    64 - 18)))) ^ (
                    (H >> 41) | (H << (64 - 41))))) + (B ^ (H & (A ^ B)))) + K[i]) + W[i];
    temp2 = ((((D >> 28) | (D << (64 - 28))) ^ ((D >> 34) | (D << (64 - 34)))) ^ (
             (D >> 39) | (D << (64 - 39)))) + ((D & E) | (F & (D | E)));
    G += temp1;
    C = temp1 + temp2;
    i ++;
    temp1 = (((B + ((((G >> 14) | (G << (64 - 14))) ^ ((G >> 18) | (G << (
                                                                    64 - 18)))) ^ (
                    (G >> 41) | (G << (64 - 41))))) + (A ^ (G & (H ^ A)))) + K[i]) + W[i];
    temp2 = ((((C >> 28) | (C << (64 - 28))) ^ ((C >> 34) | (C << (64 - 34)))) ^ (
             (C >> 39) | (C << (64 - 39)))) + ((C & D) | (E & (C | D)));
    F += temp1;
    B = temp1 + temp2;
    i ++;
    temp1 = (((A + ((((F >> 14) | (F << (64 - 14))) ^ ((F >> 18) | (F << (
                                                                    64 - 18)))) ^ (
                    (F >> 41) | (F << (64 - 41))))) + (H ^ (F & (G ^ H)))) + K[i]) + W[i];
    temp2 = ((((B >> 28) | (B << (64 - 28))) ^ ((B >> 34) | (B << (64 - 34)))) ^ (
             (B >> 39) | (B << (64 - 39)))) + ((B & C) | (D & (B | C)));
    E += temp1;
    A = temp1 + temp2;
    i ++;
    if (! (i < 80)) break;
  }
  ctx->state[0] += A;
  ctx->state[1] += B;
  ctx->state[2] += C;
  ctx->state[3] += D;
  ctx->state[4] += E;
  ctx->state[5] += F;
  ctx->state[6] += G;
  ctx->state[7] += H;
  return;
}

/*@ requires \valid_read(input + (0 .. ilen - 1));
    requires \valid(&ctx->state[0 .. 7]);
    requires \valid(&ctx->total[0 .. 1]);
    requires \valid(&ctx->buffer[0 .. 127]);
    assigns ctx->state[0 .. 7], ctx->total[0 .. 1], ctx->buffer[0 .. 127];
    assigns ctx->state[0 .. 7]
      \from ctx->state[0 .. 7], *(input + (0 .. 127)), (indirect: ilen);
    assigns ctx->total[0 .. 1] \from ctx->total[0 .. 1], ilen;
    assigns ctx->buffer[0 .. 127]
      \from *(input + (0 .. 127)), (indirect: ilen);
 */
void sha4_update(sha4_context *ctx, unsigned char const *input, size_t ilen)
{
  size_t fill;
  unsigned int left;
  if (ilen <= (size_t)0) goto return_label;
  left = (unsigned int)(ctx->total[0] & (unsigned long long)0x7F);
  fill = (unsigned int)128 - left;
  ctx->total[0] += (unsigned long long)ilen;
  if (ctx->total[0] < (unsigned long long)ilen) (ctx->total[1]) ++;
  if (left) 
    if (ilen >= fill) {
      memcpy((void *)(& ctx->buffer[left]),(void const *)input,fill);
      sha4_process(ctx,(unsigned char const *)(ctx->buffer));
      input += fill;
      ilen -= fill;
      left = (unsigned int)0;
    }
  while (ilen >= (size_t)128) {
    sha4_process(ctx,input);
    input += 128;
    ilen -= (size_t)128;
  }
  if (ilen > (size_t)0) memcpy((void *)(& ctx->buffer[left]),
                               (void const *)input,ilen);
  return_label: return;
}

static unsigned char const sha4_padding[128] =
  {(unsigned char)0x80,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0,
   (unsigned char)0};
void sha4_finish(sha4_context *ctx, unsigned char output[64])
{
  size_t last;
  size_t padn;
  unsigned long long high;
  unsigned long long low;
  unsigned char msglen[16];
  high = (ctx->total[0] >> 61) | (ctx->total[1] << 3);
  low = ctx->total[0] << 3;
  msglen[0] = (unsigned char)(high >> 56);
  msglen[0 + 1] = (unsigned char)(high >> 48);
  msglen[0 + 2] = (unsigned char)(high >> 40);
  msglen[0 + 3] = (unsigned char)(high >> 32);
  msglen[0 + 4] = (unsigned char)(high >> 24);
  msglen[0 + 5] = (unsigned char)(high >> 16);
  msglen[0 + 6] = (unsigned char)(high >> 8);
  msglen[0 + 7] = (unsigned char)high;
  msglen[8] = (unsigned char)(low >> 56);
  msglen[8 + 1] = (unsigned char)(low >> 48);
  msglen[8 + 2] = (unsigned char)(low >> 40);
  msglen[8 + 3] = (unsigned char)(low >> 32);
  msglen[8 + 4] = (unsigned char)(low >> 24);
  msglen[8 + 5] = (unsigned char)(low >> 16);
  msglen[8 + 6] = (unsigned char)(low >> 8);
  msglen[8 + 7] = (unsigned char)low;
  last = (size_t)(ctx->total[0] & (unsigned long long)0x7F);
  if (last < (size_t)112) padn = (size_t)112 - last;
  else padn = (size_t)240 - last;
  sha4_update(ctx,sha4_padding,padn);
  sha4_update(ctx,(unsigned char const *)(msglen),(size_t)16);
  *(output + 0) = (unsigned char)(ctx->state[0] >> 56);
  *(output + (0 + 1)) = (unsigned char)(ctx->state[0] >> 48);
  *(output + (0 + 2)) = (unsigned char)(ctx->state[0] >> 40);
  *(output + (0 + 3)) = (unsigned char)(ctx->state[0] >> 32);
  *(output + (0 + 4)) = (unsigned char)(ctx->state[0] >> 24);
  *(output + (0 + 5)) = (unsigned char)(ctx->state[0] >> 16);
  *(output + (0 + 6)) = (unsigned char)(ctx->state[0] >> 8);
  *(output + (0 + 7)) = (unsigned char)ctx->state[0];
  *(output + 8) = (unsigned char)(ctx->state[1] >> 56);
  *(output + (8 + 1)) = (unsigned char)(ctx->state[1] >> 48);
  *(output + (8 + 2)) = (unsigned char)(ctx->state[1] >> 40);
  *(output + (8 + 3)) = (unsigned char)(ctx->state[1] >> 32);
  *(output + (8 + 4)) = (unsigned char)(ctx->state[1] >> 24);
  *(output + (8 + 5)) = (unsigned char)(ctx->state[1] >> 16);
  *(output + (8 + 6)) = (unsigned char)(ctx->state[1] >> 8);
  *(output + (8 + 7)) = (unsigned char)ctx->state[1];
  *(output + 16) = (unsigned char)(ctx->state[2] >> 56);
  *(output + (16 + 1)) = (unsigned char)(ctx->state[2] >> 48);
  *(output + (16 + 2)) = (unsigned char)(ctx->state[2] >> 40);
  *(output + (16 + 3)) = (unsigned char)(ctx->state[2] >> 32);
  *(output + (16 + 4)) = (unsigned char)(ctx->state[2] >> 24);
  *(output + (16 + 5)) = (unsigned char)(ctx->state[2] >> 16);
  *(output + (16 + 6)) = (unsigned char)(ctx->state[2] >> 8);
  *(output + (16 + 7)) = (unsigned char)ctx->state[2];
  *(output + 24) = (unsigned char)(ctx->state[3] >> 56);
  *(output + (24 + 1)) = (unsigned char)(ctx->state[3] >> 48);
  *(output + (24 + 2)) = (unsigned char)(ctx->state[3] >> 40);
  *(output + (24 + 3)) = (unsigned char)(ctx->state[3] >> 32);
  *(output + (24 + 4)) = (unsigned char)(ctx->state[3] >> 24);
  *(output + (24 + 5)) = (unsigned char)(ctx->state[3] >> 16);
  *(output + (24 + 6)) = (unsigned char)(ctx->state[3] >> 8);
  *(output + (24 + 7)) = (unsigned char)ctx->state[3];
  *(output + 32) = (unsigned char)(ctx->state[4] >> 56);
  *(output + (32 + 1)) = (unsigned char)(ctx->state[4] >> 48);
  *(output + (32 + 2)) = (unsigned char)(ctx->state[4] >> 40);
  *(output + (32 + 3)) = (unsigned char)(ctx->state[4] >> 32);
  *(output + (32 + 4)) = (unsigned char)(ctx->state[4] >> 24);
  *(output + (32 + 5)) = (unsigned char)(ctx->state[4] >> 16);
  *(output + (32 + 6)) = (unsigned char)(ctx->state[4] >> 8);
  *(output + (32 + 7)) = (unsigned char)ctx->state[4];
  *(output + 40) = (unsigned char)(ctx->state[5] >> 56);
  *(output + (40 + 1)) = (unsigned char)(ctx->state[5] >> 48);
  *(output + (40 + 2)) = (unsigned char)(ctx->state[5] >> 40);
  *(output + (40 + 3)) = (unsigned char)(ctx->state[5] >> 32);
  *(output + (40 + 4)) = (unsigned char)(ctx->state[5] >> 24);
  *(output + (40 + 5)) = (unsigned char)(ctx->state[5] >> 16);
  *(output + (40 + 6)) = (unsigned char)(ctx->state[5] >> 8);
  *(output + (40 + 7)) = (unsigned char)ctx->state[5];
  if (ctx->is384 == 0) {
    *(output + 48) = (unsigned char)(ctx->state[6] >> 56);
    *(output + (48 + 1)) = (unsigned char)(ctx->state[6] >> 48);
    *(output + (48 + 2)) = (unsigned char)(ctx->state[6] >> 40);
    *(output + (48 + 3)) = (unsigned char)(ctx->state[6] >> 32);
    *(output + (48 + 4)) = (unsigned char)(ctx->state[6] >> 24);
    *(output + (48 + 5)) = (unsigned char)(ctx->state[6] >> 16);
    *(output + (48 + 6)) = (unsigned char)(ctx->state[6] >> 8);
    *(output + (48 + 7)) = (unsigned char)ctx->state[6];
    *(output + 56) = (unsigned char)(ctx->state[7] >> 56);
    *(output + (56 + 1)) = (unsigned char)(ctx->state[7] >> 48);
    *(output + (56 + 2)) = (unsigned char)(ctx->state[7] >> 40);
    *(output + (56 + 3)) = (unsigned char)(ctx->state[7] >> 32);
    *(output + (56 + 4)) = (unsigned char)(ctx->state[7] >> 24);
    *(output + (56 + 5)) = (unsigned char)(ctx->state[7] >> 16);
    *(output + (56 + 6)) = (unsigned char)(ctx->state[7] >> 8);
    *(output + (56 + 7)) = (unsigned char)ctx->state[7];
  }
  return;
}

/*@ requires \valid_read(input + (0 .. ilen - 1));
    requires \initialized(input + (0 .. ilen - 1));
    requires \valid(output + (0 .. 63));
    ensures \initialized(\old(output) + (0 .. 63));
    assigns *(output + (0 .. 63));
    assigns *(output + (0 .. 63)) \from *(input + (0 .. ilen - 1)), ilen;
 */
void sha4(unsigned char const *input, size_t ilen, unsigned char output[64],
          int is384)
{
  sha4_context ctx;
  sha4_starts(& ctx,is384);
  sha4_update(& ctx,input,ilen);
  sha4_finish(& ctx,output);
  memset((void *)(& ctx),0,sizeof(sha4_context));
  return;
}

int sha4_file(char const *path, unsigned char output[64], int is384)
{
  int __retres;
  FILE *f;
  size_t n;
  sha4_context ctx;
  unsigned char buf[1024];
  int tmp;
  f = fopen(path,"rb");
  if (f == (FILE *)0) {
    __retres = -0x007A;
    goto return_label;
  }
  sha4_starts(& ctx,is384);
  while (1) {
    n = fread((void *)(buf),(size_t)1,sizeof(buf),f);
    if (! (n > (size_t)0)) break;
    sha4_update(& ctx,(unsigned char const *)(buf),n);
  }
  sha4_finish(& ctx,output);
  memset((void *)(& ctx),0,sizeof(sha4_context));
  tmp = ferror(f);
  if (tmp != 0) {
    fclose(f);
    __retres = -0x007A;
    goto return_label;
  }
  fclose(f);
  __retres = 0;
  return_label: return __retres;
}

void sha4_hmac_starts(sha4_context *ctx, unsigned char const *key,
                      size_t keylen, int is384)
{
  size_t i;
  unsigned char sum[64];
  if (keylen > (size_t)128) {
    sha4(key,keylen,sum,is384);
    if (is384) keylen = (size_t)48; else keylen = (size_t)64;
    key = (unsigned char const *)(sum);
  }
  memset((void *)(ctx->ipad),0x36,(size_t)128);
  memset((void *)(ctx->opad),0x5C,(size_t)128);
  i = (size_t)0;
  while (i < keylen) {
    ctx->ipad[i] = (unsigned char)((int)ctx->ipad[i] ^ (int)*(key + i));
    ctx->opad[i] = (unsigned char)((int)ctx->opad[i] ^ (int)*(key + i));
    i ++;
  }
  sha4_starts(ctx,is384);
  sha4_update(ctx,(unsigned char const *)(ctx->ipad),(size_t)128);
  memset((void *)(sum),0,sizeof(sum));
  return;
}

void sha4_hmac_update(sha4_context *ctx, unsigned char const *input,
                      size_t ilen)
{
  sha4_update(ctx,input,ilen);
  return;
}

void sha4_hmac_finish(sha4_context *ctx, unsigned char output[64])
{
  int is384;
  int hlen;
  unsigned char tmpbuf[64];
  is384 = ctx->is384;
  if (is384 == 0) hlen = 64; else hlen = 48;
  sha4_finish(ctx,tmpbuf);
  sha4_starts(ctx,is384);
  sha4_update(ctx,(unsigned char const *)(ctx->opad),(size_t)128);
  sha4_update(ctx,(unsigned char const *)(tmpbuf),(size_t)hlen);
  sha4_finish(ctx,output);
  memset((void *)(tmpbuf),0,sizeof(tmpbuf));
  return;
}

void sha4_hmac_reset(sha4_context *ctx)
{
  sha4_starts(ctx,ctx->is384);
  sha4_update(ctx,(unsigned char const *)(ctx->ipad),(size_t)128);
  return;
}

void sha4_hmac(unsigned char const *key, size_t keylen,
               unsigned char const *input, size_t ilen,
               unsigned char output[64], int is384)
{
  sha4_context ctx;
  sha4_hmac_starts(& ctx,key,keylen,is384);
  sha4_hmac_update(& ctx,input,ilen);
  sha4_hmac_finish(& ctx,output);
  memset((void *)(& ctx),0,sizeof(sha4_context));
  return;
}

static unsigned char sha4_test_buf[3][113] =
  {{(unsigned char)'a',
    (unsigned char)'b',
    (unsigned char)'c',
    (unsigned char)'\000'},
   {(unsigned char)'a',
    (unsigned char)'b',
    (unsigned char)'c',
    (unsigned char)'d',
    (unsigned char)'e',
    (unsigned char)'f',
    (unsigned char)'g',
    (unsigned char)'h',
    (unsigned char)'b',
    (unsigned char)'c',
    (unsigned char)'d',
    (unsigned char)'e',
    (unsigned char)'f',
    (unsigned char)'g',
    (unsigned char)'h',
    (unsigned char)'i',
    (unsigned char)'c',
    (unsigned char)'d',
    (unsigned char)'e',
    (unsigned char)'f',
    (unsigned char)'g',
    (unsigned char)'h',
    (unsigned char)'i',
    (unsigned char)'j',
    (unsigned char)'d',
    (unsigned char)'e',
    (unsigned char)'f',
    (unsigned char)'g',
    (unsigned char)'h',
    (unsigned char)'i',
    (unsigned char)'j',
    (unsigned char)'k',
    (unsigned char)'e',
    (unsigned char)'f',
    (unsigned char)'g',
    (unsigned char)'h',
    (unsigned char)'i',
    (unsigned char)'j',
    (unsigned char)'k',
    (unsigned char)'l',
    (unsigned char)'f',
    (unsigned char)'g',
    (unsigned char)'h',
    (unsigned char)'i',
    (unsigned char)'j',
    (unsigned char)'k',
    (unsigned char)'l',
    (unsigned char)'m',
    (unsigned char)'g',
    (unsigned char)'h',
    (unsigned char)'i',
    (unsigned char)'j',
    (unsigned char)'k',
    (unsigned char)'l',
    (unsigned char)'m',
    (unsigned char)'n',
    (unsigned char)'h',
    (unsigned char)'i',
    (unsigned char)'j',
    (unsigned char)'k',
    (unsigned char)'l',
    (unsigned char)'m',
    (unsigned char)'n',
    (unsigned char)'o',
    (unsigned char)'i',
    (unsigned char)'j',
    (unsigned char)'k',
    (unsigned char)'l',
    (unsigned char)'m',
    (unsigned char)'n',
    (unsigned char)'o',
    (unsigned char)'p',
    (unsigned char)'j',
    (unsigned char)'k',
    (unsigned char)'l',
    (unsigned char)'m',
    (unsigned char)'n',
    (unsigned char)'o',
    (unsigned char)'p',
    (unsigned char)'q',
    (unsigned char)'k',
    (unsigned char)'l',
    (unsigned char)'m',
    (unsigned char)'n',
    (unsigned char)'o',
    (unsigned char)'p',
    (unsigned char)'q',
    (unsigned char)'r',
    (unsigned char)'l',
    (unsigned char)'m',
    (unsigned char)'n',
    (unsigned char)'o',
    (unsigned char)'p',
    (unsigned char)'q',
    (unsigned char)'r',
    (unsigned char)'s',
    (unsigned char)'m',
    (unsigned char)'n',
    (unsigned char)'o',
    (unsigned char)'p',
    (unsigned char)'q',
    (unsigned char)'r',
    (unsigned char)'s',
    (unsigned char)'t',
    (unsigned char)'n',
    (unsigned char)'o',
    (unsigned char)'p',
    (unsigned char)'q',
    (unsigned char)'r',
    (unsigned char)'s',
    (unsigned char)'t',
    (unsigned char)'u',
    (unsigned char)'\000'},
   {(unsigned char)'\000'}};
static int const sha4_test_buflen[3] = {3, 112, 1000};
static unsigned char const sha4_test_sum[6][64] =
  {{(unsigned char)0xCB,
    (unsigned char)0x00,
    (unsigned char)0x75,
    (unsigned char)0x3F,
    (unsigned char)0x45,
    (unsigned char)0xA3,
    (unsigned char)0x5E,
    (unsigned char)0x8B,
    (unsigned char)0xB5,
    (unsigned char)0xA0,
    (unsigned char)0x3D,
    (unsigned char)0x69,
    (unsigned char)0x9A,
    (unsigned char)0xC6,
    (unsigned char)0x50,
    (unsigned char)0x07,
    (unsigned char)0x27,
    (unsigned char)0x2C,
    (unsigned char)0x32,
    (unsigned char)0xAB,
    (unsigned char)0x0E,
    (unsigned char)0xDE,
    (unsigned char)0xD1,
    (unsigned char)0x63,
    (unsigned char)0x1A,
    (unsigned char)0x8B,
    (unsigned char)0x60,
    (unsigned char)0x5A,
    (unsigned char)0x43,
    (unsigned char)0xFF,
    (unsigned char)0x5B,
    (unsigned char)0xED,
    (unsigned char)0x80,
    (unsigned char)0x86,
    (unsigned char)0x07,
    (unsigned char)0x2B,
    (unsigned char)0xA1,
    (unsigned char)0xE7,
    (unsigned char)0xCC,
    (unsigned char)0x23,
    (unsigned char)0x58,
    (unsigned char)0xBA,
    (unsigned char)0xEC,
    (unsigned char)0xA1,
    (unsigned char)0x34,
    (unsigned char)0xC8,
    (unsigned char)0x25,
    (unsigned char)0xA7},
   {(unsigned char)0x09,
    (unsigned char)0x33,
    (unsigned char)0x0C,
    (unsigned char)0x33,
    (unsigned char)0xF7,
    (unsigned char)0x11,
    (unsigned char)0x47,
    (unsigned char)0xE8,
    (unsigned char)0x3D,
    (unsigned char)0x19,
    (unsigned char)0x2F,
    (unsigned char)0xC7,
    (unsigned char)0x82,
    (unsigned char)0xCD,
    (unsigned char)0x1B,
    (unsigned char)0x47,
    (unsigned char)0x53,
    (unsigned char)0x11,
    (unsigned char)0x1B,
    (unsigned char)0x17,
    (unsigned char)0x3B,
    (unsigned char)0x3B,
    (unsigned char)0x05,
    (unsigned char)0xD2,
    (unsigned char)0x2F,
    (unsigned char)0xA0,
    (unsigned char)0x80,
    (unsigned char)0x86,
    (unsigned char)0xE3,
    (unsigned char)0xB0,
    (unsigned char)0xF7,
    (unsigned char)0x12,
    (unsigned char)0xFC,
    (unsigned char)0xC7,
    (unsigned char)0xC7,
    (unsigned char)0x1A,
    (unsigned char)0x55,
    (unsigned char)0x7E,
    (unsigned char)0x2D,
    (unsigned char)0xB9,
    (unsigned char)0x66,
    (unsigned char)0xC3,
    (unsigned char)0xE9,
    (unsigned char)0xFA,
    (unsigned char)0x91,
    (unsigned char)0x74,
    (unsigned char)0x60,
    (unsigned char)0x39},
   {(unsigned char)0x9D,
    (unsigned char)0x0E,
    (unsigned char)0x18,
    (unsigned char)0x09,
    (unsigned char)0x71,
    (unsigned char)0x64,
    (unsigned char)0x74,
    (unsigned char)0xCB,
    (unsigned char)0x08,
    (unsigned char)0x6E,
    (unsigned char)0x83,
    (unsigned char)0x4E,
    (unsigned char)0x31,
    (unsigned char)0x0A,
    (unsigned char)0x4A,
    (unsigned char)0x1C,
    (unsigned char)0xED,
    (unsigned char)0x14,
    (unsigned char)0x9E,
    (unsigned char)0x9C,
    (unsigned char)0x00,
    (unsigned char)0xF2,
    (unsigned char)0x48,
    (unsigned char)0x52,
    (unsigned char)0x79,
    (unsigned char)0x72,
    (unsigned char)0xCE,
    (unsigned char)0xC5,
    (unsigned char)0x70,
    (unsigned char)0x4C,
    (unsigned char)0x2A,
    (unsigned char)0x5B,
    (unsigned char)0x07,
    (unsigned char)0xB8,
    (unsigned char)0xB3,
    (unsigned char)0xDC,
    (unsigned char)0x38,
    (unsigned char)0xEC,
    (unsigned char)0xC4,
    (unsigned char)0xEB,
    (unsigned char)0xAE,
    (unsigned char)0x97,
    (unsigned char)0xDD,
    (unsigned char)0xD8,
    (unsigned char)0x7F,
    (unsigned char)0x3D,
    (unsigned char)0x89,
    (unsigned char)0x85},
   {(unsigned char)0xDD,
    (unsigned char)0xAF,
    (unsigned char)0x35,
    (unsigned char)0xA1,
    (unsigned char)0x93,
    (unsigned char)0x61,
    (unsigned char)0x7A,
    (unsigned char)0xBA,
    (unsigned char)0xCC,
    (unsigned char)0x41,
    (unsigned char)0x73,
    (unsigned char)0x49,
    (unsigned char)0xAE,
    (unsigned char)0x20,
    (unsigned char)0x41,
    (unsigned char)0x31,
    (unsigned char)0x12,
    (unsigned char)0xE6,
    (unsigned char)0xFA,
    (unsigned char)0x4E,
    (unsigned char)0x89,
    (unsigned char)0xA9,
    (unsigned char)0x7E,
    (unsigned char)0xA2,
    (unsigned char)0x0A,
    (unsigned char)0x9E,
    (unsigned char)0xEE,
    (unsigned char)0xE6,
    (unsigned char)0x4B,
    (unsigned char)0x55,
    (unsigned char)0xD3,
    (unsigned char)0x9A,
    (unsigned char)0x21,
    (unsigned char)0x92,
    (unsigned char)0x99,
    (unsigned char)0x2A,
    (unsigned char)0x27,
    (unsigned char)0x4F,
    (unsigned char)0xC1,
    (unsigned char)0xA8,
    (unsigned char)0x36,
    (unsigned char)0xBA,
    (unsigned char)0x3C,
    (unsigned char)0x23,
    (unsigned char)0xA3,
    (unsigned char)0xFE,
    (unsigned char)0xEB,
    (unsigned char)0xBD,
    (unsigned char)0x45,
    (unsigned char)0x4D,
    (unsigned char)0x44,
    (unsigned char)0x23,
    (unsigned char)0x64,
    (unsigned char)0x3C,
    (unsigned char)0xE8,
    (unsigned char)0x0E,
    (unsigned char)0x2A,
    (unsigned char)0x9A,
    (unsigned char)0xC9,
    (unsigned char)0x4F,
    (unsigned char)0xA5,
    (unsigned char)0x4C,
    (unsigned char)0xA4,
    (unsigned char)0x9F},
   {(unsigned char)0x8E,
    (unsigned char)0x95,
    (unsigned char)0x9B,
    (unsigned char)0x75,
    (unsigned char)0xDA,
    (unsigned char)0xE3,
    (unsigned char)0x13,
    (unsigned char)0xDA,
    (unsigned char)0x8C,
    (unsigned char)0xF4,
    (unsigned char)0xF7,
    (unsigned char)0x28,
    (unsigned char)0x14,
    (unsigned char)0xFC,
    (unsigned char)0x14,
    (unsigned char)0x3F,
    (unsigned char)0x8F,
    (unsigned char)0x77,
    (unsigned char)0x79,
    (unsigned char)0xC6,
    (unsigned char)0xEB,
    (unsigned char)0x9F,
    (unsigned char)0x7F,
    (unsigned char)0xA1,
    (unsigned char)0x72,
    (unsigned char)0x99,
    (unsigned char)0xAE,
    (unsigned char)0xAD,
    (unsigned char)0xB6,
    (unsigned char)0x88,
    (unsigned char)0x90,
    (unsigned char)0x18,
    (unsigned char)0x50,
    (unsigned char)0x1D,
    (unsigned char)0x28,
    (unsigned char)0x9E,
    (unsigned char)0x49,
    (unsigned char)0x00,
    (unsigned char)0xF7,
    (unsigned char)0xE4,
    (unsigned char)0x33,
    (unsigned char)0x1B,
    (unsigned char)0x99,
    (unsigned char)0xDE,
    (unsigned char)0xC4,
    (unsigned char)0xB5,
    (unsigned char)0x43,
    (unsigned char)0x3A,
    (unsigned char)0xC7,
    (unsigned char)0xD3,
    (unsigned char)0x29,
    (unsigned char)0xEE,
    (unsigned char)0xB6,
    (unsigned char)0xDD,
    (unsigned char)0x26,
    (unsigned char)0x54,
    (unsigned char)0x5E,
    (unsigned char)0x96,
    (unsigned char)0xE5,
    (unsigned char)0x5B,
    (unsigned char)0x87,
    (unsigned char)0x4B,
    (unsigned char)0xE9,
    (unsigned char)0x09},
   {(unsigned char)0xE7,
    (unsigned char)0x18,
    (unsigned char)0x48,
    (unsigned char)0x3D,
    (unsigned char)0x0C,
    (unsigned char)0xE7,
    (unsigned char)0x69,
    (unsigned char)0x64,
    (unsigned char)0x4E,
    (unsigned char)0x2E,
    (unsigned char)0x42,
    (unsigned char)0xC7,
    (unsigned char)0xBC,
    (unsigned char)0x15,
    (unsigned char)0xB4,
    (unsigned char)0x63,
    (unsigned char)0x8E,
    (unsigned char)0x1F,
    (unsigned char)0x98,
    (unsigned char)0xB1,
    (unsigned char)0x3B,
    (unsigned char)0x20,
    (unsigned char)0x44,
    (unsigned char)0x28,
    (unsigned char)0x56,
    (unsigned char)0x32,
    (unsigned char)0xA8,
    (unsigned char)0x03,
    (unsigned char)0xAF,
    (unsigned char)0xA9,
    (unsigned char)0x73,
    (unsigned char)0xEB,
    (unsigned char)0xDE,
    (unsigned char)0x0F,
    (unsigned char)0xF2,
    (unsigned char)0x44,
    (unsigned char)0x87,
    (unsigned char)0x7E,
    (unsigned char)0xA6,
    (unsigned char)0x0A,
    (unsigned char)0x4C,
    (unsigned char)0xB0,
    (unsigned char)0x43,
    (unsigned char)0x2C,
    (unsigned char)0xE5,
    (unsigned char)0x77,
    (unsigned char)0xC3,
    (unsigned char)0x1B,
    (unsigned char)0xEB,
    (unsigned char)0x00,
    (unsigned char)0x9C,
    (unsigned char)0x5C,
    (unsigned char)0x2C,
    (unsigned char)0x49,
    (unsigned char)0xAA,
    (unsigned char)0x2E,
    (unsigned char)0x4E,
    (unsigned char)0xAD,
    (unsigned char)0xB2,
    (unsigned char)0x17,
    (unsigned char)0xAD,
    (unsigned char)0x8C,
    (unsigned char)0xC0,
    (unsigned char)0x9B}};
static unsigned char sha4_hmac_test_key[7][26] =
  {{(unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\v',
    (unsigned char)'\000'},
   {(unsigned char)'J',
    (unsigned char)'e',
    (unsigned char)'f',
    (unsigned char)'e',
    (unsigned char)'\000'},
   {(unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\252',
    (unsigned char)'\000'},
   {(unsigned char)'\001',
    (unsigned char)'\002',
    (unsigned char)'\003',
    (unsigned char)'\004',
    (unsigned char)'\005',
    (unsigned char)'\006',
    (unsigned char)'\a',
    (unsigned char)'\b',
    (unsigned char)'\t',
    (unsigned char)'\n',
    (unsigned char)'\v',
    (unsigned char)'\f',
    (unsigned char)'\r',
    (unsigned char)'\016',
    (unsigned char)'\017',
    (unsigned char)'\020',
    (unsigned char)'\021',
    (unsigned char)'\022',
    (unsigned char)'\023',
    (unsigned char)'\024',
    (unsigned char)'\025',
    (unsigned char)'\026',
    (unsigned char)'\027',
    (unsigned char)'\030',
    (unsigned char)'\031',
    (unsigned char)'\000'},
   {(unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\f',
    (unsigned char)'\000'},
   {(unsigned char)'\000'},
   {(unsigned char)'\000'}};
static int const sha4_hmac_test_keylen[7] = {20, 4, 20, 25, 20, 131, 131};
static unsigned char sha4_hmac_test_buf[7][153] =
  {{(unsigned char)'H',
    (unsigned char)'i',
    (unsigned char)' ',
    (unsigned char)'T',
    (unsigned char)'h',
    (unsigned char)'e',
    (unsigned char)'r',
    (unsigned char)'e',
    (unsigned char)'\000'},
   {(unsigned char)'w',
    (unsigned char)'h',
    (unsigned char)'a',
    (unsigned char)'t',
    (unsigned char)' ',
    (unsigned char)'d',
    (unsigned char)'o',
    (unsigned char)' ',
    (unsigned char)'y',
    (unsigned char)'a',
    (unsigned char)' ',
    (unsigned char)'w',
    (unsigned char)'a',
    (unsigned char)'n',
    (unsigned char)'t',
    (unsigned char)' ',
    (unsigned char)'f',
    (unsigned char)'o',
    (unsigned char)'r',
    (unsigned char)' ',
    (unsigned char)'n',
    (unsigned char)'o',
    (unsigned char)'t',
    (unsigned char)'h',
    (unsigned char)'i',
    (unsigned char)'n',
    (unsigned char)'g',
    (unsigned char)'?',
    (unsigned char)'\000'},
   {(unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\335',
    (unsigned char)'\000'},
   {(unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\315',
    (unsigned char)'\000'},
   {(unsigned char)'T',
    (unsigned char)'e',
    (unsigned char)'s',
    (unsigned char)'t',
    (unsigned char)' ',
    (unsigned char)'W',
    (unsigned char)'i',
    (unsigned char)'t',
    (unsigned char)'h',
    (unsigned char)' ',
    (unsigned char)'T',
    (unsigned char)'r',
    (unsigned char)'u',
    (unsigned char)'n',
    (unsigned char)'c',
    (unsigned char)'a',
    (unsigned char)'t',
    (unsigned char)'i',
    (unsigned char)'o',
    (unsigned char)'n',
    (unsigned char)'\000'},
   {(unsigned char)'T',
    (unsigned char)'e',
    (unsigned char)'s',
    (unsigned char)'t',
    (unsigned char)' ',
    (unsigned char)'U',
    (unsigned char)'s',
    (unsigned char)'i',
    (unsigned char)'n',
    (unsigned char)'g',
    (unsigned char)' ',
    (unsigned char)'L',
    (unsigned char)'a',
    (unsigned char)'r',
    (unsigned char)'g',
    (unsigned char)'e',
    (unsigned char)'r',
    (unsigned char)' ',
    (unsigned char)'T',
    (unsigned char)'h',
    (unsigned char)'a',
    (unsigned char)'n',
    (unsigned char)' ',
    (unsigned char)'B',
    (unsigned char)'l',
    (unsigned char)'o',
    (unsigned char)'c',
    (unsigned char)'k',
    (unsigned char)'-',
    (unsigned char)'S',
    (unsigned char)'i',
    (unsigned char)'z',
    (unsigned char)'e',
    (unsigned char)' ',
    (unsigned char)'K',
    (unsigned char)'e',
    (unsigned char)'y',
    (unsigned char)' ',
    (unsigned char)'-',
    (unsigned char)' ',
    (unsigned char)'H',
    (unsigned char)'a',
    (unsigned char)'s',
    (unsigned char)'h',
    (unsigned char)' ',
    (unsigned char)'K',
    (unsigned char)'e',
    (unsigned char)'y',
    (unsigned char)' ',
    (unsigned char)'F',
    (unsigned char)'i',
    (unsigned char)'r',
    (unsigned char)'s',
    (unsigned char)'t',
    (unsigned char)'\000'},
   {(unsigned char)'T',
    (unsigned char)'h',
    (unsigned char)'i',
    (unsigned char)'s',
    (unsigned char)' ',
    (unsigned char)'i',
    (unsigned char)'s',
    (unsigned char)' ',
    (unsigned char)'a',
    (unsigned char)' ',
    (unsigned char)'t',
    (unsigned char)'e',
    (unsigned char)'s',
    (unsigned char)'t',
    (unsigned char)' ',
    (unsigned char)'u',
    (unsigned char)'s',
    (unsigned char)'i',
    (unsigned char)'n',
    (unsigned char)'g',
    (unsigned char)' ',
    (unsigned char)'a',
    (unsigned char)' ',
    (unsigned char)'l',
    (unsigned char)'a',
    (unsigned char)'r',
    (unsigned char)'g',
    (unsigned char)'e',
    (unsigned char)'r',
    (unsigned char)' ',
    (unsigned char)'t',
    (unsigned char)'h',
    (unsigned char)'a',
    (unsigned char)'n',
    (unsigned char)' ',
    (unsigned char)'b',
    (unsigned char)'l',
    (unsigned char)'o',
    (unsigned char)'c',
    (unsigned char)'k',
    (unsigned char)'-',
    (unsigned char)'s',
    (unsigned char)'i',
    (unsigned char)'z',
    (unsigned char)'e',
    (unsigned char)' ',
    (unsigned char)'k',
    (unsigned char)'e',
    (unsigned char)'y',
    (unsigned char)' ',
    (unsigned char)'a',
    (unsigned char)'n',
    (unsigned char)'d',
    (unsigned char)' ',
    (unsigned char)'a',
    (unsigned char)' ',
    (unsigned char)'l',
    (unsigned char)'a',
    (unsigned char)'r',
    (unsigned char)'g',
    (unsigned char)'e',
    (unsigned char)'r',
    (unsigned char)' ',
    (unsigned char)'t',
    (unsigned char)'h',
    (unsigned char)'a',
    (unsigned char)'n',
    (unsigned char)' ',
    (unsigned char)'b',
    (unsigned char)'l',
    (unsigned char)'o',
    (unsigned char)'c',
    (unsigned char)'k',
    (unsigned char)'-',
    (unsigned char)'s',
    (unsigned char)'i',
    (unsigned char)'z',
    (unsigned char)'e',
    (unsigned char)' ',
    (unsigned char)'d',
    (unsigned char)'a',
    (unsigned char)'t',
    (unsigned char)'a',
    (unsigned char)'.',
    (unsigned char)' ',
    (unsigned char)'T',
    (unsigned char)'h',
    (unsigned char)'e',
    (unsigned char)' ',
    (unsigned char)'k',
    (unsigned char)'e',
    (unsigned char)'y',
    (unsigned char)' ',
    (unsigned char)'n',
    (unsigned char)'e',
    (unsigned char)'e',
    (unsigned char)'d',
    (unsigned char)'s',
    (unsigned char)' ',
    (unsigned char)'t',
    (unsigned char)'o',
    (unsigned char)' ',
    (unsigned char)'b',
    (unsigned char)'e',
    (unsigned char)' ',
    (unsigned char)'h',
    (unsigned char)'a',
    (unsigned char)'s',
    (unsigned char)'h',
    (unsigned char)'e',
    (unsigned char)'d',
    (unsigned char)' ',
    (unsigned char)'b',
    (unsigned char)'e',
    (unsigned char)'f',
    (unsigned char)'o',
    (unsigned char)'r',
    (unsigned char)'e',
    (unsigned char)' ',
    (unsigned char)'b',
    (unsigned char)'e',
    (unsigned char)'i',
    (unsigned char)'n',
    (unsigned char)'g',
    (unsigned char)' ',
    (unsigned char)'u',
    (unsigned char)'s',
    (unsigned char)'e',
    (unsigned char)'d',
    (unsigned char)' ',
    (unsigned char)'b',
    (unsigned char)'y',
    (unsigned char)' ',
    (unsigned char)'t',
    (unsigned char)'h',
    (unsigned char)'e',
    (unsigned char)' ',
    (unsigned char)'H',
    (unsigned char)'M',
    (unsigned char)'A',
    (unsigned char)'C',
    (unsigned char)' ',
    (unsigned char)'a',
    (unsigned char)'l',
    (unsigned char)'g',
    (unsigned char)'o',
    (unsigned char)'r',
    (unsigned char)'i',
    (unsigned char)'t',
    (unsigned char)'h',
    (unsigned char)'m',
    (unsigned char)'.',
    (unsigned char)'\000'}};
static int const sha4_hmac_test_buflen[7] = {8, 28, 50, 50, 20, 54, 152};
static unsigned char const sha4_hmac_test_sum[14][64] =
  {{(unsigned char)0xAF,
    (unsigned char)0xD0,
    (unsigned char)0x39,
    (unsigned char)0x44,
    (unsigned char)0xD8,
    (unsigned char)0x48,
    (unsigned char)0x95,
    (unsigned char)0x62,
    (unsigned char)0x6B,
    (unsigned char)0x08,
    (unsigned char)0x25,
    (unsigned char)0xF4,
    (unsigned char)0xAB,
    (unsigned char)0x46,
    (unsigned char)0x90,
    (unsigned char)0x7F,
    (unsigned char)0x15,
    (unsigned char)0xF9,
    (unsigned char)0xDA,
    (unsigned char)0xDB,
    (unsigned char)0xE4,
    (unsigned char)0x10,
    (unsigned char)0x1E,
    (unsigned char)0xC6,
    (unsigned char)0x82,
    (unsigned char)0xAA,
    (unsigned char)0x03,
    (unsigned char)0x4C,
    (unsigned char)0x7C,
    (unsigned char)0xEB,
    (unsigned char)0xC5,
    (unsigned char)0x9C,
    (unsigned char)0xFA,
    (unsigned char)0xEA,
    (unsigned char)0x9E,
    (unsigned char)0xA9,
    (unsigned char)0x07,
    (unsigned char)0x6E,
    (unsigned char)0xDE,
    (unsigned char)0x7F,
    (unsigned char)0x4A,
    (unsigned char)0xF1,
    (unsigned char)0x52,
    (unsigned char)0xE8,
    (unsigned char)0xB2,
    (unsigned char)0xFA,
    (unsigned char)0x9C,
    (unsigned char)0xB6},
   {(unsigned char)0xAF,
    (unsigned char)0x45,
    (unsigned char)0xD2,
    (unsigned char)0xE3,
    (unsigned char)0x76,
    (unsigned char)0x48,
    (unsigned char)0x40,
    (unsigned char)0x31,
    (unsigned char)0x61,
    (unsigned char)0x7F,
    (unsigned char)0x78,
    (unsigned char)0xD2,
    (unsigned char)0xB5,
    (unsigned char)0x8A,
    (unsigned char)0x6B,
    (unsigned char)0x1B,
    (unsigned char)0x9C,
    (unsigned char)0x7E,
    (unsigned char)0xF4,
    (unsigned char)0x64,
    (unsigned char)0xF5,
    (unsigned char)0xA0,
    (unsigned char)0x1B,
    (unsigned char)0x47,
    (unsigned char)0xE4,
    (unsigned char)0x2E,
    (unsigned char)0xC3,
    (unsigned char)0x73,
    (unsigned char)0x63,
    (unsigned char)0x22,
    (unsigned char)0x44,
    (unsigned char)0x5E,
    (unsigned char)0x8E,
    (unsigned char)0x22,
    (unsigned char)0x40,
    (unsigned char)0xCA,
    (unsigned char)0x5E,
    (unsigned char)0x69,
    (unsigned char)0xE2,
    (unsigned char)0xC7,
    (unsigned char)0x8B,
    (unsigned char)0x32,
    (unsigned char)0x39,
    (unsigned char)0xEC,
    (unsigned char)0xFA,
    (unsigned char)0xB2,
    (unsigned char)0x16,
    (unsigned char)0x49},
   {(unsigned char)0x88,
    (unsigned char)0x06,
    (unsigned char)0x26,
    (unsigned char)0x08,
    (unsigned char)0xD3,
    (unsigned char)0xE6,
    (unsigned char)0xAD,
    (unsigned char)0x8A,
    (unsigned char)0x0A,
    (unsigned char)0xA2,
    (unsigned char)0xAC,
    (unsigned char)0xE0,
    (unsigned char)0x14,
    (unsigned char)0xC8,
    (unsigned char)0xA8,
    (unsigned char)0x6F,
    (unsigned char)0x0A,
    (unsigned char)0xA6,
    (unsigned char)0x35,
    (unsigned char)0xD9,
    (unsigned char)0x47,
    (unsigned char)0xAC,
    (unsigned char)0x9F,
    (unsigned char)0xEB,
    (unsigned char)0xE8,
    (unsigned char)0x3E,
    (unsigned char)0xF4,
    (unsigned char)0xE5,
    (unsigned char)0x59,
    (unsigned char)0x66,
    (unsigned char)0x14,
    (unsigned char)0x4B,
    (unsigned char)0x2A,
    (unsigned char)0x5A,
    (unsigned char)0xB3,
    (unsigned char)0x9D,
    (unsigned char)0xC1,
    (unsigned char)0x38,
    (unsigned char)0x14,
    (unsigned char)0xB9,
    (unsigned char)0x4E,
    (unsigned char)0x3A,
    (unsigned char)0xB6,
    (unsigned char)0xE1,
    (unsigned char)0x01,
    (unsigned char)0xA3,
    (unsigned char)0x4F,
    (unsigned char)0x27},
   {(unsigned char)0x3E,
    (unsigned char)0x8A,
    (unsigned char)0x69,
    (unsigned char)0xB7,
    (unsigned char)0x78,
    (unsigned char)0x3C,
    (unsigned char)0x25,
    (unsigned char)0x85,
    (unsigned char)0x19,
    (unsigned char)0x33,
    (unsigned char)0xAB,
    (unsigned char)0x62,
    (unsigned char)0x90,
    (unsigned char)0xAF,
    (unsigned char)0x6C,
    (unsigned char)0xA7,
    (unsigned char)0x7A,
    (unsigned char)0x99,
    (unsigned char)0x81,
    (unsigned char)0x48,
    (unsigned char)0x08,
    (unsigned char)0x50,
    (unsigned char)0x00,
    (unsigned char)0x9C,
    (unsigned char)0xC5,
    (unsigned char)0x57,
    (unsigned char)0x7C,
    (unsigned char)0x6E,
    (unsigned char)0x1F,
    (unsigned char)0x57,
    (unsigned char)0x3B,
    (unsigned char)0x4E,
    (unsigned char)0x68,
    (unsigned char)0x01,
    (unsigned char)0xDD,
    (unsigned char)0x23,
    (unsigned char)0xC4,
    (unsigned char)0xA7,
    (unsigned char)0xD6,
    (unsigned char)0x79,
    (unsigned char)0xCC,
    (unsigned char)0xF8,
    (unsigned char)0xA3,
    (unsigned char)0x86,
    (unsigned char)0xC6,
    (unsigned char)0x74,
    (unsigned char)0xCF,
    (unsigned char)0xFB},
   {(unsigned char)0x3A,
    (unsigned char)0xBF,
    (unsigned char)0x34,
    (unsigned char)0xC3,
    (unsigned char)0x50,
    (unsigned char)0x3B,
    (unsigned char)0x2A,
    (unsigned char)0x23,
    (unsigned char)0xA4,
    (unsigned char)0x6E,
    (unsigned char)0xFC,
    (unsigned char)0x61,
    (unsigned char)0x9B,
    (unsigned char)0xAE,
    (unsigned char)0xF8,
    (unsigned char)0x97},
   {(unsigned char)0x4E,
    (unsigned char)0xCE,
    (unsigned char)0x08,
    (unsigned char)0x44,
    (unsigned char)0x85,
    (unsigned char)0x81,
    (unsigned char)0x3E,
    (unsigned char)0x90,
    (unsigned char)0x88,
    (unsigned char)0xD2,
    (unsigned char)0xC6,
    (unsigned char)0x3A,
    (unsigned char)0x04,
    (unsigned char)0x1B,
    (unsigned char)0xC5,
    (unsigned char)0xB4,
    (unsigned char)0x4F,
    (unsigned char)0x9E,
    (unsigned char)0xF1,
    (unsigned char)0x01,
    (unsigned char)0x2A,
    (unsigned char)0x2B,
    (unsigned char)0x58,
    (unsigned char)0x8F,
    (unsigned char)0x3C,
    (unsigned char)0xD1,
    (unsigned char)0x1F,
    (unsigned char)0x05,
    (unsigned char)0x03,
    (unsigned char)0x3A,
    (unsigned char)0xC4,
    (unsigned char)0xC6,
    (unsigned char)0x0C,
    (unsigned char)0x2E,
    (unsigned char)0xF6,
    (unsigned char)0xAB,
    (unsigned char)0x40,
    (unsigned char)0x30,
    (unsigned char)0xFE,
    (unsigned char)0x82,
    (unsigned char)0x96,
    (unsigned char)0x24,
    (unsigned char)0x8D,
    (unsigned char)0xF1,
    (unsigned char)0x63,
    (unsigned char)0xF4,
    (unsigned char)0x49,
    (unsigned char)0x52},
   {(unsigned char)0x66,
    (unsigned char)0x17,
    (unsigned char)0x17,
    (unsigned char)0x8E,
    (unsigned char)0x94,
    (unsigned char)0x1F,
    (unsigned char)0x02,
    (unsigned char)0x0D,
    (unsigned char)0x35,
    (unsigned char)0x1E,
    (unsigned char)0x2F,
    (unsigned char)0x25,
    (unsigned char)0x4E,
    (unsigned char)0x8F,
    (unsigned char)0xD3,
    (unsigned char)0x2C,
    (unsigned char)0x60,
    (unsigned char)0x24,
    (unsigned char)0x20,
    (unsigned char)0xFE,
    (unsigned char)0xB0,
    (unsigned char)0xB8,
    (unsigned char)0xFB,
    (unsigned char)0x9A,
    (unsigned char)0xDC,
    (unsigned char)0xCE,
    (unsigned char)0xBB,
    (unsigned char)0x82,
    (unsigned char)0x46,
    (unsigned char)0x1E,
    (unsigned char)0x99,
    (unsigned char)0xC5,
    (unsigned char)0xA6,
    (unsigned char)0x78,
    (unsigned char)0xCC,
    (unsigned char)0x31,
    (unsigned char)0xE7,
    (unsigned char)0x99,
    (unsigned char)0x17,
    (unsigned char)0x6D,
    (unsigned char)0x38,
    (unsigned char)0x60,
    (unsigned char)0xE6,
    (unsigned char)0x11,
    (unsigned char)0x0C,
    (unsigned char)0x46,
    (unsigned char)0x52,
    (unsigned char)0x3E},
   {(unsigned char)0x87,
    (unsigned char)0xAA,
    (unsigned char)0x7C,
    (unsigned char)0xDE,
    (unsigned char)0xA5,
    (unsigned char)0xEF,
    (unsigned char)0x61,
    (unsigned char)0x9D,
    (unsigned char)0x4F,
    (unsigned char)0xF0,
    (unsigned char)0xB4,
    (unsigned char)0x24,
    (unsigned char)0x1A,
    (unsigned char)0x1D,
    (unsigned char)0x6C,
    (unsigned char)0xB0,
    (unsigned char)0x23,
    (unsigned char)0x79,
    (unsigned char)0xF4,
    (unsigned char)0xE2,
    (unsigned char)0xCE,
    (unsigned char)0x4E,
    (unsigned char)0xC2,
    (unsigned char)0x78,
    (unsigned char)0x7A,
    (unsigned char)0xD0,
    (unsigned char)0xB3,
    (unsigned char)0x05,
    (unsigned char)0x45,
    (unsigned char)0xE1,
    (unsigned char)0x7C,
    (unsigned char)0xDE,
    (unsigned char)0xDA,
    (unsigned char)0xA8,
    (unsigned char)0x33,
    (unsigned char)0xB7,
    (unsigned char)0xD6,
    (unsigned char)0xB8,
    (unsigned char)0xA7,
    (unsigned char)0x02,
    (unsigned char)0x03,
    (unsigned char)0x8B,
    (unsigned char)0x27,
    (unsigned char)0x4E,
    (unsigned char)0xAE,
    (unsigned char)0xA3,
    (unsigned char)0xF4,
    (unsigned char)0xE4,
    (unsigned char)0xBE,
    (unsigned char)0x9D,
    (unsigned char)0x91,
    (unsigned char)0x4E,
    (unsigned char)0xEB,
    (unsigned char)0x61,
    (unsigned char)0xF1,
    (unsigned char)0x70,
    (unsigned char)0x2E,
    (unsigned char)0x69,
    (unsigned char)0x6C,
    (unsigned char)0x20,
    (unsigned char)0x3A,
    (unsigned char)0x12,
    (unsigned char)0x68,
    (unsigned char)0x54},
   {(unsigned char)0x16,
    (unsigned char)0x4B,
    (unsigned char)0x7A,
    (unsigned char)0x7B,
    (unsigned char)0xFC,
    (unsigned char)0xF8,
    (unsigned char)0x19,
    (unsigned char)0xE2,
    (unsigned char)0xE3,
    (unsigned char)0x95,
    (unsigned char)0xFB,
    (unsigned char)0xE7,
    (unsigned char)0x3B,
    (unsigned char)0x56,
    (unsigned char)0xE0,
    (unsigned char)0xA3,
    (unsigned char)0x87,
    (unsigned char)0xBD,
    (unsigned char)0x64,
    (unsigned char)0x22,
    (unsigned char)0x2E,
    (unsigned char)0x83,
    (unsigned char)0x1F,
    (unsigned char)0xD6,
    (unsigned char)0x10,
    (unsigned char)0x27,
    (unsigned char)0x0C,
    (unsigned char)0xD7,
    (unsigned char)0xEA,
    (unsigned char)0x25,
    (unsigned char)0x05,
    (unsigned char)0x54,
    (unsigned char)0x97,
    (unsigned char)0x58,
    (unsigned char)0xBF,
    (unsigned char)0x75,
    (unsigned char)0xC0,
    (unsigned char)0x5A,
    (unsigned char)0x99,
    (unsigned char)0x4A,
    (unsigned char)0x6D,
    (unsigned char)0x03,
    (unsigned char)0x4F,
    (unsigned char)0x65,
    (unsigned char)0xF8,
    (unsigned char)0xF0,
    (unsigned char)0xE6,
    (unsigned char)0xFD,
    (unsigned char)0xCA,
    (unsigned char)0xEA,
    (unsigned char)0xB1,
    (unsigned char)0xA3,
    (unsigned char)0x4D,
    (unsigned char)0x4A,
    (unsigned char)0x6B,
    (unsigned char)0x4B,
    (unsigned char)0x63,
    (unsigned char)0x6E,
    (unsigned char)0x07,
    (unsigned char)0x0A,
    (unsigned char)0x38,
    (unsigned char)0xBC,
    (unsigned char)0xE7,
    (unsigned char)0x37},
   {(unsigned char)0xFA,
    (unsigned char)0x73,
    (unsigned char)0xB0,
    (unsigned char)0x08,
    (unsigned char)0x9D,
    (unsigned char)0x56,
    (unsigned char)0xA2,
    (unsigned char)0x84,
    (unsigned char)0xEF,
    (unsigned char)0xB0,
    (unsigned char)0xF0,
    (unsigned char)0x75,
    (unsigned char)0x6C,
    (unsigned char)0x89,
    (unsigned char)0x0B,
    (unsigned char)0xE9,
    (unsigned char)0xB1,
    (unsigned char)0xB5,
    (unsigned char)0xDB,
    (unsigned char)0xDD,
    (unsigned char)0x8E,
    (unsigned char)0xE8,
    (unsigned char)0x1A,
    (unsigned char)0x36,
    (unsigned char)0x55,
    (unsigned char)0xF8,
    (unsigned char)0x3E,
    (unsigned char)0x33,
    (unsigned char)0xB2,
    (unsigned char)0x27,
    (unsigned char)0x9D,
    (unsigned char)0x39,
    (unsigned char)0xBF,
    (unsigned char)0x3E,
    (unsigned char)0x84,
    (unsigned char)0x82,
    (unsigned char)0x79,
    (unsigned char)0xA7,
    (unsigned char)0x22,
    (unsigned char)0xC8,
    (unsigned char)0x06,
    (unsigned char)0xB4,
    (unsigned char)0x85,
    (unsigned char)0xA4,
    (unsigned char)0x7E,
    (unsigned char)0x67,
    (unsigned char)0xC8,
    (unsigned char)0x07,
    (unsigned char)0xB9,
    (unsigned char)0x46,
    (unsigned char)0xA3,
    (unsigned char)0x37,
    (unsigned char)0xBE,
    (unsigned char)0xE8,
    (unsigned char)0x94,
    (unsigned char)0x26,
    (unsigned char)0x74,
    (unsigned char)0x27,
    (unsigned char)0x88,
    (unsigned char)0x59,
    (unsigned char)0xE1,
    (unsigned char)0x32,
    (unsigned char)0x92,
    (unsigned char)0xFB},
   {(unsigned char)0xB0,
    (unsigned char)0xBA,
    (unsigned char)0x46,
    (unsigned char)0x56,
    (unsigned char)0x37,
    (unsigned char)0x45,
    (unsigned char)0x8C,
    (unsigned char)0x69,
    (unsigned char)0x90,
    (unsigned char)0xE5,
    (unsigned char)0xA8,
    (unsigned char)0xC5,
    (unsigned char)0xF6,
    (unsigned char)0x1D,
    (unsigned char)0x4A,
    (unsigned char)0xF7,
    (unsigned char)0xE5,
    (unsigned char)0x76,
    (unsigned char)0xD9,
    (unsigned char)0x7F,
    (unsigned char)0xF9,
    (unsigned char)0x4B,
    (unsigned char)0x87,
    (unsigned char)0x2D,
    (unsigned char)0xE7,
    (unsigned char)0x6F,
    (unsigned char)0x80,
    (unsigned char)0x50,
    (unsigned char)0x36,
    (unsigned char)0x1E,
    (unsigned char)0xE3,
    (unsigned char)0xDB,
    (unsigned char)0xA9,
    (unsigned char)0x1C,
    (unsigned char)0xA5,
    (unsigned char)0xC1,
    (unsigned char)0x1A,
    (unsigned char)0xA2,
    (unsigned char)0x5E,
    (unsigned char)0xB4,
    (unsigned char)0xD6,
    (unsigned char)0x79,
    (unsigned char)0x27,
    (unsigned char)0x5C,
    (unsigned char)0xC5,
    (unsigned char)0x78,
    (unsigned char)0x80,
    (unsigned char)0x63,
    (unsigned char)0xA5,
    (unsigned char)0xF1,
    (unsigned char)0x97,
    (unsigned char)0x41,
    (unsigned char)0x12,
    (unsigned char)0x0C,
    (unsigned char)0x4F,
    (unsigned char)0x2D,
    (unsigned char)0xE2,
    (unsigned char)0xAD,
    (unsigned char)0xEB,
    (unsigned char)0xEB,
    (unsigned char)0x10,
    (unsigned char)0xA2,
    (unsigned char)0x98,
    (unsigned char)0xDD},
   {(unsigned char)0x41,
    (unsigned char)0x5F,
    (unsigned char)0xAD,
    (unsigned char)0x62,
    (unsigned char)0x71,
    (unsigned char)0x58,
    (unsigned char)0x0A,
    (unsigned char)0x53,
    (unsigned char)0x1D,
    (unsigned char)0x41,
    (unsigned char)0x79,
    (unsigned char)0xBC,
    (unsigned char)0x89,
    (unsigned char)0x1D,
    (unsigned char)0x87,
    (unsigned char)0xA6},
   {(unsigned char)0x80,
    (unsigned char)0xB2,
    (unsigned char)0x42,
    (unsigned char)0x63,
    (unsigned char)0xC7,
    (unsigned char)0xC1,
    (unsigned char)0xA3,
    (unsigned char)0xEB,
    (unsigned char)0xB7,
    (unsigned char)0x14,
    (unsigned char)0x93,
    (unsigned char)0xC1,
    (unsigned char)0xDD,
    (unsigned char)0x7B,
    (unsigned char)0xE8,
    (unsigned char)0xB4,
    (unsigned char)0x9B,
    (unsigned char)0x46,
    (unsigned char)0xD1,
    (unsigned char)0xF4,
    (unsigned char)0x1B,
    (unsigned char)0x4A,
    (unsigned char)0xEE,
    (unsigned char)0xC1,
    (unsigned char)0x12,
    (unsigned char)0x1B,
    (unsigned char)0x01,
    (unsigned char)0x37,
    (unsigned char)0x83,
    (unsigned char)0xF8,
    (unsigned char)0xF3,
    (unsigned char)0x52,
    (unsigned char)0x6B,
    (unsigned char)0x56,
    (unsigned char)0xD0,
    (unsigned char)0x37,
    (unsigned char)0xE0,
    (unsigned char)0x5F,
    (unsigned char)0x25,
    (unsigned char)0x98,
    (unsigned char)0xBD,
    (unsigned char)0x0F,
    (unsigned char)0xD2,
    (unsigned char)0x21,
    (unsigned char)0x5D,
    (unsigned char)0x6A,
    (unsigned char)0x1E,
    (unsigned char)0x52,
    (unsigned char)0x95,
    (unsigned char)0xE6,
    (unsigned char)0x4F,
    (unsigned char)0x73,
    (unsigned char)0xF6,
    (unsigned char)0x3F,
    (unsigned char)0x0A,
    (unsigned char)0xEC,
    (unsigned char)0x8B,
    (unsigned char)0x91,
    (unsigned char)0x5A,
    (unsigned char)0x98,
    (unsigned char)0x5D,
    (unsigned char)0x78,
    (unsigned char)0x65,
    (unsigned char)0x98},
   {(unsigned char)0xE3,
    (unsigned char)0x7B,
    (unsigned char)0x6A,
    (unsigned char)0x77,
    (unsigned char)0x5D,
    (unsigned char)0xC8,
    (unsigned char)0x7D,
    (unsigned char)0xBA,
    (unsigned char)0xA4,
    (unsigned char)0xDF,
    (unsigned char)0xA9,
    (unsigned char)0xF9,
    (unsigned char)0x6E,
    (unsigned char)0x5E,
    (unsigned char)0x3F,
    (unsigned char)0xFD,
    (unsigned char)0xDE,
    (unsigned char)0xBD,
    (unsigned char)0x71,
    (unsigned char)0xF8,
    (unsigned char)0x86,
    (unsigned char)0x72,
    (unsigned char)0x89,
    (unsigned char)0x86,
    (unsigned char)0x5D,
    (unsigned char)0xF5,
    (unsigned char)0xA3,
    (unsigned char)0x2D,
    (unsigned char)0x20,
    (unsigned char)0xCD,
    (unsigned char)0xC9,
    (unsigned char)0x44,
    (unsigned char)0xB6,
    (unsigned char)0x02,
    (unsigned char)0x2C,
    (unsigned char)0xAC,
    (unsigned char)0x3C,
    (unsigned char)0x49,
    (unsigned char)0x82,
    (unsigned char)0xB1,
    (unsigned char)0x0D,
    (unsigned char)0x5E,
    (unsigned char)0xEB,
    (unsigned char)0x55,
    (unsigned char)0xC3,
    (unsigned char)0xE4,
    (unsigned char)0xDE,
    (unsigned char)0x15,
    (unsigned char)0x13,
    (unsigned char)0x46,
    (unsigned char)0x76,
    (unsigned char)0xFB,
    (unsigned char)0x6D,
    (unsigned char)0xE0,
    (unsigned char)0x44,
    (unsigned char)0x60,
    (unsigned char)0x65,
    (unsigned char)0xC9,
    (unsigned char)0x74,
    (unsigned char)0x40,
    (unsigned char)0xFA,
    (unsigned char)0x8C,
    (unsigned char)0x6A,
    (unsigned char)0x58}};
/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_119(char const * restrict format, int param0, int param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_120(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_121(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_122(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param1),
            (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param1, param0;
 */
int printf_va_123(char const * restrict format, int param0, int param1);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_124(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_125(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_126(char const * restrict format);

int sha4_self_test(int verbose)
{
  int __retres;
  int i;
  int j;
  int k;
  int buflen;
  unsigned char buf[1024];
  unsigned char sha4sum[64];
  sha4_context ctx;
  i = 0;
  while (i < 6) {
    {
      int tmp;
      j = i % 3;
      k = i < 3;
      if (verbose != 0) printf("  SHA-%d test #%d: ",512 - k * 128,j + 1); /* printf_va_119 */
      sha4_starts(& ctx,k);
      if (j == 2) {
        buflen = 1000;
        memset((void *)(buf),'a',(size_t)buflen);
        j = 0;
        while (j < 1000) {
          sha4_update(& ctx,(unsigned char const *)(buf),(size_t)buflen);
          j ++;
        }
      }
      else sha4_update(& ctx,(unsigned char const *)(sha4_test_buf[j]),
                       (size_t)sha4_test_buflen[j]);
      sha4_finish(& ctx,sha4sum);
      tmp = memcmp((void const *)(sha4sum),(void const *)(sha4_test_sum[i]),
                   (size_t)(64 - k * 16));
      if (tmp != 0) {
        if (verbose != 0) printf("failed\n"); /* printf_va_120 */
        __retres = 1;
        goto return_label;
      }
      if (verbose != 0) printf("passed\n"); /* printf_va_121 */
    }
    i ++;
  }
  if (verbose != 0) printf("\n"); /* printf_va_122 */
  i = 0;
  while (i < 14) {
    {
      int tmp_0;
      j = i % 7;
      k = i < 7;
      if (verbose != 0) printf("  HMAC-SHA-%d test #%d: ",512 - k * 128,
                               j + 1); /* printf_va_123 */
      if (j == 5) goto _LOR;
      else 
        if (j == 6) {
          _LOR:
          {
            buflen = 131;
            memset((void *)(buf),'\252',(size_t)buflen);
            sha4_hmac_starts(& ctx,(unsigned char const *)(buf),
                             (size_t)buflen,k);
          }
        }
        else sha4_hmac_starts(& ctx,
                              (unsigned char const *)(sha4_hmac_test_key[j]),
                              (size_t)sha4_hmac_test_keylen[j],k);
      sha4_hmac_update(& ctx,(unsigned char const *)(sha4_hmac_test_buf[j]),
                       (size_t)sha4_hmac_test_buflen[j]);
      sha4_hmac_finish(& ctx,sha4sum);
      if (j == 4) buflen = 16; else buflen = 64 - k * 16;
      tmp_0 = memcmp((void const *)(sha4sum),
                     (void const *)(sha4_hmac_test_sum[i]),(size_t)buflen);
      if (tmp_0 != 0) {
        if (verbose != 0) printf("failed\n"); /* printf_va_124 */
        __retres = 1;
        goto return_label;
      }
      if (verbose != 0) printf("passed\n"); /* printf_va_125 */
    }
    i ++;
  }
  if (verbose != 0) printf("\n"); /* printf_va_126 */
  __retres = 0;
  return_label: return __retres;
}

__inline static int const *ssl_list_ciphersuites_2(void)
{
  int const *__retres;
  __retres = (int const *)(ssl_default_ciphersuites);
  return __retres;
}

static int ssl_write_client_hello(ssl_context *ssl)
{
  int __retres;
  int ret;
  size_t i;
  size_t n;
  unsigned char *buf;
  unsigned char *p;
  time_t t;
  unsigned char *tmp;
  unsigned char *tmp_0;
  unsigned char *tmp_1;
  unsigned char *tmp_2;
  unsigned char *tmp_3;
  unsigned char *tmp_4;
  unsigned char *tmp_5;
  unsigned char *tmp_7;
  unsigned char *tmp_8;
  unsigned char *tmp_11;
  unsigned char *tmp_12;
  ssl->major_ver = 3;
  ssl->minor_ver = 0;
  if (ssl->max_major_ver == 0) 
    if (ssl->max_minor_ver == 0) {
      ssl->max_major_ver = 3;
      ssl->max_minor_ver = 2;
    }
  buf = ssl->out_msg;
  p = buf + 4;
  tmp = p;
  p ++;
  *tmp = (unsigned char)ssl->max_major_ver;
  tmp_0 = p;
  p ++;
  *tmp_0 = (unsigned char)ssl->max_minor_ver;
  t = time((time_t *)0);
  tmp_1 = p;
  p ++;
  *tmp_1 = (unsigned char)(t >> 24);
  tmp_2 = p;
  p ++;
  *tmp_2 = (unsigned char)(t >> 16);
  tmp_3 = p;
  p ++;
  *tmp_3 = (unsigned char)(t >> 8);
  tmp_4 = p;
  p ++;
  *tmp_4 = (unsigned char)t;
  ret = (*(ssl->f_rng))(ssl->p_rng,p,(size_t)28);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  p += 28;
  memcpy((void *)(ssl->randbytes),(void const *)(buf + 6),(size_t)32);
  n = (ssl->session)->length;
  if (n < (size_t)16) n = (size_t)0;
  else 
    if (n > (size_t)32) n = (size_t)0;
    else 
      if (ssl->resume == 0) n = (size_t)0;
      else 
        if (ssl->timeout != 0) 
          if (t - (ssl->session)->start > (time_t)ssl->timeout) n = (size_t)0;
  tmp_5 = p;
  p ++;
  *tmp_5 = (unsigned char)n;
  i = (size_t)0;
  while (i < n) {
    unsigned char *tmp_6;
    tmp_6 = p;
    p ++;
    *tmp_6 = (ssl->session)->id[i];
    i ++;
  }
  n = (size_t)0;
  while (*(ssl->ciphersuites + n) != 0) n ++;
  tmp_7 = p;
  p ++;
  *tmp_7 = (unsigned char)(n >> 7);
  tmp_8 = p;
  p ++;
  *tmp_8 = (unsigned char)(n << 1);
  i = (size_t)0;
  while (i < n) {
    {
      unsigned char *tmp_9;
      unsigned char *tmp_10;
      tmp_9 = p;
      p ++;
      *tmp_9 = (unsigned char)(*(ssl->ciphersuites + i) >> 8);
      tmp_10 = p;
      p ++;
      *tmp_10 = (unsigned char)*(ssl->ciphersuites + i);
    }
    i ++;
  }
  tmp_11 = p;
  p ++;
  *tmp_11 = (unsigned char)1;
  tmp_12 = p;
  p ++;
  *tmp_12 = (unsigned char)0;
  if (ssl->hostname != (unsigned char *)0) {
    unsigned char *tmp_13;
    unsigned char *tmp_14;
    unsigned char *tmp_15;
    unsigned char *tmp_16;
    unsigned char *tmp_17;
    unsigned char *tmp_18;
    unsigned char *tmp_19;
    unsigned char *tmp_20;
    unsigned char *tmp_21;
    unsigned char *tmp_22;
    unsigned char *tmp_23;
    tmp_13 = p;
    p ++;
    *tmp_13 = (unsigned char)(((ssl->hostname_len + (size_t)9) >> 8) & (unsigned int)0xFF);
    tmp_14 = p;
    p ++;
    *tmp_14 = (unsigned char)((ssl->hostname_len + (size_t)9) & (unsigned int)0xFF);
    tmp_15 = p;
    p ++;
    *tmp_15 = (unsigned char)((0 >> 8) & 0xFF);
    tmp_16 = p;
    p ++;
    *tmp_16 = (unsigned char)(0 & 0xFF);
    tmp_17 = p;
    p ++;
    *tmp_17 = (unsigned char)(((ssl->hostname_len + (size_t)5) >> 8) & (unsigned int)0xFF);
    tmp_18 = p;
    p ++;
    *tmp_18 = (unsigned char)((ssl->hostname_len + (size_t)5) & (unsigned int)0xFF);
    tmp_19 = p;
    p ++;
    *tmp_19 = (unsigned char)(((ssl->hostname_len + (size_t)3) >> 8) & (unsigned int)0xFF);
    tmp_20 = p;
    p ++;
    *tmp_20 = (unsigned char)((ssl->hostname_len + (size_t)3) & (unsigned int)0xFF);
    tmp_21 = p;
    p ++;
    *tmp_21 = (unsigned char)(0 & 0xFF);
    tmp_22 = p;
    p ++;
    *tmp_22 = (unsigned char)((ssl->hostname_len >> 8) & (unsigned int)0xFF);
    tmp_23 = p;
    p ++;
    *tmp_23 = (unsigned char)(ssl->hostname_len & (unsigned int)0xFF);
    memcpy((void *)p,(void const *)ssl->hostname,ssl->hostname_len);
    p += ssl->hostname_len;
  }
  ssl->out_msglen = (size_t)(p - buf);
  ssl->out_msgtype = 22;
  *(ssl->out_msg + 0) = (unsigned char)1;
  (ssl->state) ++;
  ret = ssl_write_record(ssl);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static int ssl_parse_server_hello(ssl_context *ssl)
{
  int __retres;
  int ret;
  int i;
  size_t n;
  int ext_len;
  unsigned char *buf;
  buf = ssl->in_msg;
  ret = ssl_read_record(ssl);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  if (ssl->in_msgtype != 22) {
    __retres = -0x7700;
    goto return_label;
  }
  if (ssl->in_hslen < (size_t)42) goto _LOR;
  else 
    if ((int)*(buf + 0) != 2) goto _LOR;
    else 
      if ((int)*(buf + 4) != 3) {
        _LOR: {
                __retres = -0x7980;
                goto return_label;
              }
      }
  if ((int)*(buf + 5) > ssl->max_minor_ver) {
    __retres = -0x7980;
    goto return_label;
  }
  ssl->minor_ver = (int)*(buf + 5);
  memcpy((void *)(& ssl->randbytes[32]),(void const *)(buf + 6),(size_t)32);
  n = (size_t)*(buf + 38);
  if (n > (size_t)32) goto _LOR_0;
  else 
    if (ssl->in_hslen > (size_t)42 + n) _LOR_0:
                                        ext_len = (((int)*(buf + ((size_t)42 + n)) << 8) | (int)*(
                                                   buf + ((size_t)43 + n))) + 2;
    else ext_len = 0;
  if (n > (size_t)32) goto _LOR_1;
  else 
    if (ssl->in_hslen != ((size_t)42 + n) + (size_t)ext_len) {
      _LOR_1: {
                __retres = -0x7980;
                goto return_label;
              }
    }
  i = ((int)*(buf + ((size_t)39 + n)) << 8) | (int)*(buf + ((size_t)40 + n));
  if (ssl->resume == 0) goto _LOR_2;
  else 
    if (n == (size_t)0) goto _LOR_2;
    else 
      if ((ssl->session)->ciphersuite != i) goto _LOR_2;
      else 
        if ((ssl->session)->length != n) goto _LOR_2;
        else {
          int tmp;
          tmp = memcmp((void const *)((ssl->session)->id),
                       (void const *)(buf + 39),n);
          if (tmp != 0) {
            _LOR_2:
            {
              (ssl->state) ++;
              ssl->resume = 0;
              (ssl->session)->start = time((time_t *)0);
              (ssl->session)->ciphersuite = i;
              (ssl->session)->length = n;
              memcpy((void *)((ssl->session)->id),(void const *)(buf + 39),n);
            }
          }
          else {
            ssl->state = SSL_SERVER_CHANGE_CIPHER_SPEC;
            ret = ssl_derive_keys(ssl);
            if (ret != 0) {
              __retres = ret;
              goto return_label;
            }
          }
        }
  i = 0;
  while (1) {
    {
      int tmp_0;
      if (*(ssl->ciphersuites + i) == 0) {
        __retres = -0x7980;
        goto return_label;
      }
      tmp_0 = i;
      i ++;
      ;
      if (*(ssl->ciphersuites + tmp_0) == (ssl->session)->ciphersuite) 
        break;
    }
  }
  if ((int)*(buf + ((size_t)41 + n)) != 0) {
    __retres = -0x7980;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static int ssl_parse_server_key_exchange(ssl_context *ssl)
{
  int __retres;
  int ret;
  size_t n;
  unsigned char *p;
  unsigned char *end;
  unsigned char hash[36];
  md5_context md5_0;
  sha1_context sha1_0;
  if ((ssl->session)->ciphersuite != 0x16) 
    if ((ssl->session)->ciphersuite != 0x33) 
      if ((ssl->session)->ciphersuite != 0x39) 
        if ((ssl->session)->ciphersuite != 0x45) 
          if ((ssl->session)->ciphersuite != 0x88) {
            (ssl->state) ++;
            __retres = 0;
            goto return_label;
          }
  ret = ssl_read_record(ssl);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  if (ssl->in_msgtype != 22) {
    __retres = -0x7700;
    goto return_label;
  }
  if ((int)*(ssl->in_msg + 0) != 12) {
    __retres = -0x7B00;
    goto return_label;
  }
  p = ssl->in_msg + 4;
  end = ssl->in_msg + ssl->in_hslen;
  ret = dhm_read_params(& ssl->dhm_ctx,& p,(unsigned char const *)end);
  if (ret != 0) {
    __retres = -0x7B00;
    goto return_label;
  }
  if ((unsigned int)(end - p) != (ssl->peer_cert)->rsa.len) {
    __retres = -0x7B00;
    goto return_label;
  }
  if (ssl->dhm_ctx.len < (size_t)64) goto _LOR;
  else 
    if (ssl->dhm_ctx.len > (size_t)512) {
      _LOR: {
              __retres = -0x7B00;
              goto return_label;
            }
    }
  n = (ssl->in_hslen - (size_t)(end - p)) - (size_t)6;
  md5_starts(& md5_0);
  md5_update(& md5_0,(unsigned char const *)(ssl->randbytes),(size_t)64);
  md5_update(& md5_0,(unsigned char const *)(ssl->in_msg + 4),n);
  md5_finish(& md5_0,hash);
  sha1_starts(& sha1_0);
  sha1_update(& sha1_0,(unsigned char const *)(ssl->randbytes),(size_t)64);
  sha1_update(& sha1_0,(unsigned char const *)(ssl->in_msg + 4),n);
  sha1_finish(& sha1_0,& hash[16]);
  ret = rsa_pkcs1_verify(& (ssl->peer_cert)->rsa,0,0,(unsigned int)36,
                         (unsigned char const *)(hash),p);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  (ssl->state) ++;
  __retres = 0;
  return_label: return __retres;
}

static int ssl_parse_certificate_request(ssl_context *ssl)
{
  int __retres;
  int ret;
  ret = ssl_read_record(ssl);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  if (ssl->in_msgtype != 22) {
    __retres = -0x7700;
    goto return_label;
  }
  ssl->client_auth = 0;
  (ssl->state) ++;
  if ((int)*(ssl->in_msg + 0) == 13) (ssl->client_auth) ++;
  __retres = 0;
  return_label: return __retres;
}

static int ssl_parse_server_hello_done(ssl_context *ssl)
{
  int __retres;
  int ret;
  if (ssl->client_auth != 0) {
    ret = ssl_read_record(ssl);
    if (ret != 0) {
      __retres = ret;
      goto return_label;
    }
    if (ssl->in_msgtype != 22) {
      __retres = -0x7700;
      goto return_label;
    }
  }
  if (ssl->in_hslen != (size_t)4) goto _LOR;
  else 
    if ((int)*(ssl->in_msg + 0) != 14) {
      _LOR: {
              __retres = -0x7B80;
              goto return_label;
            }
    }
  (ssl->state) ++;
  __retres = 0;
  return_label: return __retres;
}

static int ssl_write_client_key_exchange(ssl_context *ssl)
{
  int __retres;
  int ret;
  size_t i;
  size_t n;
  if ((ssl->session)->ciphersuite == 0x16) goto _LOR;
  else 
    if ((ssl->session)->ciphersuite == 0x33) goto _LOR;
    else 
      if ((ssl->session)->ciphersuite == 0x39) goto _LOR;
      else 
        if ((ssl->session)->ciphersuite == 0x45) goto _LOR;
        else 
          if ((ssl->session)->ciphersuite == 0x88) {
            _LOR:
            {
              n = ssl->dhm_ctx.len;
              *(ssl->out_msg + 4) = (unsigned char)(n >> 8);
              *(ssl->out_msg + 5) = (unsigned char)n;
              i = (size_t)6;
              ret = dhm_make_public(& ssl->dhm_ctx,256,ssl->out_msg + i,n,
                                    ssl->f_rng,ssl->p_rng);
              if (ret != 0) {
                __retres = ret;
                goto return_label;
              }
              ssl->pmslen = ssl->dhm_ctx.len;
              ret = dhm_calc_secret(& ssl->dhm_ctx,ssl->premaster,
                                    & ssl->pmslen);
              if (ret != 0) {
                __retres = ret;
                goto return_label;
              }
            }
          }
          else {
            ssl->premaster[0] = (unsigned char)ssl->max_major_ver;
            ssl->premaster[1] = (unsigned char)ssl->max_minor_ver;
            ssl->pmslen = (size_t)48;
            ret = (*(ssl->f_rng))(ssl->p_rng,& ssl->premaster[2],
                                  ssl->pmslen - (size_t)2);
            if (ret != 0) {
              __retres = ret;
              goto return_label;
            }
            i = (size_t)4;
            n = (ssl->peer_cert)->rsa.len;
            if (ssl->minor_ver != 0) {
              i += (size_t)2;
              *(ssl->out_msg + 4) = (unsigned char)(n >> 8);
              *(ssl->out_msg + 5) = (unsigned char)n;
            }
            ret = rsa_pkcs1_encrypt(& (ssl->peer_cert)->rsa,ssl->f_rng,
                                    ssl->p_rng,0,ssl->pmslen,
                                    (unsigned char const *)(ssl->premaster),
                                    ssl->out_msg + i);
            if (ret != 0) {
              __retres = ret;
              goto return_label;
            }
          }
  ret = ssl_derive_keys(ssl);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  ssl->out_msglen = i + n;
  ssl->out_msgtype = 22;
  *(ssl->out_msg + 0) = (unsigned char)16;
  (ssl->state) ++;
  ret = ssl_write_record(ssl);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static int ssl_write_certificate_verify(ssl_context *ssl)
{
  int __retres;
  unsigned char hash[36];
  int ret = 0;
  size_t n = (size_t)0;
  if (ssl->client_auth == 0) goto _LOR;
  else 
    if (ssl->own_cert == (x509_cert *)0) {
      _LOR: {
              (ssl->state) ++;
              __retres = 0;
              goto return_label;
            }
    }
  if (ssl->rsa_key == (rsa_context *)0) {
    __retres = -0x7600;
    goto return_label;
  }
  ssl_calc_verify(ssl,hash);
  if (ssl->rsa_key) n = (ssl->rsa_key)->len;
  *(ssl->out_msg + 4) = (unsigned char)(n >> 8);
  *(ssl->out_msg + 5) = (unsigned char)n;
  if (ssl->rsa_key) ret = rsa_pkcs1_sign(ssl->rsa_key,ssl->f_rng,ssl->p_rng,
                                         1,0,(unsigned int)36,
                                         (unsigned char const *)(hash),
                                         ssl->out_msg + 6);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  ssl->out_msglen = (size_t)6 + n;
  ssl->out_msgtype = 22;
  *(ssl->out_msg + 0) = (unsigned char)15;
  (ssl->state) ++;
  ret = ssl_write_record(ssl);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int ssl_handshake_client(ssl_context *ssl)
{
  int __retres;
  int ret = 0;
  while (ssl->state != SSL_HANDSHAKE_OVER) {
    ret = ssl_flush_output(ssl);
    if (ret != 0) break;
    switch (ssl->state) {
      case SSL_HELLO_REQUEST: ssl->state = SSL_CLIENT_HELLO;
      break;
      case SSL_CLIENT_HELLO: ret = ssl_write_client_hello(ssl);
      break;
      case SSL_SERVER_HELLO: ret = ssl_parse_server_hello(ssl);
      break;
      case SSL_SERVER_CERTIFICATE: ret = ssl_parse_certificate(ssl);
      break;
      case SSL_SERVER_KEY_EXCHANGE: ret = ssl_parse_server_key_exchange(ssl);
      break;
      case SSL_CERTIFICATE_REQUEST: ret = ssl_parse_certificate_request(ssl);
      break;
      case SSL_SERVER_HELLO_DONE: ret = ssl_parse_server_hello_done(ssl);
      break;
      case SSL_CLIENT_CERTIFICATE: ret = ssl_write_certificate(ssl);
      break;
      case SSL_CLIENT_KEY_EXCHANGE: ret = ssl_write_client_key_exchange(ssl);
      break;
      case SSL_CERTIFICATE_VERIFY: ret = ssl_write_certificate_verify(ssl);
      break;
      case SSL_CLIENT_CHANGE_CIPHER_SPEC:
      ret = ssl_write_change_cipher_spec(ssl);
      break;
      case SSL_CLIENT_FINISHED: ret = ssl_write_finished(ssl);
      break;
      case SSL_SERVER_CHANGE_CIPHER_SPEC:
      ret = ssl_parse_change_cipher_spec(ssl);
      break;
      case SSL_SERVER_FINISHED: ret = ssl_parse_finished(ssl);
      break;
      case SSL_FLUSH_BUFFERS: ;
      ssl->state = SSL_HANDSHAKE_OVER;
      break;
      default: ;
      __retres = -0x7100;
      goto return_label;
    }
    if (ret != 0) break;
  }
  __retres = ret;
  return_label: return __retres;
}

__inline static int const *ssl_list_ciphersuites_3(void)
{
  int const *__retres;
  __retres = (int const *)(ssl_default_ciphersuites);
  return __retres;
}

static int ssl_parse_client_hello(ssl_context *ssl)
{
  int __retres;
  int ret;
  unsigned int i;
  unsigned int j;
  size_t n;
  unsigned int ciph_len;
  unsigned int sess_len;
  unsigned int chal_len;
  unsigned int comp_len;
  unsigned char *buf;
  unsigned char *p;
  ret = ssl_fetch_input(ssl,(size_t)5);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  buf = ssl->in_hdr;
  if (((int)*(buf + 0) & 0x80) != 0) {
    if ((int)*(buf + 2) != 1) goto _LOR;
    else 
      if ((int)*(buf + 3) != 3) {
        _LOR: {
                __retres = -0x7900;
                goto return_label;
              }
      }
    n = (size_t)((((int)*(buf + 0) << 8) | (int)*(buf + 1)) & 0x7FFF);
    if (n < (size_t)17) goto _LOR_0;
    else 
      if (n > (size_t)512) {
        _LOR_0: {
                  __retres = -0x7900;
                  goto return_label;
                }
      }
    ssl->max_major_ver = (int)*(buf + 3);
    ssl->max_minor_ver = (int)*(buf + 4);
    ssl->major_ver = 3;
    if ((int)*(buf + 4) <= 2) ssl->minor_ver = (int)*(buf + 4);
    else ssl->minor_ver = 2;
    ret = ssl_fetch_input(ssl,(size_t)2 + n);
    if (ret != 0) {
      __retres = ret;
      goto return_label;
    }
    md5_update(& ssl->fin_md5,(unsigned char const *)(buf + 2),n);
    sha1_update(& ssl->fin_sha1,(unsigned char const *)(buf + 2),n);
    buf = ssl->in_msg;
    n = ssl->in_left - (size_t)5;
    ciph_len = (unsigned int)(((int)*(buf + 0) << 8) | (int)*(buf + 1));
    sess_len = (unsigned int)(((int)*(buf + 2) << 8) | (int)*(buf + 3));
    chal_len = (unsigned int)(((int)*(buf + 4) << 8) | (int)*(buf + 5));
    if (ciph_len < (unsigned int)3) goto _LOR_1;
    else 
      if (ciph_len % (unsigned int)3 != (unsigned int)0) {
        _LOR_1: {
                  __retres = -0x7900;
                  goto return_label;
                }
      }
    if (sess_len > (unsigned int)32) {
      __retres = -0x7900;
      goto return_label;
    }
    if (chal_len < (unsigned int)8) goto _LOR_2;
    else 
      if (chal_len > (unsigned int)32) {
        _LOR_2: {
                  __retres = -0x7900;
                  goto return_label;
                }
      }
    if (n != (((unsigned int)6 + ciph_len) + sess_len) + chal_len) {
      __retres = -0x7900;
      goto return_label;
    }
    p = (buf + 6) + ciph_len;
    (ssl->session)->length = sess_len;
    memset((void *)((ssl->session)->id),0,sizeof((ssl->session)->id));
    memcpy((void *)((ssl->session)->id),(void const *)p,
           (ssl->session)->length);
    p += sess_len;
    memset((void *)(ssl->randbytes),0,(size_t)64);
    memcpy((void *)(& ssl->randbytes[32] - chal_len),(void const *)p,
           chal_len);
    i = (unsigned int)0;
    /*@ loop unroll 13; */
    while (*(ssl->ciphersuites + i) != 0) {
      j = (unsigned int)0;
      p = buf + 6;
      while (j < ciph_len) {
        if ((int)*(p + 0) == 0) 
          if ((int)*(p + 1) == 0) 
            if ((int)*(p + 2) == *(ssl->ciphersuites + i)) goto have_ciphersuite;
        j += (unsigned int)3;
        p += 3;
      }
      i ++;
    }
  }
  else {
    if ((int)*(buf + 0) != 22) goto _LOR_3;
    else 
      if ((int)*(buf + 1) != 3) {
        _LOR_3: {
                  __retres = -0x7900;
                  goto return_label;
                }
      }
    n = (size_t)(((int)*(buf + 3) << 8) | (int)*(buf + 4));
    if (n < (size_t)45) goto _LOR_4;
    else 
      if (n > (size_t)512) {
        _LOR_4: {
                  __retres = -0x7900;
                  goto return_label;
                }
      }
    ret = ssl_fetch_input(ssl,(size_t)5 + n);
    if (ret != 0) {
      __retres = ret;
      goto return_label;
    }
    buf = ssl->in_msg;
    n = ssl->in_left - (size_t)5;
    md5_update(& ssl->fin_md5,(unsigned char const *)buf,n);
    sha1_update(& ssl->fin_sha1,(unsigned char const *)buf,n);
    if ((int)*(buf + 0) != 1) goto _LOR_5;
    else 
      if ((int)*(buf + 4) != 3) {
        _LOR_5: {
                  __retres = -0x7900;
                  goto return_label;
                }
      }
    ssl->major_ver = 3;
    if ((int)*(buf + 5) <= 2) ssl->minor_ver = (int)*(buf + 5);
    else ssl->minor_ver = 2;
    ssl->max_major_ver = (int)*(buf + 4);
    ssl->max_minor_ver = (int)*(buf + 5);
    memcpy((void *)(ssl->randbytes),(void const *)(buf + 6),(size_t)32);
    if ((int)*(buf + 1) != 0) goto _LOR_6;
    else 
      if (n != (unsigned int)4 + (unsigned int)(((int)*(buf + 2) << 8) | (int)*(
                                                buf + 3))) {
        _LOR_6: {
                  __retres = -0x7900;
                  goto return_label;
                }
      }
    sess_len = (unsigned int)*(buf + 38);
    if (sess_len > (unsigned int)32) {
      __retres = -0x7900;
      goto return_label;
    }
    (ssl->session)->length = sess_len;
    memset((void *)((ssl->session)->id),0,sizeof((ssl->session)->id));
    memcpy((void *)((ssl->session)->id),(void const *)(buf + 39),
           (ssl->session)->length);
    ciph_len = (unsigned int)(((int)*(buf + ((unsigned int)39 + sess_len)) << 8) | (int)*(
                              buf + ((unsigned int)40 + sess_len)));
    if (ciph_len < (unsigned int)2) goto _LOR_7;
    else 
      if (ciph_len > (unsigned int)256) goto _LOR_7;
      else 
        if (ciph_len % (unsigned int)2 != (unsigned int)0) {
          _LOR_7: {
                    __retres = -0x7900;
                    goto return_label;
                  }
        }
    comp_len = (unsigned int)*(buf + (((unsigned int)41 + sess_len) + ciph_len));
    if (comp_len < (unsigned int)1) goto _LOR_8;
    else 
      if (comp_len > (unsigned int)16) {
        _LOR_8: {
                  __retres = -0x7900;
                  goto return_label;
                }
      }
    i = (unsigned int)0;
    /*@ loop unroll 13; */
    while (*(ssl->ciphersuites + i) != 0) {
      j = (unsigned int)0;
      p = (buf + 41) + sess_len;
      /*@ loop unroll 128; */
      while (j < ciph_len) {
        if ((int)*(p + 0) == 0) 
          if ((int)*(p + 1) == *(ssl->ciphersuites + i)) goto have_ciphersuite;
        j += (unsigned int)2;
        p += 2;
      }
      i ++;
    }
  }
  __retres = -0x7380;
  goto return_label;
  have_ciphersuite: (ssl->session)->ciphersuite = *(ssl->ciphersuites + i);
  ssl->in_left = (size_t)0;
  (ssl->state) ++;
  __retres = 0;
  return_label: return __retres;
}

static int ssl_write_server_hello(ssl_context *ssl)
{
  int __retres;
  time_t t;
  int ret;
  int n;
  unsigned char *buf;
  unsigned char *p;
  unsigned char *tmp;
  unsigned char *tmp_0;
  unsigned char *tmp_1;
  unsigned char *tmp_2;
  unsigned char *tmp_3;
  unsigned char *tmp_4;
  unsigned char *tmp_5;
  unsigned char *tmp_7;
  unsigned char *tmp_8;
  unsigned char *tmp_9;
  buf = ssl->out_msg;
  p = buf + 4;
  tmp = p;
  p ++;
  *tmp = (unsigned char)ssl->major_ver;
  tmp_0 = p;
  p ++;
  *tmp_0 = (unsigned char)ssl->minor_ver;
  t = time((time_t *)0);
  tmp_1 = p;
  p ++;
  *tmp_1 = (unsigned char)(t >> 24);
  tmp_2 = p;
  p ++;
  *tmp_2 = (unsigned char)(t >> 16);
  tmp_3 = p;
  p ++;
  *tmp_3 = (unsigned char)(t >> 8);
  tmp_4 = p;
  p ++;
  *tmp_4 = (unsigned char)t;
  ret = (*(ssl->f_rng))(ssl->p_rng,p,(size_t)28);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  p += 28;
  memcpy((void *)(& ssl->randbytes[32]),(void const *)(buf + 6),(size_t)32);
  n = 32;
  (ssl->session)->length = (size_t)n;
  tmp_5 = p;
  p ++;
  *tmp_5 = (unsigned char)(ssl->session)->length;
  if (ssl->s_get == (int (*)(ssl_context *))0) goto _LOR;
  else {
    int tmp_6;
    tmp_6 = (*(ssl->s_get))(ssl);
    if (tmp_6 != 0) {
      _LOR:
      {
        ssl->resume = 0;
        (ssl->state) ++;
        if (ssl->session == (ssl_session *)0) {
          __retres = -0x7100;
          goto return_label;
        }
        ret = (*(ssl->f_rng))(ssl->p_rng,(ssl->session)->id,(size_t)n);
        if (ret != 0) {
          __retres = ret;
          goto return_label;
        }
      }
    }
    else {
      ssl->resume = 1;
      ssl->state = SSL_SERVER_CHANGE_CIPHER_SPEC;
      ret = ssl_derive_keys(ssl);
      if (ret != 0) {
        __retres = ret;
        goto return_label;
      }
    }
  }
  memcpy((void *)p,(void const *)((ssl->session)->id),(ssl->session)->length);
  p += (ssl->session)->length;
  tmp_7 = p;
  p ++;
  *tmp_7 = (unsigned char)((ssl->session)->ciphersuite >> 8);
  tmp_8 = p;
  p ++;
  *tmp_8 = (unsigned char)(ssl->session)->ciphersuite;
  tmp_9 = p;
  p ++;
  *tmp_9 = (unsigned char)0;
  ssl->out_msglen = (size_t)(p - buf);
  ssl->out_msgtype = 22;
  *(ssl->out_msg + 0) = (unsigned char)2;
  ret = ssl_write_record(ssl);
  __retres = ret;
  return_label: return __retres;
}

static int ssl_write_certificate_request(ssl_context *ssl)
{
  int __retres;
  int ret;
  size_t n;
  unsigned char *buf;
  unsigned char *p;
  x509_cert const *crt;
  unsigned char *tmp;
  unsigned char *tmp_0;
  (ssl->state) ++;
  if (ssl->authmode == 0) {
    __retres = 0;
    goto return_label;
  }
  buf = ssl->out_msg;
  p = buf + 4;
  tmp = p;
  p ++;
  *tmp = (unsigned char)1;
  tmp_0 = p;
  p ++;
  *tmp_0 = (unsigned char)1;
  p += 2;
  crt = (x509_cert const *)ssl->ca_chain;
  while (1) {
    if (crt != (x509_cert const *)0) {
      if (! (crt->version != 0)) break;
    }
    else break;
    {
      unsigned char *tmp_1;
      unsigned char *tmp_2;
      if (p - buf > 4096) break;
      n = crt->subject_raw.len;
      tmp_1 = p;
      p ++;
      *tmp_1 = (unsigned char)(n >> 8);
      tmp_2 = p;
      p ++;
      *tmp_2 = (unsigned char)n;
      memcpy((void *)p,(void const *)crt->subject_raw.p,n);
      p += n;
      crt = (x509_cert const *)crt->next;
    }
  }
  n = (size_t)(p - buf);
  ssl->out_msglen = n;
  ssl->out_msgtype = 22;
  *(ssl->out_msg + 0) = (unsigned char)13;
  *(ssl->out_msg + 6) = (unsigned char)((n - (size_t)8) >> 8);
  *(ssl->out_msg + 7) = (unsigned char)(n - (size_t)8);
  ret = ssl_write_record(ssl);
  __retres = ret;
  return_label: return __retres;
}

static int ssl_write_server_key_exchange(ssl_context *ssl)
{
  int __retres;
  int ret;
  size_t n;
  unsigned char hash[36];
  md5_context md5_0;
  sha1_context sha1_0;
  size_t rsa_key_len = (size_t)0;
  if ((ssl->session)->ciphersuite != 0x16) 
    if ((ssl->session)->ciphersuite != 0x33) 
      if ((ssl->session)->ciphersuite != 0x39) 
        if ((ssl->session)->ciphersuite != 0x45) 
          if ((ssl->session)->ciphersuite != 0x88) {
            (ssl->state) ++;
            __retres = 0;
            goto return_label;
          }
  if (ssl->rsa_key == (rsa_context *)0) {
    __retres = -0x7600;
    goto return_label;
  }
  ret = dhm_make_params(& ssl->dhm_ctx,256,ssl->out_msg + 4,& n,ssl->f_rng,
                        ssl->p_rng);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  md5_starts(& md5_0);
  md5_update(& md5_0,(unsigned char const *)(ssl->randbytes),(size_t)64);
  md5_update(& md5_0,(unsigned char const *)(ssl->out_msg + 4),n);
  md5_finish(& md5_0,hash);
  sha1_starts(& sha1_0);
  sha1_update(& sha1_0,(unsigned char const *)(ssl->randbytes),(size_t)64);
  sha1_update(& sha1_0,(unsigned char const *)(ssl->out_msg + 4),n);
  sha1_finish(& sha1_0,& hash[16]);
  if (ssl->rsa_key) rsa_key_len = (ssl->rsa_key)->len;
  *(ssl->out_msg + ((size_t)4 + n)) = (unsigned char)(rsa_key_len >> 8);
  *(ssl->out_msg + ((size_t)5 + n)) = (unsigned char)rsa_key_len;
  if (ssl->rsa_key) ret = rsa_pkcs1_sign(ssl->rsa_key,ssl->f_rng,ssl->p_rng,
                                         1,0,(unsigned int)36,
                                         (unsigned char const *)(hash),
                                         (ssl->out_msg + 6) + n);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  ssl->out_msglen = ((size_t)6 + n) + rsa_key_len;
  ssl->out_msgtype = 22;
  *(ssl->out_msg + 0) = (unsigned char)12;
  (ssl->state) ++;
  ret = ssl_write_record(ssl);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static int ssl_write_server_hello_done(ssl_context *ssl)
{
  int __retres;
  int ret;
  ssl->out_msglen = (size_t)4;
  ssl->out_msgtype = 22;
  *(ssl->out_msg + 0) = (unsigned char)14;
  (ssl->state) ++;
  ret = ssl_write_record(ssl);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static int ssl_parse_client_key_exchange(ssl_context *ssl)
{
  int __retres;
  int ret;
  size_t i;
  size_t n = (size_t)0;
  ret = ssl_read_record(ssl);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  if (ssl->in_msgtype != 22) {
    __retres = -0x7C00;
    goto return_label;
  }
  if ((int)*(ssl->in_msg + 0) != 16) {
    __retres = -0x7C00;
    goto return_label;
  }
  if ((ssl->session)->ciphersuite == 0x16) goto _LOR_2;
  else 
    if ((ssl->session)->ciphersuite == 0x33) goto _LOR_2;
    else 
      if ((ssl->session)->ciphersuite == 0x39) goto _LOR_2;
      else 
        if ((ssl->session)->ciphersuite == 0x45) goto _LOR_2;
        else 
          if ((ssl->session)->ciphersuite == 0x88) {
            _LOR_2:
            {
              n = (size_t)(((int)*(ssl->in_msg + 4) << 8) | (int)*(ssl->in_msg + 5));
              if (n < (size_t)1) goto _LOR;
              else 
                if (n > ssl->dhm_ctx.len) goto _LOR;
                else 
                  if (n + (size_t)6 != ssl->in_hslen) {
                    _LOR: {
                            __retres = -0x7C00;
                            goto return_label;
                          }
                  }
              ret = dhm_read_public(& ssl->dhm_ctx,
                                    (unsigned char const *)(ssl->in_msg + 6),
                                    n);
              if (ret != 0) {
                __retres = -0x7C80;
                goto return_label;
              }
              ssl->pmslen = ssl->dhm_ctx.len;
              ret = dhm_calc_secret(& ssl->dhm_ctx,ssl->premaster,
                                    & ssl->pmslen);
              if (ret != 0) {
                __retres = -0x7D00;
                goto return_label;
              }
            }
          }
          else {
            if (ssl->rsa_key == (rsa_context *)0) {
              __retres = -0x7600;
              goto return_label;
            }
            i = (size_t)4;
            if (ssl->rsa_key) n = (ssl->rsa_key)->len;
            ssl->pmslen = (size_t)48;
            if (ssl->minor_ver != 0) {
              i += (size_t)2;
              if ((unsigned int)*(ssl->in_msg + 4) != ((n >> 8) & (unsigned int)0xFF)) 
                goto _LOR_0;
              else 
                if ((unsigned int)*(ssl->in_msg + 5) != (n & (unsigned int)0xFF)) {
                  _LOR_0: {
                            __retres = -0x7C00;
                            goto return_label;
                          }
                }
            }
            if (ssl->in_hslen != i + n) {
              __retres = -0x7C00;
              goto return_label;
            }
            if (ssl->rsa_key) ret = rsa_pkcs1_decrypt(ssl->rsa_key,1,
                                                      & ssl->pmslen,
                                                      (unsigned char const *)(
                                                      ssl->in_msg + i),
                                                      ssl->premaster,
                                                      sizeof(ssl->premaster));
            if (ret != 0) goto _LOR_1;
            else 
              if (ssl->pmslen != (size_t)48) goto _LOR_1;
              else 
                if ((int)ssl->premaster[0] != ssl->max_major_ver) goto _LOR_1;
                else 
                  if ((int)ssl->premaster[1] != ssl->max_minor_ver) {
                    _LOR_1:
                    {
                      ssl->pmslen = (size_t)48;
                      ret = (*(ssl->f_rng))(ssl->p_rng,ssl->premaster,
                                            ssl->pmslen);
                      if (ret != 0) {
                        __retres = ret;
                        goto return_label;
                      }
                    }
                  }
          }
  ret = ssl_derive_keys(ssl);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  if (ssl->s_set != (int (*)(ssl_context *))0) (*(ssl->s_set))(ssl);
  (ssl->state) ++;
  __retres = 0;
  return_label: return __retres;
}

static int ssl_parse_certificate_verify(ssl_context *ssl)
{
  int __retres;
  int ret;
  size_t n1;
  size_t n2;
  unsigned char hash[36];
  if (ssl->peer_cert == (x509_cert *)0) {
    (ssl->state) ++;
    __retres = 0;
    goto return_label;
  }
  ssl_calc_verify(ssl,hash);
  ret = ssl_read_record(ssl);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  (ssl->state) ++;
  if (ssl->in_msgtype != 22) {
    __retres = -0x7D80;
    goto return_label;
  }
  if ((int)*(ssl->in_msg + 0) != 15) {
    __retres = -0x7D80;
    goto return_label;
  }
  n1 = (ssl->peer_cert)->rsa.len;
  n2 = (size_t)(((int)*(ssl->in_msg + 4) << 8) | (int)*(ssl->in_msg + 5));
  if (n1 + (size_t)6 != ssl->in_hslen) goto _LOR;
  else 
    if (n1 != n2) {
      _LOR: {
              __retres = -0x7D80;
              goto return_label;
            }
    }
  ret = rsa_pkcs1_verify(& (ssl->peer_cert)->rsa,0,0,(unsigned int)36,
                         (unsigned char const *)(hash),ssl->in_msg + 6);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int ssl_handshake_server(ssl_context *ssl)
{
  int __retres;
  int ret = 0;
  while (ssl->state != SSL_HANDSHAKE_OVER) {
    ret = ssl_flush_output(ssl);
    if (ret != 0) break;
    switch (ssl->state) {
      case SSL_HELLO_REQUEST: ssl->state = SSL_CLIENT_HELLO;
      break;
      case SSL_CLIENT_HELLO: ret = ssl_parse_client_hello(ssl);
      break;
      case SSL_SERVER_HELLO: ret = ssl_write_server_hello(ssl);
      break;
      case SSL_SERVER_CERTIFICATE: ret = ssl_write_certificate(ssl);
      break;
      case SSL_SERVER_KEY_EXCHANGE: ret = ssl_write_server_key_exchange(ssl);
      break;
      case SSL_CERTIFICATE_REQUEST: ret = ssl_write_certificate_request(ssl);
      break;
      case SSL_SERVER_HELLO_DONE: ret = ssl_write_server_hello_done(ssl);
      break;
      case SSL_CLIENT_CERTIFICATE: ret = ssl_parse_certificate(ssl);
      break;
      case SSL_CLIENT_KEY_EXCHANGE: ret = ssl_parse_client_key_exchange(ssl);
      break;
      case SSL_CERTIFICATE_VERIFY: ret = ssl_parse_certificate_verify(ssl);
      break;
      case SSL_CLIENT_CHANGE_CIPHER_SPEC:
      ret = ssl_parse_change_cipher_spec(ssl);
      break;
      case SSL_CLIENT_FINISHED: ret = ssl_parse_finished(ssl);
      break;
      case SSL_SERVER_CHANGE_CIPHER_SPEC:
      ret = ssl_write_change_cipher_spec(ssl);
      break;
      case SSL_SERVER_FINISHED: ret = ssl_write_finished(ssl);
      break;
      case SSL_FLUSH_BUFFERS: ;
      ssl->state = SSL_HANDSHAKE_OVER;
      break;
      default: ;
      __retres = -0x7100;
      goto return_label;
    }
    if (ret != 0) break;
  }
  __retres = ret;
  return_label: return __retres;
}

__inline static int const *ssl_list_ciphersuites_4(void)
{
  int const *__retres;
  __retres = (int const *)(ssl_default_ciphersuites);
  return __retres;
}

static int tls1_prf(unsigned char *secret, size_t slen, char *label,
                    unsigned char *random_0, size_t rlen,
                    unsigned char *dstbuf, size_t dlen)
{
  int __retres;
  size_t nb;
  size_t hs;
  size_t i;
  size_t j;
  size_t k;
  unsigned char *S1;
  unsigned char *S2;
  unsigned char tmp[128];
  unsigned char h_i[20];
  size_t tmp_0;
  tmp_0 = strlen((char const *)label);
  ;
  if (sizeof(tmp) < ((size_t)20 + tmp_0) + rlen) {
    __retres = -0x7100;
    goto return_label;
  }
  hs = (slen + (size_t)1) / (size_t)2;
  S1 = secret;
  S2 = (secret + slen) - hs;
  /*@ assert secret ≤ S2 ≤ secret + slen / 2; */ ;
  nb = strlen((char const *)label);
  memcpy((void *)(& tmp[20]),(void const *)label,nb);
  memcpy((void *)(& tmp[20] + nb),(void const *)random_0,rlen);
  nb += rlen;
  md5_hmac((unsigned char const *)S1,hs,(unsigned char const *)(& tmp[20]),
           nb,& tmp[4]);
  i = (size_t)0;
  /*@ loop unroll 16; */
  while (i < dlen) {
    md5_hmac((unsigned char const *)S1,hs,(unsigned char const *)(& tmp[4]),
             (size_t)16 + nb,h_i);
    md5_hmac((unsigned char const *)S1,hs,(unsigned char const *)(& tmp[4]),
             (size_t)16,& tmp[4]);
    if (i + (size_t)16 > dlen) k = dlen % (unsigned int)16;
    else k = (size_t)16;
    j = (size_t)0;
    /*@ loop unroll 16; */
    while (j < k) {
      *(dstbuf + (i + j)) = h_i[j];
      j ++;
    }
    i += (size_t)16;
  }
  sha1_hmac((unsigned char const *)S2,hs,(unsigned char const *)(& tmp[20]),
            nb,tmp);
  i = (size_t)0;
  /*@ loop unroll 16; */
  while (i < dlen) {
    sha1_hmac((unsigned char const *)S2,hs,(unsigned char const *)(tmp),
              (size_t)20 + nb,h_i);
    sha1_hmac((unsigned char const *)S2,hs,(unsigned char const *)(tmp),
              (size_t)20,tmp);
    if (i + (size_t)20 > dlen) k = dlen % (unsigned int)20;
    else k = (size_t)20;
    j = (size_t)0;
    /*@ loop unroll 20; */
    while (j < k) {
      *(dstbuf + (i + j)) = (unsigned char)((int)*(dstbuf + (i + j)) ^ (int)h_i[j]);
      j ++;
    }
    i += (size_t)20;
  }
  memset((void *)(tmp),0,sizeof(tmp));
  memset((void *)(h_i),0,sizeof(h_i));
  __retres = 0;
  return_label: return __retres;
}

int ssl_derive_keys(ssl_context *ssl)
{
  int __retres;
  int i;
  md5_context md5_0;
  sha1_context sha1_0;
  unsigned char tmp[64];
  unsigned char padding[16];
  unsigned char sha1sum[20];
  unsigned char keyblk[256];
  unsigned char *key1;
  unsigned char *key2;
  if (ssl->resume == 0) {
    size_t len = ssl->pmslen;
    if (ssl->minor_ver == 0) {
      i = 0;
      /*@ loop unroll 3; */
      while (i < 3) {
        memset((void *)(padding),'A' + i,(size_t)(1 + i));
        sha1_starts(& sha1_0);
        sha1_update(& sha1_0,(unsigned char const *)(padding),
                    (size_t)(1 + i));
        sha1_update(& sha1_0,(unsigned char const *)(ssl->premaster),len);
        sha1_update(& sha1_0,(unsigned char const *)(ssl->randbytes),
                    (size_t)64);
        sha1_finish(& sha1_0,sha1sum);
        md5_starts(& md5_0);
        md5_update(& md5_0,(unsigned char const *)(ssl->premaster),len);
        md5_update(& md5_0,(unsigned char const *)(sha1sum),(size_t)20);
        md5_finish(& md5_0,& (ssl->session)->master[i * 16]);
        i ++;
      }
    }
    else tls1_prf(ssl->premaster,len,(char *)"master secret",ssl->randbytes,
                  (size_t)64,(ssl->session)->master,(size_t)48);
    memset((void *)(ssl->premaster),0,sizeof(ssl->premaster));
  }
  memcpy((void *)(tmp),(void const *)(ssl->randbytes),(size_t)64);
  memcpy((void *)(ssl->randbytes),(void const *)(& tmp[32]),(size_t)32);
  memcpy((void *)(& ssl->randbytes[32]),(void const *)(tmp),(size_t)32);
  memset((void *)(tmp),0,sizeof(tmp));
  if (ssl->minor_ver == 0) {
    i = 0;
    /*@ loop unroll 16; */
    while (i < 16) {
      memset((void *)(padding),'A' + i,(size_t)(1 + i));
      sha1_starts(& sha1_0);
      sha1_update(& sha1_0,(unsigned char const *)(padding),(size_t)(1 + i));
      sha1_update(& sha1_0,(unsigned char const *)((ssl->session)->master),
                  (size_t)48);
      sha1_update(& sha1_0,(unsigned char const *)(ssl->randbytes),
                  (size_t)64);
      sha1_finish(& sha1_0,sha1sum);
      md5_starts(& md5_0);
      md5_update(& md5_0,(unsigned char const *)((ssl->session)->master),
                 (size_t)48);
      md5_update(& md5_0,(unsigned char const *)(sha1sum),(size_t)20);
      md5_finish(& md5_0,& keyblk[i * 16]);
      i ++;
    }
    memset((void *)(& md5_0),0,sizeof(md5_0));
    memset((void *)(& sha1_0),0,sizeof(sha1_0));
    memset((void *)(padding),0,sizeof(padding));
    memset((void *)(sha1sum),0,sizeof(sha1sum));
  }
  else tls1_prf((ssl->session)->master,(size_t)48,(char *)"key expansion",
                ssl->randbytes,(size_t)64,keyblk,(size_t)256);
  memset((void *)(ssl->randbytes),0,sizeof(ssl->randbytes));
  switch ((ssl->session)->ciphersuite) {
    case 0x04: ssl->keylen = (unsigned int)16;
    ssl->minlen = (size_t)16;
    ssl->ivlen = (size_t)0;
    ssl->maclen = (size_t)16;
    break;
    case 0x05: ssl->keylen = (unsigned int)16;
    ssl->minlen = (size_t)20;
    ssl->ivlen = (size_t)0;
    ssl->maclen = (size_t)20;
    break;
    case 0x0A: case 0x16: ssl->keylen = (unsigned int)24;
    ssl->minlen = (size_t)24;
    ssl->ivlen = (size_t)8;
    ssl->maclen = (size_t)20;
    break;
    case 0x2F: case 0x33: ssl->keylen = (unsigned int)16;
    ssl->minlen = (size_t)32;
    ssl->ivlen = (size_t)16;
    ssl->maclen = (size_t)20;
    break;
    case 0x35: case 0x39: ssl->keylen = (unsigned int)32;
    ssl->minlen = (size_t)32;
    ssl->ivlen = (size_t)16;
    ssl->maclen = (size_t)20;
    break;
    case 0x41: case 0x45: ssl->keylen = (unsigned int)16;
    ssl->minlen = (size_t)32;
    ssl->ivlen = (size_t)16;
    ssl->maclen = (size_t)20;
    break;
    case 0x84: case 0x88: ssl->keylen = (unsigned int)32;
    ssl->minlen = (size_t)32;
    ssl->ivlen = (size_t)16;
    ssl->maclen = (size_t)20;
    break;
    default: ;
    __retres = -0x7080;
    goto return_label;
  }
  if (ssl->endpoint == 0) {
    key1 = & keyblk[ssl->maclen * (size_t)2];
    key2 = & keyblk[ssl->maclen * (size_t)2] + ssl->keylen;
    memcpy((void *)(ssl->mac_enc),(void const *)(keyblk),ssl->maclen);
    memcpy((void *)(ssl->mac_dec),(void const *)(& keyblk[ssl->maclen]),
           ssl->maclen);
    memcpy((void *)(ssl->iv_enc),(void const *)(key2 + ssl->keylen),
           ssl->ivlen);
    memcpy((void *)(ssl->iv_dec),
           (void const *)((key2 + ssl->keylen) + ssl->ivlen),ssl->ivlen);
  }
  else {
    key1 = & keyblk[ssl->maclen * (size_t)2] + ssl->keylen;
    key2 = & keyblk[ssl->maclen * (size_t)2];
    memcpy((void *)(ssl->mac_dec),(void const *)(keyblk),ssl->maclen);
    memcpy((void *)(ssl->mac_enc),(void const *)(& keyblk[ssl->maclen]),
           ssl->maclen);
    memcpy((void *)(ssl->iv_dec),(void const *)(key1 + ssl->keylen),
           ssl->ivlen);
    memcpy((void *)(ssl->iv_enc),
           (void const *)((key1 + ssl->keylen) + ssl->ivlen),ssl->ivlen);
  }
  switch ((ssl->session)->ciphersuite) {
    case 0x04: case 0x05:
    arc4_setup((arc4_context *)(ssl->ctx_enc),(unsigned char const *)key1,
               ssl->keylen);
    arc4_setup((arc4_context *)(ssl->ctx_dec),(unsigned char const *)key2,
               ssl->keylen);
    break;
    case 0x0A: case 0x16:
    des3_set3key_enc((des3_context *)(ssl->ctx_enc),
                     (unsigned char const *)key1);
    des3_set3key_dec((des3_context *)(ssl->ctx_dec),
                     (unsigned char const *)key2);
    break;
    case 0x2F: case 0x33:
    aes_setkey_enc((aes_context *)(ssl->ctx_enc),(unsigned char const *)key1,
                   (unsigned int)128);
    aes_setkey_dec((aes_context *)(ssl->ctx_dec),(unsigned char const *)key2,
                   (unsigned int)128);
    break;
    case 0x35: case 0x39:
    aes_setkey_enc((aes_context *)(ssl->ctx_enc),(unsigned char const *)key1,
                   (unsigned int)256);
    aes_setkey_dec((aes_context *)(ssl->ctx_dec),(unsigned char const *)key2,
                   (unsigned int)256);
    break;
    case 0x41: case 0x45:
    camellia_setkey_enc((camellia_context *)(ssl->ctx_enc),
                        (unsigned char const *)key1,(unsigned int)128);
    camellia_setkey_dec((camellia_context *)(ssl->ctx_dec),
                        (unsigned char const *)key2,(unsigned int)128);
    break;
    case 0x84: case 0x88:
    camellia_setkey_enc((camellia_context *)(ssl->ctx_enc),
                        (unsigned char const *)key1,(unsigned int)256);
    camellia_setkey_dec((camellia_context *)(ssl->ctx_dec),
                        (unsigned char const *)key2,(unsigned int)256);
    break;
    default: __retres = -0x7080;
    goto return_label;
  }
  memset((void *)(keyblk),0,sizeof(keyblk));
  __retres = 0;
  return_label: return __retres;
}

void ssl_calc_verify(ssl_context *ssl, unsigned char hash[36])
{
  md5_context md5_0;
  sha1_context sha1_0;
  unsigned char pad_1[48];
  unsigned char pad_2[48];
  memcpy((void *)(& md5_0),(void const *)(& ssl->fin_md5),
         sizeof(md5_context));
  memcpy((void *)(& sha1_0),(void const *)(& ssl->fin_sha1),
         sizeof(sha1_context));
  if (ssl->minor_ver == 0) {
    memset((void *)(pad_1),0x36,(size_t)48);
    memset((void *)(pad_2),0x5C,(size_t)48);
    md5_update(& md5_0,(unsigned char const *)((ssl->session)->master),
               (size_t)48);
    md5_update(& md5_0,(unsigned char const *)(pad_1),(size_t)48);
    md5_finish(& md5_0,hash);
    md5_starts(& md5_0);
    md5_update(& md5_0,(unsigned char const *)((ssl->session)->master),
               (size_t)48);
    md5_update(& md5_0,(unsigned char const *)(pad_2),(size_t)48);
    md5_update(& md5_0,(unsigned char const *)hash,(size_t)16);
    md5_finish(& md5_0,hash);
    sha1_update(& sha1_0,(unsigned char const *)((ssl->session)->master),
                (size_t)48);
    sha1_update(& sha1_0,(unsigned char const *)(pad_1),(size_t)40);
    sha1_finish(& sha1_0,hash + 16);
    sha1_starts(& sha1_0);
    sha1_update(& sha1_0,(unsigned char const *)((ssl->session)->master),
                (size_t)48);
    sha1_update(& sha1_0,(unsigned char const *)(pad_2),(size_t)40);
    sha1_update(& sha1_0,(unsigned char const *)(hash + 16),(size_t)20);
    sha1_finish(& sha1_0,hash + 16);
  }
  else {
    md5_finish(& md5_0,hash);
    sha1_finish(& sha1_0,hash + 16);
  }
  return;
}

static void ssl_mac_md5(unsigned char *secret, unsigned char *buf,
                        size_t len, unsigned char *ctr, int type)
{
  unsigned char header[11];
  unsigned char padding[48];
  md5_context md5_0;
  memcpy((void *)(header),(void const *)ctr,(size_t)8);
  header[8] = (unsigned char)type;
  header[9] = (unsigned char)(len >> 8);
  header[10] = (unsigned char)len;
  memset((void *)(padding),0x36,(size_t)48);
  md5_starts(& md5_0);
  md5_update(& md5_0,(unsigned char const *)secret,(size_t)16);
  md5_update(& md5_0,(unsigned char const *)(padding),(size_t)48);
  md5_update(& md5_0,(unsigned char const *)(header),(size_t)11);
  md5_update(& md5_0,(unsigned char const *)buf,len);
  md5_finish(& md5_0,buf + len);
  memset((void *)(padding),0x5C,(size_t)48);
  md5_starts(& md5_0);
  md5_update(& md5_0,(unsigned char const *)secret,(size_t)16);
  md5_update(& md5_0,(unsigned char const *)(padding),(size_t)48);
  md5_update(& md5_0,(unsigned char const *)(buf + len),(size_t)16);
  md5_finish(& md5_0,buf + len);
  return;
}

static void ssl_mac_sha1(unsigned char *secret, unsigned char *buf,
                         size_t len, unsigned char *ctr, int type)
{
  unsigned char header[11];
  unsigned char padding[40];
  sha1_context sha1_0;
  memcpy((void *)(header),(void const *)ctr,(size_t)8);
  header[8] = (unsigned char)type;
  header[9] = (unsigned char)(len >> 8);
  header[10] = (unsigned char)len;
  memset((void *)(padding),0x36,(size_t)40);
  sha1_starts(& sha1_0);
  sha1_update(& sha1_0,(unsigned char const *)secret,(size_t)20);
  sha1_update(& sha1_0,(unsigned char const *)(padding),(size_t)40);
  sha1_update(& sha1_0,(unsigned char const *)(header),(size_t)11);
  sha1_update(& sha1_0,(unsigned char const *)buf,len);
  sha1_finish(& sha1_0,buf + len);
  memset((void *)(padding),0x5C,(size_t)40);
  sha1_starts(& sha1_0);
  sha1_update(& sha1_0,(unsigned char const *)secret,(size_t)20);
  sha1_update(& sha1_0,(unsigned char const *)(padding),(size_t)40);
  sha1_update(& sha1_0,(unsigned char const *)(buf + len),(size_t)20);
  sha1_finish(& sha1_0,buf + len);
  return;
}

static int ssl_encrypt_buf(ssl_context *ssl)
{
  int __retres;
  size_t i;
  size_t padlen;
  if (ssl->minor_ver == 0) {
    if (ssl->maclen == (size_t)16) ssl_mac_md5(ssl->mac_enc,ssl->out_msg,
                                               ssl->out_msglen,ssl->out_ctr,
                                               ssl->out_msgtype);
    if (ssl->maclen == (size_t)20) ssl_mac_sha1(ssl->mac_enc,ssl->out_msg,
                                                ssl->out_msglen,ssl->out_ctr,
                                                ssl->out_msgtype);
  }
  else {
    if (ssl->maclen == (size_t)16) md5_hmac((unsigned char const *)(ssl->mac_enc),
                                            (size_t)16,
                                            (unsigned char const *)ssl->out_ctr,
                                            ssl->out_msglen + (size_t)13,
                                            ssl->out_msg + ssl->out_msglen);
    if (ssl->maclen == (size_t)20) sha1_hmac((unsigned char const *)(ssl->mac_enc),
                                             (size_t)20,
                                             (unsigned char const *)ssl->out_ctr,
                                             ssl->out_msglen + (size_t)13,
                                             ssl->out_msg + ssl->out_msglen);
  }
  ssl->out_msglen += ssl->maclen;
  i = (size_t)8;
  /*@ loop unroll 8; */
  while (i > (size_t)0) {
    *(ssl->out_ctr + (i - (size_t)1)) = (unsigned char)((int)*(ssl->out_ctr + (
                                                               i - (size_t)1)) + 1);
    if ((int)*(ssl->out_ctr + (i - (size_t)1)) != 0) break;
    i --;
  }
  if (ssl->ivlen == (size_t)0) {
    padlen = (size_t)0;
    arc4_crypt((arc4_context *)(ssl->ctx_enc),ssl->out_msglen,
               (unsigned char const *)ssl->out_msg,ssl->out_msg);
  }
  else {
    unsigned char *enc_msg;
    size_t enc_msglen;
    padlen = ssl->ivlen - (ssl->out_msglen + (size_t)1) % ssl->ivlen;
    if (padlen == ssl->ivlen) padlen = (size_t)0;
    i = (size_t)0;
    /*@ loop unroll 17; */
    while (i <= padlen) {
      *(ssl->out_msg + (ssl->out_msglen + i)) = (unsigned char)padlen;
      i ++;
    }
    ssl->out_msglen += padlen + (size_t)1;
    enc_msglen = ssl->out_msglen;
    enc_msg = ssl->out_msg;
    if (ssl->minor_ver == 2) {
      int tmp;
      tmp = (*(ssl->f_rng))(ssl->p_rng,ssl->iv_enc,ssl->ivlen);
      int ret = tmp;
      if (ret != 0) {
        __retres = ret;
        goto return_label;
      }
      memmove((void *)(ssl->out_msg + ssl->ivlen),(void const *)ssl->out_msg,
              ssl->out_msglen);
      memcpy((void *)ssl->out_msg,(void const *)(ssl->iv_enc),ssl->ivlen);
      enc_msg = ssl->out_msg + ssl->ivlen;
      enc_msglen = ssl->out_msglen;
      ssl->out_msglen += ssl->ivlen;
    }
    switch (ssl->ivlen) {
      case (size_t)8:
      des3_crypt_cbc((des3_context *)(ssl->ctx_enc),1,enc_msglen,ssl->iv_enc,
                     (unsigned char const *)enc_msg,enc_msg);
      break;
      case (size_t)16: ;
      if ((ssl->session)->ciphersuite == 0x2F) goto _LOR;
      else 
        if ((ssl->session)->ciphersuite == 0x33) goto _LOR;
        else 
          if ((ssl->session)->ciphersuite == 0x35) goto _LOR;
          else 
            if ((ssl->session)->ciphersuite == 0x39) {
              _LOR:
              {
                aes_crypt_cbc((aes_context *)(ssl->ctx_enc),1,enc_msglen,
                              ssl->iv_enc,(unsigned char const *)enc_msg,
                              enc_msg);
                break;
              }
            }
      if ((ssl->session)->ciphersuite == 0x41) goto _LOR_0;
      else 
        if ((ssl->session)->ciphersuite == 0x45) goto _LOR_0;
        else 
          if ((ssl->session)->ciphersuite == 0x84) goto _LOR_0;
          else 
            if ((ssl->session)->ciphersuite == 0x88) {
              _LOR_0:
              {
                camellia_crypt_cbc((camellia_context *)(ssl->ctx_enc),1,
                                   enc_msglen,ssl->iv_enc,
                                   (unsigned char const *)enc_msg,enc_msg);
                break;
              }
            }
      default: __retres = -0x7080;
      goto return_label;
    }
  }
  __retres = 0;
  return_label: return __retres;
}

static int ssl_decrypt_buf(ssl_context *ssl)
{
  int __retres;
  size_t i;
  unsigned char tmp[20];
  int tmp_0;
  size_t padlen = (size_t)0;
  size_t correct = (size_t)1;
  if (ssl->in_msglen < ssl->minlen) {
    __retres = -0x7180;
    goto return_label;
  }
  if (ssl->ivlen == (size_t)0) {
    padlen = (size_t)0;
    arc4_crypt((arc4_context *)(ssl->ctx_dec),ssl->in_msglen,
               (unsigned char const *)ssl->in_msg,ssl->in_msg);
  }
  else {
    unsigned char *dec_msg;
    unsigned char *dec_msg_result;
    size_t dec_msglen;
    size_t minlen = (size_t)0;
    if (ssl->in_msglen % ssl->ivlen != (unsigned int)0) {
      __retres = -0x7180;
      goto return_label;
    }
    if (ssl->minor_ver >= 2) minlen += ssl->ivlen;
    if (ssl->in_msglen < minlen + ssl->ivlen) goto _LOR;
    else 
      if (ssl->in_msglen < (minlen + ssl->maclen) + (size_t)1) {
        _LOR: {
                __retres = -0x7180;
                goto return_label;
              }
      }
    dec_msglen = ssl->in_msglen;
    dec_msg = ssl->in_msg;
    dec_msg_result = ssl->in_msg;
    if (ssl->minor_ver == 2) {
      dec_msg += ssl->ivlen;
      dec_msglen -= ssl->ivlen;
      ssl->in_msglen -= ssl->ivlen;
      i = (size_t)0;
      /*@ loop unroll 16; */
      while (i < ssl->ivlen) {
        ssl->iv_dec[i] = *(ssl->in_msg + i);
        i ++;
      }
    }
    switch (ssl->ivlen) {
      case (size_t)8:
      des3_crypt_cbc((des3_context *)(ssl->ctx_dec),0,dec_msglen,ssl->iv_dec,
                     (unsigned char const *)dec_msg,dec_msg_result);
      break;
      case (size_t)16: ;
      if ((ssl->session)->ciphersuite == 0x2F) goto _LOR_0;
      else 
        if ((ssl->session)->ciphersuite == 0x33) goto _LOR_0;
        else 
          if ((ssl->session)->ciphersuite == 0x35) goto _LOR_0;
          else 
            if ((ssl->session)->ciphersuite == 0x39) {
              _LOR_0:
              {
                aes_crypt_cbc((aes_context *)(ssl->ctx_dec),0,dec_msglen,
                              ssl->iv_dec,(unsigned char const *)dec_msg,
                              dec_msg_result);
                break;
              }
            }
      if ((ssl->session)->ciphersuite == 0x41) goto _LOR_1;
      else 
        if ((ssl->session)->ciphersuite == 0x45) goto _LOR_1;
        else 
          if ((ssl->session)->ciphersuite == 0x84) goto _LOR_1;
          else 
            if ((ssl->session)->ciphersuite == 0x88) {
              _LOR_1:
              {
                camellia_crypt_cbc((camellia_context *)(ssl->ctx_dec),0,
                                   dec_msglen,ssl->iv_dec,
                                   (unsigned char const *)dec_msg,
                                   dec_msg_result);
                break;
              }
            }
      default: __retres = -0x7080;
      goto return_label;
    }
    /*@ assert ssl->in_msglen > 0; */ ;
    padlen = (size_t)(1 + (int)*(ssl->in_msg + (ssl->in_msglen - (size_t)1)));
    if (ssl->in_msglen < ssl->maclen + padlen) {
      padlen = (size_t)0;
      correct = (size_t)0;
    }
    if (ssl->minor_ver == 0) {
      if (padlen > ssl->ivlen) correct = (size_t)0;
    }
    else {
      size_t pad_count = (size_t)0;
      size_t fake_pad_count = (size_t)0;
      size_t padding_idx = (ssl->in_msglen - padlen) - (size_t)1;
      i = (size_t)1;
      /*@ loop unroll 257; */
      while (i <= padlen) {
        pad_count += (size_t)((size_t)*(ssl->in_msg + (padding_idx + i)) == 
                              padlen - (size_t)1);
        i ++;
      }
      /*@ loop unroll 257; */
      while (i <= (size_t)256) {
        fake_pad_count += (size_t)((size_t)*(ssl->in_msg + (padding_idx + i)) == 
                                   padlen - (size_t)1);
        i ++;
      }
      correct &= (unsigned int)(pad_count == padlen);
      correct &= (unsigned int)(pad_count + fake_pad_count < (size_t)512);
      padlen &= correct * (size_t)0x1FF;
    }
  }
  ssl->in_msglen -= ssl->maclen + padlen;
  /*@ assert 0 ≤ ssl->in_msglen ≤ 16384; */ ;
  *(ssl->in_hdr + 3) = (unsigned char)(ssl->in_msglen >> 8);
  *(ssl->in_hdr + 4) = (unsigned char)ssl->in_msglen;
  memcpy((void *)(tmp),(void const *)(ssl->in_msg + ssl->in_msglen),
         (size_t)20);
  if (ssl->minor_ver == 0) 
    if (ssl->maclen == (size_t)16) ssl_mac_md5(ssl->mac_dec,ssl->in_msg,
                                               ssl->in_msglen,ssl->in_ctr,
                                               ssl->in_msgtype);
    else ssl_mac_sha1(ssl->mac_dec,ssl->in_msg,ssl->in_msglen,ssl->in_ctr,
                      ssl->in_msgtype);
  else {
    int j;
    int extra_run = 0;
    extra_run = (int)(((((size_t)13 + ssl->in_msglen) + padlen) + (size_t)8) / (size_t)64 - 
                      (((size_t)13 + ssl->in_msglen) + (size_t)8) / (size_t)64);
    extra_run = (int)((unsigned int)extra_run & correct * (size_t)0xFF);
    if (ssl->maclen == (size_t)16) {
      md5_context ctx;
      md5_hmac_starts(& ctx,(unsigned char const *)(ssl->mac_dec),(size_t)16);
      md5_hmac_update(& ctx,(unsigned char const *)ssl->in_ctr,
                      ssl->in_msglen + (size_t)13);
      md5_hmac_finish(& ctx,ssl->in_msg + ssl->in_msglen);
      j = 0;
      /*@ loop unroll 255; */
      while (j < extra_run) {
        md5_process(& ctx,(unsigned char const *)ssl->in_msg);
        j ++;
      }
    }
    else 
      if (ssl->maclen == (size_t)20) {
        sha1_context ctx_0;
        sha1_hmac_starts(& ctx_0,(unsigned char const *)(ssl->mac_dec),
                         (size_t)20);
        sha1_hmac_update(& ctx_0,(unsigned char const *)ssl->in_ctr,
                         ssl->in_msglen + (size_t)13);
        sha1_hmac_finish(& ctx_0,ssl->in_msg + ssl->in_msglen);
        j = 0;
        /*@ loop unroll 255; */
        while (j < extra_run) {
          sha1_process(& ctx_0,(unsigned char const *)ssl->in_msg);
          j ++;
        }
      }
      else 
        if (ssl->maclen != (size_t)0) {
          __retres = -0x7080;
          goto return_label;
        }
  }
  tmp_0 = memcmp((void const *)(tmp),
                 (void const *)(ssl->in_msg + ssl->in_msglen),ssl->maclen);
  if (tmp_0 != 0) correct = (size_t)0;
  if (correct == (size_t)0) {
    __retres = -0x7180;
    goto return_label;
  }
  if (ssl->in_msglen == (size_t)0) {
    (ssl->nb_zero) ++;
    if (ssl->nb_zero > 3) {
      __retres = -0x7180;
      goto return_label;
    }
  }
  else ssl->nb_zero = 0;
  i = (size_t)8;
  /*@ loop unroll 8; */
  while (i > (size_t)0) {
    *(ssl->in_ctr + (i - (size_t)1)) = (unsigned char)((int)*(ssl->in_ctr + (
                                                              i - (size_t)1)) + 1);
    if ((int)*(ssl->in_ctr + (i - (size_t)1)) != 0) break;
    i --;
  }
  __retres = 0;
  return_label: return __retres;
}

int ssl_fetch_input(ssl_context *ssl, size_t nb_want)
{
  int __retres;
  int ret;
  size_t len;
  while (ssl->in_left < nb_want) {
    len = nb_want - ssl->in_left;
    ret = (*(ssl->f_recv))(ssl->p_recv,ssl->in_hdr + ssl->in_left,len);
    if (ret == 0) {
      __retres = -0x7280;
      goto return_label;
    }
    if (ret < 0) {
      __retres = ret;
      goto return_label;
    }
    ssl->in_left += (size_t)ret;
  }
  __retres = 0;
  return_label: return __retres;
}

int ssl_flush_output(ssl_context *ssl)
{
  int __retres;
  int ret;
  unsigned char *buf;
  while (ssl->out_left > (size_t)0) {
    buf = ((ssl->out_hdr + 5) + ssl->out_msglen) - ssl->out_left;
    ret = (*(ssl->f_send))(ssl->p_send,(unsigned char const *)buf,
                           ssl->out_left);
    if (ret <= 0) {
      __retres = ret;
      goto return_label;
    }
    ssl->out_left -= (size_t)ret;
  }
  __retres = 0;
  return_label: return __retres;
}

int ssl_write_record(ssl_context *ssl)
{
  int __retres;
  int ret;
  size_t len = ssl->out_msglen;
  *(ssl->out_hdr + 0) = (unsigned char)ssl->out_msgtype;
  *(ssl->out_hdr + 1) = (unsigned char)ssl->major_ver;
  *(ssl->out_hdr + 2) = (unsigned char)ssl->minor_ver;
  *(ssl->out_hdr + 3) = (unsigned char)(len >> 8);
  *(ssl->out_hdr + 4) = (unsigned char)len;
  if (ssl->out_msgtype == 22) {
    *(ssl->out_msg + 1) = (unsigned char)((len - (size_t)4) >> 16);
    *(ssl->out_msg + 2) = (unsigned char)((len - (size_t)4) >> 8);
    *(ssl->out_msg + 3) = (unsigned char)(len - (size_t)4);
    md5_update(& ssl->fin_md5,(unsigned char const *)ssl->out_msg,len);
    sha1_update(& ssl->fin_sha1,(unsigned char const *)ssl->out_msg,len);
  }
  if (ssl->do_crypt != 0) {
    ret = ssl_encrypt_buf(ssl);
    if (ret != 0) {
      __retres = ret;
      goto return_label;
    }
    len = ssl->out_msglen;
    *(ssl->out_hdr + 3) = (unsigned char)(len >> 8);
    *(ssl->out_hdr + 4) = (unsigned char)len;
  }
  ssl->out_left = (size_t)5 + ssl->out_msglen;
  ret = ssl_flush_output(ssl);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int ssl_read_record(ssl_context *ssl)
{
  int __retres;
  int ret;
  if (ssl->in_hslen != (size_t)0) 
    if (ssl->in_hslen < ssl->in_msglen) {
      ssl->in_msglen -= ssl->in_hslen;
      memmove((void *)ssl->in_msg,
              (void const *)(ssl->in_msg + ssl->in_hslen),ssl->in_msglen);
      ssl->in_hslen = (size_t)4;
      ssl->in_hslen += (size_t)(((int)*(ssl->in_msg + 2) << 8) | (int)*(
                                ssl->in_msg + 3));
      if (ssl->in_msglen < (size_t)4) goto _LOR;
      else 
        if ((int)*(ssl->in_msg + 1) != 0) {
          _LOR: {
                  __retres = -0x7200;
                  goto return_label;
                }
        }
      if (ssl->in_msglen < ssl->in_hslen) {
        __retres = -0x7200;
        goto return_label;
      }
      md5_update(& ssl->fin_md5,(unsigned char const *)ssl->in_msg,
                 ssl->in_hslen);
      sha1_update(& ssl->fin_sha1,(unsigned char const *)ssl->in_msg,
                  ssl->in_hslen);
      __retres = 0;
      goto return_label;
    }
  ssl->in_hslen = (size_t)0;
  ret = ssl_fetch_input(ssl,(size_t)5);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  ssl->in_msgtype = (int)*(ssl->in_hdr + 0);
  ssl->in_msglen = (size_t)(((int)*(ssl->in_hdr + 3) << 8) | (int)*(ssl->in_hdr + 4));
  if ((int)*(ssl->in_hdr + 1) != ssl->major_ver) {
    __retres = -0x7200;
    goto return_label;
  }
  if ((int)*(ssl->in_hdr + 2) > ssl->max_minor_ver) {
    __retres = -0x7200;
    goto return_label;
  }
  if (ssl->do_crypt == 0) {
    if (ssl->in_msglen < (size_t)1) goto _LOR_0;
    else 
      if (ssl->in_msglen > (size_t)16384) {
        _LOR_0: {
                  __retres = -0x7200;
                  goto return_label;
                }
      }
  }
  else {
    if (ssl->in_msglen < ssl->minlen) {
      __retres = -0x7200;
      goto return_label;
    }
    if (ssl->minor_ver == 0) 
      if (ssl->in_msglen > ssl->minlen + (size_t)16384) {
        __retres = -0x7200;
        goto return_label;
      }
    if (ssl->minor_ver == 1) 
      if (ssl->in_msglen > (ssl->minlen + (size_t)16384) + (size_t)256) {
        __retres = -0x7200;
        goto return_label;
      }
  }
  ret = ssl_fetch_input(ssl,(size_t)5 + ssl->in_msglen);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  if (ssl->do_crypt != 0) {
    ret = ssl_decrypt_buf(ssl);
    if (ret != 0) {
      __retres = ret;
      goto return_label;
    }
    if (ssl->in_msglen > (size_t)16384) {
      __retres = -0x7200;
      goto return_label;
    }
  }
  if (ssl->in_msgtype == 22) {
    ssl->in_hslen = (size_t)4;
    ssl->in_hslen += (size_t)(((int)*(ssl->in_msg + 2) << 8) | (int)*(
                              ssl->in_msg + 3));
    if (ssl->in_msglen < (size_t)4) goto _LOR_1;
    else 
      if ((int)*(ssl->in_msg + 1) != 0) {
        _LOR_1: {
                  __retres = -0x7200;
                  goto return_label;
                }
      }
    if (ssl->in_msglen < ssl->in_hslen) {
      __retres = -0x7200;
      goto return_label;
    }
    md5_update(& ssl->fin_md5,(unsigned char const *)ssl->in_msg,
               ssl->in_hslen);
    sha1_update(& ssl->fin_sha1,(unsigned char const *)ssl->in_msg,
                ssl->in_hslen);
  }
  if (ssl->in_msgtype == 21) {
    if ((int)*(ssl->in_msg + 0) == 2) {
      __retres = -0x7780 - (int)*(ssl->in_msg + 1);
      goto return_label;
    }
    if ((int)*(ssl->in_msg + 0) == 1) 
      if ((int)*(ssl->in_msg + 1) == 0) {
        __retres = -0x7880;
        goto return_label;
      }
  }
  ssl->in_left = (size_t)0;
  __retres = 0;
  return_label: return __retres;
}

int ssl_write_certificate(ssl_context *ssl)
{
  int __retres;
  int ret;
  size_t i;
  size_t n;
  x509_cert const *crt;
  if (ssl->endpoint == 0) {
    if (ssl->client_auth == 0) {
      (ssl->state) ++;
      __retres = 0;
      goto return_label;
    }
    if (ssl->own_cert == (x509_cert *)0) 
      if (ssl->minor_ver == 0) {
        ssl->out_msglen = (size_t)2;
        ssl->out_msgtype = 21;
        *(ssl->out_msg + 0) = (unsigned char)1;
        *(ssl->out_msg + 1) = (unsigned char)41;
        goto write_msg;
      }
  }
  else 
    if (ssl->own_cert == (x509_cert *)0) {
      __retres = -0x7580;
      goto return_label;
    }
  i = (size_t)7;
  crt = (x509_cert const *)ssl->own_cert;
  while (crt != (x509_cert const *)0) {
    n = crt->raw.len;
    if ((i + (size_t)3) + n > (size_t)16384) {
      __retres = -0x7500;
      goto return_label;
    }
    *(ssl->out_msg + i) = (unsigned char)(n >> 16);
    *(ssl->out_msg + (i + (size_t)1)) = (unsigned char)(n >> 8);
    *(ssl->out_msg + (i + (size_t)2)) = (unsigned char)n;
    i += (size_t)3;
    memcpy((void *)(ssl->out_msg + i),(void const *)crt->raw.p,n);
    i += n;
    crt = (x509_cert const *)crt->next;
  }
  *(ssl->out_msg + 4) = (unsigned char)((i - (size_t)7) >> 16);
  *(ssl->out_msg + 5) = (unsigned char)((i - (size_t)7) >> 8);
  *(ssl->out_msg + 6) = (unsigned char)(i - (size_t)7);
  ssl->out_msglen = i;
  ssl->out_msgtype = 22;
  *(ssl->out_msg + 0) = (unsigned char)11;
  write_msg: (ssl->state) ++;
  ret = ssl_write_record(ssl);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int ssl_parse_certificate(ssl_context *ssl)
{
  int __retres;
  int ret;
  size_t i;
  size_t n;
  x509_cert *tmp_0;
  if (ssl->endpoint == 1) 
    if (ssl->authmode == 0) {
      ssl->verify_result = 0x80;
      (ssl->state) ++;
      __retres = 0;
      goto return_label;
    }
  ret = ssl_read_record(ssl);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  (ssl->state) ++;
  if (ssl->endpoint == 1) 
    if (ssl->minor_ver == 0) 
      if (ssl->in_msglen == (size_t)2) 
        if (ssl->in_msgtype == 21) 
          if ((int)*(ssl->in_msg + 0) == 1) 
            if ((int)*(ssl->in_msg + 1) == 41) {
              ssl->verify_result = 0x40;
              if (ssl->authmode == 1) {
                __retres = 0;
                goto return_label;
              }
              else {
                __retres = -0x7480;
                goto return_label;
              }
            }
  if (ssl->endpoint == 1) 
    if (ssl->minor_ver != 0) 
      if (ssl->in_hslen == (size_t)7) 
        if (ssl->in_msgtype == 22) 
          if ((int)*(ssl->in_msg + 0) == 11) {
            int tmp;
            tmp = memcmp((void const *)(ssl->in_msg + 4),
                         (void const *)"\000\000\000",(size_t)3);
            if (tmp == 0) {
              ssl->verify_result = 0x40;
              if (ssl->authmode == 2) {
                __retres = -0x7480;
                goto return_label;
              }
              else {
                __retres = 0;
                goto return_label;
              }
            }
          }
  if (ssl->in_msgtype != 22) {
    __retres = -0x7700;
    goto return_label;
  }
  if ((int)*(ssl->in_msg + 0) != 11) goto _LOR;
  else 
    if (ssl->in_hslen < (size_t)10) {
      _LOR: {
              __retres = -0x7A00;
              goto return_label;
            }
    }
  n = (size_t)(((int)*(ssl->in_msg + 5) << 8) | (int)*(ssl->in_msg + 6));
  if ((int)*(ssl->in_msg + 4) != 0) goto _LOR_0;
  else 
    if (ssl->in_hslen != (size_t)7 + n) {
      _LOR_0: {
                __retres = -0x7A00;
                goto return_label;
              }
    }
  tmp_0 = (x509_cert *)malloc(sizeof(x509_cert));
  ssl->peer_cert = tmp_0;
  if (tmp_0 == (x509_cert *)0) {
    __retres = -0x7F00;
    goto return_label;
  }
  memset((void *)ssl->peer_cert,0,sizeof(x509_cert));
  i = (size_t)7;
  while (i < ssl->in_hslen) {
    if ((int)*(ssl->in_msg + i) != 0) {
      __retres = -0x7A00;
      goto return_label;
    }
    n = ((unsigned int)*(ssl->in_msg + (i + (size_t)1)) << 8) | (unsigned int)*(
        ssl->in_msg + (i + (size_t)2));
    i += (size_t)3;
    if (n < (size_t)128) goto _LOR_1;
    else 
      if (i + n > ssl->in_hslen) {
        _LOR_1: {
                  __retres = -0x7A00;
                  goto return_label;
                }
      }
    ret = x509parse_crt_der(ssl->peer_cert,
                            (unsigned char const *)(ssl->in_msg + i),n);
    if (ret != 0) {
      __retres = ret;
      goto return_label;
    }
    i += n;
  }
  if (ssl->authmode != 0) {
    if (ssl->ca_chain == (x509_cert *)0) {
      __retres = -0x7680;
      goto return_label;
    }
    ret = x509parse_verify(ssl->peer_cert,ssl->ca_chain,ssl->ca_crl,
                           ssl->peer_cn,& ssl->verify_result,ssl->f_vrfy,
                           ssl->p_vrfy);
    if (ret != 0) ;
    if (ssl->authmode != 2) ret = 0;
  }
  __retres = ret;
  return_label: return __retres;
}

int ssl_write_change_cipher_spec(ssl_context *ssl)
{
  int __retres;
  int ret;
  ssl->out_msgtype = 20;
  ssl->out_msglen = (size_t)1;
  *(ssl->out_msg + 0) = (unsigned char)1;
  ssl->do_crypt = 0;
  (ssl->state) ++;
  ret = ssl_write_record(ssl);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int ssl_parse_change_cipher_spec(ssl_context *ssl)
{
  int __retres;
  int ret;
  ssl->do_crypt = 0;
  ret = ssl_read_record(ssl);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  if (ssl->in_msgtype != 20) {
    __retres = -0x7700;
    goto return_label;
  }
  if (ssl->in_msglen != (size_t)1) goto _LOR;
  else 
    if ((int)*(ssl->in_msg + 0) != 1) {
      _LOR: {
              __retres = -0x7E00;
              goto return_label;
            }
    }
  (ssl->state) ++;
  __retres = 0;
  return_label: return __retres;
}

static void ssl_calc_finished(ssl_context *ssl, unsigned char *buf, int from,
                              md5_context *md5_0, sha1_context *sha1_0)
{
  char *sender;
  unsigned char padbuf[48];
  unsigned char md5sum[16];
  unsigned char sha1sum[20];
  int len = 12;
  if (ssl->minor_ver == 0) {
    if (from == 0) sender = (char *)"CLNT"; else sender = (char *)"SRVR";
    memset((void *)(padbuf),0x36,(size_t)48);
    md5_update(md5_0,(unsigned char const *)sender,(size_t)4);
    md5_update(md5_0,(unsigned char const *)((ssl->session)->master),
               (size_t)48);
    md5_update(md5_0,(unsigned char const *)(padbuf),(size_t)48);
    md5_finish(md5_0,md5sum);
    sha1_update(sha1_0,(unsigned char const *)sender,(size_t)4);
    sha1_update(sha1_0,(unsigned char const *)((ssl->session)->master),
                (size_t)48);
    sha1_update(sha1_0,(unsigned char const *)(padbuf),(size_t)40);
    sha1_finish(sha1_0,sha1sum);
    memset((void *)(padbuf),0x5C,(size_t)48);
    md5_starts(md5_0);
    md5_update(md5_0,(unsigned char const *)((ssl->session)->master),
               (size_t)48);
    md5_update(md5_0,(unsigned char const *)(padbuf),(size_t)48);
    md5_update(md5_0,(unsigned char const *)(md5sum),(size_t)16);
    md5_finish(md5_0,buf);
    sha1_starts(sha1_0);
    sha1_update(sha1_0,(unsigned char const *)((ssl->session)->master),
                (size_t)48);
    sha1_update(sha1_0,(unsigned char const *)(padbuf),(size_t)40);
    sha1_update(sha1_0,(unsigned char const *)(sha1sum),(size_t)20);
    sha1_finish(sha1_0,buf + 16);
    len += 24;
  }
  else {
    if (from == 0) sender = (char *)"client finished";
    else sender = (char *)"server finished";
    md5_finish(md5_0,padbuf);
    sha1_finish(sha1_0,& padbuf[16]);
    tls1_prf((ssl->session)->master,(size_t)48,sender,padbuf,(size_t)36,buf,
             (size_t)len);
  }
  memset((void *)md5_0,0,sizeof(md5_context));
  memset((void *)sha1_0,0,sizeof(sha1_context));
  memset((void *)(padbuf),0,sizeof(padbuf));
  memset((void *)(md5sum),0,sizeof(md5sum));
  memset((void *)(sha1sum),0,sizeof(sha1sum));
  return;
}

int ssl_write_finished(ssl_context *ssl)
{
  int __retres;
  int ret;
  int hash_len;
  md5_context md5_0;
  sha1_context sha1_0;
  memcpy((void *)(& md5_0),(void const *)(& ssl->fin_md5),
         sizeof(md5_context));
  memcpy((void *)(& sha1_0),(void const *)(& ssl->fin_sha1),
         sizeof(sha1_context));
  ssl_calc_finished(ssl,ssl->out_msg + 4,ssl->endpoint,& md5_0,& sha1_0);
  if (ssl->minor_ver == 0) hash_len = 36; else hash_len = 12;
  ssl->out_msglen = (size_t)(4 + hash_len);
  ssl->out_msgtype = 22;
  *(ssl->out_msg + 0) = (unsigned char)20;
  if (ssl->resume != 0) 
    if (ssl->endpoint == 0) ssl->state = SSL_HANDSHAKE_OVER;
    else ssl->state = SSL_CLIENT_CHANGE_CIPHER_SPEC;
  else (ssl->state) ++;
  ssl->do_crypt = 1;
  ret = ssl_write_record(ssl);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int ssl_parse_finished(ssl_context *ssl)
{
  int __retres;
  int ret;
  unsigned int hash_len;
  unsigned char buf[36];
  md5_context md5_0;
  sha1_context sha1_0;
  int tmp;
  memcpy((void *)(& md5_0),(void const *)(& ssl->fin_md5),
         sizeof(md5_context));
  memcpy((void *)(& sha1_0),(void const *)(& ssl->fin_sha1),
         sizeof(sha1_context));
  ssl->do_crypt = 1;
  ret = ssl_read_record(ssl);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  if (ssl->in_msgtype != 22) {
    __retres = -0x7700;
    goto return_label;
  }
  if (ssl->minor_ver == 0) hash_len = (unsigned int)36;
  else hash_len = (unsigned int)12;
  if ((int)*(ssl->in_msg + 0) != 20) goto _LOR;
  else 
    if (ssl->in_hslen != (unsigned int)4 + hash_len) {
      _LOR: {
              __retres = -0x7E80;
              goto return_label;
            }
    }
  ssl_calc_finished(ssl,buf,ssl->endpoint ^ 1,& md5_0,& sha1_0);
  tmp = memcmp((void const *)(ssl->in_msg + 4),(void const *)(buf),hash_len);
  if (tmp != 0) {
    __retres = -0x7E80;
    goto return_label;
  }
  if (ssl->resume != 0) {
    if (ssl->endpoint == 0) ssl->state = SSL_CLIENT_CHANGE_CIPHER_SPEC;
    if (ssl->endpoint == 1) ssl->state = SSL_HANDSHAKE_OVER;
  }
  else (ssl->state) ++;
  __retres = 0;
  return_label: return __retres;
}

int ssl_init(ssl_context *ssl)
{
  int __retres;
  int len = 16384 + 512;
  memset((void *)ssl,0,sizeof(ssl_context));
  ssl->in_ctr = (unsigned char *)malloc((size_t)len);
  ssl->in_hdr = ssl->in_ctr + 8;
  ssl->in_msg = ssl->in_ctr + 13;
  if (ssl->in_ctr == (unsigned char *)0) {
    __retres = -0x7F00;
    goto return_label;
  }
  ssl->out_ctr = (unsigned char *)malloc((size_t)len);
  ssl->out_hdr = ssl->out_ctr + 8;
  ssl->out_msg = ssl->out_ctr + 13;
  if (ssl->out_ctr == (unsigned char *)0) {
    free((void *)ssl->in_ctr);
    __retres = -0x7F00;
    goto return_label;
  }
  memset((void *)ssl->in_ctr,0,(size_t)(16384 + 512));
  memset((void *)ssl->out_ctr,0,(size_t)(16384 + 512));
  ssl->hostname = (unsigned char *)0;
  ssl->hostname_len = (size_t)0;
  md5_starts(& ssl->fin_md5);
  sha1_starts(& ssl->fin_sha1);
  __retres = 0;
  return_label: return __retres;
}

void ssl_session_reset(ssl_context *ssl)
{
  ssl->state = SSL_HELLO_REQUEST;
  ssl->in_offt = (unsigned char *)0;
  ssl->in_msgtype = 0;
  ssl->in_msglen = (size_t)0;
  ssl->in_left = (size_t)0;
  ssl->in_hslen = (size_t)0;
  ssl->nb_zero = 0;
  ssl->out_msgtype = 0;
  ssl->out_msglen = (size_t)0;
  ssl->out_left = (size_t)0;
  ssl->do_crypt = 0;
  ssl->pmslen = (size_t)0;
  ssl->keylen = (unsigned int)0;
  ssl->minlen = (size_t)0;
  ssl->ivlen = (size_t)0;
  ssl->maclen = (size_t)0;
  memset((void *)ssl->out_ctr,0,(size_t)(16384 + 512));
  memset((void *)ssl->in_ctr,0,(size_t)(16384 + 512));
  memset((void *)(ssl->randbytes),0,(size_t)64);
  memset((void *)(ssl->premaster),0,(size_t)256);
  memset((void *)(ssl->iv_enc),0,(size_t)16);
  memset((void *)(ssl->iv_dec),0,(size_t)16);
  memset((void *)(ssl->mac_enc),0,(size_t)32);
  memset((void *)(ssl->mac_dec),0,(size_t)32);
  memset((void *)(ssl->ctx_enc),0,(size_t)128);
  memset((void *)(ssl->ctx_dec),0,(size_t)128);
  md5_starts(& ssl->fin_md5);
  sha1_starts(& ssl->fin_sha1);
  return;
}

void ssl_set_endpoint(ssl_context *ssl, int endpoint)
{
  ssl->endpoint = endpoint;
  return;
}

void ssl_set_authmode(ssl_context *ssl, int authmode)
{
  ssl->authmode = authmode;
  return;
}

void ssl_set_verify(ssl_context *ssl,
                    int (*f_vrfy)(void *, x509_cert *, int , int ),
                    void *p_vrfy)
{
  ssl->f_vrfy = f_vrfy;
  ssl->p_vrfy = p_vrfy;
  return;
}

void ssl_set_rng(ssl_context *ssl,
                 int (*f_rng)(void *, unsigned char *, size_t ), void *p_rng)
{
  ssl->f_rng = f_rng;
  ssl->p_rng = p_rng;
  return;
}

void ssl_set_dbg(ssl_context *ssl, void (*f_dbg)(void *, int , char const *),
                 void *p_dbg)
{
  ssl->f_dbg = f_dbg;
  ssl->p_dbg = p_dbg;
  return;
}

void ssl_set_bio(ssl_context *ssl,
                 int (*f_recv)(void *, unsigned char *, size_t ),
                 void *p_recv,
                 int (*f_send)(void *, unsigned char const *, size_t ),
                 void *p_send)
{
  ssl->f_recv = f_recv;
  ssl->f_send = f_send;
  ssl->p_recv = p_recv;
  ssl->p_send = p_send;
  return;
}

void ssl_set_scb(ssl_context *ssl, int (*s_get)(ssl_context *),
                 int (*s_set)(ssl_context *))
{
  ssl->s_get = s_get;
  ssl->s_set = s_set;
  return;
}

void ssl_set_session(ssl_context *ssl, int resume, int timeout,
                     ssl_session *session)
{
  ssl->resume = resume;
  ssl->timeout = timeout;
  ssl->session = session;
  return;
}

void ssl_set_ciphersuites(ssl_context *ssl, int *ciphersuites)
{
  ssl->ciphersuites = ciphersuites;
  return;
}

void ssl_set_ca_chain(ssl_context *ssl, x509_cert *ca_chain,
                      x509_crl *ca_crl, char const *peer_cn)
{
  ssl->ca_chain = ca_chain;
  ssl->ca_crl = ca_crl;
  ssl->peer_cn = peer_cn;
  return;
}

void ssl_set_own_cert(ssl_context *ssl, x509_cert *own_cert,
                      rsa_context *rsa_key)
{
  ssl->own_cert = own_cert;
  ssl->rsa_key = rsa_key;
  return;
}

int ssl_set_dh_param(ssl_context *ssl, char const *dhm_P, char const *dhm_G)
{
  int __retres;
  int ret;
  ret = mpi_read_string(& ssl->dhm_ctx.P,16,dhm_P);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  ret = mpi_read_string(& ssl->dhm_ctx.G,16,dhm_G);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int ssl_set_dh_param_ctx(ssl_context *ssl, dhm_context *dhm_ctx)
{
  int __retres;
  int ret;
  ret = mpi_copy(& ssl->dhm_ctx.P,(mpi const *)(& dhm_ctx->P));
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  ret = mpi_copy(& ssl->dhm_ctx.G,(mpi const *)(& dhm_ctx->G));
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int ssl_set_hostname(ssl_context *ssl, char const *hostname)
{
  int __retres;
  if (hostname == (char const *)0) {
    __retres = -0x7100;
    goto return_label;
  }
  ssl->hostname_len = strlen(hostname);
  ssl->hostname = (unsigned char *)malloc(ssl->hostname_len + (size_t)1);
  if (ssl->hostname == (unsigned char *)0) {
    __retres = -0x7F00;
    goto return_label;
  }
  memcpy((void *)ssl->hostname,(void const *)hostname,ssl->hostname_len);
  *(ssl->hostname + ssl->hostname_len) = (unsigned char)'\000';
  __retres = 0;
  return_label: return __retres;
}

void ssl_set_max_version(ssl_context *ssl, int major, int minor)
{
  ssl->max_major_ver = major;
  ssl->max_minor_ver = minor;
  return;
}

size_t ssl_get_bytes_avail(ssl_context const *ssl)
{
  size_t tmp;
  if (ssl->in_offt == (unsigned char *)0) tmp = (size_t)0;
  else tmp = ssl->in_msglen;
  return tmp;
}

int ssl_get_verify_result(ssl_context const *ssl)
{
  int __retres;
  __retres = ssl->verify_result;
  return __retres;
}

char const *ssl_get_ciphersuite_name(int const ciphersuite_id)
{
  char const *__retres;
  switch (ciphersuite_id) {
    case 0x04: __retres = "SSL-RSA-RC4-128-MD5";
    goto return_label;
    case 0x05: __retres = "SSL-RSA-RC4-128-SHA";
    goto return_label;
    case 0x0A: __retres = "SSL-RSA-DES-168-SHA";
    goto return_label;
    case 0x16: __retres = "SSL-EDH-RSA-DES-168-SHA";
    goto return_label;
    case 0x2F: __retres = "SSL-RSA-AES-128-SHA";
    goto return_label;
    case 0x33: __retres = "SSL-EDH-RSA-AES-128-SHA";
    goto return_label;
    case 0x35: __retres = "SSL-RSA-AES-256-SHA";
    goto return_label;
    case 0x39: __retres = "SSL-EDH-RSA-AES-256-SHA";
    goto return_label;
    case 0x41: __retres = "SSL-RSA-CAMELLIA-128-SHA";
    goto return_label;
    case 0x45: __retres = "SSL-EDH-RSA-CAMELLIA-128-SHA";
    goto return_label;
    case 0x84: __retres = "SSL-RSA-CAMELLIA-256-SHA";
    goto return_label;
    case 0x88: __retres = "SSL-EDH-RSA-CAMELLIA-256-SHA";
    goto return_label;
    default: break;
  }
  __retres = "unknown";
  return_label: return __retres;
}

int ssl_get_ciphersuite_id(char const *ciphersuite_name)
{
  int __retres;
  int tmp;
  int tmp_0;
  int tmp_1;
  int tmp_2;
  int tmp_3;
  int tmp_4;
  int tmp_5;
  int tmp_6;
  int tmp_7;
  int tmp_8;
  int tmp_9;
  int tmp_10;
  tmp = strcasecmp(ciphersuite_name,"SSL-RSA-RC4-128-MD5");
  if (0 == tmp) {
    __retres = 0x04;
    goto return_label;
  }
  tmp_0 = strcasecmp(ciphersuite_name,"SSL-RSA-RC4-128-SHA");
  if (0 == tmp_0) {
    __retres = 0x05;
    goto return_label;
  }
  tmp_1 = strcasecmp(ciphersuite_name,"SSL-RSA-DES-168-SHA");
  if (0 == tmp_1) {
    __retres = 0x0A;
    goto return_label;
  }
  tmp_2 = strcasecmp(ciphersuite_name,"SSL-EDH-RSA-DES-168-SHA");
  if (0 == tmp_2) {
    __retres = 0x16;
    goto return_label;
  }
  tmp_3 = strcasecmp(ciphersuite_name,"SSL-RSA-AES-128-SHA");
  if (0 == tmp_3) {
    __retres = 0x2F;
    goto return_label;
  }
  tmp_4 = strcasecmp(ciphersuite_name,"SSL-EDH-RSA-AES-128-SHA");
  if (0 == tmp_4) {
    __retres = 0x33;
    goto return_label;
  }
  tmp_5 = strcasecmp(ciphersuite_name,"SSL-RSA-AES-256-SHA");
  if (0 == tmp_5) {
    __retres = 0x35;
    goto return_label;
  }
  tmp_6 = strcasecmp(ciphersuite_name,"SSL-EDH-RSA-AES-256-SHA");
  if (0 == tmp_6) {
    __retres = 0x39;
    goto return_label;
  }
  tmp_7 = strcasecmp(ciphersuite_name,"SSL-RSA-CAMELLIA-128-SHA");
  if (0 == tmp_7) {
    __retres = 0x41;
    goto return_label;
  }
  tmp_8 = strcasecmp(ciphersuite_name,"SSL-EDH-RSA-CAMELLIA-128-SHA");
  if (0 == tmp_8) {
    __retres = 0x45;
    goto return_label;
  }
  tmp_9 = strcasecmp(ciphersuite_name,"SSL-RSA-CAMELLIA-256-SHA");
  if (0 == tmp_9) {
    __retres = 0x84;
    goto return_label;
  }
  tmp_10 = strcasecmp(ciphersuite_name,"SSL-EDH-RSA-CAMELLIA-256-SHA");
  if (0 == tmp_10) {
    __retres = 0x88;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

char const *ssl_get_ciphersuite(ssl_context const *ssl)
{
  char const *tmp;
  tmp = ssl_get_ciphersuite_name((ssl->session)->ciphersuite);
  return tmp;
}

char const *ssl_get_version(ssl_context const *ssl)
{
  char const *__retres;
  switch (ssl->minor_ver) {
    case 0: __retres = "SSLv3.0";
    goto return_label;
    case 1: __retres = "TLSv1.0";
    goto return_label;
    case 2: __retres = "TLSv1.1";
    goto return_label;
    default: break;
  }
  __retres = "unknown";
  return_label: return __retres;
}

int ssl_default_ciphersuites[13] =
  {0x33, 0x39, 0x45, 0x88, 0x16, 0x35, 0x84, 0x2F, 0x41, 0x0A, 0x05, 0x04, 0};
int ssl_handshake(ssl_context *ssl)
{
  int ret = -0x7080;
  if (ssl->endpoint == 0) ret = ssl_handshake_client(ssl);
  if (ssl->endpoint == 1) ret = ssl_handshake_server(ssl);
  return ret;
}

int ssl_read(ssl_context *ssl, unsigned char *buf, size_t len)
{
  int __retres;
  int ret;
  size_t n;
  if (ssl->state != SSL_HANDSHAKE_OVER) {
    ret = ssl_handshake(ssl);
    if (ret != 0) {
      __retres = ret;
      goto return_label;
    }
  }
  if (ssl->in_offt == (unsigned char *)0) {
    ret = ssl_read_record(ssl);
    if (ret != 0) {
      if (ret == -0x7280) {
        __retres = 0;
        goto return_label;
      }
      __retres = ret;
      goto return_label;
    }
    if (ssl->in_msglen == (size_t)0) 
      if (ssl->in_msgtype == 23) {
        ret = ssl_read_record(ssl);
        if (ret != 0) {
          if (ret == -0x7280) {
            __retres = 0;
            goto return_label;
          }
          __retres = ret;
          goto return_label;
        }
      }
    if (ssl->in_msgtype != 23) {
      __retres = -0x7700;
      goto return_label;
    }
    ssl->in_offt = ssl->in_msg;
  }
  if (len < ssl->in_msglen) n = len; else n = ssl->in_msglen;
  memcpy((void *)buf,(void const *)ssl->in_offt,n);
  ssl->in_msglen -= n;
  if (ssl->in_msglen == (size_t)0) ssl->in_offt = (unsigned char *)0;
  else ssl->in_offt += n;
  __retres = (int)n;
  return_label: return __retres;
}

int ssl_write(ssl_context *ssl, unsigned char const *buf, size_t len)
{
  int __retres;
  int ret;
  size_t n;
  if (ssl->state != SSL_HANDSHAKE_OVER) {
    ret = ssl_handshake(ssl);
    if (ret != 0) {
      __retres = ret;
      goto return_label;
    }
  }
  if (len < (size_t)16384) n = len; else n = (size_t)16384;
  if (ssl->out_left != (size_t)0) {
    ret = ssl_flush_output(ssl);
    if (ret != 0) {
      __retres = ret;
      goto return_label;
    }
  }
  else {
    ssl->out_msglen = n;
    ssl->out_msgtype = 23;
    memcpy((void *)ssl->out_msg,(void const *)buf,n);
    ret = ssl_write_record(ssl);
    if (ret != 0) {
      __retres = ret;
      goto return_label;
    }
  }
  __retres = (int)n;
  return_label: return __retres;
}

int ssl_close_notify(ssl_context *ssl)
{
  int __retres;
  int ret;
  ret = ssl_flush_output(ssl);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  if (ssl->state == SSL_HANDSHAKE_OVER) {
    ssl->out_msgtype = 21;
    ssl->out_msglen = (size_t)2;
    *(ssl->out_msg + 0) = (unsigned char)1;
    *(ssl->out_msg + 1) = (unsigned char)0;
    ret = ssl_write_record(ssl);
    if (ret != 0) {
      __retres = ret;
      goto return_label;
    }
  }
  __retres = ret;
  return_label: return __retres;
}

/*@ assigns \nothing; */
void ssl_free(ssl_context *ssl)
{
  if (ssl->peer_cert != (x509_cert *)0) {
    x509_free(ssl->peer_cert);
    memset((void *)ssl->peer_cert,0,sizeof(x509_cert));
    free((void *)ssl->peer_cert);
  }
  if (ssl->out_ctr != (unsigned char *)0) {
    memset((void *)ssl->out_ctr,0,(size_t)(16384 + 512));
    free((void *)ssl->out_ctr);
  }
  if (ssl->in_ctr != (unsigned char *)0) {
    memset((void *)ssl->in_ctr,0,(size_t)(16384 + 512));
    free((void *)ssl->in_ctr);
  }
  dhm_free(& ssl->dhm_ctx);
  if (ssl->hostname != (unsigned char *)0) {
    memset((void *)ssl->hostname,0,ssl->hostname_len);
    free((void *)ssl->hostname);
    ssl->hostname_len = (size_t)0;
  }
  memset((void *)ssl,0,sizeof(ssl_context));
  return;
}

/*@ assigns \result;
    assigns \result \from _hardclock_clock; */
unsigned long hardclock(void)
{
  unsigned long lo;
  unsigned long hi;
  /*@ assigns lo, hi;
      assigns lo \from \nothing;
      assigns hi \from \nothing; */
  __asm__ ("rdtsc" : "=a" (lo), "=d" (hi));
  return lo;
}

int volatile alarmed = 0;
unsigned long get_timer(struct hr_time *val, int reset)
{
  unsigned long delta;
  struct timeval offset;
  struct _hr_time *t = (struct _hr_time *)val;
  gettimeofday(& offset,(void *)0);
  delta = (unsigned long)((offset.tv_sec - t->start.tv_sec) * (time_t)1000 + (time_t)(
                          (offset.tv_usec - t->start.tv_usec) / 1000));
  if (reset) {
    t->start.tv_sec = offset.tv_sec;
    t->start.tv_usec = offset.tv_usec;
  }
  return delta;
}

static void sighandler(int signum)
{
  alarmed = 1;
  signal(signum,& sighandler);
  return;
}

void set_alarm(int seconds)
{
  alarmed = 0;
  signal(14,& sighandler);
  alarm((unsigned int)seconds);
  return;
}

void m_sleep(int milliseconds)
{
  struct timeval tv;
  tv.tv_sec = (time_t)(milliseconds / 1000);
  tv.tv_usec = milliseconds * 1000;
  select(0,(fd_set *)0,(fd_set *)0,(fd_set *)0,& tv);
  return;
}

unsigned int version_get_number(void);

void version_get_string(char *string);

void version_get_string_full(char *string);

char const version[6] =
  {(char)'1', (char)'.', (char)'1', (char)'.', (char)'7', (char)'\000'};
unsigned int version_get_number(void)
{
  unsigned int __retres;
  __retres = (unsigned int)0x01010700;
  return __retres;
}

void version_get_string(char *string)
{
  memcpy((void *)string,(void const *)"1.1.7",sizeof("1.1.7"));
  return;
}

void version_get_string_full(char *string)
{
  memcpy((void *)string,(void const *)"PolarSSL 1.1.7",
         sizeof("PolarSSL 1.1.7"));
  return;
}

static int x509_get_version(unsigned char **p, unsigned char const *end,
                            int *ver)
{
  int __retres;
  int ret;
  size_t len;
  ret = asn1_get_tag(p,end,& len,(0x80 | 0x20) | 0);
  if (ret != 0) {
    if (ret == -0x0016) {
      *ver = 0;
      __retres = 0;
      goto return_label;
    }
    __retres = ret;
    goto return_label;
  }
  end = (unsigned char const *)(*p + len);
  ret = asn1_get_int(p,end,ver);
  if (ret != 0) {
    __retres = -0x2200 + ret;
    goto return_label;
  }
  if ((void *)*p != (void *)end) {
    __retres = -0x2200 + -0x001A;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static int x509_crl_get_version(unsigned char **p, unsigned char const *end,
                                int *ver)
{
  int __retres;
  int ret;
  ret = asn1_get_int(p,end,ver);
  if (ret != 0) {
    if (ret == -0x0016) {
      *ver = 0;
      __retres = 0;
      goto return_label;
    }
    __retres = -0x2200 + ret;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static int x509_get_serial(unsigned char **p, unsigned char const *end,
                           x509_buf *serial)
{
  int __retres;
  int ret;
  unsigned char *tmp;
  if (end - *p < 1) {
    __retres = -0x2280 + -0x0014;
    goto return_label;
  }
  if ((int)*(*p) != ((0x80 | 0x00) | 2)) 
    if ((int)*(*p) != 0x02) {
      __retres = -0x2280 + -0x0016;
      goto return_label;
    }
  tmp = *p;
  (*p) ++;
  serial->tag = (int)*tmp;
  ret = asn1_get_len(p,end,& serial->len);
  if (ret != 0) {
    __retres = -0x2280 + ret;
    goto return_label;
  }
  serial->p = *p;
  *p += serial->len;
  __retres = 0;
  return_label: return __retres;
}

static int x509_get_alg(unsigned char **p, unsigned char const *end,
                        x509_buf *alg)
{
  int __retres;
  int ret;
  size_t len;
  ret = asn1_get_tag(p,end,& len,0x20 | 0x10);
  if (ret != 0) {
    __retres = -0x2300 + ret;
    goto return_label;
  }
  end = (unsigned char const *)(*p + len);
  alg->tag = (int)*(*p);
  ret = asn1_get_tag(p,end,& alg->len,0x06);
  if (ret != 0) {
    __retres = -0x2300 + ret;
    goto return_label;
  }
  alg->p = *p;
  *p += alg->len;
  if ((void *)*p == (void *)end) {
    __retres = 0;
    goto return_label;
  }
  ret = asn1_get_tag(p,end,& len,0x05);
  if (ret != 0) {
    __retres = -0x2300 + ret;
    goto return_label;
  }
  if ((void *)*p != (void *)end) {
    __retres = -0x2300 + -0x001A;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static int x509_get_attr_type_value(unsigned char **p,
                                    unsigned char const *end,
                                    x509_name *cur_0)
{
  int __retres;
  int ret;
  size_t len;
  x509_buf *oid;
  x509_buf *val;
  unsigned char *tmp;
  ret = asn1_get_tag(p,end,& len,0x20 | 0x10);
  if (ret != 0) {
    __retres = -0x2380 + ret;
    goto return_label;
  }
  oid = & cur_0->oid;
  oid->tag = (int)*(*p);
  ret = asn1_get_tag(p,end,& oid->len,0x06);
  if (ret != 0) {
    __retres = -0x2380 + ret;
    goto return_label;
  }
  oid->p = *p;
  *p += oid->len;
  if (end - *p < 1) {
    __retres = -0x2380 + -0x0014;
    goto return_label;
  }
  if ((int)*(*p) != 0x1E) 
    if ((int)*(*p) != 0x0C) 
      if ((int)*(*p) != 0x14) 
        if ((int)*(*p) != 0x13) 
          if ((int)*(*p) != 0x16) 
            if ((int)*(*p) != 0x1C) {
              __retres = -0x2380 + -0x0016;
              goto return_label;
            }
  val = & cur_0->val;
  tmp = *p;
  (*p) ++;
  val->tag = (int)*tmp;
  ret = asn1_get_len(p,end,& val->len);
  if (ret != 0) {
    __retres = -0x2380 + ret;
    goto return_label;
  }
  val->p = *p;
  *p += val->len;
  cur_0->next = (struct _x509_name *)0;
  __retres = 0;
  return_label: return __retres;
}

static int x509_get_name(unsigned char **p, unsigned char const *end,
                         x509_name *cur_0)
{
  int __retres;
  int ret;
  size_t len;
  unsigned char const *end2;
  x509_name *use;
  int tmp_1;
  ret = asn1_get_tag(p,end,& len,0x20 | 0x11);
  if (ret != 0) {
    __retres = -0x2380 + ret;
    goto return_label;
  }
  end2 = end;
  end = (unsigned char const *)(*p + len);
  use = cur_0;
  while (1) {
    ret = x509_get_attr_type_value(p,end,use);
    if (ret != 0) {
      __retres = ret;
      goto return_label;
    }
    if ((void *)*p != (void *)end) {
      use->next = (struct _x509_name *)malloc(sizeof(x509_name));
      if (use->next == (struct _x509_name *)0) {
        __retres = -0x2A80;
        goto return_label;
      }
      memset((void *)use->next,0,sizeof(x509_name));
      use = use->next;
    }
    if (! ((void *)*p != (void *)end)) break;
  }
  if ((void *)*p == (void *)end2) {
    __retres = 0;
    goto return_label;
  }
  cur_0->next = (struct _x509_name *)malloc(sizeof(x509_name));
  if (cur_0->next == (struct _x509_name *)0) {
    __retres = -0x2A80;
    goto return_label;
  }
  memset((void *)cur_0->next,0,sizeof(x509_name));
  tmp_1 = x509_get_name(p,end2,cur_0->next);
  __retres = tmp_1;
  return_label: return __retres;
}

/*@ requires \valid(param0);
    requires \valid(param1);
    requires \valid(param2);
    requires \valid(param3);
    requires \valid(param4);
    requires \valid(param5);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    ensures \initialized(param2);
    ensures \initialized(param3);
    ensures \initialized(param4);
    ensures \initialized(param5);
    assigns \result, *param5, *param4, *param3, *param2, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param5
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param4
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param3
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param2
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_2(char const * restrict s, char const * restrict format,
                int *param0, int *param1, int *param2, int *param3,
                int *param4, int *param5);

/*@ requires \valid(param0);
    requires \valid(param1);
    requires \valid(param2);
    requires \valid(param3);
    requires \valid(param4);
    requires \valid(param5);
    requires valid_read_string(format);
    requires valid_read_string(s);
    ensures \initialized(param0);
    ensures \initialized(param1);
    ensures \initialized(param2);
    ensures \initialized(param3);
    ensures \initialized(param4);
    ensures \initialized(param5);
    assigns \result, *param5, *param4, *param3, *param2, *param1, *param0;
    assigns \result
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param5
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param4
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param3
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param2
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param1
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
    assigns *param0
      \from (indirect: *(s + (0 ..))), (indirect: *(format + (0 ..)));
 */
int sscanf_va_3(char const * restrict s, char const * restrict format,
                int *param0, int *param1, int *param2, int *param3,
                int *param4, int *param5);

static int x509_get_time(unsigned char **p, unsigned char const *end,
                         x509_time *time_0)
{
  int __retres;
  int ret;
  size_t len;
  char date[64];
  unsigned char tag;
  if (end - *p < 1) {
    __retres = -0x2400 + -0x0014;
    goto return_label;
  }
  tag = *(*p);
  if ((int)tag == 0x17) {
    size_t tmp;
    int tmp_0;
    (*p) ++;
    ret = asn1_get_len(p,end,& len);
    if (ret != 0) {
      __retres = -0x2400 + ret;
      goto return_label;
    }
    memset((void *)(date),0,sizeof(date));
    if (len < sizeof(date) - (unsigned int)1) tmp = len;
    else tmp = sizeof(date) - (unsigned int)1;
    ;
    memcpy((void *)(date),(void const *)*p,tmp);
    tmp_0 = sscanf((char const *)(date),"%2d%2d%2d%2d%2d%2d",& time_0->year,
                   & time_0->mon,& time_0->day,& time_0->hour,& time_0->min,
                   & time_0->sec); /* sscanf_va_2 */
    if (tmp_0 < 5) {
      __retres = -0x2400;
      goto return_label;
    }
    time_0->year += 100 * (time_0->year < 50);
    time_0->year += 1900;
    *p += len;
    __retres = 0;
    goto return_label;
  }
  else 
    if ((int)tag == 0x18) {
      size_t tmp_1;
      int tmp_2;
      (*p) ++;
      ret = asn1_get_len(p,end,& len);
      if (ret != 0) {
        __retres = -0x2400 + ret;
        goto return_label;
      }
      memset((void *)(date),0,sizeof(date));
      if (len < sizeof(date) - (unsigned int)1) tmp_1 = len;
      else tmp_1 = sizeof(date) - (unsigned int)1;
      ;
      memcpy((void *)(date),(void const *)*p,tmp_1);
      tmp_2 = sscanf((char const *)(date),"%4d%2d%2d%2d%2d%2d",
                     & time_0->year,& time_0->mon,& time_0->day,
                     & time_0->hour,& time_0->min,& time_0->sec); /* sscanf_va_3 */
      if (tmp_2 < 5) {
        __retres = -0x2400;
        goto return_label;
      }
      *p += len;
      __retres = 0;
      goto return_label;
    }
    else {
      __retres = -0x2400 + -0x0016;
      goto return_label;
    }
  return_label: return __retres;
}

static int x509_get_dates(unsigned char **p, unsigned char const *end,
                          x509_time *from, x509_time *to)
{
  int __retres;
  int ret;
  size_t len;
  ret = asn1_get_tag(p,end,& len,0x20 | 0x10);
  if (ret != 0) {
    __retres = -0x2400 + ret;
    goto return_label;
  }
  end = (unsigned char const *)(*p + len);
  ret = x509_get_time(p,end,from);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  ret = x509_get_time(p,end,to);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  if ((void *)*p != (void *)end) {
    __retres = -0x2400 + -0x001A;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static int x509_get_pubkey(unsigned char **p, unsigned char const *end,
                           x509_buf *pk_alg_oid, mpi *N, mpi *E)
{
  int __retres;
  int ret;
  int can_handle;
  size_t len;
  unsigned char *end2;
  unsigned char *tmp_2;
  ret = x509_get_alg(p,end,pk_alg_oid);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  can_handle = 0;
  if (pk_alg_oid->len == (size_t)9) {
    int tmp;
    tmp = memcmp((void const *)pk_alg_oid->p,
                 (void const *)"*\206H\206\367\r\001\001\001",(size_t)9);
    if (tmp == 0) can_handle = 1;
  }
  if (pk_alg_oid->len == (size_t)9) {
    int tmp_0;
    tmp_0 = memcmp((void const *)pk_alg_oid->p,
                   (void const *)"*\206H\206\367\r\001\001",(size_t)8);
    if (tmp_0 == 0) {
      if ((int)*(pk_alg_oid->p + 8) >= 2) 
        if ((int)*(pk_alg_oid->p + 8) <= 5) can_handle = 1;
      if ((int)*(pk_alg_oid->p + 8) >= 11) 
        if ((int)*(pk_alg_oid->p + 8) <= 14) can_handle = 1;
    }
  }
  if (pk_alg_oid->len == (size_t)5) {
    int tmp_1;
    tmp_1 = memcmp((void const *)pk_alg_oid->p,
                   (void const *)"+\016\003\002\035",(size_t)5);
    if (tmp_1 == 0) can_handle = 1;
  }
  if (can_handle == 0) {
    __retres = -0x2700;
    goto return_label;
  }
  ret = asn1_get_tag(p,end,& len,0x03);
  if (ret != 0) {
    __retres = -0x2480 + ret;
    goto return_label;
  }
  if (end - *p < 1) {
    __retres = -0x2480 + -0x0014;
    goto return_label;
  }
  end2 = *p + len;
  tmp_2 = *p;
  (*p) ++;
  ;
  if ((int)*tmp_2 != 0) {
    __retres = -0x2480;
    goto return_label;
  }
  ret = asn1_get_tag(p,(unsigned char const *)end2,& len,0x20 | 0x10);
  if (ret != 0) {
    __retres = -0x2480 + ret;
    goto return_label;
  }
  if (*p + len != end2) {
    __retres = -0x2480 + -0x001A;
    goto return_label;
  }
  ret = asn1_get_mpi(p,(unsigned char const *)end2,N);
  if (ret != 0) {
    __retres = -0x2480 + ret;
    goto return_label;
  }
  else {
    ret = asn1_get_mpi(p,(unsigned char const *)end2,E);
    if (ret != 0) {
      __retres = -0x2480 + ret;
      goto return_label;
    }
  }
  if ((void *)*p != (void *)end) {
    __retres = -0x2480 + -0x001A;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static int x509_get_sig(unsigned char **p, unsigned char const *end,
                        x509_buf *sig)
{
  int __retres;
  int ret;
  size_t len;
  sig->tag = (int)*(*p);
  ret = asn1_get_tag(p,end,& len,0x03);
  if (ret != 0) {
    __retres = -0x2500 + ret;
    goto return_label;
  }
  len --;
  if (len < (size_t)1) {
    __retres = -0x2500;
    goto return_label;
  }
  else {
    unsigned char *tmp;
    tmp = *p;
    (*p) ++;
    ;
    if ((int)*tmp != 0) {
      __retres = -0x2500;
      goto return_label;
    }
  }
  sig->len = len;
  sig->p = *p;
  *p += len;
  __retres = 0;
  return_label: return __retres;
}

static int x509_get_uid(unsigned char **p, unsigned char const *end,
                        x509_buf *uid, int n)
{
  int __retres;
  int ret;
  if ((void *)*p == (void *)end) {
    __retres = 0;
    goto return_label;
  }
  uid->tag = (int)*(*p);
  ret = asn1_get_tag(p,end,& uid->len,(0x80 | 0x20) | n);
  if (ret != 0) {
    if (ret == -0x0016) {
      __retres = 0;
      goto return_label;
    }
    __retres = ret;
    goto return_label;
  }
  uid->p = *p;
  *p += uid->len;
  __retres = 0;
  return_label: return __retres;
}

static int x509_get_ext(unsigned char **p, unsigned char const *end,
                        x509_buf *ext, int tag)
{
  int __retres;
  int ret;
  size_t len;
  if ((void *)*p == (void *)end) {
    __retres = 0;
    goto return_label;
  }
  ext->tag = (int)*(*p);
  ret = asn1_get_tag(p,end,& ext->len,(0x80 | 0x20) | tag);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  ext->p = *p;
  end = (unsigned char const *)(*p + ext->len);
  ret = asn1_get_tag(p,end,& len,0x20 | 0x10);
  if (ret != 0) {
    __retres = -0x2580 + ret;
    goto return_label;
  }
  if ((void *)end != (void *)(*p + len)) {
    __retres = -0x2580 + -0x001A;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static int x509_get_crl_ext(unsigned char **p, unsigned char const *end,
                            x509_buf *ext)
{
  int __retres;
  int ret;
  size_t len = (size_t)0;
  ret = x509_get_ext(p,end,ext,0);
  if (ret != 0) {
    if (ret == -0x0016) {
      __retres = 0;
      goto return_label;
    }
    __retres = ret;
    goto return_label;
  }
  while ((void *)*p < (void *)end) {
    ret = asn1_get_tag(p,end,& len,0x20 | 0x10);
    if (ret != 0) {
      __retres = -0x2580 + ret;
      goto return_label;
    }
    *p += len;
  }
  if ((void *)*p != (void *)end) {
    __retres = -0x2580 + -0x001A;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static int x509_get_crl_entry_ext(unsigned char **p,
                                  unsigned char const *end, x509_buf *ext)
{
  int __retres;
  int ret;
  size_t len = (size_t)0;
  if ((void *)end <= (void *)*p) {
    __retres = 0;
    goto return_label;
  }
  ext->tag = (int)*(*p);
  ext->p = *p;
  ret = asn1_get_tag(p,end,& ext->len,0x20 | 0x10);
  if (ret != 0) {
    if (ret == -0x0016) {
      ext->p = (unsigned char *)0;
      __retres = 0;
      goto return_label;
    }
    __retres = -0x2580 + ret;
    goto return_label;
  }
  end = (unsigned char const *)(*p + ext->len);
  if ((void *)end != (void *)(*p + ext->len)) {
    __retres = -0x2580 + -0x001A;
    goto return_label;
  }
  while ((void *)*p < (void *)end) {
    ret = asn1_get_tag(p,end,& len,0x20 | 0x10);
    if (ret != 0) {
      __retres = -0x2580 + ret;
      goto return_label;
    }
    *p += len;
  }
  if ((void *)*p != (void *)end) {
    __retres = -0x2580 + -0x001A;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static int x509_get_basic_constraints(unsigned char **p,
                                      unsigned char const *end,
                                      int *ca_istrue, int *max_pathlen)
{
  int __retres;
  int ret;
  size_t len;
  *ca_istrue = 0;
  *max_pathlen = 0;
  ret = asn1_get_tag(p,end,& len,0x20 | 0x10);
  if (ret != 0) {
    __retres = -0x2580 + ret;
    goto return_label;
  }
  if ((void *)*p == (void *)end) {
    __retres = 0;
    goto return_label;
  }
  ret = asn1_get_bool(p,end,ca_istrue);
  if (ret != 0) {
    if (ret == -0x0016) ret = asn1_get_int(p,end,ca_istrue);
    if (ret != 0) {
      __retres = -0x2580 + ret;
      goto return_label;
    }
    if (*ca_istrue != 0) *ca_istrue = 1;
  }
  if ((void *)*p == (void *)end) {
    __retres = 0;
    goto return_label;
  }
  ret = asn1_get_int(p,end,max_pathlen);
  if (ret != 0) {
    __retres = -0x2580 + ret;
    goto return_label;
  }
  if ((void *)*p != (void *)end) {
    __retres = -0x2580 + -0x001A;
    goto return_label;
  }
  (*max_pathlen) ++;
  __retres = 0;
  return_label: return __retres;
}

static int x509_get_ns_cert_type(unsigned char **p, unsigned char const *end,
                                 unsigned char *ns_cert_type)
{
  int __retres;
  int ret;
  x509_bitstring bs =
    {.len = (size_t)0,
     .unused_bits = (unsigned char)0,
     .p = (unsigned char *)0};
  ret = asn1_get_bitstring(p,end,& bs);
  if (ret != 0) {
    __retres = -0x2580 + ret;
    goto return_label;
  }
  if (bs.len != (size_t)1) {
    __retres = -0x2580 + -0x0018;
    goto return_label;
  }
  *ns_cert_type = *(bs.p);
  __retres = 0;
  return_label: return __retres;
}

static int x509_get_key_usage(unsigned char **p, unsigned char const *end,
                              unsigned char *key_usage)
{
  int __retres;
  int ret;
  x509_bitstring bs =
    {.len = (size_t)0,
     .unused_bits = (unsigned char)0,
     .p = (unsigned char *)0};
  ret = asn1_get_bitstring(p,end,& bs);
  if (ret != 0) {
    __retres = -0x2580 + ret;
    goto return_label;
  }
  if (bs.len > (size_t)1) {
    __retres = -0x2580 + -0x0018;
    goto return_label;
  }
  *key_usage = *(bs.p);
  __retres = 0;
  return_label: return __retres;
}

static int x509_get_ext_key_usage(unsigned char **p,
                                  unsigned char const *end,
                                  x509_sequence *ext_key_usage)
{
  int __retres;
  int ret;
  ret = asn1_get_sequence_of(p,end,ext_key_usage,0x06);
  if (ret != 0) {
    __retres = -0x2580 + ret;
    goto return_label;
  }
  if (ext_key_usage->buf.p == (unsigned char *)0) {
    __retres = -0x2580 + -0x0018;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static int x509_get_crt_ext(unsigned char **p, unsigned char const *end,
                            x509_cert *crt)
{
  int __retres;
  int ret;
  size_t len;
  unsigned char *end_ext_data;
  unsigned char *end_ext_octet;
  ret = x509_get_ext(p,end,& crt->v3_ext,3);
  if (ret != 0) {
    if (ret == -0x0016) {
      __retres = 0;
      goto return_label;
    }
    __retres = ret;
    goto return_label;
  }
  while ((void *)*p < (void *)end) {
    x509_buf extn_oid =
      {.tag = 0, .len = (size_t)0, .p = (unsigned char *)0};
    int is_critical = 0;
    ret = asn1_get_tag(p,end,& len,0x20 | 0x10);
    if (ret != 0) {
      __retres = -0x2580 + ret;
      goto return_label;
    }
    end_ext_data = *p + len;
    extn_oid.tag = (int)*(*p);
    ret = asn1_get_tag(p,end,& extn_oid.len,0x06);
    if (ret != 0) {
      __retres = -0x2580 + ret;
      goto return_label;
    }
    extn_oid.p = *p;
    *p += extn_oid.len;
    if (end - *p < 1) {
      __retres = -0x2580 + -0x0014;
      goto return_label;
    }
    ret = asn1_get_bool(p,(unsigned char const *)end_ext_data,& is_critical);
    if (ret != 0) 
      if (ret != -0x0016) {
        __retres = -0x2580 + ret;
        goto return_label;
      }
    ret = asn1_get_tag(p,(unsigned char const *)end_ext_data,& len,0x04);
    if (ret != 0) {
      __retres = -0x2580 + ret;
      goto return_label;
    }
    end_ext_octet = *p + len;
    if (end_ext_octet != end_ext_data) {
      __retres = -0x2580 + -0x001A;
      goto return_label;
    }
    if (sizeof("U\035\023") - (unsigned int)1 == extn_oid.len) {
      int tmp_2;
      tmp_2 = memcmp((void const *)extn_oid.p,(void const *)"U\035\023",
                     extn_oid.len);
      if (tmp_2 == 0) {
        ret = x509_get_basic_constraints(p,
                                         (unsigned char const *)end_ext_octet,
                                         & crt->ca_istrue,& crt->max_pathlen);
        if (ret != 0) {
          __retres = ret;
          goto return_label;
        }
        crt->ext_types |= 1 << 8;
      }
      else goto _LAND_2;
    }
    else {
      _LAND_2: ;
      if (sizeof("`\206H\001\206\370B\001\001") - (unsigned int)1 == extn_oid.len) {
        int tmp_1;
        tmp_1 = memcmp((void const *)extn_oid.p,
                       (void const *)"`\206H\001\206\370B\001\001",
                       extn_oid.len);
        if (tmp_1 == 0) {
          ret = x509_get_ns_cert_type(p,(unsigned char const *)end_ext_octet,
                                      & crt->ns_cert_type);
          if (ret != 0) {
            __retres = ret;
            goto return_label;
          }
          crt->ext_types |= 1 << 16;
        }
        else goto _LAND_1;
      }
      else {
        _LAND_1: ;
        if (sizeof("U\035\017") - (unsigned int)1 == extn_oid.len) {
          int tmp_0;
          tmp_0 = memcmp((void const *)extn_oid.p,(void const *)"U\035\017",
                         extn_oid.len);
          if (tmp_0 == 0) {
            ret = x509_get_key_usage(p,(unsigned char const *)end_ext_octet,
                                     & crt->key_usage);
            if (ret != 0) {
              __retres = ret;
              goto return_label;
            }
            crt->ext_types |= 1 << 2;
          }
          else goto _LAND_0;
        }
        else {
          _LAND_0: ;
          if (sizeof("U\035%") - (unsigned int)1 == extn_oid.len) {
            int tmp;
            tmp = memcmp((void const *)extn_oid.p,(void const *)"U\035%",
                         extn_oid.len);
            if (tmp == 0) {
              ret = x509_get_ext_key_usage(p,
                                           (unsigned char const *)end_ext_octet,
                                           & crt->ext_key_usage);
              if (ret != 0) {
                __retres = ret;
                goto return_label;
              }
              crt->ext_types |= 1 << 11;
            }
            else goto _LAND;
          }
          else {
            _LAND:
            {
              *p = end_ext_octet;
              if (is_critical) {
                __retres = -0x2580 + -0x0016;
                goto return_label;
              }
            }
          }
        }
      }
    }
  }
  if ((void *)*p != (void *)end) {
    __retres = -0x2580 + -0x001A;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

static int x509_get_entries(unsigned char **p, unsigned char const *end,
                            x509_crl_entry *entry)
{
  int __retres;
  int ret;
  size_t entry_len;
  x509_crl_entry *cur_entry = entry;
  if ((void *)*p == (void *)end) {
    __retres = 0;
    goto return_label;
  }
  ret = asn1_get_tag(p,end,& entry_len,0x10 | 0x20);
  if (ret != 0) {
    if (ret == -0x0016) {
      __retres = 0;
      goto return_label;
    }
    __retres = ret;
    goto return_label;
  }
  end = (unsigned char const *)(*p + entry_len);
  while ((void *)*p < (void *)end) {
    size_t len2;
    unsigned char const *end2;
    ret = asn1_get_tag(p,end,& len2,0x10 | 0x20);
    if (ret != 0) {
      __retres = ret;
      goto return_label;
    }
    cur_entry->raw.tag = (int)*(*p);
    cur_entry->raw.p = *p;
    cur_entry->raw.len = len2;
    end2 = (unsigned char const *)(*p + len2);
    ret = x509_get_serial(p,end2,& cur_entry->serial);
    if (ret != 0) {
      __retres = ret;
      goto return_label;
    }
    ret = x509_get_time(p,end2,& cur_entry->revocation_date);
    if (ret != 0) {
      __retres = ret;
      goto return_label;
    }
    ret = x509_get_crl_entry_ext(p,end2,& cur_entry->entry_ext);
    if (ret != 0) {
      __retres = ret;
      goto return_label;
    }
    if ((void *)*p < (void *)end) {
      cur_entry->next = (struct _x509_crl_entry *)malloc(sizeof(x509_crl_entry));
      if (cur_entry->next == (struct _x509_crl_entry *)0) {
        __retres = -0x2A80;
        goto return_label;
      }
      cur_entry = cur_entry->next;
      memset((void *)cur_entry,0,sizeof(x509_crl_entry));
    }
  }
  __retres = 0;
  return_label: return __retres;
}

static int x509_get_sig_alg(x509_buf const *sig_oid, int *sig_alg)
{
  int __retres;
  if (sig_oid->len == (size_t)9) {
    int tmp;
    tmp = memcmp((void const *)sig_oid->p,
                 (void const *)"*\206H\206\367\r\001\001",(size_t)8);
    if (tmp == 0) {
      if ((int)*(sig_oid->p + 8) >= 2) 
        if ((int)*(sig_oid->p + 8) <= 5) {
          *sig_alg = (int)*(sig_oid->p + 8);
          __retres = 0;
          goto return_label;
        }
      if ((int)*(sig_oid->p + 8) >= 11) 
        if ((int)*(sig_oid->p + 8) <= 14) {
          *sig_alg = (int)*(sig_oid->p + 8);
          __retres = 0;
          goto return_label;
        }
      __retres = -0x2680;
      goto return_label;
    }
  }
  if (sig_oid->len == (size_t)5) {
    int tmp_0;
    tmp_0 = memcmp((void const *)sig_oid->p,
                   (void const *)"+\016\003\002\035",(size_t)5);
    if (tmp_0 == 0) {
      *sig_alg = 5;
      __retres = 0;
      goto return_label;
    }
  }
  __retres = -0x2680;
  return_label: return __retres;
}

int x509parse_crt_der_core(x509_cert *crt, unsigned char const *buf,
                           size_t buflen)
{
  int __retres;
  int ret;
  size_t len;
  unsigned char *p;
  unsigned char *end;
  unsigned char *crt_end;
  void *tmp;
  if (crt == (x509_cert *)0) {
    __retres = -0x2A00;
    goto return_label;
  }
  else 
    if (buf == (unsigned char const *)0) {
      __retres = -0x2A00;
      goto return_label;
    }
  len = buflen;
  tmp = malloc(len);
  p = (unsigned char *)tmp;
  if (p == (unsigned char *)0) {
    __retres = -0x2A80;
    goto return_label;
  }
  memcpy((void *)p,(void const *)buf,buflen);
  buflen = (size_t)0;
  crt->raw.p = p;
  crt->raw.len = len;
  end = p + len;
  ret = asn1_get_tag(& p,(unsigned char const *)end,& len,0x20 | 0x10);
  if (ret != 0) {
    x509_free(crt);
    __retres = -0x2180;
    goto return_label;
  }
  if (len > (size_t)(end - p)) {
    x509_free(crt);
    __retres = -0x2180 + -0x001A;
    goto return_label;
  }
  crt_end = p + len;
  crt->tbs.p = p;
  ret = asn1_get_tag(& p,(unsigned char const *)end,& len,0x20 | 0x10);
  if (ret != 0) {
    x509_free(crt);
    __retres = -0x2180 + ret;
    goto return_label;
  }
  end = p + len;
  crt->tbs.len = (size_t)(end - crt->tbs.p);
  ret = x509_get_version(& p,(unsigned char const *)end,& crt->version);
  if (ret != 0) goto _LOR;
  else {
    ret = x509_get_serial(& p,(unsigned char const *)end,& crt->serial);
    if (ret != 0) goto _LOR;
    else {
      ret = x509_get_alg(& p,(unsigned char const *)end,& crt->sig_oid1);
      if (ret != 0) {
        _LOR: {
                x509_free(crt);
                __retres = ret;
                goto return_label;
              }
      }
    }
  }
  (crt->version) ++;
  if (crt->version > 3) {
    x509_free(crt);
    __retres = -0x2600;
    goto return_label;
  }
  ret = x509_get_sig_alg((x509_buf const *)(& crt->sig_oid1),& crt->sig_alg);
  if (ret != 0) {
    x509_free(crt);
    __retres = ret;
    goto return_label;
  }
  crt->issuer_raw.p = p;
  ret = asn1_get_tag(& p,(unsigned char const *)end,& len,0x20 | 0x10);
  if (ret != 0) {
    x509_free(crt);
    __retres = -0x2180 + ret;
    goto return_label;
  }
  ret = x509_get_name(& p,(unsigned char const *)(p + len),& crt->issuer);
  if (ret != 0) {
    x509_free(crt);
    __retres = ret;
    goto return_label;
  }
  crt->issuer_raw.len = (size_t)(p - crt->issuer_raw.p);
  ret = x509_get_dates(& p,(unsigned char const *)end,& crt->valid_from,
                       & crt->valid_to);
  if (ret != 0) {
    x509_free(crt);
    __retres = ret;
    goto return_label;
  }
  crt->subject_raw.p = p;
  ret = asn1_get_tag(& p,(unsigned char const *)end,& len,0x20 | 0x10);
  if (ret != 0) {
    x509_free(crt);
    __retres = -0x2180 + ret;
    goto return_label;
  }
  ret = x509_get_name(& p,(unsigned char const *)(p + len),& crt->subject);
  if (ret != 0) {
    x509_free(crt);
    __retres = ret;
    goto return_label;
  }
  crt->subject_raw.len = (size_t)(p - crt->subject_raw.p);
  ret = asn1_get_tag(& p,(unsigned char const *)end,& len,0x20 | 0x10);
  if (ret != 0) {
    x509_free(crt);
    __retres = -0x2180 + ret;
    goto return_label;
  }
  ret = x509_get_pubkey(& p,(unsigned char const *)(p + len),& crt->pk_oid,
                        & crt->rsa.N,& crt->rsa.E);
  if (ret != 0) {
    x509_free(crt);
    __retres = ret;
    goto return_label;
  }
  ret = rsa_check_pubkey((rsa_context const *)(& crt->rsa));
  if (ret != 0) {
    x509_free(crt);
    __retres = ret;
    goto return_label;
  }
  crt->rsa.len = mpi_size((mpi const *)(& crt->rsa.N));
  if (crt->version == 2) goto _LOR_0;
  else 
    if (crt->version == 3) {
      _LOR_0:
      {
        ret = x509_get_uid(& p,(unsigned char const *)end,& crt->issuer_id,1);
        if (ret != 0) {
          x509_free(crt);
          __retres = ret;
          goto return_label;
        }
      }
    }
  if (crt->version == 2) goto _LOR_1;
  else 
    if (crt->version == 3) {
      _LOR_1:
      {
        ret = x509_get_uid(& p,(unsigned char const *)end,& crt->subject_id,
                           2);
        if (ret != 0) {
          x509_free(crt);
          __retres = ret;
          goto return_label;
        }
      }
    }
  if (crt->version == 3) {
    ret = x509_get_crt_ext(& p,(unsigned char const *)end,crt);
    if (ret != 0) {
      x509_free(crt);
      __retres = ret;
      goto return_label;
    }
  }
  if (p != end) {
    x509_free(crt);
    __retres = -0x2180 + -0x001A;
    goto return_label;
  }
  end = crt_end;
  ret = x509_get_alg(& p,(unsigned char const *)end,& crt->sig_oid2);
  if (ret != 0) {
    x509_free(crt);
    __retres = ret;
    goto return_label;
  }
  if (crt->sig_oid1.len != crt->sig_oid2.len) goto _LOR_2;
  else {
    int tmp_0;
    tmp_0 = memcmp((void const *)crt->sig_oid1.p,
                   (void const *)crt->sig_oid2.p,crt->sig_oid1.len);
    if (tmp_0 != 0) {
      _LOR_2: {
                x509_free(crt);
                __retres = -0x2780;
                goto return_label;
              }
    }
  }
  ret = x509_get_sig(& p,(unsigned char const *)end,& crt->sig);
  if (ret != 0) {
    x509_free(crt);
    __retres = ret;
    goto return_label;
  }
  if (p != end) {
    x509_free(crt);
    __retres = -0x2180 + -0x001A;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int x509parse_crt_der(x509_cert *chain, unsigned char const *buf,
                      size_t buflen)
{
  int __retres;
  int ret;
  x509_cert *crt = chain;
  x509_cert *prev = (x509_cert *)0;
  if (crt == (x509_cert *)0) {
    __retres = -0x2A00;
    goto return_label;
  }
  else 
    if (buf == (unsigned char const *)0) {
      __retres = -0x2A00;
      goto return_label;
    }
  while (1) {
    if (crt->version != 0) {
      if (! (crt->next != (struct _x509_cert *)0)) break;
    }
    else break;
    prev = crt;
    crt = crt->next;
  }
  if (crt->version != 0) 
    if (crt->next == (struct _x509_cert *)0) {
      crt->next = (struct _x509_cert *)malloc(sizeof(x509_cert));
      if (crt->next == (struct _x509_cert *)0) {
        __retres = -0x2A80;
        goto return_label;
      }
      prev = crt;
      crt = crt->next;
      memset((void *)crt,0,sizeof(x509_cert));
    }
  ret = x509parse_crt_der_core(crt,buf,buflen);
  if (ret != 0) {
    if (prev) prev->next = (struct _x509_cert *)0;
    if (crt != chain) free((void *)crt);
    __retres = ret;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

/*@ assigns \result;
    assigns \result \from \nothing; */
int x509parse_crt(x509_cert *chain, unsigned char const *buf, size_t buflen)
{
  int __retres;
  int ret;
  char *tmp;
  int success = 0;
  int first_error = 0;
  int total_failed = 0;
  int buf_format = 1;
  if (chain == (x509_cert *)0) {
    __retres = -0x2A00;
    goto return_label;
  }
  else 
    if (buf == (unsigned char const *)0) {
      __retres = -0x2A00;
      goto return_label;
    }
  tmp = strstr((char const *)buf,"-----BEGIN CERTIFICATE-----");
  if (tmp != (char *)0) buf_format = 2;
  if (buf_format == 1) {
    int tmp_0;
    tmp_0 = x509parse_crt_der(chain,buf,buflen);
    __retres = tmp_0;
    goto return_label;
  }
  if (buf_format == 2) {
    pem_context pem;
    while (buflen > (size_t)0) {
      size_t use_len;
      pem_init(& pem);
      ret = pem_read_buffer(& pem,(char *)"-----BEGIN CERTIFICATE-----",
                            (char *)"-----END CERTIFICATE-----",buf,
                            (unsigned char const *)0,(size_t)0,& use_len);
      if (ret == 0) {
        buflen -= use_len;
        buf += use_len;
      }
      else 
        if (ret == -0x1480) {
          __retres = ret;
          goto return_label;
        }
        else 
          if (ret != -0x1080) {
            pem_free(& pem);
            buflen -= use_len;
            buf += use_len;
            if (first_error == 0) first_error = ret;
            continue;
          }
          else break;
      ret = x509parse_crt_der(chain,(unsigned char const *)pem.buf,
                              pem.buflen);
      pem_free(& pem);
      if (ret != 0) {
        if (ret == -0x2A80) {
          __retres = ret;
          goto return_label;
        }
        if (first_error == 0) first_error = ret;
        total_failed ++;
        continue;
      }
      success = 1;
    }
  }
  if (success) {
    __retres = total_failed;
    goto return_label;
  }
  else 
    if (first_error) {
      __retres = first_error;
      goto return_label;
    }
    else {
      __retres = -0x2980;
      goto return_label;
    }
  return_label: return __retres;
}

int x509parse_crl(x509_crl *chain, unsigned char const *buf, size_t buflen)
{
  int __retres;
  int ret;
  size_t len;
  unsigned char *p;
  unsigned char *end;
  x509_crl *crl;
  size_t use_len;
  pem_context pem;
  crl = chain;
  if (crl == (x509_crl *)0) {
    __retres = -0x2A00;
    goto return_label;
  }
  else 
    if (buf == (unsigned char const *)0) {
      __retres = -0x2A00;
      goto return_label;
    }
  while (1) {
    if (crl->version != 0) {
      if (! (crl->next != (struct _x509_crl *)0)) break;
    }
    else break;
    crl = crl->next;
  }
  if (crl->version != 0) 
    if (crl->next == (struct _x509_crl *)0) {
      crl->next = (struct _x509_crl *)malloc(sizeof(x509_crl));
      if (crl->next == (struct _x509_crl *)0) {
        x509_crl_free(crl);
        __retres = -0x2A80;
        goto return_label;
      }
      crl = crl->next;
      memset((void *)crl,0,sizeof(x509_crl));
    }
  pem_init(& pem);
  ret = pem_read_buffer(& pem,(char *)"-----BEGIN X509 CRL-----",
                        (char *)"-----END X509 CRL-----",buf,
                        (unsigned char const *)0,(size_t)0,& use_len);
  if (ret == 0) {
    buflen -= use_len;
    buf += use_len;
    p = pem.buf;
    pem.buf = (unsigned char *)0;
    len = pem.buflen;
    pem_free(& pem);
  }
  else 
    if (ret != -0x1080) {
      pem_free(& pem);
      __retres = ret;
      goto return_label;
    }
    else {
      void *tmp_0;
      len = buflen;
      tmp_0 = malloc(len);
      p = (unsigned char *)tmp_0;
      if (p == (unsigned char *)0) {
        __retres = -0x2A80;
        goto return_label;
      }
      memcpy((void *)p,(void const *)buf,buflen);
      buflen = (size_t)0;
    }
  crl->raw.p = p;
  crl->raw.len = len;
  end = p + len;
  ret = asn1_get_tag(& p,(unsigned char const *)end,& len,0x20 | 0x10);
  if (ret != 0) {
    x509_crl_free(crl);
    __retres = -0x2180;
    goto return_label;
  }
  if (len != (size_t)(end - p)) {
    x509_crl_free(crl);
    __retres = -0x2180 + -0x001A;
    goto return_label;
  }
  crl->tbs.p = p;
  ret = asn1_get_tag(& p,(unsigned char const *)end,& len,0x20 | 0x10);
  if (ret != 0) {
    x509_crl_free(crl);
    __retres = -0x2180 + ret;
    goto return_label;
  }
  end = p + len;
  crl->tbs.len = (size_t)(end - crl->tbs.p);
  ret = x509_crl_get_version(& p,(unsigned char const *)end,& crl->version);
  if (ret != 0) goto _LOR;
  else {
    ret = x509_get_alg(& p,(unsigned char const *)end,& crl->sig_oid1);
    if (ret != 0) {
      _LOR: {
              x509_crl_free(crl);
              __retres = ret;
              goto return_label;
            }
    }
  }
  (crl->version) ++;
  if (crl->version > 2) {
    x509_crl_free(crl);
    __retres = -0x2600;
    goto return_label;
  }
  ret = x509_get_sig_alg((x509_buf const *)(& crl->sig_oid1),& crl->sig_alg);
  if (ret != 0) {
    x509_crl_free(crl);
    __retres = -0x2680;
    goto return_label;
  }
  crl->issuer_raw.p = p;
  ret = asn1_get_tag(& p,(unsigned char const *)end,& len,0x20 | 0x10);
  if (ret != 0) {
    x509_crl_free(crl);
    __retres = -0x2180 + ret;
    goto return_label;
  }
  ret = x509_get_name(& p,(unsigned char const *)(p + len),& crl->issuer);
  if (ret != 0) {
    x509_crl_free(crl);
    __retres = ret;
    goto return_label;
  }
  crl->issuer_raw.len = (size_t)(p - crl->issuer_raw.p);
  ret = x509_get_time(& p,(unsigned char const *)end,& crl->this_update);
  if (ret != 0) {
    x509_crl_free(crl);
    __retres = ret;
    goto return_label;
  }
  ret = x509_get_time(& p,(unsigned char const *)end,& crl->next_update);
  if (ret != 0) 
    if (ret != -0x2400 + -0x0016) 
      if (ret != -0x2400 + -0x0014) {
        x509_crl_free(crl);
        __retres = ret;
        goto return_label;
      }
  ret = x509_get_entries(& p,(unsigned char const *)end,& crl->entry);
  if (ret != 0) {
    x509_crl_free(crl);
    __retres = ret;
    goto return_label;
  }
  if (crl->version == 2) {
    ret = x509_get_crl_ext(& p,(unsigned char const *)end,& crl->crl_ext);
    if (ret != 0) {
      x509_crl_free(crl);
      __retres = ret;
      goto return_label;
    }
  }
  if (p != end) {
    x509_crl_free(crl);
    __retres = -0x2180 + -0x001A;
    goto return_label;
  }
  end = crl->raw.p + crl->raw.len;
  ret = x509_get_alg(& p,(unsigned char const *)end,& crl->sig_oid2);
  if (ret != 0) {
    x509_crl_free(crl);
    __retres = ret;
    goto return_label;
  }
  if (crl->sig_oid1.len != crl->sig_oid2.len) goto _LOR_0;
  else {
    int tmp_1;
    tmp_1 = memcmp((void const *)crl->sig_oid1.p,
                   (void const *)crl->sig_oid2.p,crl->sig_oid1.len);
    if (tmp_1 != 0) {
      _LOR_0: {
                x509_crl_free(crl);
                __retres = -0x2780;
                goto return_label;
              }
    }
  }
  ret = x509_get_sig(& p,(unsigned char const *)end,& crl->sig);
  if (ret != 0) {
    x509_crl_free(crl);
    __retres = ret;
    goto return_label;
  }
  if (p != end) {
    x509_crl_free(crl);
    __retres = -0x2180 + -0x001A;
    goto return_label;
  }
  if (buflen > (size_t)0) {
    int tmp_3;
    crl->next = (struct _x509_crl *)malloc(sizeof(x509_crl));
    if (crl->next == (struct _x509_crl *)0) {
      x509_crl_free(crl);
      __retres = -0x2A80;
      goto return_label;
    }
    crl = crl->next;
    memset((void *)crl,0,sizeof(x509_crl));
    tmp_3 = x509parse_crl(crl,buf,buflen);
    __retres = tmp_3;
    goto return_label;
  }
  __retres = 0;
  return_label: return __retres;
}

int load_file(char const *path, unsigned char **buf, size_t *n)
{
  int __retres;
  FILE *f;
  long tmp;
  unsigned char *tmp_0;
  size_t tmp_2;
  f = fopen(path,"rb");
  if (f == (FILE *)0) {
    __retres = -0x2B00;
    goto return_label;
  }
  fseek(f,(long)0,2);
  tmp = ftell(f);
  *n = (size_t)tmp;
  fseek(f,(long)0,0);
  tmp_0 = (unsigned char *)malloc(*n + (size_t)1);
  *buf = tmp_0;
  if (tmp_0 == (unsigned char *)0) {
    __retres = -0x2A80;
    goto return_label;
  }
  tmp_2 = fread((void *)*buf,(size_t)1,*n,f);
  ;
  if (tmp_2 != *n) {
    fclose(f);
    free((void *)*buf);
    __retres = -0x2B00;
    goto return_label;
  }
  fclose(f);
  *(*buf + *n) = (unsigned char)'\000';
  __retres = 0;
  return_label: return __retres;
}

int x509parse_crtfile(x509_cert *chain, char const *path)
{
  int __retres;
  int ret;
  size_t n;
  unsigned char *buf;
  ret = load_file(path,& buf,& n);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  ret = x509parse_crt(chain,(unsigned char const *)buf,n);
  memset((void *)buf,0,n + (size_t)1);
  free((void *)buf);
  __retres = ret;
  return_label: return __retres;
}

int x509parse_crlfile(x509_crl *chain, char const *path)
{
  int __retres;
  int ret;
  size_t n;
  unsigned char *buf;
  ret = load_file(path,& buf,& n);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  ret = x509parse_crl(chain,(unsigned char const *)buf,n);
  memset((void *)buf,0,n + (size_t)1);
  free((void *)buf);
  __retres = ret;
  return_label: return __retres;
}

int x509parse_keyfile(rsa_context *rsa, char const *path, char const *pwd)
{
  int __retres;
  int ret;
  size_t n;
  unsigned char *buf;
  ret = load_file(path,& buf,& n);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  if (pwd == (char const *)0) ret = x509parse_key(rsa,
                                                  (unsigned char const *)buf,
                                                  n,(unsigned char const *)0,
                                                  (size_t)0);
  else {
    size_t tmp;
    tmp = strlen(pwd);
    ;
    ;
    ;
    ;
    ret = x509parse_key(rsa,(unsigned char const *)buf,n,
                        (unsigned char const *)pwd,tmp);
  }
  memset((void *)buf,0,n + (size_t)1);
  free((void *)buf);
  __retres = ret;
  return_label: return __retres;
}

int x509parse_public_keyfile(rsa_context *rsa, char const *path)
{
  int __retres;
  int ret;
  size_t n;
  unsigned char *buf;
  ret = load_file(path,& buf,& n);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  ret = x509parse_public_key(rsa,(unsigned char const *)buf,n);
  memset((void *)buf,0,n + (size_t)1);
  free((void *)buf);
  __retres = ret;
  return_label: return __retres;
}

/*@ requires \valid(rsa);
    assigns \result, rsa->N, rsa->E, rsa->D, rsa->P, rsa->Q, rsa->DP,
            rsa->DQ, rsa->QP, rsa->len;
    assigns \result \from _rsa_keyfile;
    assigns rsa->N \from _rsa_keyfile;
    assigns rsa->E \from _rsa_keyfile;
    assigns rsa->D \from _rsa_keyfile;
    assigns rsa->P \from _rsa_keyfile;
    assigns rsa->Q \from _rsa_keyfile;
    assigns rsa->DP \from _rsa_keyfile;
    assigns rsa->DQ \from _rsa_keyfile;
    assigns rsa->QP \from _rsa_keyfile;
    assigns rsa->len \from _rsa_keyfile;
 */
int x509parse_key(rsa_context *rsa, unsigned char const *key, size_t keylen,
                  unsigned char const *pwd, size_t pwdlen)
{
  int __retres;
  int ret;
  size_t len;
  unsigned char *p;
  unsigned char *end;
  unsigned char *p_alt;
  x509_buf pk_alg_oid;
  pem_context pem;
  pem_init(& pem);
  ret = pem_read_buffer(& pem,(char *)"-----BEGIN RSA PRIVATE KEY-----",
                        (char *)"-----END RSA PRIVATE KEY-----",key,pwd,
                        pwdlen,& len);
  if (ret == -0x1080) ret = pem_read_buffer(& pem,
                                            (char *)"-----BEGIN PRIVATE KEY-----",
                                            (char *)"-----END PRIVATE KEY-----",
                                            key,pwd,pwdlen,& len);
  if (ret == 0) keylen = pem.buflen;
  else 
    if (ret != -0x1080) {
      pem_free(& pem);
      __retres = ret;
      goto return_label;
    }
  if (ret == 0) p = pem.buf; else p = (unsigned char *)key;
  end = p + keylen;
  ret = asn1_get_tag(& p,(unsigned char const *)end,& len,0x20 | 0x10);
  if (ret != 0) {
    pem_free(& pem);
    rsa_free(rsa);
    __retres = -0x2900 + ret;
    goto return_label;
  }
  end = p + len;
  ret = asn1_get_int(& p,(unsigned char const *)end,& rsa->ver);
  if (ret != 0) {
    pem_free(& pem);
    rsa_free(rsa);
    __retres = -0x2900 + ret;
    goto return_label;
  }
  if (rsa->ver != 0) {
    pem_free(& pem);
    rsa_free(rsa);
    __retres = -0x2880 + ret;
    goto return_label;
  }
  p_alt = p;
  ret = x509_get_alg(& p_alt,(unsigned char const *)end,& pk_alg_oid);
  if (ret != 0) {
    if (ret != -0x2300 + -0x0016) {
      pem_free(& pem);
      rsa_free(rsa);
      __retres = -0x2900;
      goto return_label;
    }
  }
  else {
    int can_handle;
    can_handle = 0;
    if (pk_alg_oid.len == (size_t)9) {
      int tmp;
      tmp = memcmp((void const *)pk_alg_oid.p,
                   (void const *)"*\206H\206\367\r\001\001\001",(size_t)9);
      if (tmp == 0) can_handle = 1;
    }
    if (pk_alg_oid.len == (size_t)9) {
      int tmp_0;
      tmp_0 = memcmp((void const *)pk_alg_oid.p,
                     (void const *)"*\206H\206\367\r\001\001",(size_t)8);
      if (tmp_0 == 0) {
        if ((int)*(pk_alg_oid.p + 8) >= 2) 
          if ((int)*(pk_alg_oid.p + 8) <= 5) can_handle = 1;
        if ((int)*(pk_alg_oid.p + 8) >= 11) 
          if ((int)*(pk_alg_oid.p + 8) <= 14) can_handle = 1;
      }
    }
    if (pk_alg_oid.len == (size_t)5) {
      int tmp_1;
      tmp_1 = memcmp((void const *)pk_alg_oid.p,
                     (void const *)"+\016\003\002\035",(size_t)5);
      if (tmp_1 == 0) can_handle = 1;
    }
    if (can_handle == 0) {
      __retres = -0x2700;
      goto return_label;
    }
    p = p_alt;
    ret = asn1_get_tag(& p,(unsigned char const *)end,& len,0x04);
    if (ret != 0) {
      pem_free(& pem);
      rsa_free(rsa);
      __retres = -0x2900 + ret;
      goto return_label;
    }
    if (end - p < 1) {
      pem_free(& pem);
      rsa_free(rsa);
      __retres = -0x2900 + -0x0014;
      goto return_label;
    }
    end = p + len;
    ret = asn1_get_tag(& p,(unsigned char const *)end,& len,0x20 | 0x10);
    if (ret != 0) {
      pem_free(& pem);
      rsa_free(rsa);
      __retres = -0x2900 + ret;
      goto return_label;
    }
    end = p + len;
    ret = asn1_get_int(& p,(unsigned char const *)end,& rsa->ver);
    if (ret != 0) {
      pem_free(& pem);
      rsa_free(rsa);
      __retres = -0x2900 + ret;
      goto return_label;
    }
    if (rsa->ver != 0) {
      pem_free(& pem);
      rsa_free(rsa);
      __retres = -0x2880 + ret;
      goto return_label;
    }
  }
  ret = asn1_get_mpi(& p,(unsigned char const *)end,& rsa->N);
  if (ret != 0) goto _LOR;
  else {
    ret = asn1_get_mpi(& p,(unsigned char const *)end,& rsa->E);
    if (ret != 0) goto _LOR;
    else {
      ret = asn1_get_mpi(& p,(unsigned char const *)end,& rsa->D);
      if (ret != 0) goto _LOR;
      else {
        ret = asn1_get_mpi(& p,(unsigned char const *)end,& rsa->P);
        if (ret != 0) goto _LOR;
        else {
          ret = asn1_get_mpi(& p,(unsigned char const *)end,& rsa->Q);
          if (ret != 0) goto _LOR;
          else {
            ret = asn1_get_mpi(& p,(unsigned char const *)end,& rsa->DP);
            if (ret != 0) goto _LOR;
            else {
              ret = asn1_get_mpi(& p,(unsigned char const *)end,& rsa->DQ);
              if (ret != 0) goto _LOR;
              else {
                ret = asn1_get_mpi(& p,(unsigned char const *)end,& rsa->QP);
                if (ret != 0) {
                  _LOR:
                  {
                    pem_free(& pem);
                    rsa_free(rsa);
                    __retres = -0x2900 + ret;
                    goto return_label;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  rsa->len = mpi_size((mpi const *)(& rsa->N));
  if (p != end) {
    pem_free(& pem);
    rsa_free(rsa);
    __retres = -0x2900 + -0x001A;
    goto return_label;
  }
  ret = rsa_check_privkey((rsa_context const *)rsa);
  if (ret != 0) {
    pem_free(& pem);
    rsa_free(rsa);
    __retres = ret;
    goto return_label;
  }
  pem_free(& pem);
  __retres = 0;
  return_label: return __retres;
}

int x509parse_public_key(rsa_context *rsa, unsigned char const *key,
                         size_t keylen)
{
  int __retres;
  int ret;
  size_t len;
  unsigned char *p;
  unsigned char *end;
  x509_buf alg_oid;
  pem_context pem;
  pem_init(& pem);
  ret = pem_read_buffer(& pem,(char *)"-----BEGIN PUBLIC KEY-----",
                        (char *)"-----END PUBLIC KEY-----",key,
                        (unsigned char const *)0,(size_t)0,& len);
  if (ret == 0) keylen = pem.buflen;
  else 
    if (ret != -0x1080) {
      pem_free(& pem);
      __retres = ret;
      goto return_label;
    }
  if (ret == 0) p = pem.buf; else p = (unsigned char *)key;
  end = p + keylen;
  ret = asn1_get_tag(& p,(unsigned char const *)end,& len,0x20 | 0x10);
  if (ret != 0) {
    pem_free(& pem);
    rsa_free(rsa);
    __retres = -0x2180 + ret;
    goto return_label;
  }
  ret = x509_get_pubkey(& p,(unsigned char const *)end,& alg_oid,& rsa->N,
                        & rsa->E);
  if (ret != 0) {
    pem_free(& pem);
    rsa_free(rsa);
    __retres = -0x2900 + ret;
    goto return_label;
  }
  ret = rsa_check_pubkey((rsa_context const *)rsa);
  if (ret != 0) {
    pem_free(& pem);
    rsa_free(rsa);
    __retres = ret;
    goto return_label;
  }
  rsa->len = mpi_size((mpi const *)(& rsa->N));
  pem_free(& pem);
  __retres = 0;
  return_label: return __retres;
}

int x509parse_dhm(dhm_context *dhm, unsigned char const *dhmin,
                  size_t dhminlen)
{
  int __retres;
  int ret;
  size_t len;
  unsigned char *p;
  unsigned char *end;
  pem_context pem;
  pem_init(& pem);
  ret = pem_read_buffer(& pem,(char *)"-----BEGIN DH PARAMETERS-----",
                        (char *)"-----END DH PARAMETERS-----",dhmin,
                        (unsigned char const *)0,(size_t)0,& dhminlen);
  if (ret == 0) dhminlen = pem.buflen;
  else 
    if (ret != -0x1080) {
      pem_free(& pem);
      __retres = ret;
      goto return_label;
    }
  if (ret == 0) p = pem.buf; else p = (unsigned char *)dhmin;
  end = p + dhminlen;
  memset((void *)dhm,0,sizeof(dhm_context));
  ret = asn1_get_tag(& p,(unsigned char const *)end,& len,0x20 | 0x10);
  if (ret != 0) {
    pem_free(& pem);
    __retres = -0x2900 + ret;
    goto return_label;
  }
  end = p + len;
  ret = asn1_get_mpi(& p,(unsigned char const *)end,& dhm->P);
  if (ret != 0) goto _LOR;
  else {
    ret = asn1_get_mpi(& p,(unsigned char const *)end,& dhm->G);
    if (ret != 0) {
      _LOR:
      {
        pem_free(& pem);
        dhm_free(dhm);
        __retres = -0x2900 + ret;
        goto return_label;
      }
    }
  }
  if (p != end) {
    pem_free(& pem);
    dhm_free(dhm);
    __retres = -0x2900 + -0x001A;
    goto return_label;
  }
  pem_free(& pem);
  __retres = 0;
  return_label: return __retres;
}

int x509parse_dhmfile(dhm_context *dhm, char const *path)
{
  int __retres;
  int ret;
  size_t n;
  unsigned char *buf;
  ret = load_file(path,& buf,& n);
  if (ret != 0) {
    __retres = ret;
    goto return_label;
  }
  ret = x509parse_dhm(dhm,(unsigned char const *)buf,n);
  memset((void *)buf,0,n + (size_t)1);
  free((void *)buf);
  __retres = ret;
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_12(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_13(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_14(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_15(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_16(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_17(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_18(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))), (indirect: param0);
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param0;
 */
int snprintf_va_19(char * restrict s, size_t n, char const * restrict format,
                   unsigned int param0);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_20(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))), (indirect: param0);
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param0;
 */
int snprintf_va_21(char * restrict s, size_t n, char const * restrict format,
                   unsigned int param0);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_22(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int snprintf_va_23(char * restrict s, size_t n, char const * restrict format,
                   char *param0);

int x509parse_dn_gets(char *buf, size_t size, x509_name const *dn)
{
  int __retres;
  int ret;
  size_t i;
  size_t n;
  unsigned char c;
  x509_name const *name;
  char s[128];
  char *p;
  memset((void *)(s),0,sizeof(s));
  name = dn;
  p = buf;
  n = size;
  while (name != (x509_name const *)0) {
    if (name != dn) {
      ret = snprintf(p,n,", "); /* snprintf_va_12 */
      if (ret == -1) {
        __retres = -1;
        goto return_label;
      }
      if ((unsigned int)ret > n) {
        *(p + (n - (size_t)1)) = (char)'\000';
        __retres = -2;
        goto return_label;
      }
      n -= (unsigned int)ret;
      p += (unsigned int)ret;
    }
    if (name->oid.len == (size_t)3) {
      int tmp_0;
      tmp_0 = memcmp((void const *)name->oid.p,(void const *)"U\004",
                     (size_t)2);
      if (tmp_0 == 0) {
        switch ((int)*(name->oid.p + 2)) {
          case 3: ret = snprintf(p,n,"CN="); /* snprintf_va_13 */
          break;
          case 6: ret = snprintf(p,n,"C="); /* snprintf_va_14 */
          break;
          case 7: ret = snprintf(p,n,"L="); /* snprintf_va_15 */
          break;
          case 8: ret = snprintf(p,n,"ST="); /* snprintf_va_16 */
          break;
          case 10: ret = snprintf(p,n,"O="); /* snprintf_va_17 */
          break;
          case 11: ret = snprintf(p,n,"OU="); /* snprintf_va_18 */
          break;
          default:
          ret = snprintf(p,n,"0x%02X=",
                         (unsigned int)((int)*(name->oid.p + 2))); /* snprintf_va_19 */
          break;
        }
        if (ret == -1) {
          __retres = -1;
          goto return_label;
        }
        if ((unsigned int)ret > n) {
          *(p + (n - (size_t)1)) = (char)'\000';
          __retres = -2;
          goto return_label;
        }
        n -= (unsigned int)ret;
        p += (unsigned int)ret;
      }
      else goto _LAND_0;
    }
    else {
      _LAND_0: ;
      if (name->oid.len == (size_t)9) {
        int tmp;
        tmp = memcmp((void const *)name->oid.p,
                     (void const *)"*\206H\206\367\r\001\t",(size_t)8);
        if (tmp == 0) {
          switch ((int)*(name->oid.p + 8)) {
            case 1: ret = snprintf(p,n,"emailAddress="); /* snprintf_va_20 */
            break;
            default:
            ret = snprintf(p,n,"0x%02X=",
                           (unsigned int)((int)*(name->oid.p + 8))); /* snprintf_va_21 */
            break;
          }
          if (ret == -1) {
            __retres = -1;
            goto return_label;
          }
          if ((unsigned int)ret > n) {
            *(p + (n - (size_t)1)) = (char)'\000';
            __retres = -2;
            goto return_label;
          }
          n -= (unsigned int)ret;
          p += (unsigned int)ret;
        }
        else goto _LAND;
      }
      else {
        _LAND:
        {
          ret = snprintf(p,n,"?\?="); /* snprintf_va_22 */
          if (ret == -1) {
            __retres = -1;
            goto return_label;
          }
          if ((unsigned int)ret > n) {
            *(p + (n - (size_t)1)) = (char)'\000';
            __retres = -2;
            goto return_label;
          }
          n -= (unsigned int)ret;
          p += (unsigned int)ret;
        }
      }
    }
    i = (size_t)0;
    while (i < name->val.len) {
      if (i >= sizeof(s) - (unsigned int)1) break;
      c = *(name->val.p + i);
      if ((int)c < 32) s[i] = (char)'?';
      else 
        if ((int)c == 127) s[i] = (char)'?';
        else 
          if ((int)c > 128) 
            if ((int)c < 160) s[i] = (char)'?'; else s[i] = (char)c;
          else s[i] = (char)c;
      i ++;
    }
    s[i] = (char)'\000';
    ret = snprintf(p,n,"%s",s); /* snprintf_va_23 */
    if (ret == -1) {
      __retres = -1;
      goto return_label;
    }
    if ((unsigned int)ret > n) {
      *(p + (n - (size_t)1)) = (char)'\000';
      __retres = -2;
      goto return_label;
    }
    n -= (unsigned int)ret;
    p += (unsigned int)ret;
    name = (x509_name const *)name->next;
  }
  __retres = (int)(size - n);
  return_label: return __retres;
}

/*@ requires valid_read_string(param1);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: *(param1 + (0 ..))), (indirect: param0);
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))),
            *(param1 + (0 ..)), param0;
 */
int snprintf_va_24(char * restrict s, size_t n, char const * restrict format,
                   unsigned int param0, char *param1);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_25(char * restrict s, size_t n, char const * restrict format);

int x509parse_serial_gets(char *buf, size_t size, x509_buf const *serial)
{
  int __retres;
  int ret;
  size_t i;
  size_t n;
  size_t nr;
  char *p;
  p = buf;
  n = size;
  if (serial->len <= (size_t)32) nr = serial->len; else nr = (size_t)28;
  i = (size_t)0;
  while (i < nr) {
    {
      char const *tmp;
      if (i == (size_t)0) 
        if (nr > (size_t)1) 
          if ((int)*(serial->p + i) == 0x0) goto __Cont;
      if (i < nr - (size_t)1) tmp = ":"; else tmp = "";
      ;
      ;
      ;
      ret = snprintf(p,n,"%02X%s",(unsigned int)((int)*(serial->p + i)),
                     (char *)tmp); /* snprintf_va_24 */
      if (ret == -1) {
        __retres = -1;
        goto return_label;
      }
      if ((unsigned int)ret > n) {
        *(p + (n - (size_t)1)) = (char)'\000';
        __retres = -2;
        goto return_label;
      }
      n -= (unsigned int)ret;
      p += (unsigned int)ret;
    }
    __Cont: i ++;
  }
  if (nr != serial->len) {
    ret = snprintf(p,n,"...."); /* snprintf_va_25 */
    if (ret == -1) {
      __retres = -1;
      goto return_label;
    }
    if ((unsigned int)ret > n) {
      *(p + (n - (size_t)1)) = (char)'\000';
      __retres = -2;
      goto return_label;
    }
    n -= (unsigned int)ret;
    p += (unsigned int)ret;
  }
  __retres = (int)(size - n);
  return_label: return __retres;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: param1), (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param1,
            *(param0 + (0 ..));
 */
int snprintf_va_26(char * restrict s, size_t n, char const * restrict format,
                   char *param0, int param1);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int snprintf_va_27(char * restrict s, size_t n, char const * restrict format,
                   char *param0);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int snprintf_va_28(char * restrict s, size_t n, char const * restrict format,
                   char *param0);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int snprintf_va_29(char * restrict s, size_t n, char const * restrict format,
                   char *param0);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: param6), (indirect: param5), (indirect: param4),
            (indirect: param3), (indirect: param2), (indirect: param1),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param6, param5,
            param4, param3, param2, param1, *(param0 + (0 ..));
 */
int snprintf_va_30(char * restrict s, size_t n, char const * restrict format,
                   char *param0, int param1, int param2, int param3,
                   int param4, int param5, int param6);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: param6), (indirect: param5), (indirect: param4),
            (indirect: param3), (indirect: param2), (indirect: param1),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param6, param5,
            param4, param3, param2, param1, *(param0 + (0 ..));
 */
int snprintf_va_31(char * restrict s, size_t n, char const * restrict format,
                   char *param0, int param1, int param2, int param3,
                   int param4, int param5, int param6);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int snprintf_va_32(char * restrict s, size_t n, char const * restrict format,
                   char *param0);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_33(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_34(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_35(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_36(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_37(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_38(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_39(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_40(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_41(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: param1), (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param1,
            *(param0 + (0 ..));
 */
int snprintf_va_42(char * restrict s, size_t n, char const * restrict format,
                   char *param0, int param1);

int x509parse_cert_info(char *buf, size_t size, char const *prefix,
                        x509_cert const *crt)
{
  int __retres;
  int ret;
  size_t n;
  char *p;
  p = buf;
  n = size;
  ret = snprintf(p,n,"%scert. version : %d\n",(char *)prefix,crt->version); /* snprintf_va_26 */
  if (ret == -1) {
    __retres = -1;
    goto return_label;
  }
  if ((unsigned int)ret > n) {
    *(p + (n - (size_t)1)) = (char)'\000';
    __retres = -2;
    goto return_label;
  }
  n -= (unsigned int)ret;
  p += (unsigned int)ret;
  ret = snprintf(p,n,"%sserial number : ",(char *)prefix); /* snprintf_va_27 */
  if (ret == -1) {
    __retres = -1;
    goto return_label;
  }
  if ((unsigned int)ret > n) {
    *(p + (n - (size_t)1)) = (char)'\000';
    __retres = -2;
    goto return_label;
  }
  n -= (unsigned int)ret;
  p += (unsigned int)ret;
  ret = x509parse_serial_gets(p,n,& crt->serial);
  if (ret == -1) {
    __retres = -1;
    goto return_label;
  }
  if ((unsigned int)ret > n) {
    *(p + (n - (size_t)1)) = (char)'\000';
    __retres = -2;
    goto return_label;
  }
  n -= (unsigned int)ret;
  p += (unsigned int)ret;
  ret = snprintf(p,n,"\n%sissuer name   : ",(char *)prefix); /* snprintf_va_28 */
  if (ret == -1) {
    __retres = -1;
    goto return_label;
  }
  if ((unsigned int)ret > n) {
    *(p + (n - (size_t)1)) = (char)'\000';
    __retres = -2;
    goto return_label;
  }
  n -= (unsigned int)ret;
  p += (unsigned int)ret;
  ret = x509parse_dn_gets(p,n,& crt->issuer);
  if (ret == -1) {
    __retres = -1;
    goto return_label;
  }
  if ((unsigned int)ret > n) {
    *(p + (n - (size_t)1)) = (char)'\000';
    __retres = -2;
    goto return_label;
  }
  n -= (unsigned int)ret;
  p += (unsigned int)ret;
  ret = snprintf(p,n,"\n%ssubject name  : ",(char *)prefix); /* snprintf_va_29 */
  if (ret == -1) {
    __retres = -1;
    goto return_label;
  }
  if ((unsigned int)ret > n) {
    *(p + (n - (size_t)1)) = (char)'\000';
    __retres = -2;
    goto return_label;
  }
  n -= (unsigned int)ret;
  p += (unsigned int)ret;
  ret = x509parse_dn_gets(p,n,& crt->subject);
  if (ret == -1) {
    __retres = -1;
    goto return_label;
  }
  if ((unsigned int)ret > n) {
    *(p + (n - (size_t)1)) = (char)'\000';
    __retres = -2;
    goto return_label;
  }
  n -= (unsigned int)ret;
  p += (unsigned int)ret;
  ret = snprintf(p,n,"\n%sissued  on    : %04d-%02d-%02d %02d:%02d:%02d",
                 (char *)prefix,crt->valid_from.year,crt->valid_from.mon,
                 crt->valid_from.day,crt->valid_from.hour,
                 crt->valid_from.min,crt->valid_from.sec); /* snprintf_va_30 */
  if (ret == -1) {
    __retres = -1;
    goto return_label;
  }
  if ((unsigned int)ret > n) {
    *(p + (n - (size_t)1)) = (char)'\000';
    __retres = -2;
    goto return_label;
  }
  n -= (unsigned int)ret;
  p += (unsigned int)ret;
  ret = snprintf(p,n,"\n%sexpires on    : %04d-%02d-%02d %02d:%02d:%02d",
                 (char *)prefix,crt->valid_to.year,crt->valid_to.mon,
                 crt->valid_to.day,crt->valid_to.hour,crt->valid_to.min,
                 crt->valid_to.sec); /* snprintf_va_31 */
  if (ret == -1) {
    __retres = -1;
    goto return_label;
  }
  if ((unsigned int)ret > n) {
    *(p + (n - (size_t)1)) = (char)'\000';
    __retres = -2;
    goto return_label;
  }
  n -= (unsigned int)ret;
  p += (unsigned int)ret;
  ret = snprintf(p,n,"\n%ssigned using  : RSA+",(char *)prefix); /* snprintf_va_32 */
  if (ret == -1) {
    __retres = -1;
    goto return_label;
  }
  if ((unsigned int)ret > n) {
    *(p + (n - (size_t)1)) = (char)'\000';
    __retres = -2;
    goto return_label;
  }
  n -= (unsigned int)ret;
  p += (unsigned int)ret;
  switch (crt->sig_alg) {
    case 2: ret = snprintf(p,n,"MD2"); /* snprintf_va_33 */
    break;
    case 3: ret = snprintf(p,n,"MD4"); /* snprintf_va_34 */
    break;
    case 4: ret = snprintf(p,n,"MD5"); /* snprintf_va_35 */
    break;
    case 5: ret = snprintf(p,n,"SHA1"); /* snprintf_va_36 */
    break;
    case 14: ret = snprintf(p,n,"SHA224"); /* snprintf_va_37 */
    break;
    case 11: ret = snprintf(p,n,"SHA256"); /* snprintf_va_38 */
    break;
    case 12: ret = snprintf(p,n,"SHA384"); /* snprintf_va_39 */
    break;
    case 13: ret = snprintf(p,n,"SHA512"); /* snprintf_va_40 */
    break;
    default: ret = snprintf(p,n,"?\?\?"); /* snprintf_va_41 */
    break;
  }
  if (ret == -1) {
    __retres = -1;
    goto return_label;
  }
  if ((unsigned int)ret > n) {
    *(p + (n - (size_t)1)) = (char)'\000';
    __retres = -2;
    goto return_label;
  }
  n -= (unsigned int)ret;
  p += (unsigned int)ret;
  ret = snprintf(p,n,"\n%sRSA key size  : %d bits\n",(char *)prefix,
                 ((int)crt->rsa.N.n * (int)sizeof(unsigned long)) * 8); /* snprintf_va_42 */
  if (ret == -1) {
    __retres = -1;
    goto return_label;
  }
  if ((unsigned int)ret > n) {
    *(p + (n - (size_t)1)) = (char)'\000';
    __retres = -2;
    goto return_label;
  }
  n -= (unsigned int)ret;
  p += (unsigned int)ret;
  __retres = (int)(size - n);
  return_label: return __retres;
}

char const *x509_oid_get_description(x509_buf *oid)
{
  char const *__retres;
  if (oid == (x509_buf *)0) {
    __retres = (char const *)0;
    goto return_label;
  }
  else 
    if (sizeof("+\006\001\005\005\a\003\001") - (unsigned int)1 == oid->len) {
      int tmp_4;
      tmp_4 = memcmp((void const *)"+\006\001\005\005\a\003\001",
                     (void const *)oid->p,oid->len);
      if (tmp_4 == 0) {
        __retres = "TLS Web Server Authentication";
        goto return_label;
      }
      else goto _LAND_3;
    }
    else {
      _LAND_3: ;
      if (sizeof("+\006\001\005\005\a\003\002") - (unsigned int)1 == oid->len) {
        int tmp_3;
        tmp_3 = memcmp((void const *)"+\006\001\005\005\a\003\002",
                       (void const *)oid->p,oid->len);
        if (tmp_3 == 0) {
          __retres = "TLS Web Client Authentication";
          goto return_label;
        }
        else goto _LAND_2;
      }
      else {
        _LAND_2: ;
        if (sizeof("+\006\001\005\005\a\003\003") - (unsigned int)1 == oid->len) {
          int tmp_2;
          tmp_2 = memcmp((void const *)"+\006\001\005\005\a\003\003",
                         (void const *)oid->p,oid->len);
          if (tmp_2 == 0) {
            __retres = "Code Signing";
            goto return_label;
          }
          else goto _LAND_1;
        }
        else {
          _LAND_1: ;
          if (sizeof("+\006\001\005\005\a\003\004") - (unsigned int)1 == oid->len) {
            int tmp_1;
            tmp_1 = memcmp((void const *)"+\006\001\005\005\a\003\004",
                           (void const *)oid->p,oid->len);
            if (tmp_1 == 0) {
              __retres = "E-mail Protection";
              goto return_label;
            }
            else goto _LAND_0;
          }
          else {
            _LAND_0: ;
            if (sizeof("+\006\001\005\005\a\003\b") - (unsigned int)1 == oid->len) {
              int tmp_0;
              tmp_0 = memcmp((void const *)"+\006\001\005\005\a\003\b",
                             (void const *)oid->p,oid->len);
              if (tmp_0 == 0) {
                __retres = "Time Stamping";
                goto return_label;
              }
              else goto _LAND;
            }
            else {
              _LAND: ;
              if (sizeof("+\006\001\005\005\a\003\t") - (unsigned int)1 == oid->len) {
                int tmp;
                tmp = memcmp((void const *)"+\006\001\005\005\a\003\t",
                             (void const *)oid->p,oid->len);
                if (tmp == 0) {
                  __retres = "OCSP Signing";
                  goto return_label;
                }
              }
            }
          }
        }
      }
    }
  __retres = (char const *)0;
  return_label: return __retres;
}

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: param1), (indirect: param0);
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param1, param0;
 */
int snprintf_va_43(char * restrict s, size_t n, char const * restrict format,
                   int param0, int param1);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))), (indirect: param0);
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param0;
 */
int snprintf_va_44(char * restrict s, size_t n, char const * restrict format,
                   int param0);

int x509_oid_get_numeric_string(char *buf, size_t size, x509_buf *oid)
{
  int __retres;
  int ret;
  size_t i;
  size_t n;
  unsigned int value;
  char *p;
  p = buf;
  n = size;
  if (oid->len > (size_t)0) {
    ret = snprintf(p,n,"%d.%d",(int)*(oid->p + 0) / 40,
                   (int)*(oid->p + 0) % 40); /* snprintf_va_43 */
    if (ret == -1) {
      __retres = -1;
      goto return_label;
    }
    if ((unsigned int)ret > n) {
      *(p + (n - (size_t)1)) = (char)'\000';
      __retres = -2;
      goto return_label;
    }
    n -= (unsigned int)ret;
    p += (unsigned int)ret;
  }
  value = (unsigned int)0;
  i = (size_t)1;
  while (i < oid->len) {
    value <<= 7;
    value += (unsigned int)((int)*(oid->p + i) & 0x7F);
    if (! ((int)*(oid->p + i) & 0x80)) {
      ret = snprintf(p,n,".%d",(int)value); /* snprintf_va_44 */
      if (ret == -1) {
        __retres = -1;
        goto return_label;
      }
      if ((unsigned int)ret > n) {
        *(p + (n - (size_t)1)) = (char)'\000';
        __retres = -2;
        goto return_label;
      }
      n -= (unsigned int)ret;
      p += (unsigned int)ret;
      value = (unsigned int)0;
    }
    i ++;
  }
  __retres = (int)(size - n);
  return_label: return __retres;
}

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: param1), (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param1,
            *(param0 + (0 ..));
 */
int snprintf_va_45(char * restrict s, size_t n, char const * restrict format,
                   char *param0, int param1);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int snprintf_va_46(char * restrict s, size_t n, char const * restrict format,
                   char *param0);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: param6), (indirect: param5), (indirect: param4),
            (indirect: param3), (indirect: param2), (indirect: param1),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param6, param5,
            param4, param3, param2, param1, *(param0 + (0 ..));
 */
int snprintf_va_47(char * restrict s, size_t n, char const * restrict format,
                   char *param0, int param1, int param2, int param3,
                   int param4, int param5, int param6);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: param6), (indirect: param5), (indirect: param4),
            (indirect: param3), (indirect: param2), (indirect: param1),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param6, param5,
            param4, param3, param2, param1, *(param0 + (0 ..));
 */
int snprintf_va_48(char * restrict s, size_t n, char const * restrict format,
                   char *param0, int param1, int param2, int param3,
                   int param4, int param5, int param6);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int snprintf_va_49(char * restrict s, size_t n, char const * restrict format,
                   char *param0);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int snprintf_va_50(char * restrict s, size_t n, char const * restrict format,
                   char *param0);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: param5), (indirect: param4), (indirect: param3),
            (indirect: param2), (indirect: param1), (indirect: param0);
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), param5, param4,
            param3, param2, param1, param0;
 */
int snprintf_va_51(char * restrict s, size_t n, char const * restrict format,
                   int param0, int param1, int param2, int param3,
                   int param4, int param5);

/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result
      \from (indirect: n), (indirect: *(format + (0 ..))),
            (indirect: *(param0 + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int snprintf_va_52(char * restrict s, size_t n, char const * restrict format,
                   char *param0);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_53(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_54(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_55(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_56(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_57(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_58(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_59(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_60(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_61(char * restrict s, size_t n, char const * restrict format);

/*@ requires valid_read_string(format);
    requires
      \valid(s + (0 .. n - 1)) ∨
      \valid(s + (0 .. format_length(format) - 1));
    assigns \result, *(s + (0 ..));
    assigns \result \from (indirect: n), (indirect: *(format + (0 ..)));
    assigns *(s + (0 ..))
      \from (indirect: n), (indirect: *(format + (0 ..)));
 */
int snprintf_va_62(char * restrict s, size_t n, char const * restrict format);

int x509parse_crl_info(char *buf, size_t size, char const *prefix,
                       x509_crl const *crl)
{
  int __retres;
  int ret;
  size_t n;
  char *p;
  x509_crl_entry const *entry;
  p = buf;
  n = size;
  ret = snprintf(p,n,"%sCRL version   : %d",(char *)prefix,crl->version); /* snprintf_va_45 */
  if (ret == -1) {
    __retres = -1;
    goto return_label;
  }
  if ((unsigned int)ret > n) {
    *(p + (n - (size_t)1)) = (char)'\000';
    __retres = -2;
    goto return_label;
  }
  n -= (unsigned int)ret;
  p += (unsigned int)ret;
  ret = snprintf(p,n,"\n%sissuer name   : ",(char *)prefix); /* snprintf_va_46 */
  if (ret == -1) {
    __retres = -1;
    goto return_label;
  }
  if ((unsigned int)ret > n) {
    *(p + (n - (size_t)1)) = (char)'\000';
    __retres = -2;
    goto return_label;
  }
  n -= (unsigned int)ret;
  p += (unsigned int)ret;
  ret = x509parse_dn_gets(p,n,& crl->issuer);
  if (ret == -1) {
    __retres = -1;
    goto return_label;
  }
  if ((unsigned int)ret > n) {
    *(p + (n - (size_t)1)) = (char)'\000';
    __retres = -2;
    goto return_label;
  }
  n -= (unsigned int)ret;
  p += (unsigned int)ret;
  ret = snprintf(p,n,"\n%sthis update   : %04d-%02d-%02d %02d:%02d:%02d",
                 (char *)prefix,crl->this_update.year,crl->this_update.mon,
                 crl->this_update.day,crl->this_update.hour,
                 crl->this_update.min,crl->this_update.sec); /* snprintf_va_47 */
  if (ret == -1) {
    __retres = -1;
    goto return_label;
  }
  if ((unsigned int)ret > n) {
    *(p + (n - (size_t)1)) = (char)'\000';
    __retres = -2;
    goto return_label;
  }
  n -= (unsigned int)ret;
  p += (unsigned int)ret;
  ret = snprintf(p,n,"\n%snext update   : %04d-%02d-%02d %02d:%02d:%02d",
                 (char *)prefix,crl->next_update.year,crl->next_update.mon,
                 crl->next_update.day,crl->next_update.hour,
                 crl->next_update.min,crl->next_update.sec); /* snprintf_va_48 */
  if (ret == -1) {
    __retres = -1;
    goto return_label;
  }
  if ((unsigned int)ret > n) {
    *(p + (n - (size_t)1)) = (char)'\000';
    __retres = -2;
    goto return_label;
  }
  n -= (unsigned int)ret;
  p += (unsigned int)ret;
  entry = & crl->entry;
  ret = snprintf(p,n,"\n%sRevoked certificates:",(char *)prefix); /* snprintf_va_49 */
  if (ret == -1) {
    __retres = -1;
    goto return_label;
  }
  if ((unsigned int)ret > n) {
    *(p + (n - (size_t)1)) = (char)'\000';
    __retres = -2;
    goto return_label;
  }
  n -= (unsigned int)ret;
  p += (unsigned int)ret;
  while (1) {
    if (entry != (x509_crl_entry const *)0) {
      if (! (entry->raw.len != (size_t)0)) break;
    }
    else break;
    ret = snprintf(p,n,"\n%sserial number: ",(char *)prefix); /* snprintf_va_50 */
    if (ret == -1) {
      __retres = -1;
      goto return_label;
    }
    if ((unsigned int)ret > n) {
      *(p + (n - (size_t)1)) = (char)'\000';
      __retres = -2;
      goto return_label;
    }
    n -= (unsigned int)ret;
    p += (unsigned int)ret;
    ret = x509parse_serial_gets(p,n,& entry->serial);
    if (ret == -1) {
      __retres = -1;
      goto return_label;
    }
    if ((unsigned int)ret > n) {
      *(p + (n - (size_t)1)) = (char)'\000';
      __retres = -2;
      goto return_label;
    }
    n -= (unsigned int)ret;
    p += (unsigned int)ret;
    ret = snprintf(p,n," revocation date: %04d-%02d-%02d %02d:%02d:%02d",
                   entry->revocation_date.year,entry->revocation_date.mon,
                   entry->revocation_date.day,entry->revocation_date.hour,
                   entry->revocation_date.min,entry->revocation_date.sec); /* snprintf_va_51 */
    if (ret == -1) {
      __retres = -1;
      goto return_label;
    }
    if ((unsigned int)ret > n) {
      *(p + (n - (size_t)1)) = (char)'\000';
      __retres = -2;
      goto return_label;
    }
    n -= (unsigned int)ret;
    p += (unsigned int)ret;
    entry = (x509_crl_entry const *)entry->next;
  }
  ret = snprintf(p,n,"\n%ssigned using  : RSA+",(char *)prefix); /* snprintf_va_52 */
  if (ret == -1) {
    __retres = -1;
    goto return_label;
  }
  if ((unsigned int)ret > n) {
    *(p + (n - (size_t)1)) = (char)'\000';
    __retres = -2;
    goto return_label;
  }
  n -= (unsigned int)ret;
  p += (unsigned int)ret;
  switch (crl->sig_alg) {
    case 2: ret = snprintf(p,n,"MD2"); /* snprintf_va_53 */
    break;
    case 3: ret = snprintf(p,n,"MD4"); /* snprintf_va_54 */
    break;
    case 4: ret = snprintf(p,n,"MD5"); /* snprintf_va_55 */
    break;
    case 5: ret = snprintf(p,n,"SHA1"); /* snprintf_va_56 */
    break;
    case 14: ret = snprintf(p,n,"SHA224"); /* snprintf_va_57 */
    break;
    case 11: ret = snprintf(p,n,"SHA256"); /* snprintf_va_58 */
    break;
    case 12: ret = snprintf(p,n,"SHA384"); /* snprintf_va_59 */
    break;
    case 13: ret = snprintf(p,n,"SHA512"); /* snprintf_va_60 */
    break;
    default: ret = snprintf(p,n,"?\?\?"); /* snprintf_va_61 */
    break;
  }
  if (ret == -1) {
    __retres = -1;
    goto return_label;
  }
  if ((unsigned int)ret > n) {
    *(p + (n - (size_t)1)) = (char)'\000';
    __retres = -2;
    goto return_label;
  }
  n -= (unsigned int)ret;
  p += (unsigned int)ret;
  ret = snprintf(p,n,"\n"); /* snprintf_va_62 */
  if (ret == -1) {
    __retres = -1;
    goto return_label;
  }
  if ((unsigned int)ret > n) {
    *(p + (n - (size_t)1)) = (char)'\000';
    __retres = -2;
    goto return_label;
  }
  n -= (unsigned int)ret;
  p += (unsigned int)ret;
  __retres = (int)(size - n);
  return_label: return __retres;
}

int x509parse_time_expired(x509_time const *to)
{
  int __retres;
  int year;
  int mon;
  int day;
  int hour;
  int min;
  int sec;
  struct tm *lt;
  time_t tt;
  tt = time((time_t *)0);
  lt = localtime((time_t const *)(& tt));
  year = lt->tm_year + 1900;
  mon = lt->tm_mon + 1;
  day = lt->tm_mday;
  hour = lt->tm_hour;
  min = lt->tm_min;
  sec = lt->tm_sec;
  if (year > to->year) {
    __retres = 1;
    goto return_label;
  }
  if (year == to->year) 
    if (mon > to->mon) {
      __retres = 1;
      goto return_label;
    }
  if (year == to->year) 
    if (mon == to->mon) 
      if (day > to->day) {
        __retres = 1;
        goto return_label;
      }
  if (year == to->year) 
    if (mon == to->mon) 
      if (day == to->day) 
        if (hour > to->hour) {
          __retres = 1;
          goto return_label;
        }
  if (year == to->year) 
    if (mon == to->mon) 
      if (day == to->day) 
        if (hour == to->hour) 
          if (min > to->min) {
            __retres = 1;
            goto return_label;
          }
  if (year == to->year) 
    if (mon == to->mon) 
      if (day == to->day) 
        if (hour == to->hour) 
          if (min == to->min) 
            if (sec > to->sec) {
              __retres = 1;
              goto return_label;
            }
  __retres = 0;
  return_label: return __retres;
}

int x509parse_revoked(x509_cert const *crt, x509_crl const *crl)
{
  int __retres;
  x509_crl_entry const *cur_0 = & crl->entry;
  while (1) {
    if (cur_0 != (x509_crl_entry const *)0) {
      if (! (cur_0->serial.len != (size_t)0)) break;
    }
    else break;
    if (crt->serial.len == cur_0->serial.len) {
      int tmp_0;
      tmp_0 = memcmp((void const *)crt->serial.p,
                     (void const *)cur_0->serial.p,crt->serial.len);
      if (tmp_0 == 0) {
        int tmp;
        tmp = x509parse_time_expired(& cur_0->revocation_date);
        if (tmp) {
          __retres = 1;
          goto return_label;
        }
      }
    }
    cur_0 = (x509_crl_entry const *)cur_0->next;
  }
  __retres = 0;
  return_label: return __retres;
}

static void x509_hash(unsigned char const *in, size_t len, int alg,
                      unsigned char *out)
{
  switch (alg) {
    case 4: md5(in,len,out);
    break;
    case 5: sha1(in,len,out);
    break;
    case 14: sha2(in,len,out,1);
    break;
    case 11: sha2(in,len,out,0);
    break;
    case 12: sha4(in,len,out,1);
    break;
    case 13: sha4(in,len,out,0);
    break;
    default: memset((void *)out,'\377',(size_t)64);
    break;
  }
  return;
}

/*@ assigns \result;
    assigns \result \from \nothing; */
static int x509parse_verifycrl(x509_cert *crt, x509_cert *ca,
                               x509_crl *crl_list)
{
  int hash_id;
  unsigned char hash[64];
  int flags = 0;
  while (1) {
    if (ca != (x509_cert *)0) 
      if (crl_list != (x509_crl *)0) {
        if (! (crl_list->version != 0)) break;
      }
      else break;
    else break;
    {
      int tmp_1;
      int tmp_0;
      int tmp_2;
      int tmp_3;
      if (crl_list->issuer_raw.len != ca->subject_raw.len) goto _LOR;
      else {
        int tmp;
        tmp = memcmp((void const *)crl_list->issuer_raw.p,
                     (void const *)ca->subject_raw.p,
                     crl_list->issuer_raw.len);
        if (tmp != 0) {
          _LOR: {
                  crl_list = crl_list->next;
                  continue;
                }
        }
      }
      hash_id = crl_list->sig_alg;
      x509_hash((unsigned char const *)crl_list->tbs.p,crl_list->tbs.len,
                hash_id,hash);
      tmp_0 = rsa_pkcs1_verify(& ca->rsa,0,hash_id,(unsigned int)0,
                               (unsigned char const *)(hash),crl_list->sig.p);
      if (tmp_0) tmp_1 = 0; else tmp_1 = 1;
      if (tmp_1 == 0) {
        flags |= 0x10;
        break;
      }
      tmp_2 = x509parse_time_expired((x509_time const *)(& crl_list->next_update));
      if (tmp_2) flags |= 0x20;
      tmp_3 = x509parse_revoked((x509_cert const *)crt,
                                (x509_crl const *)crl_list);
      if (tmp_3) {
        flags |= 0x02;
        break;
      }
      crl_list = crl_list->next;
    }
  }
  return flags;
}

int x509parse_verify(x509_cert *crt, x509_cert *trust_ca, x509_crl *ca_crl,
                     char const *cn, int *flags,
                     int (*f_vrfy)(void *, x509_cert *, int , int ),
                     void *p_vrfy)
{
  int __retres;
  size_t cn_len;
  int hash_id;
  int pathlen;
  x509_cert *parent;
  x509_name *name;
  unsigned char hash[64];
  int tmp;
  int tmp_8;
  *flags = 0;
  tmp = x509parse_time_expired((x509_time const *)(& crt->valid_to));
  if (tmp) *flags = 0x01;
  if (cn != (char const *)0) {
    name = & crt->subject;
    cn_len = strlen(cn);
    while (name != (x509_name *)0) {
      if (name->oid.len == (size_t)3) {
        int tmp_0;
        tmp_0 = memcmp((void const *)name->oid.p,(void const *)"U\004\003",
                       (size_t)3);
        if (tmp_0 == 0) 
          if (name->val.len == cn_len) {
            int tmp_1;
            tmp_1 = memcmp((void const *)name->val.p,(void const *)cn,cn_len);
            if (tmp_1 == 0) break;
          }
      }
      name = name->next;
    }
    if (name == (x509_name *)0) *flags |= 0x04;
  }
  parent = crt->next;
  pathlen = 1;
  while (1) {
    if (parent != (x509_cert *)0) {
      if (! (parent->version != 0)) break;
    }
    else break;
    {
      int tmp_3;
      int tmp_4;
      if (parent->ca_istrue == 0) goto _LOR;
      else 
        if (crt->issuer_raw.len != parent->subject_raw.len) goto _LOR;
        else {
          int tmp_2;
          tmp_2 = memcmp((void const *)crt->issuer_raw.p,
                         (void const *)parent->subject_raw.p,
                         crt->issuer_raw.len);
          if (tmp_2 != 0) {
            _LOR: {
                    parent = parent->next;
                    continue;
                  }
          }
        }
      hash_id = crt->sig_alg;
      x509_hash((unsigned char const *)crt->tbs.p,crt->tbs.len,hash_id,hash);
      tmp_3 = rsa_pkcs1_verify(& parent->rsa,0,hash_id,(unsigned int)0,
                               (unsigned char const *)(hash),crt->sig.p);
      if (tmp_3 != 0) *flags |= 0x08;
      tmp_4 = x509parse_verifycrl(crt,parent,ca_crl);
      *flags |= tmp_4;
      if ((int (*)(void *, x509_cert *, int , int ))0 != f_vrfy) {
        int tmp_5;
        tmp_5 = (*f_vrfy)(p_vrfy,crt,pathlen - 1,*flags == 0);
        if (tmp_5 != 0) {
          __retres = -0x2800;
          goto return_label;
        }
        else *flags = 0;
      }
      else 
        if (*flags != 0) {
          __retres = -0x2800;
          goto return_label;
        }
      pathlen ++;
      crt = parent;
      parent = crt->next;
    }
  }
  *flags |= 0x08;
  while (1) {
    if (trust_ca != (x509_cert *)0) {
      if (! (trust_ca->version != 0)) break;
    }
    else break;
    {
      int tmp_7;
      if (crt->issuer_raw.len != trust_ca->subject_raw.len) goto _LOR_0;
      else {
        int tmp_6;
        tmp_6 = memcmp((void const *)crt->issuer_raw.p,
                       (void const *)trust_ca->subject_raw.p,
                       crt->issuer_raw.len);
        if (tmp_6 != 0) {
          _LOR_0: {
                    trust_ca = trust_ca->next;
                    continue;
                  }
        }
      }
      if (trust_ca->max_pathlen > 0) 
        if (trust_ca->max_pathlen < pathlen) break;
      hash_id = crt->sig_alg;
      x509_hash((unsigned char const *)crt->tbs.p,crt->tbs.len,hash_id,hash);
      tmp_7 = rsa_pkcs1_verify(& trust_ca->rsa,0,hash_id,(unsigned int)0,
                               (unsigned char const *)(hash),crt->sig.p);
      if (tmp_7 == 0) {
        *flags &= ~ 0x08;
        break;
      }
      trust_ca = trust_ca->next;
    }
  }
  tmp_8 = x509parse_verifycrl(crt,trust_ca,ca_crl);
  *flags |= tmp_8;
  if ((int (*)(void *, x509_cert *, int , int ))0 != f_vrfy) {
    int tmp_9;
    tmp_9 = (*f_vrfy)(p_vrfy,crt,pathlen - 1,*flags == 0);
    if (tmp_9 != 0) {
      __retres = -0x2800;
      goto return_label;
    }
    else *flags = 0;
  }
  else 
    if (*flags != 0) {
      __retres = -0x2800;
      goto return_label;
    }
  __retres = 0;
  return_label: return __retres;
}

/*@ assigns \nothing; */
void x509_free(x509_cert *crt)
{
  x509_cert *cert_prv;
  x509_name *name_cur;
  x509_name *name_prv;
  x509_sequence *seq_cur;
  x509_sequence *seq_prv;
  x509_cert *cert_cur = crt;
  if (crt == (x509_cert *)0) goto return_label;
  while (1) {
    rsa_free(& cert_cur->rsa);
    name_cur = cert_cur->issuer.next;
    while (name_cur != (x509_name *)0) {
      name_prv = name_cur;
      name_cur = name_cur->next;
      memset((void *)name_prv,0,sizeof(x509_name));
      free((void *)name_prv);
    }
    name_cur = cert_cur->subject.next;
    while (name_cur != (x509_name *)0) {
      name_prv = name_cur;
      name_cur = name_cur->next;
      memset((void *)name_prv,0,sizeof(x509_name));
      free((void *)name_prv);
    }
    seq_cur = cert_cur->ext_key_usage.next;
    while (seq_cur != (x509_sequence *)0) {
      seq_prv = seq_cur;
      seq_cur = seq_cur->next;
      memset((void *)seq_prv,0,sizeof(x509_sequence));
      free((void *)seq_prv);
    }
    if (cert_cur->raw.p != (unsigned char *)0) {
      memset((void *)cert_cur->raw.p,0,cert_cur->raw.len);
      free((void *)cert_cur->raw.p);
    }
    cert_cur = cert_cur->next;
    if (! (cert_cur != (x509_cert *)0)) break;
  }
  cert_cur = crt;
  while (1) {
    cert_prv = cert_cur;
    cert_cur = cert_cur->next;
    memset((void *)cert_prv,0,sizeof(x509_cert));
    if (cert_prv != crt) free((void *)cert_prv);
    if (! (cert_cur != (x509_cert *)0)) break;
  }
  return_label: return;
}

void x509_crl_free(x509_crl *crl)
{
  x509_crl *crl_prv;
  x509_name *name_cur;
  x509_name *name_prv;
  x509_crl_entry *entry_cur;
  x509_crl_entry *entry_prv;
  x509_crl *crl_cur = crl;
  if (crl == (x509_crl *)0) goto return_label;
  while (1) {
    name_cur = crl_cur->issuer.next;
    while (name_cur != (x509_name *)0) {
      name_prv = name_cur;
      name_cur = name_cur->next;
      memset((void *)name_prv,0,sizeof(x509_name));
      free((void *)name_prv);
    }
    entry_cur = crl_cur->entry.next;
    while (entry_cur != (x509_crl_entry *)0) {
      entry_prv = entry_cur;
      entry_cur = entry_cur->next;
      memset((void *)entry_prv,0,sizeof(x509_crl_entry));
      free((void *)entry_prv);
    }
    if (crl_cur->raw.p != (unsigned char *)0) {
      memset((void *)crl_cur->raw.p,0,crl_cur->raw.len);
      free((void *)crl_cur->raw.p);
    }
    crl_cur = crl_cur->next;
    if (! (crl_cur != (x509_crl *)0)) break;
  }
  crl_cur = crl;
  while (1) {
    crl_prv = crl_cur;
    crl_cur = crl_cur->next;
    memset((void *)crl_prv,0,sizeof(x509_crl));
    if (crl_prv != crl) free((void *)crl_prv);
    if (! (crl_cur != (x509_crl *)0)) break;
  }
  return_label: return;
}

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_127(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_128(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_129(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_130(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_131(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_132(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_133(char const * restrict format, unsigned int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_134(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_135(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_136(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_137(char const * restrict format);

int x509_self_test(int verbose)
{
  int __retres;
  int ret;
  int flags;
  size_t i;
  size_t j;
  x509_cert cacert;
  x509_cert clicert;
  rsa_context rsa;
  dhm_context dhm;
  size_t tmp;
  size_t tmp_0;
  if (verbose != 0) printf("  X.509 certificate load: "); /* printf_va_127 */
  memset((void *)(& clicert),0,sizeof(x509_cert));
  tmp = strlen(test_cli_crt);
  ret = x509parse_crt(& clicert,(unsigned char const *)(test_cli_crt),tmp);
  if (ret != 0) {
    if (verbose != 0) printf("failed\n"); /* printf_va_128 */
    __retres = ret;
    goto return_label;
  }
  memset((void *)(& cacert),0,sizeof(x509_cert));
  tmp_0 = strlen(test_ca_crt);
  ret = x509parse_crt(& cacert,(unsigned char const *)(test_ca_crt),tmp_0);
  if (ret != 0) {
    if (verbose != 0) printf("failed\n"); /* printf_va_129 */
    __retres = ret;
    goto return_label;
  }
  if (verbose != 0) printf("passed\n  X.509 private key load: "); /* printf_va_130 */
  i = strlen(test_ca_key);
  j = strlen(test_ca_pwd);
  rsa_init(& rsa,0,0);
  ret = x509parse_key(& rsa,(unsigned char const *)(test_ca_key),i,
                      (unsigned char const *)(test_ca_pwd),j);
  if (ret != 0) {
    if (verbose != 0) printf("failed\n"); /* printf_va_131 */
    __retres = ret;
    goto return_label;
  }
  if (verbose != 0) printf("passed\n  X.509 signature verify: "); /* printf_va_132 */
  ret = x509parse_verify(& clicert,& cacert,(x509_crl *)0,
                         "PolarSSL Client 2",& flags,
                         (int (*)(void *, x509_cert *, int , int ))0,
                         (void *)0);
  if (ret != 0) {
    printf("%02x",(unsigned int)flags); /* printf_va_133 */
    if (verbose != 0) printf("failed\n"); /* printf_va_134 */
    __retres = ret;
    goto return_label;
  }
  if (verbose != 0) printf("passed\n  X.509 DHM parameter load: "); /* printf_va_135 */
  i = strlen(test_dhm_params);
  j = strlen(test_ca_pwd);
  ret = x509parse_dhm(& dhm,(unsigned char const *)(test_dhm_params),i);
  if (ret != 0) {
    if (verbose != 0) printf("failed\n"); /* printf_va_136 */
    __retres = ret;
    goto return_label;
  }
  if (verbose != 0) printf("passed\n\n"); /* printf_va_137 */
  x509_free(& cacert);
  x509_free(& clicert);
  rsa_free(& rsa);
  dhm_free(& dhm);
  __retres = 0;
  return_label: return __retres;
}

void xtea_setup(xtea_context *ctx, unsigned char key[16])
{
  int i;
  memset((void *)ctx,0,sizeof(xtea_context));
  i = 0;
  while (i < 4) {
    ctx->k[i] = (uint32_t)(((((unsigned long)*(key + (i << 2)) << 24) | (
                             (unsigned long)*(key + ((i << 2) + 1)) << 16)) | (
                            (unsigned long)*(key + ((i << 2) + 2)) << 8)) | (unsigned long)*(
                           key + ((i << 2) + 3)));
    i ++;
  }
  return;
}

int xtea_crypt_ecb(xtea_context *ctx, int mode, unsigned char input[8],
                   unsigned char output[8])
{
  int __retres;
  uint32_t *k;
  uint32_t v0;
  uint32_t v1;
  uint32_t i;
  k = ctx->k;
  v0 = (uint32_t)(((((unsigned long)*(input + 0) << 24) | ((unsigned long)*(
                                                           input + (0 + 1)) << 16)) | (
                   (unsigned long)*(input + (0 + 2)) << 8)) | (unsigned long)*(
                  input + (0 + 3)));
  v1 = (uint32_t)(((((unsigned long)*(input + 4) << 24) | ((unsigned long)*(
                                                           input + (4 + 1)) << 16)) | (
                   (unsigned long)*(input + (4 + 2)) << 8)) | (unsigned long)*(
                  input + (4 + 3)));
  if (mode == 1) {
    uint32_t sum = (uint32_t)0;
    uint32_t delta = 0x9E3779B9;
    i = (uint32_t)0;
    while (i < (uint32_t)32) {
      v0 += (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + *(k + (sum & (unsigned int)3)));
      sum += delta;
      v1 += (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + *(k + ((sum >> 11) & (unsigned int)3)));
      i ++;
    }
  }
  else {
    uint32_t delta_0 = 0x9E3779B9;
    uint32_t sum_0 = delta_0 * (uint32_t)32;
    i = (uint32_t)0;
    while (i < (uint32_t)32) {
      v1 -= (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum_0 + *(k + ((sum_0 >> 11) & (unsigned int)3)));
      sum_0 -= delta_0;
      v0 -= (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum_0 + *(k + (sum_0 & (unsigned int)3)));
      i ++;
    }
  }
  *(output + 0) = (unsigned char)(v0 >> 24);
  *(output + (0 + 1)) = (unsigned char)(v0 >> 16);
  *(output + (0 + 2)) = (unsigned char)(v0 >> 8);
  *(output + (0 + 3)) = (unsigned char)v0;
  *(output + 4) = (unsigned char)(v1 >> 24);
  *(output + (4 + 1)) = (unsigned char)(v1 >> 16);
  *(output + (4 + 2)) = (unsigned char)(v1 >> 8);
  *(output + (4 + 3)) = (unsigned char)v1;
  __retres = 0;
  return __retres;
}

int xtea_crypt_cbc(xtea_context *ctx, int mode, size_t length,
                   unsigned char iv[8], unsigned char *input,
                   unsigned char *output)
{
  int __retres;
  int i;
  unsigned char temp[8];
  if (length % (unsigned int)8) {
    __retres = -0x0028;
    goto return_label;
  }
  if (mode == 0) 
    while (length > (size_t)0) {
      memcpy((void *)(temp),(void const *)input,(size_t)8);
      xtea_crypt_ecb(ctx,mode,input,output);
      i = 0;
      while (i < 8) {
        *(output + i) = (unsigned char)((int)*(output + i) ^ (int)*(iv + i));
        i ++;
      }
      memcpy((void *)iv,(void const *)(temp),(size_t)8);
      input += 8;
      output += 8;
      length -= (size_t)8;
    }
  else 
    while (length > (size_t)0) {
      i = 0;
      while (i < 8) {
        *(output + i) = (unsigned char)((int)*(input + i) ^ (int)*(iv + i));
        i ++;
      }
      xtea_crypt_ecb(ctx,mode,output,output);
      memcpy((void *)iv,(void const *)output,(size_t)8);
      input += 8;
      output += 8;
      length -= (size_t)8;
    }
  __retres = 0;
  return_label: return __retres;
}

static unsigned char const xtea_test_key[6][16] =
  {{(unsigned char)0x00,
    (unsigned char)0x01,
    (unsigned char)0x02,
    (unsigned char)0x03,
    (unsigned char)0x04,
    (unsigned char)0x05,
    (unsigned char)0x06,
    (unsigned char)0x07,
    (unsigned char)0x08,
    (unsigned char)0x09,
    (unsigned char)0x0a,
    (unsigned char)0x0b,
    (unsigned char)0x0c,
    (unsigned char)0x0d,
    (unsigned char)0x0e,
    (unsigned char)0x0f},
   {(unsigned char)0x00,
    (unsigned char)0x01,
    (unsigned char)0x02,
    (unsigned char)0x03,
    (unsigned char)0x04,
    (unsigned char)0x05,
    (unsigned char)0x06,
    (unsigned char)0x07,
    (unsigned char)0x08,
    (unsigned char)0x09,
    (unsigned char)0x0a,
    (unsigned char)0x0b,
    (unsigned char)0x0c,
    (unsigned char)0x0d,
    (unsigned char)0x0e,
    (unsigned char)0x0f},
   {(unsigned char)0x00,
    (unsigned char)0x01,
    (unsigned char)0x02,
    (unsigned char)0x03,
    (unsigned char)0x04,
    (unsigned char)0x05,
    (unsigned char)0x06,
    (unsigned char)0x07,
    (unsigned char)0x08,
    (unsigned char)0x09,
    (unsigned char)0x0a,
    (unsigned char)0x0b,
    (unsigned char)0x0c,
    (unsigned char)0x0d,
    (unsigned char)0x0e,
    (unsigned char)0x0f},
   {(unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00},
   {(unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00},
   {(unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00,
    (unsigned char)0x00}};
static unsigned char const xtea_test_pt[6][8] =
  {{(unsigned char)0x41,
    (unsigned char)0x42,
    (unsigned char)0x43,
    (unsigned char)0x44,
    (unsigned char)0x45,
    (unsigned char)0x46,
    (unsigned char)0x47,
    (unsigned char)0x48},
   {(unsigned char)0x41,
    (unsigned char)0x41,
    (unsigned char)0x41,
    (unsigned char)0x41,
    (unsigned char)0x41,
    (unsigned char)0x41,
    (unsigned char)0x41,
    (unsigned char)0x41},
   {(unsigned char)0x5a,
    (unsigned char)0x5b,
    (unsigned char)0x6e,
    (unsigned char)0x27,
    (unsigned char)0x89,
    (unsigned char)0x48,
    (unsigned char)0xd7,
    (unsigned char)0x7f},
   {(unsigned char)0x41,
    (unsigned char)0x42,
    (unsigned char)0x43,
    (unsigned char)0x44,
    (unsigned char)0x45,
    (unsigned char)0x46,
    (unsigned char)0x47,
    (unsigned char)0x48},
   {(unsigned char)0x41,
    (unsigned char)0x41,
    (unsigned char)0x41,
    (unsigned char)0x41,
    (unsigned char)0x41,
    (unsigned char)0x41,
    (unsigned char)0x41,
    (unsigned char)0x41},
   {(unsigned char)0x70,
    (unsigned char)0xe1,
    (unsigned char)0x22,
    (unsigned char)0x5d,
    (unsigned char)0x6e,
    (unsigned char)0x4e,
    (unsigned char)0x76,
    (unsigned char)0x55}};
static unsigned char const xtea_test_ct[6][8] =
  {{(unsigned char)0x49,
    (unsigned char)0x7d,
    (unsigned char)0xf3,
    (unsigned char)0xd0,
    (unsigned char)0x72,
    (unsigned char)0x61,
    (unsigned char)0x2c,
    (unsigned char)0xb5},
   {(unsigned char)0xe7,
    (unsigned char)0x8f,
    (unsigned char)0x2d,
    (unsigned char)0x13,
    (unsigned char)0x74,
    (unsigned char)0x43,
    (unsigned char)0x41,
    (unsigned char)0xd8},
   {(unsigned char)0x41,
    (unsigned char)0x41,
    (unsigned char)0x41,
    (unsigned char)0x41,
    (unsigned char)0x41,
    (unsigned char)0x41,
    (unsigned char)0x41,
    (unsigned char)0x41},
   {(unsigned char)0xa0,
    (unsigned char)0x39,
    (unsigned char)0x05,
    (unsigned char)0x89,
    (unsigned char)0xf8,
    (unsigned char)0xb8,
    (unsigned char)0xef,
    (unsigned char)0xa5},
   {(unsigned char)0xed,
    (unsigned char)0x23,
    (unsigned char)0x37,
    (unsigned char)0x5a,
    (unsigned char)0x82,
    (unsigned char)0x1a,
    (unsigned char)0x8c,
    (unsigned char)0x2d},
   {(unsigned char)0x41,
    (unsigned char)0x41,
    (unsigned char)0x41,
    (unsigned char)0x41,
    (unsigned char)0x41,
    (unsigned char)0x41,
    (unsigned char)0x41,
    (unsigned char)0x41}};
/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: param0);
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..))),
            param0;
 */
int printf_va_138(char const * restrict format, int param0);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_139(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_140(char const * restrict format);

/*@ requires valid_read_string(format);
    assigns \result, __fc_stdout->__fc_FILE_data;
    assigns \result
      \from (indirect: __fc_stdout->__fc_FILE_id),
            (indirect: __fc_stdout->__fc_FILE_data),
            (indirect: *(format + (0 ..)));
    assigns __fc_stdout->__fc_FILE_data
      \from (indirect: __fc_stdout->__fc_FILE_id),
            __fc_stdout->__fc_FILE_data, (indirect: *(format + (0 ..)));
 */
int printf_va_141(char const * restrict format);

int xtea_self_test(int verbose)
{
  int __retres;
  int i;
  unsigned char buf[8];
  xtea_context ctx;
  i = 0;
  while (i < 6) {
    {
      int tmp;
      if (verbose != 0) printf("  XTEA test #%d: ",i + 1); /* printf_va_138 */
      memcpy((void *)(buf),(void const *)(xtea_test_pt[i]),(size_t)8);
      xtea_setup(& ctx,(unsigned char *)(xtea_test_key[i]));
      xtea_crypt_ecb(& ctx,1,buf,buf);
      tmp = memcmp((void const *)(buf),(void const *)(xtea_test_ct[i]),
                   (size_t)8);
      if (tmp != 0) {
        if (verbose != 0) printf("failed\n"); /* printf_va_139 */
        __retres = 1;
        goto return_label;
      }
      if (verbose != 0) printf("passed\n"); /* printf_va_140 */
    }
    i ++;
  }
  if (verbose != 0) printf("\n"); /* printf_va_141 */
  __retres = 0;
  return_label: return __retres;
}

/*@ requires \valid(str + (0 .. 5));
    ensures \initialized(\old(str) + (0 .. 5));
    assigns \result, _state, *(str + (0 .. 5));
    assigns \result \from _state;
    assigns _state \from _state;
    assigns *(str + (0 .. 5)) \from _state;
 */
int my_sprintf(char *str);

__inline static int const *ssl_list_ciphersuites_5(void)
{
  int const *__retres;
  __retres = (int const *)(ssl_default_ciphersuites);
  return __retres;
}

char *my_dhm_P =
  (char *)"E4004C1F94182000103D883A448B3F802CE4B44A83301270002C20D0321CFD0011CCEF784C26A400F43DFB901BCA7538F2C6B176001CF5A0FD16D2C48B1D0C1CF6AC8E1DA6BCC3B4E1F96B0564965300FFA1D0B601EB2800F489AA512C4B248C01F76949A60BB7F00A40B1EAB64BDD48E8A700D60B7F1200FA8E77B0A979DABF";
char *my_dhm_G = (char *)"4";
int my_ciphersuites[13] =
  {0x39, 0x88, 0x33, 0x45, 0x16, 0x35, 0x84, 0x2F, 0x41, 0x0A, 0x05, 0x04, 0};
/*@ requires valid_read_string(param0);
    requires valid_read_string(format);
    assigns \result, stream->__fc_FILE_data;
    assigns \result
      \from (indirect: stream->__fc_FILE_id),
            (indirect: stream->__fc_FILE_data),
            (indirect: *(format + (0 ..))), (indirect: *(param0 + (0 ..)));
    assigns stream->__fc_FILE_data
      \from (indirect: stream->__fc_FILE_id), stream->__fc_FILE_data,
            (indirect: *(format + (0 ..))), *(param0 + (0 ..));
 */
int fprintf_va_1(FILE * restrict stream, char const * restrict format,
                 char *param0);

void my_debug(void *ctx, int level, char const *str)
{
  if (level < 0) {
    fprintf((FILE *)ctx,"%s",(char *)str); /* fprintf_va_1 */
    fflush((FILE *)ctx);
  }
  return;
}

ssl_session *s_list_1st = (ssl_session *)0;
ssl_session *cur;
ssl_session *prv;
/*@ requires \valid(&(ssl->session)->master[0 .. 47]);
    ensures \initialized(&(\old(ssl)->session)->master[0 .. 47]);
    ensures \result ≡ 0 ∨ \result ≡ 1;
    assigns (ssl->session)->master[0 .. 47], \result, _state;
    assigns (ssl->session)->master[0 .. 47] \from _state;
    assigns \result \from _state;
    assigns _state \from _state;
 */
static int my_get_session(ssl_context *ssl)
{
  int __retres;
  time_t t = time((time_t *)0);
  if (ssl->resume == 0) {
    __retres = 1;
    goto return_label;
  }
  cur = s_list_1st;
  prv = (ssl_session *)0;
  while (cur != (ssl_session *)0) {
    int tmp_0;
    prv = cur;
    cur = cur->next;
    if (ssl->timeout != 0) 
      if ((int)(t - prv->start) > ssl->timeout) continue;
    if ((ssl->session)->ciphersuite != prv->ciphersuite) continue;
    else 
      if ((ssl->session)->length != prv->length) continue;
    tmp_0 = memcmp((void const *)((ssl->session)->id),
                   (void const *)(prv->id),prv->length);
    if (tmp_0 != 0) continue;
    memcpy((void *)((ssl->session)->master),(void const *)(prv->master),
           (size_t)48);
    __retres = 0;
    goto return_label;
  }
  __retres = 1;
  return_label: return __retres;
}

/*@ assigns \result;
    assigns \result \from _state; */
static int my_set_session(ssl_context *ssl)
{
  int __retres;
  time_t t = time((time_t *)0);
  cur = s_list_1st;
  prv = (ssl_session *)0;
  while (cur != (ssl_session *)0) {
    int tmp_0;
    if (ssl->timeout != 0) 
      if ((int)(t - cur->start) > ssl->timeout) break;
    tmp_0 = memcmp((void const *)((ssl->session)->id),
                   (void const *)(cur->id),cur->length);
    if (tmp_0 == 0) break;
    prv = cur;
    cur = cur->next;
  }
  if (cur == (ssl_session *)0) {
    cur = (ssl_session *)malloc(sizeof(ssl_session));
    if (cur == (ssl_session *)0) {
      __retres = 1;
      goto return_label;
    }
    if (prv == (ssl_session *)0) s_list_1st = cur; else prv->next = cur;
  }
  memcpy((void *)cur,(void const *)ssl->session,sizeof(ssl_session));
  __retres = 0;
  return_label: return __retres;
}

int main(int argc, char **argv)
{
  int ret;
  int len;
  int listen_fd;
  unsigned char buf[1024];
  entropy_context entropy;
  ctr_drbg_context ctr_drbg;
  ssl_context ssl;
  ssl_session ssn;
  x509_cert srvcert;
  rsa_context rsa;
  time_t t;
  char *stime;
  size_t tmp;
  size_t tmp_0;
  size_t tmp_1;
  size_t tmp_2;
  int client_fd = -1;
  char *pers = (char *)"ssl_server";
  fflush(__fc_stdout);
  memset((void *)(& srvcert),0,sizeof(x509_cert));
  tmp = strlen(test_srv_crt);
  ret = x509parse_crt(& srvcert,(unsigned char const *)(test_srv_crt),tmp);
  if (ret != 0) goto exit;
  tmp_0 = strlen(test_ca_crt);
  ret = x509parse_crt(& srvcert,(unsigned char const *)(test_ca_crt),tmp_0);
  if (ret != 0) goto exit;
  rsa_init(& rsa,0,0);
  tmp_1 = strlen(test_srv_key);
  ret = x509parse_key(& rsa,(unsigned char const *)(test_srv_key),tmp_1,
                      (unsigned char const *)0,(size_t)0);
  if (ret != 0) goto exit;
  fflush(__fc_stdout);
  ret = net_bind(& listen_fd,(char const *)0,4433);
  if (ret != 0) goto exit;
  fflush(__fc_stdout);
  entropy_init(& entropy);
  tmp_2 = strlen((char const *)pers);
  ;
  ret = ctr_drbg_init(& ctr_drbg,& entropy_func,(void *)(& entropy),
                      (unsigned char const *)pers,tmp_2);
  if (ret != 0) goto exit;
  fflush(__fc_stdout);
  ret = ssl_init(& ssl);
  if (ret != 0) goto exit;
  ssl_set_endpoint(& ssl,1);
  ssl_set_authmode(& ssl,0);
  ssl_set_rng(& ssl,& ctr_drbg_random,(void *)(& ctr_drbg));
  ssl_set_dbg(& ssl,& my_debug,(void *)__fc_stdout);
  ssl_set_scb(& ssl,& my_get_session,& my_set_session);
  ssl_set_ciphersuites(& ssl,my_ciphersuites);
  ssl_set_session(& ssl,1,0,& ssn);
  memset((void *)(& ssn),0,sizeof(ssl_session));
  ssl_set_ca_chain(& ssl,srvcert.next,(x509_crl *)0,(char const *)0);
  ssl_set_own_cert(& ssl,& srvcert,& rsa);
  ssl_set_dh_param(& ssl,(char const *)my_dhm_P,(char const *)my_dhm_G);
  reset: ;
  if (ret != 0) {
    char error_buf[100];
    error_strerror(ret,error_buf,(size_t)100);
  }
  if (client_fd != -1) net_close(client_fd);
  ssl_session_reset(& ssl);
  client_fd = -1;
  fflush(__fc_stdout);
  ret = net_accept(listen_fd,& client_fd,(void *)0);
  if (ret != 0) goto exit;
  ssl_set_bio(& ssl,& net_recv,(void *)(& client_fd),& net_send,
              (void *)(& client_fd));
  fflush(__fc_stdout);
  while (1) {
    ret = ssl_handshake(& ssl);
    if (! (ret != 0)) break;
    if (ret != -0x0052) 
      if (ret != -0x0054) goto reset;
  }
  fflush(__fc_stdout);
  while (1) {
    len = (int)(sizeof(buf) - (unsigned int)1);
    memset((void *)(buf),0,sizeof(buf));
    ret = ssl_read(& ssl,buf,(size_t)len);
    if (ret == -0x0052) goto __Cont;
    else 
      if (ret == -0x0054) goto __Cont;
    if (ret <= 0) {
      switch (ret) {
        case -0x7880: ;
        break;
        case -0x0050: ;
        break;
        default: ;
        break;
      }
      break;
    }
    len = ret;
    __Cont: break;
  }
  fflush(__fc_stdout);
  time(& t);
  stime = ctime((time_t const *)(& t));
  len = my_sprintf((char *)(buf));
  while (1) {
    ret = ssl_write(& ssl,(unsigned char const *)(buf),(size_t)len);
    if (! (ret <= 0)) break;
    if (ret == -0x0050) goto reset;
    if (ret != -0x0052) 
      if (ret != -0x0054) goto exit;
  }
  len = ret;
  ssl_close_notify(& ssl);
  ret = 0;
  goto reset;
  exit: ;
  if (ret != 0) {
    char error_buf_0[100];
    error_strerror(ret,error_buf_0,(size_t)100);
  }
  net_close(client_fd);
  x509_free(& srvcert);
  rsa_free(& rsa);
  ssl_free(& ssl);
  cur = s_list_1st;
  while (cur != (ssl_session *)0) {
    prv = cur;
    cur = cur->next;
    memset((void *)prv,0,sizeof(ssl_session));
    free((void *)prv);
  }
  memset((void *)(& ssl),0,sizeof(ssl_context));
  return ret;
}


